<html>
<head>
<title>Graph Theory: Creating a Relationship Network in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论:用Python创建关系网络</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/graph-theory-creating-a-relationship-network-in-python-f7b6ecf7f50?source=collection_archive---------0-----------------------#2021-04-16">https://pub.towardsai.net/graph-theory-creating-a-relationship-network-in-python-f7b6ecf7f50?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f01b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="d470" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用代码模拟具有多个指标的完整图形。完整的代码可在我的回购<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20210414_Relationship_Network" rel="noopener ugc nofollow" target="_blank">。</a></h2></div><p id="d1fc" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated"><a class="ae kr" href="http://www.michelangiolo.best/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku jd">点击这里了解我，我的项目，我的最新文章。</strong> </a></p><p id="36a8" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我想用python模拟的一个有趣的实验是这样的:我有一个包含n个对象(人)的系统，我想量化所有这些包含多个值的对象之间的关系。比如系统中有三个人:A，B，C，A和B的关系可以用一个值来表示:5，A和C，B和C也可以这样做，基本上我把所有的对象都连接起来了，但是我也给每一个单个的关系赋了一个<strong class="ku jd">单值</strong>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/08b08155495f7a40de96df82a44bc0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLI0SvbFTnvwpDeKY5s7Pg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">具有3个对象和2个值的关系网络示例</figcaption></figure><p id="deb9" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我想创建一个算法，给定系统中的人数和每个关系的值的数量，它将随机生成值，并将它们分配给这些对象之间的每个现有关系。</p><h2 id="1a0b" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">图论</h2><p id="4dee" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我的实验非常接近图论，这是一门研究图形(概述元素之间关系的数学结构)的学科。本质上，它通过使用两个元素简化了图的定义:</p><ul class=""><li id="d48a" class="nb nc it ku b kv kw ky kz lb nd lf ne lj nf ln ng nh ni nj bi translated">节点(下面十边形边缘的编号点)</li><li id="dc41" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">边(连接节点的线:它们的关系)</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi np"><img src="../Images/d2fe54e1fd40507d306c56a72fb77eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTXRmI4Bh4McgF2Q3xOI9Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">我想用python复制的图形表示，只是每条边有多个度量。检索自:<a class="ae kr" href="https://www.researchgate.net/figure/A-complete-graph-with-10-nodes-and-45-edges_fig3_279242256" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/figure/A-complete-graph-with-10-nodes-and-45-edges _ fig 3 _ 279242256</a></figcaption></figure><p id="8619" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我的目标是复制所谓的完美图:一个所有节点都相连的图。唯一的区别是，我将为每个现有的关系分配多个值。这不是普通图论算法的一部分，这就是为什么我想自己创建一个。</p><h1 id="4672" class="nq mf it bd mg nr ns nt mj nu nv nw mm ki nx kj mp kl ny km ms ko nz kp mv oa bi translated">算法</h1><h2 id="4eb0" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">简化示例</h2><p id="502f" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">在试图对整个事情进行编码之前，我想模拟一个更简单的例子。创建一个人和两个对象，然后使用两个指标设置它们之间的关系。</p><pre class="lp lq lr ls gt ob oc od oe aw of bi"><span id="dd9a" class="me mf it oc b gy og oh l oi oj">class person():<br/>  def __init__(self):<br/>    self.value_map = dict()</span><span id="b05c" class="me mf it oc b gy ok oh l oi oj">  def set_relationship(self, obj1, value):<br/>    self.value_map[obj1] = value</span><span id="d852" class="me mf it oc b gy ok oh l oi oj">class object():<br/>  def __init__(self):<br/>    pass</span><span id="b204" class="me mf it oc b gy ok oh l oi oj">p1 = person()<br/>obj1 = object()<br/>obj2 = object()</span><span id="60aa" class="me mf it oc b gy ok oh l oi oj">p1.set_relationship(obj1, {'metric1':4, 'metric2':30})<br/>p1.set_relationship(obj2, {'metric1':12, 'metric2':100})<br/>p1.value_map</span><span id="2608" class="me mf it oc b gy ok oh l oi oj">Output:<br/>{&lt;__main__.object at 0x7f20e879d890&gt;: {'metric1': 12, 'metric2': 100},<br/> &lt;__main__.object at 0x7f20e87c65d0&gt;: {'metric1': 4, 'metric2': 30}}</span></pre><p id="246c" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我认为代码很简单，因为p1是人，我可以给它分配一个以object作为键的字典，和另一个以值(metric1和metric2)包含关系的字典。</p><h2 id="88d3" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">完全码</h2><p id="9477" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我心目中的算法的最终代码如下。我创建了一个对象列表，然后迭代地从中取出一个对象，并再次迭代列表中的其余元素。在这一点上，我重置了列表，这样我要移除的下一个元素将总是来自一个包含10个元素的列表(这样我就不需要改变元素的索引):这防止了索引的移动。当一个对象完成时(它有一个包含9个关系的字典)，我将把它附加到函数输出的最终列表中。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/b9c986e25429ee1152ecfb05152338cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*tlbyV1hD15KP9HJ9DGSOEA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">流程的图形表示</figcaption></figure><pre class="lp lq lr ls gt ob oc od oe aw of bi"><span id="e96a" class="me mf it oc b gy og oh l oi oj">import random</span><span id="3eba" class="me mf it oc b gy ok oh l oi oj">def relationship_network(n_people, n_values):<br/>  class person():<br/>    def __init__(self):<br/>      self.value_map = dict()</span><span id="569b" class="me mf it oc b gy ok oh l oi oj">    def set_relationship(self, obj1, value):<br/>      self.value_map[obj1] = value</span><span id="ff8e" class="me mf it oc b gy ok oh l oi oj">#create a list of people<br/>  person_list = [person() for x in range(n_people)]</span><span id="ab89" class="me mf it oc b gy ok oh l oi oj">#create relationships between those people<br/>  final_list = list()<br/>  #iterate through the original list<br/>  for person_index in range(len(person_list)):<br/>    #make an exact copy, so we can extract a person every time and then reset it<br/>    person_list_ = person_list.copy()<br/>    popped = person_list_.pop(person_index)<br/>    #after extracting a person, create relationship with all the others, and place it in a final list<br/>    for remaining in person_list_:<br/>      popped.set_relationship(remaining, {'metric_'+str(x+1):random.randint(0, 100) for x in range(n_values)}) #{'metric1': random.randint(0, 100), 'metric2': random.randint(0, 100)})<br/>    final_list.append(popped)</span><span id="137d" class="me mf it oc b gy ok oh l oi oj">#contains the relationship between every element in the system<br/>  return final_list</span><span id="b207" class="me mf it oc b gy ok oh l oi oj">relationship_table = relationship_network(3, 3)<br/>[print(x.value_map) for x in relationship_table]<br/>None</span><span id="8761" class="me mf it oc b gy ok oh l oi oj">#check values of a single person<br/>print('person_3')<br/>relationship_table[2].value_map</span><span id="7699" class="me mf it oc b gy ok oh l oi oj">Output:<br/>{&lt;__main__.relationship_network.&lt;locals&gt;.person object at 0x7f1ce4449350&gt;: {'metric_1': 11, 'metric_2': 71, 'metric_3': 22}, &lt;__main__.relationship_network.&lt;locals&gt;.person object at 0x7f1ce44490d0&gt;: {'metric_1': 52, 'metric_2': 69, 'metric_3': 54}}<br/>{&lt;__main__.relationship_network.&lt;locals&gt;.person object at 0x7f1ce43d3850&gt;: {'metric_1': 38, 'metric_2': 97, 'metric_3': 36}, &lt;__main__.relationship_network.&lt;locals&gt;.person object at 0x7f1ce44490d0&gt;: {'metric_1': 38, 'metric_2': 15, 'metric_3': 46}}<br/>{&lt;__main__.relationship_network.&lt;locals&gt;.person object at 0x7f1ce43d3850&gt;: {'metric_1': 53, 'metric_2': 99, 'metric_3': 2}, &lt;__main__.relationship_network.&lt;locals&gt;.person object at 0x7f1ce4449350&gt;: {'metric_1': 64, 'metric_2': 56, 'metric_3': 99}}<br/>person_3</span></pre><p id="ea43" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">为了节省空间，我没有使用一个有10个节点的例子，而是使用一个有3个节点和3个值的例子。从函数的输出可以看出，这个字典有3个对象作为键，包含系统元素之间的所有关系。</p></div></div>    
</body>
</html>