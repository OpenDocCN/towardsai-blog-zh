<html>
<head>
<title>Tf.estimator, a Tensorflow High-level API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tf.estimator，一个Tensorflow高级API</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/tf-estimator-an-another-tensorflow-high-level-api-ef763c32465b?source=collection_archive---------0-----------------------#2019-10-06">https://pub.towardsai.net/tf-estimator-an-another-tensorflow-high-level-api-ef763c32465b?source=collection_archive---------0-----------------------#2019-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b8fd7f694e0c6b744fc7054c4dab6467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyA1WjY8wC4p5eIt43jTHA.png"/></div></div></figure><p id="8972" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在Tensorflow 2.0已经正式发布，它有两个高级深度学习API。<br/>第一个是tf.keras，另一个是tf.estimator，上图可以看到TensorFlow的Python API列表。你们中的一些人熟悉使用Keras构建ML模型。但是我们对tf.estimator不是那么熟悉(假设我们指的是ML初学者)。<br/>那么让我们来了解一下tf.estimator。</p><h1 id="ccff" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这篇文章的背景是:</h1><blockquote class="lu lv lw"><p id="b050" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">1.给你一个关于tf.estimator的概念。<br/> 2。在编写基于估算器(预制估算器)的张量流程序时，我们必须遵循什么任务。<br/> 3。优点。<br/> 4。评估者的能力。<br/> 5。我们将使用tf.estimator建立并测试一个模型，将鸢尾花分为三个种类。</p></blockquote><h1 id="f29e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是tf.estimator？</h1><p id="4941" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">估计器是TensorFlow对完整模型的高级表示，它旨在方便扩展和异步训练。它用于训练神经网络模型，并使用它们来预测新数据。它是一个高级API，位于低级核心TensorFlow API之上。人们可以使用预制的评估器或定制的评估器。</p><h2 id="1e21" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">1.预制估算器</h2><p id="3198" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">与基本的TensorFlow APIs相比，预制的估算器使您能够在更高的概念层次上工作。您不再需要担心创建计算图或会话，因为评估人员会为您处理所有的“管道”。此外，预制的评估器允许您通过只做最小的代码更改来试验不同的模型架构。例如，tf.estimator. DNNClassifier是一个预制的估计器类，它基于密集的前馈神经网络训练分类模型。</p><h2 id="2c39" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">2.定制估算器</h2><p id="bea5" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">无论是预制的还是定制的，每个估计器的核心都是其模型函数，这是一种为训练、评估和预测构建图表的方法。当你在使用一个预制的估算器时，别人已经实现了模型函数。当依赖一个定制的估计器时，你必须自己编写模型函数。在这个模型中，我们主要处理预先做好的估计</p><h1 id="d244" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">编写张量流预制估计量的任务。</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/7494e395d845a19b975316f8f3020670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cv-u3ZwrOYiYlGzh1Yhz0g.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">来源。<a class="ae nb" href="https://torres.ai" rel="noopener ugc nofollow" target="_blank"> https://torres.ai </a></figcaption></figure><blockquote class="lu lv lw"><p id="2ca2" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">1.创建一个或多个输入函数。<br/> 2。定义模型的特征列。<br/> 3。实例化一个估计器，指定特性列和各种超参数。<br/> 4。调用Estimator对象上的一个或多个方法，传递适当的输入函数作为数据源。</p></blockquote><p id="15d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文的后面，我们将为虹膜分类实现上述任务。</p><h1 id="89f0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">优势</h1><blockquote class="nc"><p id="7e23" class="nd ne iq bd nf ng nh ni nj nk nl kv dk translated">tf.estimator为tf.keras. <br/>提供了一些目前仍在开发中的功能，它们是:- <br/> 1。我们可以使用评估者API <br/> 2在多个服务器上进行分布式训练。完全TFX一体化。<br/> TensorFlow Extended (TFX)是一个用于部署生产ML管道的端到端平台。tf.estimator支持完全TFX积分。</p></blockquote><h1 id="e290" class="kw kx iq bd ky kz la lb lc ld le lf lg lh nm lj lk ll nn ln lo lp no lr ls lt bi translated">评估者能力</h1><p id="737c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">估计器提供了以下好处:</p><ol class=""><li id="77cb" class="np nq iq ka b kb kc kf kg kj nr kn ns kr nt kv nu nv nw nx bi translated">您可以在本地主机或分布式多服务器环境中运行基于评估器的模型，而无需更改您的模型。此外，您可以在CPU、GPU或TPU上运行基于估算器的模型，而无需重新编码您的模型。</li></ol><p id="47dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.估算器提供了一个安全分布的训练循环，控制如何以及何时:<br/> (a)加载数据<br/> (b)处理异常<br/>创建检查点文件并从故障中恢复<br/> (d)保存TensorBoard的摘要</p><h1 id="edee" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用tf估计器的虹膜分类器</h1><p id="854a" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们将使用tf.estimator建立一个虹膜分类器。我们使用的数据集是虹膜数据集，它有四个特征萼片长度、萼片宽度、花瓣长度和花瓣宽度以及三个标签Setosa、Versicolor和Virginica。<br/>但是首先，我们导入所有的依赖项</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="4a43" class="mg kx iq nz b gy od oe l of og">from __future__ import absolute_import, division, print_function, unicode_literals<br/></span><span id="a2b6" class="mg kx iq nz b gy oh oe l of og">import tensorflow as tf</span><span id="c70c" class="mg kx iq nz b gy oh oe l of og">import pandas as pd</span></pre><p id="622e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们对数据进行预处理，以执行以下任务</p><p id="aa72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(a)创建一个或多个输入函数。<br/> (b)定义模型的特征列。(c)实例化一个估计器，指定特征列和各种超参数。<br/> (d)调用评估器对象上的一个或多个方法，传递适当的输入函数作为数据源。</p><p id="1e44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">数据预处理</strong></p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="898f" class="mg kx iq nz b gy od oe l of og">CSV_COLUMN_NAMES = ['SepalLength', 'SepalWidth', 'PetalLength', 'PetalWidth', 'Species']<br/>SPECIES = ['Setosa', 'Versicolor', 'Virginica']</span></pre><p id="d75d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正在下载数据集。</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="713f" class="mg kx iq nz b gy od oe l of og">train_path = tf.keras.utils.get_file(<br/>    "iris_training.csv", "https://storage.googleapis.com/download.tensorflow.org/data/iris_training.csv")<br/>test_path = tf.keras.utils.get_file(<br/>    "iris_test.csv", "https://storage.googleapis.com/download.tensorflow.org/data/iris_test.csv")</span><span id="de4a" class="mg kx iq nz b gy oh oe l of og">train = pd.read_csv(train_path, names=CSV_COLUMN_NAMES, header=0)<br/>test = pd.read_csv(test_path, names=CSV_COLUMN_NAMES, header=0)</span></pre><h2 id="7bf3" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">创建输入函数</h2><p id="f975" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">您必须创建输入函数来为训练、评估和预测提供数据。</p><p id="3750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输入函数是返回tf.data.Dataset对象的函数，该对象输出以下两元素元组:</p><p id="5427" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">features——一个Python字典，其中:<br/> (a)每个键都是一个特性的名称。<br/> (b)每个值都是一个数组，包含了该特性的所有值。<br/>标签-包含每个示例的标签值的数组。<br/>我们用熊猫来建立输入管道</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="8ce5" class="mg kx iq nz b gy od oe l of og">def input_fn(features, labels, training=True, batch_size=256):<br/>    """An input function for training or evaluating"""<br/>    # Convert the inputs to a Dataset.<br/>    dataset = tf.data.Dataset.from_tensor_slices((dict(features), labels))</span><span id="bc7f" class="mg kx iq nz b gy oh oe l of og">    # Shuffle and repeat if you are in training mode.<br/>    if training:<br/>        dataset = dataset.shuffle(1000).repeat()<br/>    <br/>    return dataset.batch(batch_size)</span></pre><h2 id="b1db" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">定义特征列</h2><p id="6c3a" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">要素列是描述模型应如何使用要素字典中的原始输入数据的对象。当您构建一个估计器模型时，我们向它传递一个特性列的列表，该列表描述了您希望模型使用的每个特性。tf.feature_column模块提供了许多向模型表示数据的选项。</p><p id="9b74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于Iris，4个原始特征是数值，因此我们将构建一个特征列列表，告诉估计器模型将4个特征中的每一个表示为32位浮点值。因此，创建feature列的代码是:</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="82a0" class="mg kx iq nz b gy od oe l of og"># Feature columns describe how to use the input.<br/>my_feature_columns = []<br/>for key in train.keys():<br/>    my_feature_columns.append(tf.feature_column.numeric_column(key=key))</span></pre><h1 id="bbed" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">实例化一个评估者</h1><p id="7a16" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">虹膜问题是一个经典的分类问题。幸运的是，TensorFlow提供了几个预制的分类器估计器，包括:</p><p id="7778" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a.TF . estimator . dnn用于执行多类分类的深度模型的分类器。<br/>b . TF . estimator . dnnlinearcombinedclassifier用于宽&amp;深度模型。<br/>基于线性模型的分类器c . TF . estimator . linear classifier。</p><p id="16af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于虹膜问题，tf.estimator.DNNClassifier似乎是最好的选择。下面是我们如何实例化这个估计器的:</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="356a" class="mg kx iq nz b gy od oe l of og"># Build a DNN with 2 hidden layers with 30 and 10 hidden nodes each.<br/>classifier = tf.estimator.DNNClassifier(<br/>    feature_columns=my_feature_columns,<br/>    # Two hidden layers of 10 nodes each.<br/>    hidden_units=[30, 10],<br/>    # The model must choose between 3 classes.<br/>    n_classes=3)</span></pre><h2 id="a2b0" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">训练、评估和预测</h2><p id="a090" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><em class="lx">训练模型</em> <br/>通过调用估计器的训练方法训练模型，如下所示:</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="4658" class="mg kx iq nz b gy od oe l of og"># Train the Model.<br/>classifier.train(<br/>    input_fn=lambda: input_fn(train, train_y, training=True),<br/>    steps=5000)</span></pre><p id="9453" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">评价</p><p id="aead" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在模型已经训练好了，您可以得到一些关于它的性能的统计数据。下面的代码块根据测试数据评估定型模型的准确性:</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="bf9e" class="mg kx iq nz b gy od oe l of og">eval_result = classifier.evaluate(<br/>    input_fn=lambda: input_fn(test, test_y, training=False))</span><span id="c3a7" class="mg kx iq nz b gy oh oe l of og">print('\nTest set accuracy: {accuracy:0.3f}\n'.format(**eval_result))</span></pre><p id="c5f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">评估后，我们将获得大约56%的准确率</p><h2 id="6b12" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">根据训练好的模型进行预测(推断)</h2><p id="0447" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">您现在已经有了一个经过训练的模型，可以产生良好的评估结果。现在，您可以根据一些未标记的测量值，使用训练好的模型来预测鸢尾花的种类。与训练和评估一样，您可以使用单个函数调用进行预测:</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="76cc" class="mg kx iq nz b gy od oe l of og"># Generate predictions from the model<br/>expected = ['Setosa', 'Versicolor', 'Virginica']<br/>predict_x = {<br/>    'SepalLength': [5.1, 5.9, 6.9],<br/>    'SepalWidth': [3.3, 3.0, 3.1],<br/>    'PetalLength': [1.7, 4.2, 5.4],<br/>    'PetalWidth': [0.5, 1.5, 2.1],<br/>}</span><span id="c823" class="mg kx iq nz b gy oh oe l of og">def input_fn(features, batch_size=256):<br/>    """An input function for prediction."""<br/>    # Convert the inputs to a Dataset without labels.<br/>    return tf.data.Dataset.from_tensor_slices(dict(features)).batch(batch_size)</span><span id="99c8" class="mg kx iq nz b gy oh oe l of og">predictions = classifier.predict(<br/>    input_fn=lambda: input_fn(predict_x))</span></pre><p id="8d44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe oi oj ok nz b">predict</code>方法返回一个Python iterable，为每个例子生成一个预测结果字典。以下代码打印了一些预测及其概率:</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="2049" class="mg kx iq nz b gy od oe l of og">for pred_dict, expec in zip(predictions, expected):<br/>    class_id = pred_dict['class_ids'][0]<br/>    probability = pred_dict['probabilities'][class_id]</span><span id="6644" class="mg kx iq nz b gy oh oe l of og">    print('Prediction is "{}" ({:.1f}%), expected "{}"'.format(<br/>        SPECIES[class_id], 100 * probability, expec))</span></pre><p id="f3af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将得到这样的输出</p><pre class="mt mu mv mw gt ny nz oa ob aw oc bi"><span id="54b6" class="mg kx iq nz b gy od oe l of og">INFO:tensorflow:Calling model_fn.<br/>INFO:tensorflow:Done calling model_fn.<br/>INFO:tensorflow:Graph was finalized.<br/>INFO:tensorflow:Restoring parameters from /tmp/tmpy5w5zoj8/model.ckpt-5000<br/>INFO:tensorflow:Running local_init_op.<br/>INFO:tensorflow:Done running local_init_op.<br/>Prediction is "Setosa" (73.0%), expected "Setosa"<br/>Prediction is "Virginica" (42.6%), expected "Versicolor"<br/>Prediction is "Virginica" (49.0%), expected "Virginica"</span></pre><h2 id="a761" class="mg kx iq bd ky mh mi dn lc mj mk dp lg kj ml mm lk kn mn mo lo kr mp mq ls mr bi translated">参考资料:- Tensorflow的官方文档</h2><p id="149d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">希望你喜欢这篇文章</p><p id="381c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你知道吗，你可以按50次拍手键？如果你喜欢这个博客，鼓掌来表达你的爱。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/61ee3c58d4b040be8643e984391dfde0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HnhqbqJ1vlHFEZmO5oEtqQ.gif"/></div></figure></div></div>    
</body>
</html>