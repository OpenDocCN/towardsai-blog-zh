<html>
<head>
<title>Machine learning with PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PySpark进行机器学习</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/machine-learning-with-pyspark-23d54d82dbc4?source=collection_archive---------1-----------------------#2020-09-10">https://pub.towardsai.net/machine-learning-with-pyspark-23d54d82dbc4?source=collection_archive---------1-----------------------#2020-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b054" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><p id="d3c5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这篇文章中，我将分享我使用PySpark在spark中完成的几个机器学习工作。</p><p id="1f6d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">机器学习是人工智能的热点应用之一。人工智能是一个更大的生态系统，有许多令人惊叹的应用。机器学习简单来说就是在没有明确编程的情况下，机器自动学习并根据经验进行改进的能力。学习过程从观察数据开始，然后发现数据中的模式，并根据数据做出更好的学习决策。</p><h2 id="06a6" class="ku kv iq bd kw kx ky dn kz la lb dp lc kh ld le lf kl lg lh li kp lj lk ll iw bi translated">机器学习算法的类别</h2><p id="4a07" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">通常有监督学习和非监督学习，但有些介于两者之间</p><ol class=""><li id="76dd" class="lr ls iq jy b jz ka kd ke kh lt kl lu kp lv kt lw lx ly lz bi translated">监督机器学习算法</li><li id="27bf" class="lr ls iq jy b jz ma kd mb kh mc kl md kp me kt lw lx ly lz bi translated">无监督机器学习算法</li><li id="4686" class="lr ls iq jy b jz ma kd mb kh mc kl md kp me kt lw lx ly lz bi translated">半监督机器学习算法</li><li id="e19c" class="lr ls iq jy b jz ma kd mb kh mc kl md kp me kt lw lx ly lz bi translated">强化机器学习算法</li></ol><p id="3b31" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为什么要给机器输入数据？</p><p id="70e4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">主要原因之一是数据量。你能想象亚马逊服务器一天产生多少数据吗？很多。第二个原因是质量。一台机器通常更快、更准确、更省力。</p><h1 id="aa02" class="mf kv iq bd kw mg mh mi kz mj mk ml lc mm mn mo lf mp mq mr li ms mt mu ll mv bi translated"><strong class="ak">Spark中的机器学习</strong></h1><p id="b09c" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">Apache spark有一个名为MLlib的机器学习库。</p><p id="cdc8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">来自<a class="ae mw" href="https://spark.apache.org/docs/1.1.0/mllib-guide.html" rel="noopener ugc nofollow" target="_blank">https://spark.apache.org/docs/1.1.0/mllib-guide.html</a>。</p><p id="b29d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">MLlib是Spark的可扩展机器学习库，由常见的学习算法和实用程序组成，包括分类、回归、聚类、协同过滤、降维以及底层优化原语。</p><p id="6951" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">该库中内置了许多机器学习方法，有助于数据科学家专注于任务，而不是配置和基础设施。</p><p id="62d5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们将讨论三种流行的机器学习算法。他们</p><ol class=""><li id="3f0d" class="lr ls iq jy b jz ka kd ke kh lt kl lu kp lv kt lw lx ly lz bi translated">决策树回归</li><li id="876f" class="lr ls iq jy b jz ma kd mb kh mc kl md kp me kt lw lx ly lz bi translated">随机森林回归</li><li id="ad87" class="lr ls iq jy b jz ma kd mb kh mc kl md kp me kt lw lx ly lz bi translated">梯度推进树回归</li></ol><p id="af30" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">那么，什么是机器学习中的回归呢？</p><p id="b309" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">通过建立基于一个或多个预测因素的模型来预测目标值(主要是数字变量)是一项任务。预测值可以是数字变量或分类变量。范畴变量也叫名义变量，是那些有类别但没有内在顺序的变量。一个例子可以是性别、头发颜色等。</p><p id="3634" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">你也可以用统计术语来描述回归。这是一个统计过程，用于估计因变量和一个或多个自变量之间的关系。更多信息，你可以阅读本页。<a class="ae mw" href="https://en.wikipedia.org/wiki/Regression_analysis" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Regression_analysis</a></p><h2 id="d10d" class="ku kv iq bd kw kx ky dn kz la lb dp lc kh ld le lf kl lg lh li kp lj lk ll iw bi translated">数据集和问题</h2><p id="6460" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">我们根据今年的房价预测明年的房价。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi mx"><img src="../Images/ae0fb9e349099a587ff90b0c79046043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUmIFKVfJP2huogO1CIqJQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">资料组</figcaption></figure><h2 id="6961" class="ku kv iq bd kw kx ky dn kz la lb dp lc kh ld le lf kl lg lh li kp lj lk ll iw bi translated">决策树回归</h2><p id="2019" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">这是一个非常简单的回归模型。它以树形结构的形式创建一个回归模型。这是它的工作原理。它将数据集分解成小的子集组，直到达到某个阈值，例如50。这些小数据集是回归模型的抽样方法。这种情况递归地发生，直到所有的数据都除以一个最小的阈值。然后，它从数据集计算相对重要性，并将其划分为叶。决策树可以处理分类数据和数字数据。以下是关于决策树的更多细节。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nn"><img src="../Images/c62d16fbb75de0818da9739fa9a6a1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_9Kju3GD_8YcTXIBeDxmw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">图片来源:<a class="ae mw" href="https://saedsayad.com/decision_tree_reg.htm" rel="noopener ugc nofollow" target="_blank">https://saedsayad.com/decision_tree_reg.htm</a></figcaption></figure><p id="099f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">密码</p><pre class="my mz na nb gt no np nq nr aw ns bi"><span id="b82f" class="ku kv iq np b gy nt nu l nv nw"># To add a new cell, type '# %%'<br/># To add a new markdown cell, type '# %% [markdown]'<br/># %%<br/>#Creating a spark session in order to have access to creating dataframes<br/>from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.getOrCreate()</span><span id="15e0" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Importing the algorithms and evaluator needed for creating the model and evaluating its performance</span><span id="f524" class="ku kv iq np b gy nx nu l nv nw">from pyspark.ml.regression import DecisionTreeRegressor<br/>from pyspark.ml.regression import RandomForestRegressor<br/>from pyspark.ml.regression import GBTRegressor<br/>from pyspark.ml.evaluation import RegressionEvaluator</span><span id="7505" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Loading in the data, printing the schema, and showing the top 20 rows</span><span id="0790" class="ku kv iq np b gy nx nu l nv nw">ecommerceData = spark.read.csv(r'Data/ServiceUsage.csv', header = True, inferSchema = True)<br/>ecommerceData.printSchema()<br/>ecommerceData.show()</span><span id="e0ae" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Immporting the vector libraries in order to transform the dataset</span><span id="b8d4" class="ku kv iq np b gy nx nu l nv nw">from pyspark.ml.linalg import Vectors<br/>from pyspark.ml.feature import VectorAssembler</span><span id="42ba" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Feeding the dataframe into the vector assembler (transformer) and combining 4 columns into one column called "features"</span><span id="a57b" class="ku kv iq np b gy nx nu l nv nw">assembler = VectorAssembler(inputCols = ['Avg Session Length', 'Time on App', 'Time on Website', 'Length of Membership'], outputCol = 'Features')<br/>transformedEcommerceData = assembler.transform(ecommerceData)<br/>transformedEcommerceData.show()</span><span id="d023" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Preparing the data for the model by only having two columns: the features and the column of known data we're trying to predict</span><span id="76b5" class="ku kv iq np b gy nx nu l nv nw">finalData = transformedEcommerceData.select('Features', 'Yearly Amount Spent')<br/>finalData.show()</span><span id="80b4" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Splitting the data into training and testing sets by randomly choosing 70% of the rows for training and 30% of the rows for testing</span><span id="0fe0" class="ku kv iq np b gy nx nu l nv nw">trainingData, testingData = finalData.randomSplit([0.7, 0.3])</span><span id="4988" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Decision Tree Regression<br/>decisionTree = DecisionTreeRegressor(featuresCol = "Features", labelCol = "Yearly Amount Spent", maxDepth = 15, maxBins = 32)<br/>decisionTreeModel = decisionTree.fit(trainingData)<br/>dtresults = decisionTreeModel.transform(testingData)<br/>dtresults.select("Prediction", "Yearly Amount Spent", "Features")<br/>dtresults.show()<br/>#Using RMSE to evaluate the model<br/>gbtevaluator = RegressionEvaluator(labelCol="Yearly Amount Spent", predictionCol="prediction", metricName="rmse")<br/>gbtrmse = gbtevaluator.evaluate(dtresults)<br/>print("Gradient-Boosted Tree RMSE: ", gbtrmse)</span></pre><p id="a6f3" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">预言；预测；预告</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/dca57716b86955a8b664351e033bdf89.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*uR4vncF4ajtzDOk6YNW-bA.jpeg"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">决策树回归的输出</figcaption></figure><h2 id="f027" class="ku kv iq bd kw kx ky dn kz la lb dp lc kh ld le lf kl lg lh li kp lj lk ll iw bi translated">2.随机森林回归:</h2><p id="1ef8" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">随机森林回归是预测的最有效和最准确的机器学习模型之一。这是一种监督学习算法。它是一种元估计器，在数据集的各个子样本上拟合几个分类决策树，并使用平均来提高预测精度和控制过拟合。它非常擅长处理表格数据、数字或分类特征。有关随机森林回归的更多信息，请阅读本文。<a class="ae mw" href="https://levelup.gitconnected.com/random-forest-regression-209c0f354c84" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/random-forest-regression-209 c0f 354 c 84</a></p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c9e85be7c7a93257702fa6ebb40fbeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*PGHafuCcCGDIzpZVsaScqg.jpeg"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">来自中等邮政的随机森林结构</figcaption></figure><p id="de0a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">密码</p><pre class="my mz na nb gt no np nq nr aw ns bi"><span id="e1b6" class="ku kv iq np b gy nt nu l nv nw"># To add a new cell, type '# %%'<br/># To add a new markdown cell, type '# %% [markdown]'<br/># %%<br/>#Creating a spark session in order to have access to creating dataframes</span><span id="5046" class="ku kv iq np b gy nx nu l nv nw">from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.getOrCreate()<br/><br/><br/># %%<br/>#Importing the algorithms and evaluator needed for creating the model and evaluating its performance</span><span id="02dc" class="ku kv iq np b gy nx nu l nv nw">from pyspark.ml.regression import DecisionTreeRegressor<br/>from pyspark.ml.regression import RandomForestRegressor<br/>from pyspark.ml.regression import GBTRegressor<br/>from pyspark.ml.evaluation import RegressionEvaluator<br/><br/><br/># %%<br/>#Loading in the data, printing the schema, and showing the top 20 rows</span><span id="f853" class="ku kv iq np b gy nx nu l nv nw">ecommerceData = spark.read.csv(r'Data/ServiceUsage.csv', header = True, inferSchema = True)<br/>ecommerceData.printSchema()<br/>ecommerceData.show()<br/><br/><br/># %%<br/>#Immporting the vector libraries in order to transform the dataset</span><span id="ea47" class="ku kv iq np b gy nx nu l nv nw">from pyspark.ml.linalg import Vectors<br/>from pyspark.ml.feature import VectorAssembler<br/><br/><br/># %%<br/>#Feeding the dataframe into the vector assembler (transformer) and combining 4 columns into one column called "features"</span><span id="d7ae" class="ku kv iq np b gy nx nu l nv nw">assembler = VectorAssembler(inputCols = ['Avg Session Length', 'Time on App', 'Time on Website', 'Length of Membership'], outputCol = 'Features')<br/>transformedEcommerceData = assembler.transform(ecommerceData)<br/>transformedEcommerceData.show()<br/><br/><br/># %%<br/>#Preparing the data for the model by only having two columns: the features and the column of known data we're trying to predict</span><span id="4c4f" class="ku kv iq np b gy nx nu l nv nw">finalData = transformedEcommerceData.select('Features', 'Yearly Amount Spent')<br/>finalData.show()<br/><br/><br/># %%<br/>#Splitting the data into training and testing sets by randomly choosing 70% of the rows for training and 30% of the rows for testing</span><span id="6c8b" class="ku kv iq np b gy nx nu l nv nw">trainingData, testingData = finalData.randomSplit([0.7, 0.3])<br/><br/><br/><br/># %%<br/>#Random Forest Regression<br/>randomForest = RandomForestRegressor(featuresCol = "Features", labelCol = "Yearly Amount Spent",  maxDepth = 15, maxBins = 32, numTrees = 200)<br/>randomForestModel = randomForest.fit(trainingData)<br/>rfresults = randomForestModel.transform(testingData)<br/>rfresults.select("Prediction", "Yearly Amount Spent", "Features")<br/>rfresults.show()<br/>#Using RMSE to evaluate the model<br/>gbtevaluator = RegressionEvaluator(labelCol="Yearly Amount Spent", predictionCol="prediction", metricName="rmse")<br/>gbtrmse = gbtevaluator.evaluate(rfresults)<br/>print("Gradient-Boosted Tree RMSE: ", gbtrmse)</span></pre><p id="a92e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">预言；预测；预告</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e5bc781c0a1f121dc7c6b799ab46c760.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*o-xfiUEvxkgQPcHfi8MeKw.jpeg"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">随机森林回归的输出</figcaption></figure><h2 id="2b13" class="ku kv iq bd kw kx ky dn kz la lb dp lc kh ld le lf kl lg lh li kp lj lk ll iw bi translated">3.梯度推进树回归</h2><p id="04cc" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">机器学习中的Boosting是一种将弱学习者转化为强学习者的方法。它结合了许多样本模型。那么最终的模型将会是一个强有力的预测器。它使用梯度下降来最小化损失。它可以执行回归、分类和排序。这是一种强大的机器学习算法。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/352dc554d2759067fc4204a2ed6b9f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*w_WcJNn-n7DD883TZwwJvw.jpeg"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">图片来源:<a class="ae mw" href="https://towardsdatascience.com/gradient-boosted-decision-trees-explained-9259bd8205af" rel="noopener" target="_blank">https://towards data science . com/gradient-boosted-decision-trees-explained-9259 BD 8205 af</a></figcaption></figure><p id="6446" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">它构建了一系列树，其中每棵树都进行了训练，以便尝试纠正该系列中前一棵树的错误。通常，梯度构建树集成使用大量被称为弱学习器的浅树。它们是以一种非随机的方式建立起来的，随着树的增加，模型的错误越来越少。它速度很快，不会占用太多内存。要了解更多关于梯度推进决策树的信息，请关注Coursera上的这个精彩视频。<a class="ae mw" href="https://www.coursera.org/lecture/python-machine-learning/gradient-boosted-decision-trees-emwn3" rel="noopener ugc nofollow" target="_blank">https://www . coursera . org/lecture/python-machine-learning/gradient-boosted-decision-trees-emwn 3</a></p><p id="c7b5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">密码</p><pre class="my mz na nb gt no np nq nr aw ns bi"><span id="c289" class="ku kv iq np b gy nt nu l nv nw"># To add a new cell, type '# %%'<br/># To add a new markdown cell, type '# %% [markdown]'<br/># %%<br/>#Creating a spark session in order to have access to creating dataframes</span><span id="6a20" class="ku kv iq np b gy nx nu l nv nw">from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.getOrCreate()</span><span id="4138" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Importing the algorithms and evaluator needed for creating the model and evaluating its performance</span><span id="ae20" class="ku kv iq np b gy nx nu l nv nw">from pyspark.ml.regression import DecisionTreeRegressor<br/>from pyspark.ml.regression import RandomForestRegressor<br/>from pyspark.ml.regression import GBTRegressor<br/>from pyspark.ml.evaluation import RegressionEvaluator</span><span id="03f5" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Loading in the data, printing the schema, and showing the top 20 rows</span><span id="7701" class="ku kv iq np b gy nx nu l nv nw">ecommerceData = spark.read.csv(r'Data/ServiceUsage.csv', header = True, inferSchema = True)<br/>ecommerceData.printSchema()<br/>ecommerceData.show()</span><span id="77fd" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Immporting the vector libraries in order to transform the dataset<br/>from pyspark.ml.linalg import Vectors<br/>from pyspark.ml.feature import VectorAssembler</span><span id="461a" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Feeding the dataframe into the vector assembler (transformer) and combining 4 columns into one column called "features"</span><span id="5376" class="ku kv iq np b gy nx nu l nv nw">assembler = VectorAssembler(inputCols = ['Avg Session Length', 'Time on App', 'Time on Website', 'Length of Membership'], outputCol = 'Features')<br/>transformedEcommerceData = assembler.transform(ecommerceData)<br/>transformedEcommerceData.show()</span><span id="b99b" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Preparing the data for the model by only having two columns: the features and the column of known data we're trying to predict</span><span id="c2a2" class="ku kv iq np b gy nx nu l nv nw">finalData = transformedEcommerceData.select('Features', 'Yearly Amount Spent')<br/>finalData.show()</span><span id="1814" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Splitting the data into training and testing sets by randomly choosing 70% of the rows for training and 30% of the rows for testing</span><span id="b33e" class="ku kv iq np b gy nx nu l nv nw">trainingData, testingData = finalData.randomSplit([0.7, 0.3])</span><span id="c132" class="ku kv iq np b gy nx nu l nv nw"># %%<br/>#Gradient Boosted Tree Regression to do the prediction<br/>boostedTree = GBTRegressor(featuresCol = "Features", labelCol = "Yearly Amount Spent", maxDepth = 5, maxBins = 32, maxIter = 200)<br/>boostedTreeModel = boostedTree.fit(trainingData)<br/>gbtresults = boostedTreeModel.transform(testingData)<br/>gbtresults.select("Prediction", "Yearly Amount Spent", "Features")<br/>gbtresults.show()<br/>#Using RMSE to evaluate the model<br/>gbtevaluator = RegressionEvaluator(labelCol="Yearly Amount Spent", predictionCol="prediction", metricName="rmse")<br/>gbtrmse = gbtevaluator.evaluate(gbtresults)<br/>print("Gradient-Boosted Tree RMSE: ", gbtrmse)</span></pre><p id="bfb4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">预言；预测；预告</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0fee5da42f7bc4bc865056ea063aae11.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*ETCzV1rs-6tQ_dbBHjCpdQ.jpeg"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">GBT成果</figcaption></figure><h2 id="d729" class="ku kv iq bd kw kx ky dn kz la lb dp lc kh ld le lf kl lg lh li kp lj lk ll iw bi translated">结论</h2><p id="da72" class="pw-post-body-paragraph jw jx iq jy b jz lm kb kc kd ln kf kg kh lo kj kk kl lp kn ko kp lq kr ks kt ij bi translated">预测的结果令人惊讶。这真的很容易实现，但随机森林和GBT需要更长的时间来运行。就得分和预测而言，最好的算法是GBT算法。</p></div></div>    
</body>
</html>