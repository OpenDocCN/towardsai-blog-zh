<html>
<head>
<title>My Workflow To Profile Python Code Using VS Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我使用VS代码分析Python代码的工作流程</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-i-profile-python-code-using-vs-code-714d0ba71b6d?source=collection_archive---------0-----------------------#2022-01-25">https://pub.towardsai.net/how-i-profile-python-code-using-vs-code-714d0ba71b6d?source=collection_archive---------0-----------------------#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4427" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/software-engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/2b4eaa682b2df87f76723726a653d210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDuGsK4TT3bD7ta2ItSLZw.png"/></div></div></figure><h1 id="c003" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">简介</strong></h1><p id="3d52" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">本文描述了我如何使用VS代码来分析Python代码，以识别CPU或内存问题。</p><p id="15b1" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">为了使事情更加具体和实用，我将通过快速找到真实项目中高CPU利用率的来源来演示工作流是如何工作的:2.8.22版本中rasa开源项目中的<a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/rasa/core/policies/rule_policy.py#L92" rel="noopener ugc nofollow" target="_blank"> RulePolicy </a>类。</p><p id="6dfb" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">复制本文中描述的工作流的代码是这里的<a class="ae ml" href="https://github.com/hsm207/python_profile" rel="noopener ugc nofollow" target="_blank">和</a>。</p><h1 id="25df" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">问题陈述</h1><p id="4a28" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">假设您收到一个错误报告，声称使用rasa构建的聊天机器人具有不合理的高CPU利用率，并且报告作者声称这是RulePolicy类导致的。</p><p id="c873" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">您试图使用错误报告中共享的信息来重现该行为，实际上，您也观察到了高CPU利用率。</p><p id="be24" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">下一步是找出这是如何发生的。你如何着手做这件事？</p><p id="48da" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">最简单的办法就是问问你的资深同事的想法。不幸的是，编写该类的作者已经不在了，其他人只能提供通用或模糊的想法。</p><p id="8499" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">在这一点上，你几乎是靠你自己。您必须自己找出高CPU利用率的来源。你将如何着手做这件事？</p><p id="1d30" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">你可以从阅读代码开始…</p><p id="71bd" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们看看这种方法能走多远。</p><p id="b035" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">错误报告提到问题只发生在推理时，并且您知道<code class="fe mm mn mo mp b"><a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/rasa/core/policies/rule_policy.py#L1070" rel="noopener ugc nofollow" target="_blank">predict_action_probabilities</a></code>方法是推理时的主要入口点。所以，这看起来是一个开始阅读的好地方。</p><p id="d8d1" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这个方法看起来是这样的:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/9e1b172729e64eda989f6c02f53e7f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*4jKzuqnahO3EPvktq-OAEQ.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图1:预测行动概率方法</figcaption></figure><p id="f530" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">结果这个方法非常简单:它只是调用另一个方法，<code class="fe mm mn mo mp b"><a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/rasa/core/policies/rule_policy.py#L1081" rel="noopener ugc nofollow" target="_blank">_predict</a></code>。让我们看看这个方法是如何工作的:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2ae889f0964b9d9396aab5e07ebed6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRGSjcBRbGb0wBppYiyzlw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图2:predict方法的一个片段</figcaption></figure><p id="0b28" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated"><code class="fe mm mn mo mp b">_predict</code>有一个非常长的实现，它有许多分支，也调用其他函数。</p><p id="6fa7" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">即使您决定坚持到底，一行一行地跟踪整个实现，也不能保证您真的理解每一行在做什么或应该做什么，更不用说导致高CPU利用率的实际行了。</p><p id="b158" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这就是剖析器快速锁定违规行的方便之处。</p><h1 id="133b" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">解决办法</h1><h2 id="9a56" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">概观</h2><p id="0193" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">以下是我分析python代码(或任何相关语言)的主要步骤:</p><ol class=""><li id="6f4e" class="nl nm it lk b ll mg lp mh lt nn lx no mb np mf nq nr ns nt bi translated">建立集装箱化的环境</li><li id="ebce" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf nq nr ns nt bi translated">编写一个调用我们想要分析的函数的最小脚本</li><li id="4102" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf nq nr ns nt bi translated">重现问题</li><li id="441a" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf nq nr ns nt bi translated">设置调试基础结构</li><li id="f004" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf nq nr ns nt bi translated">剖析脚本</li><li id="7cec" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf nq nr ns nt bi translated">可视化并分析结果</li><li id="0619" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf nq nr ns nt bi translated">尝试各种修复[可选]</li></ol><h2 id="fe19" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">步骤1:建立一个容器化的环境</h2><p id="3649" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我们应该在集装箱化的环境中进行分析，这样我们就可以轻松地与同事分享我们的结果。</p><p id="5095" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">使用VS代码很容易做到这一点，因为它允许开发人员无缝地创建一个容器、登录到该容器并编码，就像他们在本地机器上一样。有关详细信息，请参考VS <a class="ae ml" href="https://code.visualstudio.com/docs/remote/containers" rel="noopener ugc nofollow" target="_blank">代码在容器内开发</a>指南。</p><p id="7b6f" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">在本例中，我们将基于<code class="fe mm mn mo mp b">rasa/rasa:2.8.22-full</code>映像创建一个容器，因为这是报告高CPU利用率问题的版本。</p><h2 id="df77" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated"><strong class="ak">第二步:编写一个最小的脚本来调用我们想要分析的函数</strong></h2><p id="0a51" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">“最小”这个词很重要。换句话说，我们希望直接或者尽可能直接地调用我们认为有问题的函数。</p><p id="d096" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">为什么？</p><p id="f3da" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">假设您决定从头构建一个完整的机器人，并通过与它对话来测试CPU负载，从而重现这种行为。这将会降低您以后的分析速度，因为您所做的每一项更改都需要启动bot并与之对话，以评估您的更改的影响。此外，bot中有许多移动部件，因此即使您在与它交谈时看到高CPU负载，也很难确定它发生在RulePolicy的<code class="fe mm mn mo mp b"><a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/rasa/core/policies/rule_policy.py#L1070" rel="noopener ugc nofollow" target="_blank">predict_action_probabilities</a></code>方法内部的某个地方。</p><p id="feed" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">那么，我们如何找出调用该方法的最快方法呢？</p><p id="2239" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">一个好的起点是阅读RulePolicy类的测试用例。当然，这是假设您在一个一直努力遵循软件工程最佳实践的团队中工作。如果不是这样，那么你有更大的问题要解决:)</p><p id="7740" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">通过阅读<a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/tests/core/policies/test_rule_policy.py#L154" rel="noopener ugc nofollow" target="_blank">test _ potential _ conflict _ resolved _ by _ conversation _ start _ when _ slot _ initial _ value</a>函数，我们了解到这是调用RulePolicy的<code class="fe mm mn mo mp b"><a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/rasa/core/policies/rule_policy.py#L1070" rel="noopener ugc nofollow" target="_blank">predict_action_probabilities</a></code>方法的最直接方式:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/35b689b0df37b4d8d267e74180ae8372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fvg7WYN7xz6xo7hJRPQIw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图3:测试RulePolicy的<code class="fe mm mn mo mp b"><a class="ae ml" href="https://github.com/RasaHQ/rasa/blob/a215ae5ef54bed0c62e25331866f97f6f2845df7/rasa/core/policies/rule_policy.py#L1070" rel="noopener ugc nofollow" target="_blank">predict_action_probabilities</a></code>方法的最小脚本</figcaption></figure><p id="c747" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">注意，我们已经将对<code class="fe mm mn mo mp b">predict_action_probabilities</code>方法的调用封装在另一个名为<code class="fe mm mn mo mp b">problem_function</code>的函数中。这看起来是多余的，但实际上非常重要，因为我们想防止其他函数调用，例如<code class="fe mm mn mo mp b">DialogueStateTracker.from_events</code>影响稍后<code class="fe mm mn mo mp b">rule_policy.predict_action_probabilities</code>的计时。</p><p id="e2a7" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">此外，因为我们将重复运行这个脚本，所以有一个快捷方式来快速完成它会很有帮助。我们可以为此使用makefile</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ccd9567aa5600a43f3e94625a7ced51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*XB1Yp8oI23sQ81ylLOFIlw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图4:运行最小脚本的makefile目标</figcaption></figure><h2 id="6a88" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">步骤3:重现问题</h2><p id="fa07" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">现在我们准备测试bug报告者的声明，即RulePolicy是运行时高CPU负载的原因！</p><p id="bed4" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">为此，我们可以重复调用我们在上一步中编写的脚本，并使用类似<code class="fe mm mn mo mp b">htop</code>的工具观察脚本运行时的CPU负载:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oa"><img src="../Images/43c1e3c34370f7e31d0b092918de9a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ybIfimTMmAe1MN662lDROg.gif"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图5:重复调用脚本并观察cpu负载</figcaption></figure><p id="83be" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">在图5中，我们调用最小脚本3次，并注意到在一个CPU内核中总是有一个峰值。但这可能只是由于TensorFlow将我们的模型加载到内存中。</p><p id="e258" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">为了确保不是这种情况，我们可以在<code class="fe mm mn mo mp b">problem_function</code>之前插入一个调用sleep来休眠5秒钟，并在该间隔之后观察CPU负载。为了简洁起见，我将在本文中省略这一步。</p><h2 id="2bc9" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">步骤4:设置调试基础设施</h2><p id="058c" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">既然我们已经确认了<code class="fe mm mn mo mp b">rule_policy.predict_action_probabilities</code>的实现有问题或效率低下，我们应该配置脚本运行时附带一个调试器，这样我们就可以检查脚本在整个执行过程中的状态。</p><p id="8f84" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这一步非常容易设置VS代码，因为我们已经将问题隔离到一个python脚本中。我们只需要创建一个<a class="ae ml" href="https://code.visualstudio.com/docs/python/debugging" rel="noopener ugc nofollow" target="_blank">启动配置</a>来调试当前文件:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/506141e270e9a08aa85536c53c2aeec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*2Lrwd4OG7CkY4d6YSQDUjw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图6:调试main.py的launch.json配置</figcaption></figure><p id="8fa8" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">注意，我们已经将<code class="fe mm mn mo mp b">justMyCode</code>设置为<code class="fe mm mn mo mp b">false</code>(第13行)。如果我们将这个设置为<code class="fe mm mn mo mp b">true</code>，那么我们在<code class="fe mm mn mo mp b">rasa</code>库中插入的断点都不会有任何效果。</p><h2 id="2011" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">步骤5:剖析脚本</h2><p id="3c0a" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我们可以使用<a class="ae ml" href="https://docs.python.org/3.8/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>模块为<code class="fe mm mn mo mp b">main.py</code>中的函数调用计时。它输出一堆在终端上阅读起来很麻烦的统计数据，所以我们应该使用以下命令将它保存到一个文件中:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/79a828090e3e86844d62965e91fbffb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*6lCeRxI5O9mmQl10QtyIFw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图7:概要文件main.py的makefile目标</figcaption></figure><h2 id="3dc7" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">第六步:想象并分析结果</h2><p id="a757" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我们可以使用<a class="ae ml" href="https://docs.python.org/3.8/library/profile.html#module-pstats" rel="noopener ugc nofollow" target="_blank"> pstats </a>模块来操作我们在上一步中创建的<code class="fe mm mn mo mp b">cprofile.stats</code>的内容。</p><p id="2db6" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">然而，通过使用<a class="ae ml" href="https://jiffyclub.github.io/snakeviz/" rel="noopener ugc nofollow" target="_blank"> snakeviz </a>模块可视化结果来开始分析更容易:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ea6d9c33b2383070279cc43420209410.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*Bdfp1N3Aj2A_0jzG9dPXWg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图8:使用snakeviz可视化cProfile的结果</figcaption></figure><p id="0ac3" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">图8显示了snake via在容器内的端口8080 <strong class="lk jd">上启动了一个web服务器。但是，VS代码以某种方式检测到这一点，并将自动转发该端口，因此您应该会看到以下提示:</strong></p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d7dbf8c130ae4174ab4a841516e192c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*3g2vGLOTmACLP3RWdfq4bg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图9: VS代码神奇地完成了端口转发…</figcaption></figure><p id="5403" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">点击“在浏览器中打开”按钮，导航到从<code class="fe mm mn mo mp b">problem_function</code>发出的函数调用，我们看到:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi of"><img src="../Images/90e9730f9937b75cb099a1854365f320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VeEfjcX2C46x3CAdOylFTQ.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图10:来自problem_function的所有函数调用的计时</figcaption></figure><p id="d078" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">运行这个函数需要3.03秒。这个函数调用<code class="fe mm mn mo mp b">_predict</code>，T8又调用<code class="fe mm mn mo mp b">find_action_from_rules</code>，T9又调用<code class="fe mm mn mo mp b">_get_possible_keys</code>。</p><p id="0e42" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">似乎在<code class="fe mm mn mo mp b">_get_possible_keys</code>内部有一个匿名函数，这个函数占用了大部分执行时间(总共3.02秒中的2.97秒)。方便的是，图10中的图表告诉我们，我们可以在rule_policy.py文件的第895行找到这个函数。让我们看看这个函数的作用:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi og"><img src="../Images/0d3beafd946e9d000189bcaddda4b39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSSGTKdyyNPgoml-6fbkqw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图11:花费很长时间完成的匿名函数</figcaption></figure><p id="cb6f" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">匿名函数慢是因为<code class="fe mm mn mo mp b">possible_keys</code>真的很大还是因为谓词函数，<code class="fe mm mn mo mp b">self._is_rule_applicable</code>是CPU密集型函数？</p><p id="6eb6" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我们可以通过查看python遍历一个集合并执行一些简单操作需要多长时间来检查前一种情况。例如:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oh"><img src="../Images/720449e890f9377206ad03a96afed830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHtH5LD6EH3XqsDEA6Y01Q.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图12:快速检查一个集合的循环开销是否很大</figcaption></figure><p id="3c15" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">图12显示，对一组100万个元素进行函数调用需要不到1秒的时间。对一组1000万个元素做同样的事情几乎需要2秒钟。</p><p id="da71" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated"><code class="fe mm mn mo mp b">possible_keys</code>有多大？使用<a class="ae ml" href="https://code.visualstudio.com/blogs/2018/07/12/introducing-logpoints-and-auto-attach" rel="noopener ugc nofollow" target="_blank">日志点</a>很容易检查:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fa92f1c499f6ac2714ee94ef7494846e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*3paQpN-iC7Q03MpblqC7wQ.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图13:添加一个日志点来检查states和possible_keys变量的大小</figcaption></figure><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7cad8a37b6591d28e879862cbf2d8d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*LT1zVPE3HtHqyxlNLRZbaw.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图13:States和possible_keys变量的大小</figcaption></figure><p id="918c" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我们看到变量<code class="fe mm mn mo mp b">possible_keys</code>只有4082个元素，变量<code class="fe mm mn mo mp b">states</code>只有2个元素。</p><p id="025e" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">因此，我们得出结论，高CPU负载的主要原因更多地与<code class="fe mm mn mo mp b">self._is_rule_applicable</code>的实现有关，而不是在<code class="fe mm mn mo mp b">states</code>和<code class="fe mm mn mo mp b">possible_keys</code>数据结构上循环。</p><p id="d503" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">谜团解开了！</p><h2 id="733e" class="na kl it bd km nb nc dn kq nd ne dp ku lt nf ng ky lx nh ni lc mb nj nk lg iz bi translated">尝试各种修复方法[可选]</h2><p id="6aae" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">此时，我们可以提交一份新的错误报告，让开发人员知道他们需要重新考虑他们的<code class="fe mm mn mo mp b">self._is_rule_applicable</code>或者甚至<code class="fe mm mn mo mp b">_get_possible_keys</code>的实现。</p><p id="ee16" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我们也可以多逛逛，看看我们自己是否能想出一个快速的解决办法。</p><p id="0ec3" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">回头看图10，我们看到<code class="fe mm mn mo mp b">_is_rule_applicable</code>大部分时间花在了<code class="fe mm mn mo mp b">_rule_key_to_state</code>函数上。这个函数看起来是这样的:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/49047aae359a97263fd75ad142ba21a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*KiIWJOhM4jmBdF1gpHTOVg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图14: <code class="fe mm mn mo mp b">_rule_key_to_state definition</code></figcaption></figure><p id="e001" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这个函数的目的是将一段文本转换成JSON对象/python字典。值得注意的是，这个函数有一个<code class="fe mm mn mo mp b">lru_cache</code>装饰器，并且被设置为只缓存1000个元素。</p><p id="e220" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">如果我们把<code class="fe mm mn mo mp b">maxsize</code>设为5000会怎么样？这能解决高CPU利用率的问题吗？</p><p id="eedc" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">在我们这样做之前，让我们返回snakeviz来看看当<code class="fe mm mn mo mp b">maxsize=1000</code>发生以下情况时<code class="fe mm mn mo mp b">json.loads</code>函数调用的统计数据:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ol"><img src="../Images/99683efcb3ab8ef2c57e6785df3055ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHOccI5jOunx_1wvfEK7ew.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图maxsize = 1000时的json.loads()统计数据</figcaption></figure><p id="f49e" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我们还可以使用<a class="ae ml" href="https://pypi.org/project/memory-profiler/#description" rel="noopener ugc nofollow" target="_blank"> memory_profiler </a>模块来监控内存使用情况:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi om"><img src="../Images/a98448cdc5edaa31575a143e7ba1ee16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ho9CnUPvN4vD_PfbTAeQHg.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图maxsize = 1000时的内存使用情况</figcaption></figure><p id="1329" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">图16显示该函数在<code class="fe mm mn mo mp b">maxsize=1000</code>时消耗了27.312 MiB的内存。请注意，在编写关于当对象被销毁时如何报告内存使用情况的文章时，有一个公开的bug。详见本<a class="ae ml" href="https://github.com/pythonprofilers/memory_profiler/issues/236#issuecomment-503996763" rel="noopener ugc nofollow" target="_blank">期</a>。</p><p id="258e" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">下面是当我们将<code class="fe mm mn mo mp b">maxsize</code>设置为5000时发生的情况:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi on"><img src="../Images/01acea7ca9950c4483d548a9751ff8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzG92BFcat8PbF0ksE7NBw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图maxsize = 5000时的json.loads()统计数据</figcaption></figure><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oo"><img src="../Images/6438caffcdeeac07b1187a1aed5a196c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhFv-xu7p-ZVkB5cFUVDmw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图maxsize = 5000时的内存使用情况</figcaption></figure><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi op"><img src="../Images/a633ba0a5af51220d48429ae3c845da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ickK41xRuCgHVo8DL8ynbA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图19:当maxsize=5000时，来自problem_function的所有函数调用的计时</figcaption></figure><p id="3bd7" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">将<code class="fe mm mn mo mp b">maxsize</code>从1000增加到5000的影响是:</p><ul class=""><li id="8dfe" class="nl nm it lk b ll mg lp mh lt nn lx no mb np mf oq nr ns nt bi translated">对<code class="fe mm mn mo mp b">json.loads()</code>的呼叫次数减少50%</li><li id="2321" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf oq nr ns nt bi translated">内存使用量增加了近5倍</li><li id="373f" class="nl nm it lk b ll nu lp nv lt nw lx nx mb ny mf oq nr ns nt bi translated">运行时间减少28%</li></ul><p id="1acb" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">运行时间的减少可能看起来不明显，但请记住，这是基于对<code class="fe mm mn mo mp b">problem_function()</code>的1次呼叫的概况。多次修改<code class="fe mm mn mo mp b">main.py</code>来调用<code class="fe mm mn mo mp b">problem_function()</code>会节省更多的时间。</p><p id="8f7b" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">更重要的是，高CPU负载现在不那么明显了(本文省略了结果)。</p><p id="523c" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">因此，设置<code class="fe mm mn mo mp b">maxisze=5000</code>可能是一个可接受的临时快速修复。</p><h1 id="ae57" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="5886" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">本文解释了我使用VS代码分析python代码的工作流程。我们已经了解了如何使用docker、make、cprofile、snakeviz等工具来快速识别代码中的性能瓶颈并评估修复的影响。</p><p id="d375" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">我希望你已经发现这是有用的。</p><p id="cf80" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">关于剖析python代码的更多技巧和诀窍，我强烈推荐[1]。</p><h1 id="8b17" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">参考</h1><p id="7b7b" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">[1] <a class="ae ml" href="https://github.com/mynameisfiber/high_performance_python_2e" rel="noopener ugc nofollow" target="_blank">高性能Python，第二版</a>。米莎·戈瑞克和伊恩·奥兹瓦尔德。2020.</p></div></div>    
</body>
</html>