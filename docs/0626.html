<html>
<head>
<title>Image Processing Basics through OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV中的图像处理基础知识</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/image-processing-basics-through-opencv-e9cbc6130821?source=collection_archive---------2-----------------------#2020-06-26">https://pub.towardsai.net/image-processing-basics-through-opencv-e9cbc6130821?source=collection_archive---------2-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="90ac" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a></h2><div class=""/><div class=""><h2 id="bce4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过阈值处理(直方图投影)和过滤等主题对Python的基本介绍</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/21c9a955ff1f42a16b6d268af7dc87f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PLBNhkqntnKlVMj1"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特拉赫曼</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1c08" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated"><strong class="ak">图像处理</strong></h1><blockquote class="ma mb mc"><p id="7c28" class="md me mf mg b mh mi kd mj mk ml kg mm mn mo mp mq mr ms mt mu mv mw mx my mz im bi translated"><em class="it">在计算机科学中，</em> <strong class="mg jd"> <em class="it">数字图像处理</em> </strong> <em class="it">是利用数字计算机通过某种算法对数字图像进行处理。【</em><a class="ae lh" href="https://en.wikipedia.org/wiki/Digital_image_processing" rel="noopener ugc nofollow" target="_blank"><em class="it">1</em></a><em class="it">】</em></p></blockquote><p id="8ea0" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">一幅图像被作为输入，一组算法在其上运行，根据应用程序的使用得到一定的结果。为什么受欢迎？</p><p id="3234" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">答案在于，从网络安全到医学图像分析，几乎在生活的每一个方面都使用图像处理，并且图像处理正被迅速应用于所有领域。因此，这是一项非常需要掌握的技能。</p><p id="22a4" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">虽然图像处理应该用快速语言如C++来完成，但为了理解和简洁起见，我将在本教程中使用<a class="ae lh" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>。</p><h1 id="34c9" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">OpenCV</h1><blockquote class="ma mb mc"><p id="9c53" class="md me mf mg b mh mi kd mj mk ml kg mm mn mo mp mq mr ms mt mu mv mw mx my mz im bi translated"><em class="it"> OpenCV是一个主要针对实时计算机视觉的编程函数库。最初由英特尔开发，后来由Willow Garage和Itseez支持。该库是跨平台的，在开源BSD许可下可以免费使用。【</em><a class="ae lh" href="https://en.wikipedia.org/wiki/OpenCV" rel="noopener ugc nofollow" target="_blank"><em class="it">2</em></a><em class="it">】</em></p></blockquote><p id="24ab" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">这是一个非常酷的库，它使得通过一个黑盒应用图像处理算法变得非常容易(尽管我非常鼓励你了解每个算法背后的基本原理，这有助于应用算法)。</p><p id="4444" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">我相信通过这样做的学习，我们将直接从一个任务开始，找到图像的垂直直方图投影。</p><h1 id="91d5" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">阈值处理</h1><p id="1a96" class="pw-post-body-paragraph md me it mg b mh nd kd mj mk ne kg mm na nf mp mq nb ng mt mu nc nh mx my mz im bi translated">让我们从我在Unsplash上找到的这张图片开始。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/962bc4062889f8d9f333b332c7292e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*T4NBRRn9Iwc6otx3.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">兰迪·塔兰皮在<a class="ae lh" href="https://unsplash.com/photos/U2eUlPEKIgU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="01da" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">我们都做梦，对吧？</p><p id="f8ee" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">这张图片包含了什么？</p><p id="4461" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">让我们来了解一下！</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="248b" class="no lj it nk b gy np nq l nr ns"># Requiring minimum libraries for our use</span><span id="43fd" class="no lj it nk b gy nt nq l nr ns">from PIL import Image<br/>import numpy as np<br/>image = Image.open( img_path ).convert('L') #define the img_path<br/>image = np.array(image) # storing the image as an 3d array<br/>print( image.shape ) # (81, 276, 3)<br/>print( np.unique( image)) # ([ 0 ... 255 ])<br/># np.unique returns all the unique elements in an array</span></pre><p id="32c5" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">所以图像基本上是一个3D数组，元素范围从0到255。</p><p id="9971" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">然而，这无助于识别图像中感兴趣的边缘或区域。</p><p id="d699" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">所以我们会遵循一种叫做<a class="ae lh" href="https://en.wikipedia.org/wiki/Binary_image" rel="noopener ugc nofollow" target="_blank">二值化的方法。</a></p><p id="1bd4" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">让我们通过简单的阈值处理将它转换成二值图像。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="940b" class="no lj it nk b gy np nq l nr ns">import cv2<br/>_,thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)<br/># we are converting the image into 255 and 0  <br/># according to pixel value &gt; 127 -&gt; 255 else 0<br/>print (np.unique( thresh1 )) # [ 0 , 255 ]<br/>Image.fromarray(thresh1).show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/40ccb0c04a9cb1cf166ace6b554ca638.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*VV8-68cFCs2lS6KI.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">二值化图像</figcaption></figure><p id="8c0e" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">更多的功能可读性哈！然而，这种二进制化在光照不恒定的情况下不起作用，这不是这个图像的情况。</p><p id="9a9f" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">我们考虑一种更强大的阈值处理技术，<strong class="mg jd">自适应阈值处理</strong>，它根据固定大小的相邻块对图像进行阈值处理。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="456c" class="no lj it nk b gy np nq l nr ns">thresh2 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\<br/>            cv2.THRESH_BINARY,61,2)<br/># we are converting the image into 255 and 0  <br/># according to neighbouring blocks of size 11 and fixed constant <br/>#c =2<br/>print (np.unique( thresh2 )) # [ 0 , 255 ]<br/>Image.fromarray(thresh1).show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/b51a71e2085d2ec14691c7fb48306fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*B7wUBfQrIkqQD94i.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">自适应阈值</figcaption></figure><p id="58c8" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">所以你可以看到它更侧重于文本部分，因为它是基于相邻像素的计算。</p><p id="ec9c" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">让我们检查一下两幅图像的<strong class="mg jd">垂直投影</strong>。</p><p id="64ac" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated"><strong class="mg jd">垂直投影</strong>只不过是图像每一行中所有元素的列方向总和。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="b2f5" class="no lj it nk b gy np nq l nr ns"># code for vertical projection<br/>import matplotlib.pyplot as plt <br/>img_col_sums = np.sum( thresh , axis =0 ) <br/>plt.plot( img_col_sums )<br/>plt.show()<br/>## pretty easy huh , try writing it in C++ 🤓</span></pre><p id="fa34" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">好了，表演时间到了。</p><p id="4bf2" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">对于第一幅图像:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/37e7bbbe0223d546eedea696b14b6db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*vbnVFSvVaKlEtr92.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">阈值1</figcaption></figure><p id="8f4f" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">对于第二幅图像:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5aa408d50c56c65c285b36105c98873d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*rD4XR8Pw5gtvKcle.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">阈值2(自适应)</figcaption></figure><p id="9b56" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated"><strong class="mg jd">推论:</strong></p><p id="c0bc" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">感兴趣的区域在第二幅图像中更加明显，您可以从阵列中轻松地获得峰值<strong class="mg jd">。一个简单的数组中值就能证明我的观点。</strong></p><p id="0c3c" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated"><strong class="mg jd">应用:</strong></p><ul class=""><li id="9bd7" class="nv nw it mg b mh mi mk ml na nx nb ny nc nz mz oa ob oc od bi translated">这在OCR中有应用，并用于分割文本中的字符以供进一步识别。</li></ul><h1 id="6cac" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">滤像</h1><p id="2b92" class="pw-post-body-paragraph md me it mg b mh nd kd mj mk ne kg mm na nf mp mq nb ng mt mu nc nh mx my mz im bi translated">滤镜在图像处理中用于锐化和模糊图像。</p><p id="105f" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">让我们再从一张图片开始，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/aef3cc956d1a0330c1443624aec46f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*NKD2SktFcV4cqqU0.jpeg"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">本·科尔德在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ad51" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">过滤可以通过两种方式实现:</p><ul class=""><li id="2e9b" class="nv nw it mg b mh mi mk ml na nx nb ny nc nz mz oa ob oc od bi translated">用滤波器进行图像卷积。</li><li id="6515" class="nv nw it mg b mh of mk og na oh nb oi nc oj mz oa ob oc od bi translated">在频域中掩蔽频率区域。</li></ul><p id="0d0d" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated"><strong class="mg jd">身份过滤</strong></p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="c665" class="no lj it nk b gy np nq l nr ns">from PIL import Image<br/>import numpy as np<br/>import cv2image = Image.open( img_path )<br/>#define the image path image = np.array(image) # converting the image into an arraykernel = np.zeros((3,3))<br/>kernel[1,1] = 1<br/>dst = cv2.filter2D( image , -1 , kernel )</span></pre><p id="dfcc" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">这产生了相同的图像。</p><p id="8475" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated"><strong class="mg jd">均匀模糊</strong></p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="6bf7" class="no lj it nk b gy np nq l nr ns">kernel = np.ones((3,3))* (1 /10.3 ) <br/>dst = cv2.filter2D( image ,-1 ,kernel ) <br/>Image.fromarray(dst).show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/3918a052c2cba3af8b4e28996c040baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*tUdpLkddijnzRknF.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">均匀模糊</figcaption></figure><p id="3983" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">这是一个用于平均或模糊图像的<strong class="mg jd">低通滤波器</strong>的例子。</p><p id="98f9" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated"><strong class="mg jd">拉普拉斯边缘检测</strong></p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="cfdc" class="no lj it nk b gy np nq l nr ns">kernel = np.zeros((3,3))<br/>kernel[1,1] = 4<br/>for p in [ [0,1] , [1,0]]:<br/>   kernel[ p[0],p[1]] =-1<br/>   kernel[ p[0]+1 ,p[1] +1] =-1<br/>'''<br/>0 -1 0<br/>-1 4 -1<br/>0 -1 0'''</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8863b807bb6ff06b36f9fd57d6af0600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*vwuPguIpkq49D3fY.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">拉普拉斯边缘检测</figcaption></figure><p id="5d7e" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">很酷不是吗？这是用于提取图像的高级特征的高通滤波器的例子。[ <a class="ae lh" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/py_fourier_transform.html#why-laplacian-is-a-high-pass-filter" rel="noopener ugc nofollow" target="_blank"> 4 </a></p><p id="cf28" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">制作一些新的过滤器，并在一些图像上试用，以了解这些过滤器实际上是如何工作的。</p><p id="874d" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">希望我已经很好地介绍了图像处理。如果你感到兴奋，就为它鼓掌。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="6deb" class="li lj it bd lk ll or ln lo lp os lr ls ki ot kj lu kl ou km lw ko ov kp ly lz bi translated">参考</h1><p id="3258" class="pw-post-body-paragraph md me it mg b mh nd kd mj mk ne kg mm na nf mp mq nb ng mt mu nc nh mx my mz im bi translated">[1]:数字图像处理百科，<a class="ae lh" href="https://en.wikipedia.org/wiki/Digital_image_processing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Digital_image_processing</a></p><p id="fc86" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">[2]:OpenCv维基百科，【https://en.wikipedia.org/wiki/OpenCV T2】</p><p id="16eb" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">[3]:默罕默德·贾韦德，<em class="mf">直接从游程长度压缩的文本文档中提取投影轮廓、游程直方图和熵特征，</em><a class="ae lh" href="https://arxiv.org/pdf/1404.0627.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1404.0627.pdf</a></p><p id="a6b0" class="pw-post-body-paragraph md me it mg b mh mi kd mj mk ml kg mm na mo mp mq nb ms mt mu nc mw mx my mz im bi translated">[4]:拉普拉斯是一个高通滤波器，<a class="ae lh" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_transforms/py_fourier_transform/py_fourier_transform.html#why-laplacian-is-a-high-pass-filter" rel="noopener ugc nofollow" target="_blank">https://opencv-python-tutro als . readthedocs . io/en/latest/py _ tutorials/py _ imgproc/py _ transforms/py _ Fourier _ transforms/py _ Fourier _ transform . html # why-Laplacian-is-a-high-pass-filter</a></p></div></div>    
</body>
</html>