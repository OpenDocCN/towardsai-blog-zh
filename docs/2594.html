<html>
<head>
<title>Pandas hacks for a Data Scientist: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的熊猫黑客:第二部分</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/pandas-hacks-for-a-data-scientist-part-ii-60cb64b800fb?source=collection_archive---------0-----------------------#2022-03-05">https://pub.towardsai.net/pandas-hacks-for-a-data-scientist-part-ii-60cb64b800fb?source=collection_archive---------0-----------------------#2022-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="244f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇博文是我第一篇关于<a class="ae ko" href="https://medium.com/@tangri.anurag/pandas-hacks-for-a-data-scientist-part-i-e8625646a2b6" rel="noopener">熊猫黑客:第一部分</a>的博文的延续</p><p id="5438" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我前面提到的，学习熊猫是你在数据科学职业生涯中可以做的最好的投资之一。我要重复一遍，Pandas无疑是为数据科学家创建的最重要的Python库。</p><p id="a1b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想成为一名优秀的数据科学家，我强烈建议你继续学习更多关于熊猫的知识。正如我在之前的<a class="ae ko" href="https://medium.com/me/stats/post/d5adc289e974" rel="noopener">帖子</a>中所写的，熊猫就是力量。此外，看看我的其他博客帖子，我在那里讨论了<a class="ae ko" href="https://medium.com/mlearning-ai/p-for-pandas-p-for-power-and-p-for-pyplot-f06b0048e39f" rel="noopener">基于熊猫的阴谋</a>。</p><p id="01b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天，我想涵盖一些额外的熊猫黑客非常方便。那么，我们开始吧。</p><p id="b755" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用来自Kaggle的新的乌克兰推文数据集，其中包含关于乌克兰战争的推文数据。数据集中的列如下所示:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="8d54" class="ky kz it ku b gy la lb l lc ld">ukraini_tweets_df = pd.read_csv('slava_ukraini.csv')<br/>print("ukraini_tweets_df.dtypes", ukraini_tweets_df.dtypes)</span></pre><p id="545a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出是:</p><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi le"><img src="../Images/d566496389825736475af770de0d186f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTVCsZqcTLR8k4mN1QLL2A.png"/></div></div></figure><h1 id="11ef" class="lm kz it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">筛选与字符串匹配的dataframe列中的行</h1><p id="56e6" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">假设我们现在想搜索tweet“text”列，只选择包含单词“Russia”的tweet。这可以通过下面的oneliner轻松完成:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="b2c7" class="ky kz it ku b gy la lb l lc ld">tweets_abt_russia_df = ukraini_tweets_df[ukraini_tweets_df['text'].str.contains('Russia')][['text']]</span></pre><p id="1112" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们使用“text”列，这是实际的tweet，并使用pandas中的str()访问器将其转换为字符串序列，然后应用字符串函数contains()检查“text”列是否包含单词“Russia”。输出如下所示:</p><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi mo"><img src="../Images/a585c9708d797384a4425ad0fe9474d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UCgwAkPtgnBFqs_qhUyzA.png"/></div></div></figure><p id="53ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，只有文本包含单词“俄罗斯”的推文被选中。当您执行探索性数据分析并希望将重点放在表现出特定行为的数据集的特定部分时，这非常有用。你可以点击查看熊猫系列<a class="ae ko" href="https://pandas.pydata.org/docs/reference/series.html#string-handling'" rel="noopener ugc nofollow" target="_blank">支持的字符串函数的完整列表。</a></p><h1 id="bc08" class="lm kz it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">筛选列表中dataframe列中的行</h1><p id="b9b1" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">现在假设我们有一个列表，其中包含我们想要搜索dataframe列的单词。这也可以通过字符串访问器和字符串函数轻松完成，如下所示:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="504e" class="ky kz it ku b gy la lb l lc ld">tweets_filter_on_russia_list=['Russia', 'war', 'attack', 'Zelenskyy',' Putin']<br/>tweets_abt_russia_list_df = ukraini_tweets_df[ukraini_tweets_df['text'].str.contains("|".join(tweets_filter_on_russia_list))][['text']]</span></pre><p id="c944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们打破这些陈述来更好地理解它:</p><ul class=""><li id="c200" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">这里，我们首先在我们的列表中定义一组单词。在这种情况下，我们选择一些与当前俄乌冲突相关的常用词。</li><li id="1e48" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">此外，我们再次使用“文本”列并转换为字符串。</li><li id="1da0" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">现在我们准备在列表中搜索单词。我们获取列表中的单词，并使用分隔符“|”和join()将它们连接在一起，以创建一个正则表达式。最终模式评估为‘俄罗斯|战争|进攻|泽伦斯基|普京’。</li><li id="278f" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">熊猫现在将只选择在contains()调用中出现这5个单词的推文。</li></ul><p id="b2c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出如下所示:</p><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nd"><img src="../Images/afd0402c01ba1b0f3dd2d684c39bf103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLIFca-ZstmD8bkhiZDCZA.png"/></div></div></figure><p id="b651" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好地解释了为什么只有包含我们列表中单词的推文被熊猫选中了。这在我们想要创建停用词黑名单或白名单以仅过滤/选择匹配列表的行的情况下特别有用。</p><h1 id="88a7" class="lm kz it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用日期操作创建派生列</h1><p id="2286" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">现在假设我们有一个需求，要找出我们的平台上有多少活跃用户。我们可以通过找到一个用户上Twitter的月份，以及有多少用户正在积极地评论俄罗斯的战争形势来找到这个统计数据。这可以通过下面的语句轻松实现:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="16e8" class="ky kz it ku b gy la lb l lc ld">ukraini_tweets_df['month_of_onboarding'] = pd.to_datetime(ukraini_tweets_df['user_created']).dt.to_period('M')<br/>print(ukraini_tweets_df['month_of_onboarding'].value_counts())</span></pre><p id="3627" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再来分解一下:</p><ul class=""><li id="6336" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">首先，我们获取用户创建日期，并将其转换为datetime对象。</li><li id="bc06" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">接下来，我们使用dt访问器和to_period('M ')函数从这个日期中提取月份和年份(YYYY-MM)。</li><li id="005d" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">然后，我们在这个新创建的列上使用value_counts()找到每个YYYY-MM的频率计数。</li></ul><p id="143d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看输出是什么样子的:</p><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi ne"><img src="../Images/c40d008536a76859c21c7c81427eaeca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EInwuqPWO3r5G1eWlgrPXg.png"/></div></div></figure><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nf"><img src="../Images/135f488edf021c536842d8b12688ce65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6QzJtDgN9H1UDWlRvRVxw.png"/></div></div></figure><p id="32cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码输出片段显示了2022–02年加入的一些用户在该数据集中是如何最活跃的。我们看到2009年的一些用户也非常积极地在推特上谈论俄罗斯危机。在底部，我们看到2006年和2007年的老账户仍然活跃在平台上，但他们的活跃度很低。这个统计数据对于系统了解他们的活跃用户和参与度非常有价值。</p><h1 id="15e0" class="lm kz it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用日期算法创建复杂的派生列</h1><p id="2a7a" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">在这个数据集中，我们有两个日期列:</p><ul class=""><li id="eb12" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">user_created:用户创建其帐户的日期</li><li id="48ef" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">日期:实际发布推文的地点。</li></ul><p id="6786" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想知道用户发微博当天的年龄。我们可以通过以下陈述实现这一目标:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="a6f0" class="ky kz it ku b gy la lb l lc ld">ukraini_tweets_df['user_age'] = pd.to_numeric((pd.to_datetime(ukraini_tweets_df['date']) - pd.to_datetime(ukraini_tweets_df['user_created'])).dt.days)</span></pre><p id="0e98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着把这种说法分解一下:</p><ul class=""><li id="c65a" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">首先，我们使用pd.to_datetime()将“date”列转换为datetime对象</li><li id="0358" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">接下来，我们使用pd.to_datetime()将“user_created”转换为日期时间对象</li><li id="02d1" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">然后我们找出它们的差异，得到一个timedelta对象，该对象表示两个日期之间的天数和小时数的差异。区别如下:4524天23:16:43</li><li id="b69b" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">此外，我们使用pandas dt访问器，并将差异的天数部分选择为:4524</li><li id="c5fd" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">最后，我们使用pd.to_numeric()将它转换成数字:4524，这样我们就可以根据用户首次加入twitter以来的天数得出他的年龄。</li></ul><p id="0ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出如下所示:</p><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi ng"><img src="../Images/6c2d66b619dc23c4b0073a4e325378da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TFweRNnka5tSJ3YmtjIXg.png"/></div></div></figure><p id="4b93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以很容易地从上面的输出中验证user_age是用户帐户创建日期和tweet的日期时间之差。这显示了pandas在如何使用日期算法和dt accesor函数创建用户年龄方面的强大功能。该年龄可以直接用作机器学习模型中的输入特征，以代理账户的真实年龄，并对用户行为进行预测。</p><p id="8847" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就把我们带到了熊猫黑客系列的第二部分的结尾。请继续关注，了解更多此类有用的技巧，它们使得在数据分析或建模过程中处理数据变得非常容易。欢迎随时评论分享。</p><p id="4cff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想知道其他基于数据科学的库的更多这样的技巧，请在评论中添加，我会在我未来的博客中添加。</p><p id="a31c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多这样的故事，请加入medium.com</p></div></div>    
</body>
</html>