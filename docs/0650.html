<html>
<head>
<title>Sentiment Analysis — ML project from Scratch to Production (Web Application)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">情感分析—从无到有的ML项目(Web应用程序)</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/sentiment-analysis-from-scratch-to-production-web-api-3382f19748e8?source=collection_archive---------0-----------------------#2020-07-05">https://pub.towardsai.net/sentiment-analysis-from-scratch-to-production-web-api-3382f19748e8?source=collection_archive---------0-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4459" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/85117291da4b996826d9a5fece500264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AUH1JemyTBiy0z78LeYNg.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">我们将要构建的应用程序的一瞥。</figcaption></figure><h1 id="54ff" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">背景:</h1><p id="e85b" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> W </span>当我开始学习数据科学时，我总是迷失在它提供的大量资料中。学了一段时间后，我会忘记它，然后回来看视频或参考博客。然后我意识到，像其他技能一样，你需要练习和解决现实世界的问题。牢记这一点，我开始着手一个简单的项目。在开发一个端到端项目的过程中，你会了解到很多简单学习所不能获得的东西。实际上，当你被一个问题困住时，你搜索它，你尝试多种调整来让它工作。这是真正的学习。</p><h1 id="6e8c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">动机:</h1><p id="ae25" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">当我在搜索一篇涵盖从零开始到部署应用程序的机器学习项目的文章时，我发现很少有这样的文章涵盖端到端。所以我想我应该借此机会写一篇博客，涵盖我自己的项目，以最简单的方式从获得数据到部署。所以我来了。</p><p id="5e70" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">好吧，我们开始吧。</strong></p><blockquote class="my mz na"><p id="eeb9" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">免责声明:如果你正在寻找代码，你可以在结论部分找到它</p></blockquote></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="534c" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">本文讨论的主题:</h1><ol class=""><li id="b3e4" class="nr ns it lo b lp lq lt lu lx nt mb nu mf nv mj nw nx ny nz bi translated">问题陈述</li><li id="663b" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">数据采集</li><li id="6ca3" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">工具和指标</li><li id="6516" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">数据清理</li><li id="8925" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">探索性数据分析</li><li id="6c5b" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">建模和调整数据</li><li id="78b0" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">评估模型</li><li id="edad" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">部署模型</li></ol></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="98ca" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">1.问题陈述:</h1><p id="c265" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">这是开始一个项目前的关键步骤之一，如果你不明白你真正想要的是什么，相信我，你会遇到比你想象的更多的问题。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c7911e440f93a8e22de86077c0efb0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*SkzVAiI9dRflzKx4JQzJEA.png"/></div></figure><p id="a770" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">如今，一切都变得数字化，过去每个人都去购物中心购买产品的日子已经一去不复返了，现在一切都只需点击一下鼠标。随着互联网公司的蓬勃发展，行业竞争激烈，因此为了留住客户，公司迫切需要分析反馈并随着时间的推移不断发展。面对数百万的客户，手动审查客户情绪几乎是不可能的。这就是我们的问题所在，我们需要找到最合适的分类器，根据客户对某个产品的评论来判断他们的情绪。</p><blockquote class="my mz na"><p id="b462" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">因此，我们的目标是由客户给出一个评论，我们的模型必须预测评论的情绪是积极或消极或中立。</p></blockquote></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="e05e" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">2.数据采集:</h1><p id="fc4f" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">这是你需要获得正确数据的关键阶段之一，你的模型和你的数据一样好。就这么简单。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/218db383f2dd80bed34d428e9fd80cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*esy8vKdzhslUJIYIdUl95Q.png"/></div></figure><p id="fd8f" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在实时环境中，我们可能需要处理很多复杂的事情来获得正确的数据。你可以通过抓取网页来获取数据，但在此之前，我建议你先从现有的数据集入手。Kaggle是一个很好的起点，它有一些不错的数据集。</p><p id="343e" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在这个项目中，我们将研究取自Kaggle的亚马逊美食评论。</p><p id="69bd" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在我们的数据中，每个评论都包含其Id、ProductId、UserId、ProfileName、有用性分子、有用性分母、分数、时间、摘要、文本。</p><p id="1cf4" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">尽管有很多专栏，我们将只考虑评论T <strong class="lo jd"> ext </strong>和他们的<strong class="lo jd">分数</strong>。</p><p id="3380" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">文本包含实际的评论，分数包含评分值，如1、2、3、4、5。我们会将评分为&lt; 3 as Negative and reviews with rating=3 as Neutral and reviews with ratings &gt; 3的评论视为正面评论。</p><p id="197d" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">然后我们要从复习课文中预测情绪。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="ee4f" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">3.工具和指标:</h1><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi om"><img src="../Images/503fdd5e412729c96cedf1298d792851.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*ywuXeJfcV524JRZADItuZQ.png"/></div></figure><p id="e2d8" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">为您的模型定义正确的度量是一项具有挑战性的任务。</p><h2 id="6d7f" class="on kp it bd kq oo op dn ku oq or dp ky lx os ot lc mb ou ov lg mf ow ox lk iz bi translated">使用的指标:</h2><p id="d8b8" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><strong class="lo jd"> F1_score </strong>(加权)，<strong class="lo jd">混淆矩阵。</strong></p><p id="ff21" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><em class="nb"> F1 = 2 *(精度*召回)/(精度+召回)</em></p><p id="6f69" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">F1_score可以解释为精确度和召回率的调和平均值。这里有一篇关于它的有趣的<a class="ae ol" href="https://towardsdatascience.com/multi-class-metrics-made-simple-part-ii-the-f1-score-ebe8b2c2ca1" rel="noopener" target="_blank">文章</a>。</p><p id="dfef" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">混淆矩阵将帮助我们发现我们的模型能够多好地预测每个类别。这里有一个关于它的有趣的博客。</p><p id="8529" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">需要的工具:</strong> Python，Github账号，Heroku账号。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="4639" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">4.数据清理:</h1><p id="e3cf" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">据称，数据科学家将几乎70%的时间花在数据清理上。这是最乏味的任务之一。模型的性能与数据的整洁程度成正比。这里的清理包括删除重复数据、不必要的元素和处理丢失的数据。</p><p id="368a" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在对文本进行预处理之前，我们将执行一些标准的清理技术。</p><p id="7075" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd"> 4.1。处理缺失数据和重复数据</strong></p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="ef6f" class="on kp it oz b gy pd pe l pf pg"># drop the missing values.<br/>reviews_df[[“Text”,”Score”]].isnull().any()<br/>reviews_df.dropna(subset=["Text","Score"])</span></pre><p id="e896" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">为了处理缺失值，我们可以简单地删除它们，或者如果您不想丢失信息，您可以使用一些插补技术来填充这些缺失值。在我们的例子中，<strong class="lo jd">文本</strong>(我们的数据)和<strong class="lo jd">分数</strong>(我们的标签)没有任何缺失值，所以我们可以继续下一步删除重复项。</p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="54de" class="on kp it oz b gy pd pe l pf pg">#dropping the duplicate values.<br/>reviews_df = reviews.drop_duplicates(subset={"UserId","ProfileName","Time","Text"},keep='first')</span></pre><p id="2b83" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">我们删除了所有具有相同用户id、名称、时间和文本的评论。</p><p id="2c28" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">4.2。文本预处理:</p><p id="6529" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">我们得到的评论有很多不必要的字符，一些常规的常用词，并没有真正增加模型的性能。我们需要在建模之前消除这些因素。</p><p id="b8e8" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">I)使用漂亮的soap删除所有HTML标签</p><p id="4d17" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">ii)使用re删除所有特殊字符和数字。</p><p id="bf8c" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">iii)将评论符号化并转换为小写</p><p id="755e" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">iv)使用PorterStemmer执行词干分析</p><p id="3840" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">v)删除所有停用词。</p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="4554" class="on kp it oz b gy pd pe l pf pg">def text_Preprocessing(reviews):<br/>    <br/>    <br/>    <em class="nb">""" This will clean the text data, remove html tags, remove special characters and then tokenize the reviews to apply Stemmer on each word token."""<br/>    </em><br/>    pre_processed_reviews=[]<br/>    <br/>    for review in tqdm(reviews.values):<br/>        review= BeautifulSoup(review,'lxml').getText()<em class="nb">#remove html tags</em><br/>    <br/>        review=re.sub('[^A-Za-z]+',' ',review) <em class="nb">#remove special chars</em><br/>        review=re.sub("n't","not",review)<br/>        review=word_tokenize(str(review.lower())) <em class="nb">#tokenize the reviews into word tokens</em></span><span id="516a" class="on kp it oz b gy ph pe l pf pg">review=' '.join(PorterStemmer().stem(word) for word in review if word not in stop_words)<br/>        pre_processed_reviews.append(review.strip())<br/>    return pre_processed_review</span></pre><h2 id="5dcc" class="on kp it bd kq oo op dn ku oq or dp ky lx os ot lc mb ou ov lg mf ow ox lk iz bi translated">4.2.特色化:</h2><p id="3a4a" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">虽然我们从评论中删除了所有噪音和不必要的字符，但是想想我们的评论仍然是字符串格式(文本)，我们的计算机不能处理字符串，这些需要转换成一些数字表示。将该文本转换成数字/矢量形式通常被称为特征化。</p><p id="3cd5" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">有许多可用的特征化技术，其中我们将使用一个简单的TFIDF矢量器将这些文本转换成矢量。在此之前，我们将把数据分成训练和测试数据集，以避免数据泄漏。</p><p id="1448" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">我们将在TFIDF中使用单字和双字。二元模型认为两个连续的单词是一个单词，而一元模型认为是一个单词。</p><p id="1c24" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">产品质量不好。</p><p id="82b0" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">对于这个词，单词将是['质量'，'的'，'产品'，'是'，'不是'，'好']</p><p id="0927" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">二元模型:['质量'，'的'，'产品'，'产品是'，'不是'，'不好']</p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="5c7a" class="on kp it oz b gy pd pe l pf pg">#split the data into train and test datasets<br/>reviews_train,reviews_test,sentiment_train,sentiment_test=train_test_split(preprocessed_reviews.text,preprocessed_reviews.sentiment)</span><span id="c88f" class="on kp it oz b gy ph pe l pf pg">#Applying TFIDF<br/>tfidf_model=TfidfVectorizer(ngram_range=(1,2),min_df=10, max_features=6000)<br/>tfidf_model.fit(reviews_train,sentiment_train)<br/>reviews_train_tfidf=tfidf_model.transform(reviews_train)<br/>reviews_test_tfidf=tfidf_model.transform(reviews_test)</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="ea76" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">5.EDA:</h1><p id="44e1" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在对数据应用任何建模之前，让我们先了解我们的数据。知道你的数据想要告诉你什么是一个很好的实践。</p><ol class=""><li id="58a6" class="nr ns it lo b lp mt lt mu lx pi mb pj mf pk mj nw nx ny nz bi translated">在预处理和删除重复和缺失值后，我们能够保留93%的实际数据。</li></ol><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/5fad6b29d965af3056c08798996bd792.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*baMr_ALrCjF5KmHvYq5jMw.png"/></div></figure><p id="9c8b" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">2.从饼图中，我们可以观察到类别1几乎占了总类别标签的77%,类别0占了15%,类别2占了8%。显然，我们可以说这是一个不平衡的数据集。这可能会给我们的模型的性能带来问题，我们将在建模过程中解决这个问题。</p><p id="e8cb" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">3.让我们使用IDF权重找出前10个单词。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/4903aa52a556b36d4570e187a8167b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*EkhJOtRH4YUKtv3jWXCMHQ.png"/></div></figure><p id="3722" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">从词云来看，前10个关键词分别是<strong class="lo jd">喜欢、不喜欢、好、很棒、喜欢、味道、风味、</strong>等。这些话有道理。所以我们的数据看起来没问题。</p><p id="8c95" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">好了，现在我们有了开始构建模型所需的一切。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="8775" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">6.建模和调整:</h1><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/b4d96ae8618602239d46cc489db2095d.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*zGOg40PEzbk3nW8MCBuKQg.png"/></div></figure><p id="80bf" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">建模就是应用模型(ML算法)从数据中学习潜在的模式。</p><p id="d5cd" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">为此，让我们从一个简单的基础模型开始，逻辑回归。我们将使用逻辑回归的sklearn实现。</p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="ddc4" class="on kp it oz b gy pd pe l pf pg">#Applying Logistic Regression</span><span id="d50b" class="on kp it oz b gy ph pe l pf pg">from sklearn.linear_model importLogisticRegression lr=LogisticRegression(max_iter=1000)<br/>lr.fit(reviews_train_tfidf,sentiment_train)<br/>lr_predict=lr.predict(reviews_test_tfidf)<br/>plain_lr_f1=f1_score(sentiment_test,lr_predict,average=None)<br/>plain_lr_f1</span></pre><p id="9eaa" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在使用默认参数应用逻辑回归后，我们得到了82%的f1_score，让我们看看它的混淆矩阵:</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi po"><img src="../Images/77353b49c297dad703e0aac42aea22a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*ZfEf6X9FWKzoRBTnJjfHpA.png"/></div></figure><blockquote class="my mz na"><p id="9cfb" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">理想混淆矩阵的经验法则是在矩阵的对角元素中有一个最佳值。对角线元素表示我们的模型预测实际标签的有效程度。</p></blockquote><p id="0d05" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在这里，我们可以观察到，即使我们的模型的f1_score为82%，当我们从混淆矩阵检查类的准确性时，我们可以观察到我们的模型能够以58%预测类0，以98 %预测类1，以10%预测类2，这确实非常差。</p><p id="9dcf" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">为什么你认为我们的模型能够预测正面评价，比如正面评价和负面评价，但却很难预测中性情绪？</strong></p><blockquote class="my mz na"><p id="fa3e" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">还记得我们之前讨论的一个问题，阶级失衡。我们的模型有更多正面评价的数据，然后是负面评价。中性的数据最少。这也是我们这款表现不好的原因之一。</p></blockquote><ol class=""><li id="4a34" class="nr ns it lo b lp mt lt mu lx pi mb pj mf pk mj nw nx ny nz bi translated">阶层失衡问题。</li><li id="32c0" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">另一个问题是，我们没有用最佳参数训练我们的模型，我们只是用默认参数训练。</li></ol><p id="acad" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">让我们解决这两个问题，看看我们是否可以提高模型性能。</p><p id="4191" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">处理不平衡数据集:</strong>当我们处理不平衡数据集时，有两种常见的方法来解决它。</p><p id="2c84" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd"> <em class="nb">欠采样</em> </strong>:在采样方法下删除<strong class="lo jd">或</strong>合并多数类中的例子。我们不打算使用这种技术，因为这种技术有可能会丢失信息。</p><p id="4588" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd"> <em class="nb">过采样</em> : </strong>过采样方法复制<strong class="lo jd">或</strong>在少数类中创建新的合成示例，我们将使用一种称为<strong class="lo jd"> Smote的过采样技术。</strong></p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="e138" class="on kp it oz b gy pd pe l pf pg">from imblearn.over_sampling import SMOTE</span><span id="d613" class="on kp it oz b gy ph pe l pf pg"># Resample the minority class.<br/>sm = SMOTE(sampling_strategy='auto', random_state=7)</span><span id="f222" class="on kp it oz b gy ph pe l pf pg">oversampled_trainX, oversampled_trainY = sm.fit_resample(reviews_train_tfidf,sentiment_train)<br/>oversampled_trainY.value_counts()</span></pre><p id="9481" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">之后，我们得到了新的X和Y值。让我们使用更新后的X和y应用逻辑回归模型。这一次，我们将使用RandomizedSearchCV找到逻辑回归的最佳参数。</p><p id="7d0c" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">超参数调整的逻辑回归。</strong></p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="c3ba" class="on kp it oz b gy pd pe l pf pg">lr_params={"penalty":["l1","l2"],<br/>           "C":[10**i for i in range(-5,5)]}<br/>lr=LogisticRegression()</span><span id="213d" class="on kp it oz b gy ph pe l pf pg">lr_rndm_clf=RandomizedSearchCV(lr,lr_params)<br/>lr_rndm_clf.fit(reviews_train_tfidf,sentiment_train)<br/>lr_rndm_clf.best_params_</span><span id="c81a" class="on kp it oz b gy ph pe l pf pg">#passing the best pararms and creating a new model<br/>lr_model=LogisticRegression(**lr_rndm_clf.best_params_,solver="liblinear")<br/>lr_model.fit(reviews_train_tfidf,sentiment_train)<br/>lr_predict=lr_model.predict(reviews_test_tfidf)<br/>f1_score(sentiment_test,lr_predict,average=None)</span></pre><p id="5986" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">这里我们得到加权f1_score为89。但是让我们看看我们的模型能够多好地预测每一类。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/c7376695420e73494ca0d2d138a62cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*6oKm5jpQrB8T_--I4oiI6g.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">后置过采样和参数调整</figcaption></figure><p id="c016" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">正如我们可以看到的，现在我们的模型比以前的模型略有改进。中性阶层的预测正确率为27%，几乎是之前10%的三倍。</p><p id="6904" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">虽然有所改进，但仍然不是很好，我们可以尝试一些其他的方法。但是为了简单起见，让我们继续讨论这个问题，因为中性阶级并没有给商业问题增加太多，我们更倾向于找出正确的积极和消极情绪。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="990b" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">7.评估:</h1><blockquote class="my mz na"><p id="07aa" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">“<strong class="lo jd">没有免费的午餐</strong>”<strong class="lo jd">定理</strong>指出，没有一个模型能最好地解决所有问题。</p></blockquote><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/7ca55c92a763a1a08dc46ef55f79b9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*MCZHocHz1v0Dk_M1Sy20yA.png"/></div></figure><p id="a42f" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">到目前为止，我们只试验了一种模式，我们永远不应该停止它。我们需要尝试多种算法来找出最佳模型。为此，我试验了其他算法，如SVC、决策树、朴素贝叶斯、随机森林。</p><p id="c0d2" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">由于不可能在这里逐一介绍每个模型，我尝试用下面的可视化表示来总结模型的性能。</p><blockquote class="my mz na"><p id="f1a6" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated"><strong class="lo jd">注意:</strong>你只需要遵循我们对其他模型的逻辑回归所遵循的相同方法。唯一的变化将是算法和他们的超参数休息是相同的。不要担心，我会留下一个链接到我的代码，你可以通过它。</p></blockquote><figure class="og oh oi oj gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi pr"><img src="../Images/bfc888b38e1032bc959d6fa5cb564ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9OGis8gkrPXDD9hAbJhlQ.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">所有型号的性能</figcaption></figure><p id="23f4" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">如果你在这里观察，我们可以看到几乎所有的模型都有相同的分数，而随机森林是最少的，并且<strong class="lo jd">朴素贝叶斯</strong>比其他模型略好。</p><p id="3111" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">让我们看看混淆矩阵，找出最佳模式。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ps"><img src="../Images/b93ce06c6cb94f37050340a985a29439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xP5TQyvtxAG4bJiDggEEig.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">所有模型的混淆矩阵</figcaption></figure><p id="9cd7" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">如果你观察上面的混淆矩阵，<strong class="lo jd">朴素贝叶斯</strong>在预测第0类和第2类以及预测第1类时表现优于所有其他模型，具有相当不错的准确性。</p><blockquote class="my mz na"><p id="96a7" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">因此，在评估了多个模型之后，我们选择了朴素贝叶斯作为我们的模型。</p></blockquote><p id="b7a3" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">我们将以pickle格式保存朴素贝叶斯模型，以便以后使用。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="1c0f" class="ko kp it bd kq kr nm kt ku kv nn kx ky kz no lb lc ld np lf lg lh nq lj lk ll bi translated">8.部署模型:</h1><p id="357c" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">部署模型是交付ML模型的关键步骤之一。有许多方法可以部署模型。我将使用<strong class="lo jd"> Heroku </strong>和<strong class="lo jd"> Github </strong>来托管我的模型。</p><p id="8947" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd"> <em class="nb">现在我们只是有了一个模型，还需要什么来部署模型呢？</em> </strong></p><ol class=""><li id="71f0" class="nr ns it lo b lp mt lt mu lx pi mb pj mf pk mj nw nx ny nz bi translated">我们将使用Flask创建一个web应用程序。</li><li id="d418" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated">需要为我们的应用程序创建一个脸。为此，我们将使用简单的HTML和CSS。</li></ol><p id="622f" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">烧瓶是微框架。实际上，flask有很棒的文档，你可以在这里查看。</p><pre class="og oh oi oj gt oy oz pa pb aw pc bi"><span id="204d" class="on kp it oz b gy pd pe l pf pg"># -*- coding: utf-8 -*-<br/>from flask import Flask,render_template,url_for,request<br/>import pickle<br/>import preprocessing</span><span id="a016" class="on kp it oz b gy ph pe l pf pg"># load the model from disk<br/>clf = pickle.load(open('nb_clf.pkl', 'rb'))<br/>cv=pickle.load(open('tfidf_model.pkl','rb'))<br/>app = Flask(__name__)</span><span id="f356" class="on kp it oz b gy ph pe l pf pg"><a class="ae ol" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def home():<br/> return render_template('home.html')</span><span id="1ac5" class="on kp it oz b gy ph pe l pf pg"><a class="ae ol" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict',methods=['POST'])<br/>def predict():<br/>    if request.method == 'POST':<br/>        message = request.form['message']<br/>        if(len(message)&gt;2):<br/>            text = [message]<br/>            data = preprocessing.text_Preprocessing(text)<br/>            vect = cv.transform(data)<br/>            my_prediction = clf.predict(vect)<br/>        else:<br/>            my_prediction=3<br/>        <br/>    return render_template('home.html',prediction = my_prediction)</span><span id="1857" class="on kp it oz b gy ph pe l pf pg">if __name__ == '__main__':<br/> app.run(debug=True)</span></pre><p id="27ec" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在上面的代码中，首先，我们使用pickle load加载了我们之前保存的模型和TFIDF模型。然后创建了一个名为<strong class="lo jd"> app </strong>的flask app。</p><p id="f3ba" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">然后我们使用<code class="fe pt pu pv oz b"><a class="ae ol" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.route" rel="noopener ugc nofollow" target="_blank"><strong class="lo jd">route()</strong></a></code>装饰器告诉Flask哪个URL应该触发我们的函数。在<code class="fe pt pu pv oz b">render_template</code>的帮助下，我们将渲染我们的home.html，这是我们应用程序的主页。</p><p id="87f4" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">在前端，当用户在文本字段中输入一些文本并点击<strong class="lo jd">预测</strong>按钮时，我们的URL将被追加<strong class="lo jd">/预测、</strong>和<strong class="lo jd"> </strong> <a class="ae ol" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"> @app </a>。route('/predict '，methods=['POST'])被触发，用户输入的文本将使用request.form获取。</p><p id="8a0b" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">该文本将像我们对训练数据所做的那样进行预处理，然后我们用加载的模型预测结果。</p><p id="b6d4" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">现在转到终端，转到项目目录，键入<strong class="lo jd"> python app.py. </strong>如果一切正常，您一定会看到类似这样的内容。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/a013dc8d6eab2463c3e6c9d856e2ff14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*GwEaF1593RCMOvzYSmtJiw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">末端的</figcaption></figure><p id="0de7" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">复制URL (http://127.0.0.1:5000/)并粘贴到浏览器中，然后您一定会看到类似这样的内容。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi px"><img src="../Images/c967202c505f740eb9f213be8c081eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPuOyPnJNA0BQ218vi0sFA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">浏览器中的应用</figcaption></figure><blockquote class="py"><p id="8d1a" class="pz qa it bd qb qc qd qe qf qg qh mj dk translated">万岁！！！我们刚刚成功创建了我们的web应用程序。</p></blockquote><blockquote class="my mz na"><p id="c525" class="lm ln nb lo b lp qi lr ls lt qj lv lw nc qk lz ma nd ql md me ne qm mh mi mj im bi translated">注意:我没有在这里分享html，因为它已经很长了，html只是一个简单的形式，你可以参考下面分享的代码。</p></blockquote><p id="cfbb" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">如果你观察到我们仍然在本地服务器上运行，我们的目标是确保每个人都可以访问它。所以Heroku来拯救我们了。</p><p id="66ab" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">首先，我们应该将所有这些文件转移到github，因为你可以简单地复制粘贴你的文件，也可以从终端上完成。我们将从终端这样做，只是为了避免在上传拖放时经常遇到的一些限制问题。</p><p id="0cfc" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">之后，在我们转移到Heroku之前，我们需要添加几个文件，<strong class="lo jd"> Requirements.txt </strong>和<strong class="lo jd">Procfile</strong>with text "<strong class="lo jd">web:guni corn app:app</strong></p><p id="4ec8" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">Requirements.txt将包含运行项目所需的所有库，Heroku将首先安装所有这些库，然后运行项目。</p><figure class="og oh oi oj gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi qn"><img src="../Images/c323514f0927d5d267ce235ed1960925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYwCi8RkddJw82V88C98mw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">Heroku应用程序页面</figcaption></figure><p id="953c" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">一旦上传完成。下一步是登录Heroku。</p><blockquote class="my mz na"><p id="e49b" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">创建新应用程序。打开应用程序。在部署方法下选择GitHub。(<strong class="lo jd">注</strong>:这里Heroku会要求你连接你的github账号)。</p></blockquote><p id="3f3c" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">完成后，输入包含我们刚刚上传的文件的存储库的名称。向下滚动并点击<strong class="lo jd">部署分支</strong>。等待一段时间以查看成功消息。</p><p id="3a2d" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">就这样</strong>。<strong class="lo jd">我们已经</strong> <strong class="lo jd">成功部署了我们的</strong> <a class="ae ol" href="http://sentimentanalysis.shareefshaik.me/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo jd"> <em class="nb">情感分析</em> </strong> </a> <strong class="lo jd"> <em class="nb"> </em>应用。</strong></p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h2 id="2a68" class="on kp it bd kq oo op dn ku oq or dp ky lx os ot lc mb ou ov lg mf ow ox lk iz bi translated">结论:</h2><p id="6d8a" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们能够以相当高的79%的准确率从文本中预测情感，我们需要理解我们的模型的性能是有限的，因为由于内存限制，我们只使用了568k评论中的40k评论。如果您有一个好的配置，尝试使用总数据集，总数据意味着模型可以学习更多的单词，从而提高性能。</p><blockquote class="my mz na"><p id="f7c0" class="lm ln nb lo b lp mt lr ls lt mu lv lw nc mv lz ma nd mw md me ne mx mh mi mj im bi translated">这是部署<a class="ae ol" href="https://sentimentanalysiswithtext.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo jd">情绪分析</strong> </a> <strong class="lo jd">后的样子。</strong>随时检查其性能。<strong class="lo jd">这里</strong>  <strong class="lo jd">可以得到完整的代码</strong> <a class="ae ol" href="https://github.com/Shareef-shaik/SentimentAnalysis" rel="noopener ugc nofollow" target="_blank"> <strong class="lo jd">。</strong></a></p></blockquote><h2 id="822e" class="on kp it bd kq oo op dn ku oq or dp ky lx os ot lc mb ou ov lg mf ow ox lk iz bi translated">接下来是什么:</h2><p id="b974" class="pw-post-body-paragraph lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">这只是一个分类问题，我们已经使用经典的机器学习算法来分析文本中的情感。下一步应该开始研究一些最先进的技术，如RNN和LSTMs，它们可以提高模型的性能。我会试着在我的下一篇博客中讨论这个问题。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="7e16" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated">这是我的第<strong class="lo jd">篇</strong>帖子，如果你觉得缺少了什么或者有任何疑问，请通过评论让我知道，我将非常乐意帮助你。</p><p id="2f40" class="pw-post-body-paragraph lm ln it lo b lp mt lr ls lt mu lv lw lx mv lz ma mb mw md me mf mx mh mi mj im bi translated"><strong class="lo jd">回头见！编码快乐！！！</strong></p><h2 id="2e1f" class="on kp it bd kq oo op dn ku oq or dp ky lx os ot lc mb ou ov lg mf ow ox lk iz bi translated">参考资料:</h2><ol class=""><li id="0f6f" class="nr ns it lo b lp lq lt lu lx nt mb nu mf nv mj nw nx ny nz bi translated">【https://www.kaggle.com/snap/amazon-fine-food-reviews T4】</li><li id="3549" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated"><a class="ae ol" href="https://towardsdatascience.com/multi-class-metrics-made-simple-part-ii-the-f1-score-ebe8b2c2ca1" rel="noopener" target="_blank">https://towards data science . com/multi-class-metrics-made-simple-part-ii-the-f1-score-ebe 8 b 2c a1</a></li><li id="8b1a" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated"><a class="ae ol" href="https://towardsdatascience.com/multi-class-metrics-made-simple-part-ii-the-f1-score-ebe8b2c2ca1" rel="noopener" target="_blank">https://towards data science . com/multi-class-metrics-made-simple-part-ii-the-f1-score-ebe 8 b 2c a1</a></li><li id="fff5" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated"><a class="ae ol" href="https://www.youtube.com/watch?v=UbCWoMf80PY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=UbCWoMf80PY</a></li><li id="e478" class="nr ns it lo b lp oa lt ob lx oc mb od mf oe mj nw nx ny nz bi translated"><a class="ae ol" href="https://towardsdatascience.com/hyperparameter-tuning-the-random-forest-in-python-using-scikit-learn-28d2aa77dd74" rel="noopener" target="_blank">https://towards data science . com/hyperparameter-tuning-the-random-forest-in-python-using-scikit-learn-28 D2 aa 77 DD 74</a></li></ol></div></div>    
</body>
</html>