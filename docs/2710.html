<html>
<head>
<title>Advanced Concepts in Python — I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的高级概念— I</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/advanced-concepts-in-python-i-85949fb9cc1c?source=collection_archive---------3-----------------------#2022-04-27">https://pub.towardsai.net/advanced-concepts-in-python-i-85949fb9cc1c?source=collection_archive---------3-----------------------#2022-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="16db" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">详细介绍迭代器、生成器、协同程序和迭代器协议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1edfdf42f562c3d33590663f974df7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nMWuG8VcIpP61nZD"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯里德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9ea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两年多来，Python一直是我的首选语言。一般来说，这是一种非常简单的语言。但是，有些概念有时令人难以置信。<br/>因此，我开始了这一系列的博客来简化和编码这些概念，使它们更加连贯。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="86a5" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">涵盖的主题</h2><ol class=""><li id="89da" class="ms mt iq ky b kz mu lc mv lf mw lj mx ln my lr mz na nb nc bi translated">迭代器</li><li id="9406" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">可重复的</li><li id="e81e" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">发电机</li><li id="dc9b" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">协同程序</li><li id="f89c" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">迭代器协议</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="b396" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">迭代器</h2><p id="c62b" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Python中的迭代器是一次发出一个值流的对象。为了访问流中的下一个值，我们对对象调用“<strong class="ky ir"> <em class="nl"> __next__() </em> </strong>”方法。<br/>你可以把Python中的迭代器想象成一把枪。项目符号是值，而“__next__”方法是触发器。你按下扳机(__next__)，它射出子弹(数值)。</p><p id="62dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">关于迭代器需要记住的要点<br/> </strong> a .迭代器对象在迭代过程中会记住自己的状态。<br/> b .迭代器只能向前移动，如果序列中的元素用尽，会引发StopIteration错误。<br/> c .迭代器一旦元素用尽就不能重用。<br/> d .循环可以迭代迭代器对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">自定义迭代器的代码</figcaption></figure><p id="6fbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在单元格1中，我创建了一个“CustomIterator”类，并在其中添加了“__iter__”和“__next__”方法。__iter__返回自身的实例，而__next__保持状态并返回迭代器中的下一个元素。<br/>在单元格6中，我一直迭代到前四个元素，但是当我稍后在单元格7中对同一对象运行for循环时，它从第五个元素开始迭代到最后一个元素。所以，迭代器对象不能重用。</p><p id="a303" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像zip、enumerate，甚至在python中打开的文件上的函数都返回一个迭代器对象。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="0173" class="lz ma iq np b gy nt nu l nv nw">z = zip(["asd","sdf"],[1,2])<br/>next(z)</span><span id="0532" class="lz ma iq np b gy nx nu l nv nw">## <strong class="np ir">Output</strong><br/>("asd",1)</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="5124" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">可重复的</h2><p id="9e2c" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Iterables是Python中的对象，其元素可以被循环迭代。Python中内置的数据结构序列称为Iterables。列表、元组、集合和字典都是可迭代的。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="3419" class="lz ma iq np b gy nt nu l nv nw">lst = [1,2,3,4,5]<br/>for i in lst:<br/>    print(lst)</span><span id="af30" class="lz ma iq np b gy nx nu l nv nw">## <strong class="np ir"><em class="nl">Output</em></strong><br/>1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="e6c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="nl">如何检查一个对象是否可迭代？<br/> </em> </strong>每个Iterables类都会有一个“<strong class="ky ir"> <em class="nl"> __iter__() </em> </strong>”方法来创建iterator对象。要检查一个对象是否是可迭代的，调用它的"<strong class="ky ir"> <em class="nl"> __dir__() </em> </strong>"方法，可以在返回的列表中看到一个" __iter__ "</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="ed14" class="lz ma iq np b gy nt nu l nv nw">lst = [1,2,3,4,5]<br/>print(lst.__dir__())</span></pre><p id="3b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">** <em class="nl">所有迭代器都是可迭代的，但不是所有可迭代的都是迭代器</em>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="af40" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">发电机</h2><p id="935f" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">Python中的生成器是一个通过“<strong class="ky ir"> yield </strong>关键字返回一串值的函数。它返回一个生成器迭代器对象。所以，你可以调用它的“__next__”方法来获取下一个值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9c2e5575fc853e42838925912aa649bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*Grb6Da08sVCv3H0e9ZMAww.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">生成值的生成器函数</figcaption></figure><p id="ddff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的gif中，你可以把那台机器想象成一个生成器，那些邮件就是值。每当调用“__next__”时，它将生成下一个值。</p><p id="12c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像迭代器一样，生成器也遵循惰性加载策略。它不会将所有的数据都加载到内存中并霸占它。因此，在处理像深度学习中的海量图像数据集这样的大数据时，生成器非常有用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">生成器函数的代码</figcaption></figure><p id="79db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在单元格1中，我创建了一个生成器函数“custom_generator ”,它对一个范围内的每个值进行平方，然后逐一返回。<br/>在单元格4中，我使用了一个生成器表达式来获得一串值的立方体。</p><p id="2a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">生成器表达式<br/> </strong>这是在一行中实现生成器的另一种方式。看起来像是“<strong class="ky ir">综合</strong>”与生成器函数性质相同。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="d115" class="lz ma iq np b gy nt nu l nv nw"># List Comprehension<br/>lst_comp = [x**3 for x in range(10)]<br/>print(lst_comp)</span><span id="81e6" class="lz ma iq np b gy nx nu l nv nw"># Generator expression<br/>gen = (x**3 for x in range(10))<br/>print(gen.__next__())<br/>print(gen.__next__())<br/>print(gen.__next__())</span><span id="cc10" class="lz ma iq np b gy nx nu l nv nw">## <strong class="np ir">Output<br/></strong>[0,1,8,...,729]<br/>0<br/>1<br/>4</span></pre><p id="3a25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不使用生成器函数，那么可以这样做:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="f1e7" class="lz ma iq np b gy nt nu l nv nw">def <strong class="np ir">not_generator_function</strong>(n):<br/>    square_list = []<br/>    for i in range(n):<br/>        square_list.append(i)<br/>    return square_list</span><span id="a679" class="lz ma iq np b gy nx nu l nv nw">lst = <strong class="np ir">not_generator_function</strong>(10)<br/>print(lst)</span><span id="1fb4" class="lz ma iq np b gy nx nu l nv nw">## <strong class="np ir"><em class="nl">Output<br/></em></strong><em class="nl">[0,1,4,....,81]</em></span></pre><p id="0882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设范围是万亿，这个函数会使内存崩溃，因为它会一次加载内存中的所有数据。所以，更好的选择是创建一个生成器函数。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="703b" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">协同程序</h2><p id="34f3" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">协程是可以在执行过程中暂停的函数，稍后可以从该点继续执行。<br/>协程有几个用例，如网络调用、数据预处理管道、协作式多任务处理等。<br/>我们来举个例子。你有一个大规模的影像数据集，你想使用不同的预处理步骤。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/12b79f9b78a656bc7eaf5aa468c16294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AgULbjaDFNeKExsPn1oKg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">协程图</figcaption></figure><p id="2521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">自定义管道功能</strong>拍摄图像并调整大小。然后，该功能暂停并转到“<strong class="ky ir">图像变换1”</strong>功能<strong class="ky ir"> </strong>和<strong class="ky ir">“图像变换2”</strong>功能，并应用变换。然后，它恢复<strong class="ky ir">自定义管道函数</strong>来将这些转换后的图像与标签配对。这是一个可以使用协程的实际场景。</p><p id="a19d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协程使用“<strong class="ky ir"> yield </strong>暂停函数，使用“<strong class="ky ir"> next </strong>继续函数的执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Python中的协程</figcaption></figure><p id="d9f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，你可以看到当我们在函数上调用“<strong class="ky ir"> next </strong>时，函数执行开始，然后在到达“yield”时停止。当函数中不再有“<strong class="ky ir"> yield </strong>”时，它会引发StopIteration。</p><p id="6595" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协程允许我们将值发送到函数中最后一个暂停的检查点。为了传递值，我们使用“<strong class="ky ir"> send </strong>关键字，但是“<strong class="ky ir"> send </strong>关键字只能在函数执行在“<strong class="ky ir"> yield </strong>处暂停时使用。</p><p id="5cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对协程有了基本的了解。现在，让我们创建一个有多个协同程序同时工作的管道。我创建了三个协程，然后通过根据需要在协程之间切换来修改整个管道中的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">协同流水线</figcaption></figure><p id="7531" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“<strong class="ky ir"> cor_main </strong>”是主协程管道，它采用参数“a”。协程在“x = yield”处停止，然后我给它发送一个值，这个函数然后产生“x+a”。然后从另外两个协程“<strong class="ky ir">转换1 </strong>”和“<strong class="ky ir">转换2 </strong>”传递过来。<br/>然后将转换后的值传递给主协程，以“z = yield”，主协程产生的最终值是“x+a+z”。</p><p id="8eb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> yield from <br/>“<strong class="ky ir"> yield from </strong>”和“yield”很像，只是用了类固醇。用一句话来解释一个简单的生成器很有帮助。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">“产量”的代码</figcaption></figure><p id="7649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在单元格2中，您可以看到，我没有在“<strong class="ky ir"> yield_main </strong>”函数上循环，而是使用“yield from”来解包生成器。Yield也可用于扩展iterables，如单元格5所示。在单元格7中，我定义了一个“data_sink”生成器来获取值并打印出来。从“data_source”函数接收值，然后用包含“yield from”的函数包装“data_sink ”,它充当“data_sink”函数的子生成器。</p><p id="33a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">* *“yield from”在python 3.3中添加</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="d7f0" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">迭代器协议</h2><p id="ba99" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated"><strong class="ky ir"> <em class="nl">免责声明</em> </strong> <em class="nl">:本部分可选。我写这篇文章是因为我发现这很有趣。所以，我想和你们分享一下。<br/> </em>迭代器协议规定了迭代器和可迭代对象的工作方式，以及“__next__”如何给出后续值，并在迭代器用尽时引发异常。事实上，对可重复项的理解和解包是在幕后进行的。</p><p id="157b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，python中的for-in循环不使用索引来遍历iterables。让我们创建一个自定义的for-loop，不带“for loop ”,带迭代器协议，这样你就能更好地理解这个概念了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Python中的自定义For循环</figcaption></figure><p id="c36c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在单元格1中，我创建了一个函数“<strong class="ky ir"> custom_loop </strong>”，它将一个可迭代对象作为参数，然后用“<strong class="ky ir"> __iter__() </strong>”将可迭代对象转换为迭代器。我使用了一个无限while循环，当“<strong class="ky ir"> StopIteration </strong>被引发，并且在try块“<strong class="ky ir"> __next__() </strong>”被调用以获得后续值时，该循环中断。<br/>在下一部分，除了我使用“yield from”进行迭代之外，其他几乎相同。</p><p id="af52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，为了说明这一点，迭代器协议是统治python迭代器世界的魔法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="d729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是这个系列的第一部分的结束。在下一部分，我将讨论一级函数、高阶函数、作用域和闭包。<br/>查看我的《机器学习中的统计学》系列点击<a class="ae kv" href="https://towardsdev.com/statistics-for-machine-learning-i-b0be71b2050f" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nl">此处</em> </strong> </a> <strong class="ky ir"> <em class="nl">。</em>T19】</strong></p><blockquote class="oa ob oc"><p id="1451" class="kw kx nl ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">一个程序员的生活一言以蔽之:<br/> <strong class="ky ir"> google_it() </strong>如果<strong class="ky ir">卡住了</strong>否则继续</p></blockquote></div></div>    
</body>
</html>