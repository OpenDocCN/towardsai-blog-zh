<html>
<head>
<title>K-Fold Cross Validation for Machine Learning Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习模型的k重交叉验证</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/k-fold-cross-validation-for-machine-learning-models-918f6ccfd6d?source=collection_archive---------0-----------------------#2021-02-17">https://pub.towardsai.net/k-fold-cross-validation-for-machine-learning-models-918f6ccfd6d?source=collection_archive---------0-----------------------#2021-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2852" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用sklearn的交叉验证技术概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03b2286372ce8f9dfc360b2c8741e1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RPHQk-xpKMInxkEd1qFyg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者制作的图像</figcaption></figure><p id="2886" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">机器学习方法通常不能对数据建模，因为它们学习训练集的特定特征，而这些特征不存在于测试集中。所以这些特征不具有代表性，我们处于<strong class="la iu">过度拟合</strong>的情况。当模型符合太多的训练数据，但无法在新样本中推广时，就会发生这种情况。有许多方法可以解决这个问题，正则化，选择最佳超参数，以及<strong class="la iu"> K折叠交叉验证</strong>。</p><p id="f546" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将重点放在最后一个主题上，因为我认为公正地执行模型有着重要的作用。简单地将数据分成训练集和测试集并不能让我们真正了解模型的性能。你可以说“哇”，在训练集上有90%的准确率，但在你看到60%的测试准确率之后。肯定出了什么问题。</p><p id="beb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的想法是将数据集分成k个部分，k-1个用于训练，一个用于验证/测试。例如，我们可以将数据集拆分为5个折叠，因此4个折叠将用于训练模型，而剩余的折叠用于评估模型的性能。因此，如果我们决定这个分区，我们需要重复这个过程5次，每次都要改变用于评估模型的折叠位置。</p><p id="eec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更好地了解要使用的所有工具，我将使用来自<a class="ae lu" href="https://www.kaggle.com/c/titanic/data" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的<strong class="la iu">泰坦尼克号数据集</strong>展示最常用的交叉验证技术。完整代码是<a class="ae lu" href="https://github.com/eugeniaring/sklearn-tutorial/blob/main/titanic-kcv.ipynb" rel="noopener ugc nofollow" target="_blank">这里是</a>。在本教程中，我将只使用训练集，因为测试集不包括目标标签。此外，这是避免过度拟合的更好方法，我们将使用更少的训练数据来训练模型，并在验证集中对其进行评估。</p><h1 id="7510" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">内容:</h1><ol class=""><li id="5d94" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated"><a class="ae lu" href="#b027" rel="noopener ugc nofollow"> <strong class="la iu">交叉验证</strong> </a></li><li id="3e15" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae lu" href="#974e" rel="noopener ugc nofollow"> <strong class="la iu">留一交叉验证</strong> </a></li><li id="4c68" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae lu" href="#bbf6" rel="noopener ugc nofollow"> <strong class="la iu"> K倍交叉验证</strong> </a></li><li id="636a" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae lu" href="#f07d" rel="noopener ugc nofollow"> <strong class="la iu">分层K折交叉验证</strong> </a></li><li id="7b97" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae lu" href="#35f5" rel="noopener ugc nofollow"> <strong class="la iu">时间序列交叉验证</strong> </a></li></ol></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="b027" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">1.交互效度分析</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/fd5a092820b7d0a1298867a2a584a6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-ZCXqAobGdFKhV-ljWd6Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图1:交叉验证。作者图片</figcaption></figure><p id="5475" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">传统的老式方法包括将数据集分成3个固定的子集:通常的选择是将60%用于训练，20%用于验证，20%用于测试。您可以根据数据集的大小来决定这些比例。对于一个小的数据集，这个比例是可以的。</p><p id="83f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当有更多数据时，您可以考虑为定型集增加更大的百分比，为验证集和测试集减少更小的百分比。现在，我将使用带有已处理要素的Titanic数据集来展示这种方法。在训练模型之前，我们将训练数据分成训练集和验证集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/ae14914bb3127a5fd86a4c97ec110163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*20njBfcBTg25R6shOPwZOA.png"/></div></div></figure><p id="ad9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦数据被拆分，我们就训练决策树分类器，并在验证集中对其进行评估。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/6eb424a908832faf5a8737df971921d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUvjvUqbr0TfQJ2oZfj7lw.png"/></div></div></figure><h1 id="974e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.留一交叉验证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/97e22fc3055e0240327faf7c0732085e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*g3SXNT7u4iAGp7G_yrK3_w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图2:遗漏一项的简历。作者图片</figcaption></figure><p id="c15f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二种方法将观察值集分成两部分:n-1个观察值用于拟合模型，其余的观察值用于评估模型。这个操作将重复n次。下面我展示了函数LeaveOneOut是如何工作的，遵循同样的推理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/2a9658177fce3c293ae536ca3e74ef0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n43iqlQO7ZZ4XytbSFhlhg.png"/></div></div></figure><p id="0457" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我使用cross_val_score函数来应用留一法。cv是决定使用不同方法分割数据集的策略的参数。在这种情况下，它采用留一个对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/1b84a62994f512a5db969e041072cfd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSGiu9uMAupTs0LJ2d-UAg.png"/></div></div></figure><p id="0c92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到每次分裂的预测和精度，然后计算所有获得值的平均值。准确度低于通过交叉验证获得的准确度。这可能是因为每次分割数据集并使用不同的验证折叠不会高估验证准确性。但是这通常不是优选的方法，因为在分割中没有随机性，并且计算量很大。所以，我们需要尝试其他方法。</p><h1 id="bbf6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.k倍交叉验证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/078ca7590ff540a851564cdb3e69cb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7REeTIvnNA8p0gfgLBzi-A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图3: K折叠交叉验证。作者图片</figcaption></figure><p id="a715" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，在K折叠交叉验证中，我们将数据集分成K个折叠，k-1用于训练模型，剩下的一个用于评估模型。我们不断重复这个操作k次。下面有一个很好的例子来说明这种方法是如何分割数据集的。为了简单起见，我们仅使用5次折叠，并且我们指定shuffle等于True以进行随机拆分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/c7b8a03148c3dbd565cffd5380c795a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEkr4MsUBXCfeh67Y5iMCw.png"/></div></div></figure><p id="a942" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有可能观察到在每个折叠中具有阳性和阴性类别(存活/未存活)的样本数量是不同的。这是由于泰坦尼克号数据集有不平衡的类。我们来看看模型的性能会如何。这一次，我们在函数cross_val_score中应用了<strong class="la iu"> KFold </strong>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6e13bec8be99220e141f22b674e30f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9_zaJKQpkZQLo8qUIe77Q.png"/></div></div></figure><p id="58c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">性能比以前的方法获得的性能好得多。但是还有一个问题。正如我说过的，带有正类和负类的观察值的数量是不同的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/9d9de52c081b0298e310e339c84feebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xa_LrV_DxV32_HafYaZEZw.png"/></div></div></figure><p id="93b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸存的人数少于死亡的人数。作为故事和电影的见证人，莱昂纳多·迪卡普里奥和凯特·温斯莱特。还有一种更好的方法来管理不平衡的类，称为分层K折叠交叉验证。</p><h1 id="f07d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.分层k折叠交叉验证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cd96ec59bd4300c9011128a46da5b252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RT84HelfSxhzcP2W1AnXIA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图4:层状K型褶皱CV。作者图片</figcaption></figure><p id="06b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分层K折叠交叉验证的工作方式与K折叠交叉验证相同。唯一的区别是，它确保每个分类值的观察百分比相同。在这种情况下，幸存和未幸存的两个阶级。</p><p id="1c00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的示例中，分层K交叉验证根据变量Survival划分数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/e4c0c4da03f2e91c73469b6af7da88bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srHxVeh66SHAoLaH5NtT5A.png"/></div></div></figure><p id="5cff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以看到，从一个折叠到另一个折叠，不同类别的样本数量没有变化或变化很小。这是因为我们根据目标变量对数据集进行了分层。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a2db7346271e574a9094cbb280b8066d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jH1WbSabWXyYw5bfZdWskQ.png"/></div></div></figure><p id="c5be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有褶皱的平均准确率为79.79%。它比以前的方法得到的略小。但是我仍然认为这种方法更适合这种类型的数据。</p><h1 id="35f5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.时间序列交叉验证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a170fd663ace8d4a4fd1b3f1846ec009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syCddkhFeq6tlQFD1gCqAg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图5:时间序列CV。作者图片</figcaption></figure><p id="0623" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将展示的最后一种方法是时间序列交叉验证。当数据在时间上相关时，这很有用，因此我们需要保持数据的顺序。通过随机化，我们将失去观察之间的相关性。在第一步中，我们不像其他方法那样需要所有的样本来训练和评估模型，而只是一个子集。在第一步之后，每个训练集都是来自之前的训练集和验证集的组合，我们每次都添加更小的数据来评估模型。只有在最后一次拆分中，我们才能使用所有数据。在这个例子中，我们使用了5个folds，没有指定，因为它是TimeSeriesSplit中的默认参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c2943939ecf4c78a306cafc7afb55715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgcCOyojFepSN1LiEz2fRg.png"/></div></div></figure><p id="98f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们按照之前完成的相同程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0c7721b11d4f381a189aa3d840689f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lI2oH4bYXCSVduQRA5nkPw.png"/></div></div></figure><p id="2d6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">平均性能不是很好，因为数据中没有时间相关性。因此，对Titanic数据集更有效的方法是K折交叉验证和相应的分层版本。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="995a" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">最终想法:</h1><p id="1c1e" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">恭喜你！现在，您已经了解了将数据分成子集的最常见方法。这不是一个容易做到的步骤。我建议你用同一个数据集尝试更多的方法，看看哪种效果更好。</p><p id="885b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好的方法通常是K-Fold交叉验证和分层K-Fold交叉验证。我希望它能帮助你通过例子和图像理解这些概念，这些有时比文字更直接。谢谢你阅读它。祝您愉快！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="8a00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你喜欢我的文章吗？ <a class="ae lu" href="https://eugenia-anello.medium.com/membership" rel="noopener"> <strong class="la iu"> <em class="oh">成为会员</em> </strong> </a> <strong class="la iu"> <em class="oh">每天无限获取数据科学新帖！这是一种间接的支持我的方式，不会给你带来任何额外的费用。如果您已经是会员，</em> </strong> <a class="ae lu" href="https://eugenia-anello.medium.com/subscribe" rel="noopener"> <strong class="la iu"> <em class="oh">订阅</em> </strong> </a> <strong class="la iu"> <em class="oh">每当我发布新的数据科学和python指南时，您都可以收到电子邮件！</em> </strong></p></div></div>    
</body>
</html>