<html>
<head>
<title>The Ultimate Guide To Shallow Copy and Deep Copy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中浅层复制和深层复制的终极指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-ultimate-guide-to-shallow-copy-and-deep-copy-in-python-9cac2ebfe1af?source=collection_archive---------1-----------------------#2021-07-27">https://pub.towardsai.net/the-ultimate-guide-to-shallow-copy-and-deep-copy-in-python-9cac2ebfe1af?source=collection_archive---------1-----------------------#2021-07-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="7c7a" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="c5f8" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">详细解释了Python中的浅层拷贝和深层拷贝</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/d4af816b3c7f5efb4b35aaa3f4080d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CW6TmHPbU_4nOWJOpjgR8Q.jpeg"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供(根据Canva创建)</figcaption></figure></div><div class="ab cl li lj hy lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="in io ip iq ir"><h1 id="b534" class="lp lq iu bd lr ls lt lu lv lw lx ly lz kj ma kk mb km mc kn md kp me kq mf mg bi translated">介绍</h1><p id="cb9e" class="pw-post-body-paragraph mh mi iu mj b mk ml ke mm mn mo kh mp mq mr ms mt mu mv mw mx my mz na nb nc in bi translated">在编写程序时，我们经常要创建一个对象的副本(<em class="nd"> int、float、list、tuple、dictionary等)。</em>)。因为我们想在不改变原对象内容的情况下使用复制(新)对象。</p><p id="9862" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">在Python中有多种方法可以创建对象的副本。<strong class="mj je">但是，要小心！</strong>这些方法大多会创建一个你不想要的<strong class="mj je">浅拷贝</strong>。但是在这个场景中你需要的是一个<strong class="mj je">深度拷贝</strong>。</p><p id="94e5" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">那么，创建对象副本的不同方法是什么呢？什么是浅抄和深抄？我们将在本文中回答所有这些问题。</p></div><div class="ab cl li lj hy lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="in io ip iq ir"><p id="c935" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">让我们先了解一下<strong class="mj je">赋值操作符(=) </strong>并不创建复制(新)对象。它只是在复制(新)对象和原始对象之间创建一个绑定(即<em class="nd">两个对象共享同一个内存地址</em>)。<strong class="mj je">但是这对于不可变的对象没有影响，比如int、float、decimal、bool、tuple等等。因为我们不能修改不可变的对象。</strong></p><blockquote class="nj nk nl"><p id="993b" class="mh mi nd mj b mk ne ke mm mn nf kh mp nm ng ms mt nn nh mw mx no ni na nb nc in bi translated">浅层和深层复制仅对复合对象(包含其他对象的对象，如列表、集合、字典或类实例)有意义。</p></blockquote><h1 id="ced2" class="lp lq iu bd lr ls np lu lv lw nq ly lz kj nr kk mb km ns kn md kp nt kq mf mg bi translated">浅拷贝</h1><p id="60f9" class="pw-post-body-paragraph mh mi iu mj b mk ml ke mm mn mo kh mp mq mr ms mt mu mv mw mx my mz na nb nc in bi translated">浅层拷贝创建给定复合对象的拷贝，同时插入对原始对象的引用。一旦你读完这一节，你就会理解这个定义。</p><p id="9a61" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">在Python中有很多方法可以创建浅层副本。让我们在下一节看看创建浅层副本的6种不同方法——</p><p id="e631" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">请注意下面显示的所有方法中两个对象(<em class="nd"> my_list1 </em>和<em class="nd"> my_list2 </em>)的内存位置。可以看到，<strong class="mj je"> <em class="nd"> id(my_list1) </em> </strong>和<strong class="mj je"> <em class="nd"> id(my_list2) </em> </strong>返回两个不同的内存地址。它表示已经创建了一个新对象(副本)。</p><p id="f8b2" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">函数的作用是:返回对象的地址。这里简单介绍了<a class="ae nu" href="https://pythonsimplified.com/mutability-immutability-in-python/#id_function" rel="noopener ugc nofollow" target="_blank"><strong class="mj je"><em class="nd"/></strong></a><em class="nd">如果你想快速看一下。</em></p><p id="f57b" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je"> For循环:</strong></p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="d1c8" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = []<br/>&gt;&gt;&gt; for num in my_list1:<br/>        my_list2.append(num)</span><span id="afe3" class="oa lq iu nw b gz of oc l od oe">&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964682668352 1964682820800</strong></span></pre><p id="82ca" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">列表理解</strong></p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="782d" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = [ num for num in my_list1]<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964682602752 1964681785728</strong></span></pre><p id="a76f" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">复制方法</strong></p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="44bb" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = my_list1.copy()<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964682620480, 1964682668352</strong></span></pre><p id="5667" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">切片</strong></p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="33c1" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = my_list1[:]<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964682859008 1964682620480</strong></span></pre><p id="6e70" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">构造器</strong></p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="d62e" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = list(mylist_1)<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964683214656 1964683576832</strong></span></pre><p id="46a7" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">复制模块</strong></p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="04d0" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; import copy<br/>&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = copy.copy(my_list1)<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964683560512 1964683214784</strong></span></pre><p id="d657" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">在所有这些方法中，如果你试图修改<strong class="mj je"> my_list1 </strong>或<strong class="mj je"> my_list2 </strong>中的一个元素，你希望其他列表不会得到更新。这正是正在发生的事情。这是因为我们使用了一个元素不可变的列表。例如，在<strong class="mj je"> my_list = [10，20，30，40，50] </strong>中，元素是不可变的。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="5b12" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [10,20,30,40,50]<br/>&gt;&gt;&gt; my_list2 = [num for num in my_list1]<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964682380992 1964682885952</strong></span></pre><p id="0c60" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">现在，您将<strong class="mj je"> my_list[0] </strong>中的值从10更改为100。如你所见，这并没有修改<strong class="mj je"> my_list1 </strong>。因为<strong class="mj je"> my_list1 </strong>和<strong class="mj je"> my_list2 </strong>是两个不同的对象。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="b5c7" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list2[0] = 100<br/>&gt;&gt;&gt; print("my_list1:", my_list1)<br/>&gt;&gt;&gt; print("my_list2:", my_list2)<br/>&gt;&gt;&gt; print(id(my_list1), id(my_list2))<br/><strong class="nw je">my_list1: [10, 20, 30, 40, 50]<br/>my_list2: [10, 20, 30, 40, 50, 60]<br/>1964682380992 1964682885952</strong></span></pre><p id="6f94" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">到目前为止一切顺利。复制操作完全按照我们的预期进行。如果原始对象(例如list)有一个嵌套结构(列表中的列表),你试图修改这些可变元素？接下来会发生什么？</p><p id="87d6" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">在下面的示例中，<strong class="mj je"> my_list1 </strong>具有嵌套结构。这意味着<strong class="mj je"> my_list1 </strong>的各个元素也是列表。接下来，假设您使用上述6种方法中的任意一种创建了my_list2。这是它在视觉上的样子。虽然<strong class="mj je">我的列表1 </strong>和<strong class="mj je">我的列表2 </strong>是两个不同的对象，但是它们的内容共享同一个内存地址。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj og"><img src="../Images/7e6b7bf74f3169dbd4fab83978ef784a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*CDqjE4OB6YD58GO3N4hxqQ.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">浅层拷贝(图片由作者提供)</figcaption></figure><p id="3861" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">让我们通过编程来确认这一点。<strong class="mj je"> id() </strong>函数清楚的表明<strong class="mj je"> my_list1 </strong>和<strong class="mj je"> my_list2 </strong>是两个不同的对象。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="0ff3" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [[10,20], [30,40]]<br/>&gt;&gt;&gt; my_list2 = [num for num in my_list1]<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1964682568960 1964682620672</strong></span></pre><p id="8db9" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">但是请注意，如果列表的元素是可变的，那么共享相同的内存地址，如下所示。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="e071" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; print(id(my_list1[0]), id(my_list2[0]))  <br/>&gt;&gt;&gt; print(id(my_list1[1]), id(my_list2[1]))<br/><strong class="nw je">1964682602560 1964682647424<br/>1964682602560 1964682647424</strong></span></pre><p id="af71" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">由于它们共享相同的内存地址，如果您修改<strong class="mj je"> my_list2[0] </strong>或<strong class="mj je"> my_list2[1] </strong>，相同的更改也会反映在my_list1中，尽管我们并不打算这样做。但这不是我们想要的。对吗？我们想要一个不影响原件的真正的克隆品或复制品。那么，你是怎么处理的呢？这就是<strong class="mj je">深度复制</strong>的用武之地。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="4b8f" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list2[0][0] = 100<br/>&gt;&gt;&gt; print(my_list1)<br/>&gt;&gt;&gt; print(my_list2)<br/><strong class="nw je">[[100, 20], [30, 40]]<br/>[[100, 20], [30, 40]]</strong></span></pre><h1 id="56fb" class="lp lq iu bd lr ls np lu lv lw nq ly lz kj nr kk mb km ns kn md kp nt kq mf mg bi translated">深层拷贝</h1><p id="5de8" class="pw-post-body-paragraph mh mi iu mj b mk ml ke mm mn mo kh mp mq mr ms mt mu mv mw mx my mz na nb nc in bi translated">深度复制创建给定复合对象的副本，同时递归地插入在原始对象中找到的对象的副本。</p><p id="1ed5" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">要创建对象的深层副本，需要使用<strong class="mj je"> copy </strong>模块中的<strong class="mj je"> deepcopy() </strong>方法。让我们举一个同样的例子，我们在浅层复制一节中提到过。</p><p id="dc4f" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">正如你从代码输出和图表中看到的，使用<strong class="mj je"> deepcopy() </strong>我们能够克服浅层拷贝的问题。请注意，嵌套元素不再共享同一个地址。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="3e20" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; my_list1 = [[10,20], [30,40]]<br/>&gt;&gt;&gt; my_list2 = copy.deepcopy(my_list1)<br/>&gt;&gt;&gt; id(my_list1), id(my_list2)<br/><strong class="nw je">1898086629760, 1898086651392</strong></span><span id="a649" class="oa lq iu nw b gz of oc l od oe">&gt;&gt;&gt; id(my_list1[0])), hex(id(my_list2[0]))<br/><strong class="nw je">1964682647424 1964682649152</strong></span><span id="4113" class="oa lq iu nw b gz of oc l od oe">&gt;&gt;&gt; hex(id(my_list1[1])), hex(id(my_list2[1]))<br/><strong class="nw je">1964682602560 1964682648704</strong></span></pre><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oh"><img src="../Images/f7a80c3400308c4c51dd329096486f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*u74Szn31med_H2gCOEbtjg.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">深层副本(图片由作者提供)</figcaption></figure><h1 id="1c37" class="lp lq iu bd lr ls np lu lv lw nq ly lz kj nr kk mb km ns kn md kp nt kq mf mg bi translated">任意Python对象</h1><p id="0116" class="pw-post-body-paragraph mh mi iu mj b mk ml ke mm mn mo kh mp mq mr ms mt mu mv mw mx my mz na nb nc in bi translated">在上述所有方法中，我们都使用了一个列表进行演示。事实上，您可以使用任何可变类型列表、集合、字典或任意Python对象。下面我们来看一个任意对象的例子。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="389d" class="oa lq iu nw b gz ob oc l od oe">import copy</span><span id="d014" class="oa lq iu nw b gz of oc l od oe">class MyClass():<br/>    def __init__(self):<br/>        self.x = [[1,2], [3,4]]</span></pre><p id="1691" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">浅拷贝:</strong>在下面的例子中，我们首先创建了<strong class="mj je"> MyClass </strong>的对象<strong class="mj je"> c </strong>，然后创建了一个浅拷贝<strong class="mj je"> c1 </strong>。如你所见，尽管<strong class="mj je"> c </strong>(原始对象<strong class="mj je"> ) </strong>和浅拷贝对象<strong class="mj je"> c1 </strong>是不同的对象，但它们的内容共享相同的内存。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="69a6" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; c = MyClass()<br/>&gt;&gt;&gt; c1 = copy.copy(c)<br/>&gt;&gt;&gt; print(c is c1)<br/>&gt;&gt;&gt; print(id(c.x[0]), id(c.x[1]))<br/>&gt;&gt;&gt; print(id(c1.x[0]), id(c1.x[1]))<br/><strong class="nw je">False<br/>2709490337928 2709490334920<br/>2709490337928 2709490334920</strong></span></pre><p id="b5b6" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">由于我们处理的是浅层拷贝，当我们将<strong class="mj je">【5，6】</strong>追加到原始对象<strong class="mj je"> c </strong>时，拷贝对象<strong class="mj je"> c1 </strong>也按照预期得到了更新。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="4639" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; c.x.append([5,6])<br/>&gt;&gt;&gt; print(c.x)<br/>&gt;&gt;&gt; print(c1.x)<br/><strong class="nw je">[[1, 2], [3, 4], [5, 6]]<br/>[[1, 2], [3, 4], [5, 6]]</strong></span></pre><p id="0387" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><strong class="mj je">深层拷贝:</strong>继续上面的例子，我们已经创建了对象<strong class="mj je"> c </strong>的深层拷贝<strong class="mj je"> c2 </strong>。原始对象<strong class="mj je"> c </strong>和复制对象<strong class="mj je"> c2 </strong>是两个不同的对象。因为这是一个深层拷贝，所以创建了对象的真实拷贝(克隆),而不是共享相同的内存。如你所见，c和c2中的元素不共享相同的内存。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="1fdf" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; c = MyClass()<br/>&gt;&gt;&gt; c2 = copy.deepcopy(c)<br/>&gt;&gt;&gt; c is c2<br/>&gt;&gt;&gt; print(id(c.x[0]), id(c.x[1]))<br/>&gt;&gt;&gt; print(id(c2.x[0]), id(c2.x[1]))<br/><strong class="nw je">False<br/>1964683630976 1964682581248<br/>1964682779456 1964683675008</strong></span></pre><p id="66d3" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">因此，即使我们改变了<code class="fe oi oj ok nw b"><strong class="mj je">c</strong></code>的内容，它也不会反映在复制对象<code class="fe oi oj ok nw b"><strong class="mj je">c2</strong></code>中。</p><pre class="kt ku kv kw gu nv nw nx ny aw nz bi"><span id="4e8f" class="oa lq iu nw b gz ob oc l od oe">&gt;&gt;&gt; c.x.append([5,6])<br/>&gt;&gt;&gt; print(c.x)<br/>&gt;&gt;&gt; print(c2.x)<br/><strong class="nw je">[[1, 2], [3, 4], [5, 6]]<br/>[[1, 2], [3, 4]]</strong></span></pre><h1 id="d97f" class="lp lq iu bd lr ls np lu lv lw nq ly lz kj nr kk mb km ns kn md kp nt kq mf mg bi translated">结论</h1><p id="4194" class="pw-post-body-paragraph mh mi iu mj b mk ml ke mm mn mo kh mp mq mr ms mt mu mv mw mx my mz na nb nc in bi translated">在本文中，我们通过例子了解了Python中的浅层复制和深层复制。我们已经经历了6种创建浅层拷贝的不同方法。为了创建深层拷贝，我们使用了拷贝模块。在上一节中，我们看到我们也可以在Python任意对象上创建浅层拷贝和深层拷贝。</p><p id="d10e" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">希望这回答了你对Python中浅拷贝和深拷贝的所有疑惑。如果你有任何问题，请在评论区告诉我们。</p><p id="f04f" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><em class="nd">原载于2021年5月31日</em><a class="ae nu" href="https://pythonsimplified.com/the-ultimate-guide-to-shallow-copy-and-deep-copy-in-python/" rel="noopener ugc nofollow" target="_blank"><strong class="mj je"><em class="nd">pythonsimplified.com</em></strong></a><em class="nd">。</em></p><p id="0471" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated"><em class="nd">阅读更多关于Python和数据科学的此类有趣文章，</em> <a class="ae nu" href="https://pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="mj je"> <em class="nd">订阅</em> </strong> </a> <em class="nd">到我的博客</em><a class="ae nu" href="https://pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"><strong class="mj je"><em class="nd">【pythonsimplified.com】</em></strong></a><strong class="mj je"><em class="nd">。</em> </strong>你也可以通过<a class="ae nu" href="https://www.linkedin.com/in/chetanambi/" rel="noopener ugc nofollow" target="_blank"> <strong class="mj je"> LinkedIn </strong> </a>联系我。</p><h1 id="24bc" class="lp lq iu bd lr ls np lu lv lw nq ly lz kj nr kk mb km ns kn md kp nt kq mf mg bi translated">进一步阅读</h1><ul class=""><li id="2974" class="ol om iu mj b mk ml mn mo mq on mu oo my op nc oq or os ot bi translated"><a class="ae nu" href="https://pythonsimplified.com/difference-between-sort-and-sorted-in-python/" rel="noopener ugc nofollow" target="_blank">Python中sort()和sorted()的区别</a></li><li id="0e9f" class="ol om iu mj b mk ou mn ov mq ow mu ox my oy nc oq or os ot bi translated"><a class="ae nu" href="https://pythonsimplified.com/the-most-controversial-python-walrus-operator/" rel="noopener ugc nofollow" target="_blank">最有争议的Python的海象算子</a></li><li id="fcdb" class="ol om iu mj b mk ou mn ov mq ow mu ox my oy nc oq or os ot bi translated"><a class="ae nu" rel="noopener ugc nofollow" target="_blank" href="/the-difference-between-a-a-b-and-a-b-in-python-a7338d96e408">Python中a=a+b和a+=b的区别</a></li><li id="a953" class="ol om iu mj b mk ou mn ov mq ow mu ox my oy nc oq or os ot bi translated"><a class="ae nu" href="https://pythonsimplified.com/understanding-indexing-and-slicing-in-python/" rel="noopener ugc nofollow" target="_blank">了解Python中的索引和切片</a></li><li id="6c3c" class="ol om iu mj b mk ou mn ov mq ow mu ox my oy nc oq or os ot bi translated"><a class="ae nu" href="https://pythonsimplified.com/python-list-vs-tuple/" rel="noopener ugc nofollow" target="_blank"> Python列表Vs元组</a></li></ul><p id="a303" class="pw-post-body-paragraph mh mi iu mj b mk ne ke mm mn nf kh mp mq ng ms mt mu nh mw mx my ni na nb nc in bi translated">我希望你喜欢阅读这篇文章。如果你喜欢我的文章并想订阅Medium，你可以在这里订阅:</p><div class="oz pa gq gs pb pc"><a href="https://chetanambi.medium.com/membership" rel="noopener follow" target="_blank"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd je gz z fq ph fs ft pi fv fx jd bi translated">通过我的推荐链接加入媒体- Chetan Ambi</h2><div class="pj l"><h3 class="bd b gz z fq ph fs ft pi fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pk l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">chetanambi.medium.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq lc pc"/></div></div></a></div></div><div class="ab cl li lj hy lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="in io ip iq ir"><h1 id="8bf4" class="lp lq iu bd lr ls lt lu lv lw lx ly lz kj ma kk mb km mc kn md kp me kq mf mg bi translated">参考</h1><p id="a8e7" class="pw-post-body-paragraph mh mi iu mj b mk ml ke mm mn mo kh mp mq mr ms mt mu mv mw mx my mz na nb nc in bi translated">[.]<a class="ae nu" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/copy.html</a></p></div></div>    
</body>
</html>