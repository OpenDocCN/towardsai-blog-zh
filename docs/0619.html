<html>
<head>
<title>AI on Thanos Tweets, Emotion Detector using torchMoji</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能在灭霸推特上，使用火炬码的情绪检测器</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/ai-on-thanos-tweets-emotion-detector-using-torchmoji-eda6026625be?source=collection_archive---------1-----------------------#2020-06-24">https://pub.towardsai.net/ai-on-thanos-tweets-emotion-detector-using-torchmoji-eda6026625be?source=collection_archive---------1-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="11d0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a></h2><div class=""/><div class=""><h2 id="25ef" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在NLP上使用深度学习。<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20200621_Thanos_Emotion_Detection" rel="noopener ugc nofollow" target="_blank">完整代码可在我的Github回购。</a></h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/9a67800c76a1e50174975222eea9e778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HeB1kylmWsMMKVXO7c_xVQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">灭霸大战复仇者联盟，无限战争，2018</figcaption></figure><p id="a3a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae kr" href="https://medium.com/towards-artificial-intelligence/using-torchmoji-with-python-and-deep-learning-3fefee62c9a1" rel="noopener">在我的上一篇教程</a>中，我终于能够发布代码，在你的python代码中使用torch moji(deep moji的PyTorch版本)。所有接近NLP的人工智能开发人员都希望从对一些文本进行情感分析开始。</p><p id="b878" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，情感分析有很大的局限性。情感分析的输出范围从-1到1，一个单一的维度。你可以在一维输出中找到的集群是通过排序一个列表得到的，到目前为止，没什么特别的。</p><h2 id="c07f" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">为什么我要使用情绪检测？</h2><p id="8d54" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">DeepMoji已经在1.246.000条社交媒体文本上进行了训练，以识别何时使用了64种不同的情绪。输出不是单一维度，而是64个维度(64列)。我可以执行更深入的分析，甚至在数据中找到聚类，这增加了我管理NLP问题的复杂性。</p><h1 id="1ed8" class="nb mf it bd mg nc nd ne mj nf ng nh mm ki ni kj mp kl nj km ms ko nk kp mv nl bi translated">下载推文</h1><p id="e3c7" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">要下载成千上万条推文，你可以使用原始的Twitter API，也可以使用twint。因为使用这个工具违反了Twitter的服务条款，所以要明智。我不会在学术出版物中使用这些数据，并且，在我的存储库中，我将只保存那些不会向您显示发布补间者的用户信息的数据集部分。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="1dc2" class="me mf it nn b gy nr ns l nt nu">!pip3 install twint</span><span id="5d6c" class="me mf it nn b gy nv ns l nt nu"><a class="ae kr" href="https://github.com/twintproject/twint" rel="noopener ugc nofollow" target="_blank">https://github.com/twintproject/twint</a></span><span id="c05d" class="me mf it nn b gy nv ns l nt nu">import twint</span><span id="fc7a" class="me mf it nn b gy nv ns l nt nu"># Configure<br/>c = twint.Config()<br/>c.Search = '#thanos', 'Thanos'<br/>#c.Search = 'Thanos', 'snap'<br/>c.Store_csv = True<br/>c.Since = "2018-06-16 00:00:00" #anno, mese, giorno<br/>#c.g="48.880048,2.385939,1km" #1km radius from Paris<br/>c.Limit = 10000 #non funziona<br/>c.Output = "Thanos.csv"</span></pre><p id="be12" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了这些设置，当我运行下面的代码时，软件将下载它在网上找到的所有推文。我只对推文感兴趣，所以我会放弃所有其他信息。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="3b14" class="me mf it nn b gy nr ns l nt nu"># Run<br/>twint.run.Search(c)</span></pre><p id="c5b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">经过10分钟的等待时间，我已经能够存储5k条推文进行分析。的。csv文件已自动存储在我的文件中，因此我可以在以后检索它。</p><h1 id="e136" class="nb mf it bd mg nc nd ne mj nf ng nh mm ki ni kj mp kl nj km ms ko nk kp mv nl bi translated">正在安装DeepMoji</h1><p id="72f0" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">不幸的是，安装需要几分钟，并且需要下载大量数据。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="e935" class="me mf it nn b gy nr ns l nt nu">#Install torchMoji<br/>!pip3 install torch==1.0.1 -f <a class="ae kr" href="https://download.pytorch.org/whl/cpu/stable" rel="noopener ugc nofollow" target="_blank">https://download.pytorch.org/whl/cpu/stable</a> <br/>!git clone <a class="ae kr" href="https://github.com/huggingface/torchMoji" rel="noopener ugc nofollow" target="_blank">https://github.com/huggingface/torchMoji</a><br/>import os<br/>os.chdir('torchMoji')<br/>!pip3 install -e .</span></pre><p id="f0c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，软件现在会要求您重新启动笔记本电脑，但是，如果您这样做了，笔记本电脑有可能会在循环中崩溃。如果你设法好奇，使它卡住了，小心重置所有设置，以防止崩溃循环。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="00ad" class="me mf it nn b gy nr ns l nt nu">!python3 scripts/download_weights.py</span></pre><p id="77b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要完成第二部分，您必须授权下载。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="d97e" class="me mf it nn b gy nr ns l nt nu">import numpy as np<br/>import emoji, json<br/>from torchmoji.global_variables import PRETRAINED_PATH, VOCAB_PATH<br/>from torchmoji.sentence_tokenizer import SentenceTokenizer<br/>from torchmoji.model_def import torchmoji_emojis<br/>  <br/>EMOJIS = ":joy: :unamused: :weary: :sob: :heart_eyes: :pensive: :ok_hand: :blush: :heart: :smirk: :grin: :notes: :flushed: :100: :sleeping: :relieved: :relaxed: :raised_hands: :two_hearts: :expressionless: :sweat_smile: :pray: :confused: :kissing_heart: :heartbeat: :neutral_face: :information_desk_person: :disappointed: :see_no_evil: :tired_face: :v: :sunglasses: :rage: :thumbsup: :cry: :sleepy: :yum: :triumph: :hand: :mask: :clap: :eyes: :gun: :persevere: :smiling_imp: :sweat: :broken_heart: :yellow_heart: :musical_note: :speak_no_evil: :wink: :skull: :confounded: :smile: :stuck_out_tongue_winking_eye: :angry: :no_good: :muscle: :facepunch: :purple_heart: :sparkling_heart: :blue_heart: :grimacing: :sparkles:".split(' ')<br/>model = torchmoji_emojis(PRETRAINED_PATH)<br/>with open(VOCAB_PATH, 'r') as f:<br/>  vocabulary = json.load(f)<br/>st = SentenceTokenizer(vocabulary, 30)</span></pre><p id="a672" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">创建解码函数。虽然这个函数在源代码中已经可用，但我添加了一些简单的修改，让你可以访问情绪检测的概率分布，这样你就知道从文本中估计的每个表情符号的概率是多少。当我必须执行更复杂的分析(如聚类)时，这些数据将被证明是有用的。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="8393" class="me mf it nn b gy nr ns l nt nu">def deepmojify(sentence, top_n=5, return_emoji=True, return_prob=False):<br/>  #converte lista probabilità in emoticon più probabili<br/>  def top_elements(array, k):<br/>    ind = np.argpartition(array, -k)[-k:]<br/>    return ind[np.argsort(array[ind])][::-1]</span><span id="0cba" class="me mf it nn b gy nv ns l nt nu">tokenized, _, _ = st.tokenize_sentences([sentence])<br/>  #print(tokenized)<br/>  #lista di probabilità<br/>  prob = model(tokenized)[0]<br/>  #se ci sono errori parte da qui: too many values to unpack (expected 2), non riesce a trovare prob<br/>  #trova le n emoticono più alte <br/>  emoji_ids = top_elements(prob, top_n)</span><span id="971d" class="me mf it nn b gy nv ns l nt nu">#converte questi numeri in emoticons<br/>  emojis = map(lambda x: EMOJIS[x], emoji_ids)<br/>  <br/>  if return_emoji == False and return_prob == False:<br/>    return None<br/>  elif return_emoji == True and return_prob == False:<br/>    return emoji.emojize(f"{sentence} {' '.join(emojis)}", use_aliases=True)<br/>  elif return_emoji == True and return_prob == True:<br/>    return emoji.emojize(f"{sentence} {' '.join(emojis)}", use_aliases=True), prob<br/>  elif return_emoji == False and return_prob == True:<br/>    return prob</span></pre><h2 id="dba9" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">将单个文本转换为表情符号</h2><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="d93e" class="me mf it nn b gy nr ns l nt nu">deepmojify('ciao come stai?', top_n=3, return_emoji=True, return_prob=False)<br/>'ciao come stai? 💓 💛 ❤'</span></pre><p id="67c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段代码将简单地返回这句话中最可能的表情符号。我将在下一篇文章中使用这段代码来更高级地使用数据分析工具。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="155f" class="me mf it nn b gy nr ns l nt nu">deepmojify('ciao come stai?', top_n=3, return_emoji=False, return_prob=True)<br/>array([<br/>0.00394054, 0.00129295, 0.00197147, 0.00432513, 0.01371501,        0.00560058, 0.00418637, 0.02010225, 0.07735906, 0.01391253,        0.01317994, 0.00444024, 0.0065301 , 0.0008908 , 0.0036633 ,        0.00902654, 0.03026676, 0.00181301, 0.03949212, 0.00103115,        0.00485938, 0.00700757, 0.00463908, 0.02274275, 0.17968854,        0.00277099, 0.00447128, 0.00739905, 0.02860775, 0.00278266,        0.03876906, 0.0063387 , 0.00113546, 0.00621301, 0.00847516,        0.00747591, 0.01020002, 0.00090959, 0.00828929, 0.00162419,        0.00219347, 0.0071467 , 0.00454975, 0.0043973 , 0.00239056,        0.00502038, 0.00712393, 0.13541125, 0.00248322, 0.02106217,        0.02085136, 0.00176592, 0.00304266, 0.02627314, 0.01630236,        0.00183573, 0.00255118, 0.00402961, 0.00483469, 0.02000473,        0.02692209, 0.02151149, 0.00628529, 0.04087168<br/>], dtype=float32)</span></pre><p id="d144" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，如果你对DeepMoji背后发生的过程感兴趣，通过这些参数，你可以获得这句话的概率分布。</p><h2 id="e13e" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">错误:要解包的值太多(应为2)</h2><p id="16bc" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">它可能无缘无故地发生。如果代码运行此错误，重置变量并从零开始重新启动。我把它放在文章里是为了避免你感到沮丧。</p><h2 id="39e9" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">将列表转换为DataFrame +表情符号</h2><p id="ade8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">tweet数据集被存储为熊猫数据帧。然而，前面的函数将单个文本作为输入。该函数将列表作为输入，然后创建一个数据帧，在下面的列中存储指定数量的表情符号。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="dff6" class="me mf it nn b gy nr ns l nt nu">import pandas as pd</span><span id="2c75" class="me mf it nn b gy nv ns l nt nu">#converts a list to emoji<br/>def emoji_dataset(list1, n_emoji=3, only_prob=False):<br/>  emoji_list = [[x] for x in list1]</span><span id="5537" class="me mf it nn b gy nv ns l nt nu">for _ in range(len(list1)):<br/>    for n_emo in range(1, n_emoji+1):<br/>      if only_prob == False:<br/>        emoji_list[_].append(deepmojify(list1[_], top_n=n_emoji, return_emoji=True, return_prob=False)[2*-n_emo+1])<br/>      else:<br/>        emoji_list[_].append(deepmojify(list1[_], top_n=1, return_emoji=False, return_prob=True))</span><span id="fc1c" class="me mf it nn b gy nv ns l nt nu">emoji_list = pd.DataFrame(emoji_list)<br/>  return emoji_list</span></pre><h1 id="a413" class="nb mf it bd mg nc nd ne mj nf ng nh mm ki ni kj mp kl nj km ms ko nk kp mv nl bi translated">处理推特数据集</h1><h2 id="2d75" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">清理数据</h2><p id="9897" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">最后，我可以收集5k条推文。在将它们输入emoji_dataset功能之前，我会仔细检查，至少，这些推文包含关键词“灭霸”。</p><p id="2c20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">* * *我认为有更好的方法来从无效的推文中选择有效的，但是我还没有探索它们。Twint并不总是完美的，它可能会下载不相关的推文。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="3394" class="me mf it nn b gy nr ns l nt nu">##Emotional Detector<br/>df = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Projects/20200621_Emotion_Detector/Thanos.csv')<br/>df = pd.DataFrame(df['tweet'])<br/>df</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8fa7e7990564610a77a912f4f71dad67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*sEtYHuH1KoG0ayPpN2vo_w.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">tweets数据集的示例</figcaption></figure><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="7697" class="me mf it nn b gy nr ns l nt nu">def check_string(string1):<br/>  if '#thanos' in string1:<br/>    return 1<br/>  elif 'Thanos' in string1:<br/>    return 1<br/>  elif 'thanos' in string1:<br/>    return 1<br/>  elif 'THANOS' in string1:<br/>    return 1<br/>  else:<br/>    return 0</span><span id="9307" class="me mf it nn b gy nv ns l nt nu">#cleaning the data<br/>df['healthy'] = 0<br/>df</span></pre><p id="8cbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将应用该算法创建另一个列。对于不包含函数中指定的关键字的所有tweets，该列将显示0值。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="a5fe" class="me mf it nn b gy nr ns l nt nu">#only conserve tweets with the right keywords<br/>df['healthy'] = df['tweet'].apply(lambda x : check_string(x))<br/>df</span></pre><p id="e9c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将只选择健康值为0的列。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="8c95" class="me mf it nn b gy nr ns l nt nu">df = df.loc[df['healthy'] == 1]<br/>df</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a1291f484439e58809c102824788a266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*19T_9M1WdDoXXSrkR4vyjQ.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">数据集的样本</figcaption></figure><h2 id="0df5" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">转换成表情符号</h2><p id="ef5a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在是时候将整个数据集转换成表情符号了。我选择5作为神经网络最有可能做出的选择。对于每一句话，神经网络将估计最可能的5个表情符号。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="fbf6" class="me mf it nn b gy nr ns l nt nu">df = df['tweet'].to_list()<br/>df</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ny"><img src="../Images/0fd6840278b8e3ba31be200d0f3c1804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQYjwZno-3k9Gk8XH7x6sQ.png"/></div></div></figure><p id="0ffd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，该算法只接受列表。现在我已经有了正确格式的数据集，可以将它输入到模型中了。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="a9d8" class="me mf it nn b gy nr ns l nt nu">#start converting text to emoji<br/>df = emoji_dataset(df, 5)<br/>df</span></pre><p id="3304" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">等待时间大约是30分钟。对此我很抱歉，我也没有耐心。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nz"><img src="../Images/4acd2f13a7ea889ea2135c8b4dad8fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZsWl2704TKvbLhBTOe2vsQ.png"/></div></div></figure><p id="e073" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太棒了。我们的数据集已经被转换成表情符号。我将在下一篇文章中讨论如何分析数据来找出聚类在哪里。</p><h2 id="fe36" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">导出数据集</h2><p id="ed08" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你想在你的电脑上导出结果，这是代码。</p><pre class="kt ku kv kw gt nm nn no np aw nq bi"><span id="41c8" class="me mf it nn b gy nr ns l nt nu">#export dataset<br/>df.to_csv('Thanos_.csv')</span></pre><p id="a716" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你喜欢，请随意鼓掌。感谢您的阅读。</p></div></div>    
</body>
</html>