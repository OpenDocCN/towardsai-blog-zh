<html>
<head>
<title>ROCKET: Fast and Accurate Time Series Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ROCKET:快速准确的时间序列分类</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/rocket-fast-and-accurate-time-series-classification-f54923ad0ac9?source=collection_archive---------0-----------------------#2020-09-27">https://pub.towardsai.net/rocket-fast-and-accurate-time-series-classification-f54923ad0ac9?source=collection_archive---------0-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5fbd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="dd0f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用python实现时间序列分类的最新算法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/0604e4bee6d93d4a1449e45a76dac3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*s_uAEu-AlMxqwTqTXXF6Jw@2x.jpeg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图片由<a class="ae ld" href="https://pixabay.com/users/OpenClipart-Vectors-30363/" rel="noopener ugc nofollow" target="_blank">openclipbart-Vectors</a>在<a class="ae ld" href="https://pixabay.com/vectors/alphabet-word-images-animation-1297651/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></figcaption></figure><blockquote class="le lf lg"><p id="9b5a" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“时间序列分类的任务可以被认为是学习或检测与相关类相关的时间序列中的信号或模式。”— <a class="ae ld" href="https://link.springer.com/article/10.1007/s10618-020-00701-z#Sec2" rel="noopener ugc nofollow" target="_blank"> Dempster等人，2020，火箭论文的作者</a></p></blockquote><p id="cd4c" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">大多数具有最新(SOTA)精度的时间序列分类方法计算复杂度高，可扩展性差。这意味着它们在较小的数据集上训练很慢，并且在大型数据集上实际上不可用。</p><p id="dad4" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">ROCKET(随机卷积核变换)可以在很短的时间内达到与竞争SOTA算法(包括卷积神经网络)相同的精度。这些算法在UCR档案馆<a class="ae ld" href="https://timeseriesclassification.com/index.php" rel="noopener ugc nofollow" target="_blank">的基准数据集上进行评估。</a></p><p id="b96b" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">ROCKET首先使用随机卷积核(如CNN中使用的那些核)转换时间序列数据集，然后使用这些特征训练线性分类器。</p><p id="aa45" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">火箭快多少？为了在85个基准数据集上连续训练和测试ROCKET，花费了1小时40分钟。对于同样的任务，下一个最快的SOTA算法(cBOSS)需要19小时33分钟。关于速度的更多比较，参见<a class="ae ld" href="https://link.springer.com/article/10.1007/s10618-020-00701-z#Sec1" rel="noopener ugc nofollow" target="_blank">论文</a>。</p><p id="3455" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">在本文的剩余部分，我将:</p><ul class=""><li id="96cf" class="mh mi it lk b ll lm lo lp me mj mf mk mg ml md mm mn mo mp bi translated">讨论替代的时间序列分类器</li><li id="1758" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated">解释火箭如何工作</li><li id="c09b" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated">提供一个python代码示例</li></ul><h1 id="e5af" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">有哪些替代方案？</h1><p id="c3d4" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">时间序列分类的其他方法通常依赖于序列的特定表示，如形状、频率或方差。ROCKET的卷积内核用一个可以捕获许多相同特征的单一机制取代了这种工程化的特征提取。</p><h2 id="34f1" class="ns mw it bd mx nt nu dn nb nv nw dp nf me nx ny nh mf nz oa nj mg ob oc nl iz bi translated">时间序列分类综述</h2><p id="94aa" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">时间序列变换是时间序列分类的一个基本思想。<strong class="lk jd">许多时间序列特定算法是转换的时间序列和常规分类算法</strong>的组合，例如scikit-learn中的算法。</p><p id="e1d0" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">对于时间序列分类算法的介绍性调查，请参阅我以前的文章。</p><div class="od oe gp gr of og"><a href="https://towardsdatascience.com/a-brief-introduction-to-time-series-classification-algorithms-7b4284d31b97" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">时间序列分类算法综述</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">专门为时间序列分类设计的专用算法</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kx og"/></div></div></a></div><h2 id="de00" class="ns mw it bd mx nt nu dn nb nv nw dp nf me nx ny nh mf nz oa nj mg ob oc nl iz bi translated">竞争SOTA方法</h2><p id="3f33" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">以下方法旨在提高上述<a class="ae ld" href="https://towardsdatascience.com/a-brief-introduction-to-time-series-classification-algorithms-7b4284d31b97" rel="noopener" target="_blank">调查</a>中描述的算法的速度和准确性。</p><ul class=""><li id="dace" class="mh mi it lk b ll lm lo lp me mj mf mk mg ml md mm mn mo mp bi translated"><em class="lj">邻近森林</em>是根据弹性距离度量划分的决策树的集合。</li><li id="3c15" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated"><em class="lj"> TS-CHIEF </em>通过使用基于字典和基于区间的分裂标准来扩展邻近森林。</li><li id="df1c" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated"><a class="ae ld" href="https://github.com/hfawaz/InceptionTime" rel="noopener ugc nofollow" target="_blank"> <em class="lj"> InceptionTime </em> </a>是基于Inception架构的5个深度CNN的合集。</li><li id="9e5f" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated"><a class="ae ld" href="https://www.sktime.org/en/latest/examples/mrseql.html" rel="noopener ugc nofollow" target="_blank"> Mr-SEQL </a>将线性分类器应用于通过时间序列的符号表示(SAX，SFA)提取的特征。</li><li id="58fe" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated">cBOSS，或称为contractable BOSS，是基于SFA变换的基于字典的分类器。</li><li id="d10d" class="mh mi it lk b ll mq lo mr me ms mf mt mg mu md mm mn mo mp bi translated"><a class="ae ld" href="https://github.com/chlubba/catch22" rel="noopener ugc nofollow" target="_blank"> catch22 </a>是一组22个预选的时间序列转换，可以传递给分类器。</li></ul><h2 id="1bbe" class="ns mw it bd mx nt nu dn nb nv nw dp nf me nx ny nh mf nz oa nj mg ob oc nl iz bi translated">小型火箭</h2><p id="415f" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">MiniRocket是Rocket的优化版本，最近发布了。</p><blockquote class="ov"><p id="fd2e" class="ow ox it bd oy oz pa pb pc pd pe md dk translated">根据作者的说法，MiniRocket应该被视为Rocket的默认版本。</p></blockquote><div class="pf pg ph pi pj og"><a href="https://towardsdatascience.com/minirocket-fast-er-and-accurate-time-series-classification-cdacca2dcbfa" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">微型火箭:快速和准确的时间序列分类</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用Python实现系列分类的最快的先进算法</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="pk l or os ot op ou kx og"/></div></div></a></div><h1 id="f151" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">火箭是如何工作的？</h1><p id="fe80" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">ROCKET首先使用卷积核转换时间序列，然后将转换后的数据传递给线性分类器。</p><h2 id="3942" class="ns mw it bd mx nt nu dn nb nv nw dp nf me nx ny nh mf nz oa nj mg ob oc nl iz bi translated">卷积核</h2><p id="50ea" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">卷积核与卷积神经网络中的相同，使用随机长度、权重、偏差、<a class="ae ld" href="https://www.inference.vc/dilated-convolutions-and-kronecker-factorisation/" rel="noopener ugc nofollow" target="_blank">膨胀</a>和填充进行初始化。关于如何对随机参数进行采样，参见<a class="ae ld" href="https://link.springer.com/article/10.1007/s10618-020-00701-z#Sec8" rel="noopener ugc nofollow" target="_blank">论文</a>——它们是ROCKET的一部分，采样不需要调整。步幅总是一个。ROCKET不会对生成的要素应用非线性变换，如ReLU。</p><div class="od oe gp gr of og"><a href="https://arxiv.org/abs/1603.07285" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">深度学习卷积算法指南</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">我们介绍了一个指南，以帮助深度学习从业者理解和操纵卷积神经网络…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">arxiv.org</p></div></div></div></a></div><p id="38d0" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">ROCKET使用了大量的内核——默认是10，000个。使用这么多是可能的，因为计算卷积的成本非常低。这是因为内核权重不是“学习”的，并且只有一层卷积。</p><p id="0a79" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">与典型的CNN不同，ROCKET使用了多种内核。随机的长度、膨胀、填充、重量和偏差使得ROCKET能够捕捉广泛的信息。特别是，内核膨胀的多样性允许ROCKET捕捉不同频率和尺度的模式。</p><p id="6b49" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">这些随机核组合在一起，能够捕获与时间序列分类相关的特征。单独地，单个随机卷积核可能仅微弱地从时间序列中捕获有用的特征。</p><h2 id="4d93" class="ns mw it bd mx nt nu dn nb nv nw dp nf me nx ny nh mf nz oa nj mg ob oc nl iz bi translated">卷积核变换</h2><p id="0574" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">每个核与每个时间序列进行卷积以产生特征图。内核的特征映射被聚集以产生每个内核的两个特征:最大值<strong class="lk jd"/>和正值比例<strong class="lk jd"/>。</p><p id="3e46" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated"><em class="lj">最大值</em>功能类似于全局最大池。</p><p id="2e23" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">正值的<em class="lj">比例</em>表示如何对内核捕获的模式的流行程度进行加权。这个值是ROCKET最关键的元素，有助于它的高精度。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/b933f9d14569e85f9678fcb3ecdcfb86.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*lA-PtZhWnJbJmU7W5hGTQQ.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">zi是卷积运算的输出</figcaption></figure><h2 id="4c8c" class="ns mw it bd mx nt nu dn nb nv nw dp nf me nx ny nh mf nz oa nj mg ob oc nl iz bi translated">线性分类</h2><p id="a45e" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated"><strong class="lk jd">对于较小的数据集</strong>，作者推荐使用<em class="lj">岭回归分类器</em>，因为它可以快速交叉验证正则化参数，并且没有其他超参数。</p><p id="c8cb" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">当要素的数量超过训练样本的数量时，正则化就变得至关重要，小数据集经常出现这种情况。(默认情况下，ROCKET使用10，000个内核，每个内核生成两个特性，结果是20，000个特性)</p><p id="3a7f" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated"><strong class="lk jd">对于大型数据集</strong>，由于可扩展性，作者推荐<em class="lj">带有随机梯度下降的逻辑回归</em>。</p><p id="035b" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">在“大型”数据集中，训练样本的数量远大于提取特征的数量。</p><h1 id="3a63" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">如何用Python使用ROCKET？</h1><p id="268f" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">ROCKET转换在<code class="fe pm pn po pp b"><a class="ae ld" href="https://www.sktime.org/en/latest/examples/rocket.html" rel="noopener ugc nofollow" target="_blank">sktime</a></code> python包中实现。</p><div class="od oe gp gr of og"><a href="https://link.medium.com/TyOyddIK19" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">Sktime:用于时间序列机器学习的统一Python库</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">为什么？现有工具不太适合时间序列任务，并且不容易集成在一起。方法在…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">link.medium.com</p></div></div><div class="op l"><div class="pq l or os ot op ou kx og"/></div></div></a></div><p id="783d" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">以下代码示例改编自ROCKET Transform 的sktime <a class="ae ld" href="https://www.sktime.org/en/latest/examples/rocket.html" rel="noopener ugc nofollow" target="_blank">演示。</a></p><p id="f317" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">首先，加载所需的包。</p><pre class="ks kt ku kv gt pr pp ps pt aw pu bi"><span id="e8c2" class="ns mw it pp b gy pv pw l px py">import numpy as np<br/>from sklearn.linear_model import RidgeClassifierCV<br/>from sktime.datasets import load_arrow_head  # univariate dataset<br/>from sktime.transformers.series_as_features.rocket import Rocket</span></pre><p id="e653" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">接下来设置训练和测试数据——在这种情况下，为了方便起见，我使用单变量<a class="ae ld" href="https://timeseriesclassification.com/description.php?Dataset=ArrowHead" rel="noopener ugc nofollow" target="_blank"> <em class="lj">箭头</em> </a>系列数据集。<em class="lj">Rocket变换也可应用于多元数据。</em></p><pre class="ks kt ku kv gt pr pp ps pt aw pu bi"><span id="8ba6" class="ns mw it pp b gy pv pw l px py">X_train, y_train = load_arrow_head(split="test", return_X_y=True)<br/>X_test, y_test = load_arrow_head(split="train", return_X_y=True)<br/>print(X_train.shape, X_test.shape) <br/><em class="lj">&gt;&gt; (175, 1) (36, 1)</em></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="qa qb di qc bf qd"><div class="gh gi pz"><img src="../Images/e9e87d221002a7a5240b621195564917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pOvYH_8aQG9mxBkaN-VyQ.png"/></div></div></figure><p id="4274" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">使用Rocket变换来变换训练数据。默认情况下，ROCKET使用10，000个内核。<em class="lj">一般来说，核越多，分类精度越高；然而，在增加的精度和计算时间之间有一个折衷。即使有大量的内核，ROCKET依然很快。</em></p><pre class="ks kt ku kv gt pr pp ps pt aw pu bi"><span id="e5e8" class="ns mw it pp b gy pv pw l px py">rocket = Rocket(num_kernels=10000, random_state=111) <br/>rocket.fit(X_train)<br/>X_train_transform = rocket.transform(X_train)<br/>X_train_transform.shape<br/>&gt;&gt; (175, 20000)</span></pre><p id="bc9c" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">从scikit-learn初始化并训练线性分类器。<code class="fe pm pn po pp b">sktime</code>的作者推荐对更小的数据集使用<code class="fe pm pn po pp b"><a class="ae ld" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeClassifierCV.html" rel="noopener ugc nofollow" target="_blank">RidgeClassifierCV</a> </code>(&lt;20k训练示例)。对于更大的数据集，使用随机梯度下降<code class="fe pm pn po pp b"><a class="ae ld" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html" rel="noopener ugc nofollow" target="_blank">SGDClassifier(loss='log')</a></code>训练的逻辑回归。</p><pre class="ks kt ku kv gt pr pp ps pt aw pu bi"><span id="3b55" class="ns mw it pp b gy pv pw l px py">classifier = RidgeClassifierCV(alphas=np.logspace(-3, 3, 10), normalize=True)<br/>classifier.fit(X_train_transform, y_train)</span></pre><p id="4033" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">最后，为了给训练好的模型评分并生成预测，使用Rocket转换测试数据并调用训练好的模型。</p><pre class="ks kt ku kv gt pr pp ps pt aw pu bi"><span id="60ca" class="ns mw it pp b gy pv pw l px py">X_test_transform = rocket.transform(X_test)<br/>classifier.score(X_test_transform, y_test)<br/>&gt;&gt; 0.9167</span></pre><h1 id="8dd4" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">引用</h1><p id="731e" class="pw-post-body-paragraph lh li it lk b ll nn kd ln lo no kg lq me np lt lu mf nq lx ly mg nr mb mc md im bi translated">Dempster，a .，Petitjean，F. &amp; Webb，G.I. <a class="ae ld" href="https://link.springer.com/article/10.1007/s10618-020-00701-z" rel="noopener ugc nofollow" target="_blank"> ROCKET:使用随机卷积核进行异常快速和准确的时间序列分类</a>。<em class="lj">数据最小已知盘</em> <strong class="lk jd"> 34，</strong>1454–1495(2020)。<a class="ae ld" href="https://doi.org/10.1007/s10618-020-00701-z" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1007/s10618-020-00701-z</a></p><h1 id="a6c9" class="mv mw it bd mx my mz na nb nc nd ne nf ki ng kj nh kl ni km nj ko nk kp nl nm bi translated">加入Medium！</h1><div class="od oe gp gr of og"><a href="http://alexandra-amidon.medium.com/membership" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">阅读亚历山德拉·阿米登(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">alexandra-amidon.medium.com</p></div></div><div class="op l"><div class="qe l or os ot op ou kx og"/></div></div></a></div></div></div>    
</body>
</html>