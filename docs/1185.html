<html>
<head>
<title>The Python Record Linkage Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python记录链接工具包</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-python-record-linkage-toolkit-9b1c59fd156a?source=collection_archive---------2-----------------------#2020-11-27">https://pub.towardsai.net/the-python-record-linkage-toolkit-9b1c59fd156a?source=collection_archive---------2-----------------------#2020-11-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="68a4" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="7bae" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">用于在数据源之间链接记录的库</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/71e8049d1df9a66eea528265e2a3a325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R_GyaL9BIflLWIbY"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">来源:<a class="ae li" href="https://unsplash.com/photos/ImcUkZ72oUs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure></div><div class="ab cl lj lk hy ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="in io ip iq ir"><h1 id="f386" class="lq lr iu bd ls lt lu lv lw lx ly lz ma kj mb kk mc km md kn me kp mf kq mg mh bi translated">介绍</h1><p id="a400" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">顾名思义<strong class="mk je"> Python记录链接工具包</strong>用于链接同一文件中或不同数据源之间的记录。它提供了许多工具/功能来帮助记录链接和重复数据删除过程。</p><h2 id="94e8" class="ne lr iu bd ls nf ng dn lw nh ni dp ma mr nj nk mc mv nl nm me mz nn no mg ja bi translated">重复数据删除</h2><p id="6e11" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">重复数据删除是从给定数据中消除或删除冗余数据的过程。</p><h2 id="a9f7" class="ne lr iu bd ls nf ng dn lw nh ni dp ma mr nj nk mc mv nl nm me mz nn no mg ja bi translated"><strong class="ak">记录联动</strong></h2><p id="166d" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">记录链接是将一个来源的数据与描述同一实体的另一个来源的数据结合起来的过程。例如，我们可以将file_1中的记录<strong class="mk je"><em class="np">Narendra Modi</em></strong><em class="np"/>与file_2中的<strong class="mk je"><em class="np">Narendra Damodardas Modi</em></strong>进行链接/联接，因为两者都引用同一个实体。</p><p id="9d61" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated"><strong class="mk je">考虑一下这个场景</strong>——您从两个不同的来源获得两个文件，其中包含关于同一个实体的信息。假设您的需求是使用这两个文件，并使用公共/相似的列从这两个文件中生成一个报告。如何合并或链接两个文件中的记录？工具箱来拯救你。</p><p id="9717" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated"><code class="fe nv nw nx ny b">recordlinkage</code>库提供的功能可以大致分为五类。在这篇博客中，我们将只关注预处理、索引和比较。我将在以后的文章中尝试介绍分类和评估。</p><ul class=""><li id="a00b" class="nz oa iu mk b ml nq mo nr mr ob mv oc mz od nd oe of og oh bi translated">预处理</li><li id="d53e" class="nz oa iu mk b ml oi mo oj mr ok mv ol mz om nd oe of og oh bi translated">索引</li><li id="4df0" class="nz oa iu mk b ml oi mo oj mr ok mv ol mz om nd oe of og oh bi translated">比较</li><li id="1581" class="nz oa iu mk b ml oi mo oj mr ok mv ol mz om nd oe of og oh bi translated">分类</li><li id="8f4d" class="nz oa iu mk b ml oi mo oj mr ok mv ol mz om nd oe of og oh bi translated">估价</li></ul><p id="244c" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">一旦你看完下面的例子，你就会很好地理解什么时候可以使用记录链接工具包。</p><h1 id="3cf7" class="lq lr iu bd ls lt on lv lw lx oo lz ma kj op kk mc km oq kn me kp or kq mg mh bi translated">装置</h1><pre class="kt ku kv kw gu os ny ot ou aw ov bi"><span id="d806" class="ne lr iu ny b gz ow ox l oy oz">pip install recordlinkage</span></pre><h1 id="1a11" class="lq lr iu bd ls lt on lv lw lx oo lz ma kj op kk mc km oq kn me kp or kq mg mh bi translated">使用</h1><p id="5b2b" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">我们将使用数据集<code class="fe nv nw nx ny b"><strong class="mk je">load_febrl14</strong></code> <strong class="mk je"> </strong>，它也是记录链接库附带的数据集之一。</p><h2 id="fd25" class="ne lr iu bd ls nf ng dn lw nh ni dp ma mr nj nk mc mv nl nm me mz nn no mg ja bi translated">1.预处理</h2><p id="2121" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">顾名思义，如果需要清理文本，如删除空白、无效字符、标准化文本等，就使用这种预处理功能。您可以在下面找到使用预处理的示例代码。有关预处理实用程序的更多高级用法，请参考此处的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/899ca120b02365a571da7b14925112cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7_-6i-VhxMud9O4wBbmGg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><h2 id="dd2f" class="ne lr iu bd ls nf ng dn lw nh ni dp ma mr nj nk mc mv nl nm me mz nn no mg ja bi translated">2.索引</h2><p id="bbf8" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">代码的第一行<code class="fe nv nw nx ny b">recordlinkage.Index()</code>是一个类，它将用于根据不同的算法创建记录对。目前，集成了三种算法— <code class="fe nv nw nx ny b">full</code>、<code class="fe nv nw nx ny b">block</code>和<code class="fe nv nw nx ny b">sortedneighbourhood</code>。</p><p id="1dab" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated"><strong class="mk je">完整<br/> </strong>在下面的例子中，我们使用了<code class="fe nv nw nx ny b">full</code>索引算法进行索引。然后<code class="fe nv nw nx ny b">indexer.index()</code>方法将根据选择的算法创建所有可能的记录对。由于我们已经使用了<code class="fe nv nw nx ny b">full</code>索引，它将创建<code class="fe nv nw nx ny b">n x m</code>个可能的候选项，可以在接下来的步骤中使用。</p><pre class="kt ku kv kw gu os ny ot ou aw ov bi"><span id="77b8" class="ne lr iu ny b gz ow ox l oy oz">indexer = recordlinkage.Index()<br/><strong class="ny je">indexer.full()</strong><br/>candidates = indexer.index(dfA, dfB)<br/>print("candidate:", len(candidates))<br/><em class="np">&gt;&gt; candidate: 25000000</em></span></pre><p id="9818" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated"><strong class="mk je">分块<br/> </strong>在这种方法中，我们选择一列或多列作为比较的索引。这种方法叫做阻塞。因为我们在一个或多个列上达成一致，所以可能的比较次数会少得多，从而减少了计算时间。在下面的例子中，我们使用<code class="fe nv nw nx ny b">given_name</code>列作为阻塞变量。如您所见，用于比较的可能候选链接的数量显著减少。</p><pre class="kt ku kv kw gu os ny ot ou aw ov bi"><span id="2e3c" class="ne lr iu ny b gz ow ox l oy oz">indexer = recordlinkage.Index()<br/><strong class="ny je">indexer.block('given_name')</strong><br/>candidate_links = indexer.index(dfA, dfB)<br/>print("candidate_links:", len(candidate_links))<br/>&gt;&gt;&gt; candidate_links: 77249</span></pre><h2 id="0127" class="ne lr iu bd ls nf ng dn lw nh ni dp ma mr nj nk mc mv nl nm me mz nn no mg ja bi translated">3.比较</h2><p id="d5ff" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">一旦我们使用了索引，下一步就是定义如何比较两个文件中的列。Recordlinkage <code class="fe nv nw nx ny b">compare()</code>方法提供了如何比较<code class="fe nv nw nx ny b">numeric</code>、<code class="fe nv nw nx ny b">string</code>、<code class="fe nv nw nx ny b">date</code>、&amp;、<code class="fe nv nw nx ny b">geo</code>字段类型的高级用法。例如，您可能希望将两个文件中的“given_name”列作为完全匹配进行比较，将“address”列作为至少85%匹配，等等。最后，<code class="fe nv nw nx ny b">compute()</code>方法将计算相似性，结果存储在特征中。</p><pre class="kt ku kv kw gu os ny ot ou aw ov bi"><span id="f74c" class="ne lr iu ny b gz ow ox l oy oz">compare_cl = recordlinkage.Compare()</span><span id="3aac" class="ne lr iu ny b gz pb ox l oy oz">compare_cl.exact('given_name', 'given_name', label='given_name')</span><span id="62df" class="ne lr iu ny b gz pb ox l oy oz">compare_cl.string('surname', 'surname', method='jarowinkler', threshold=0.85, label='surname')</span><span id="ae10" class="ne lr iu ny b gz pb ox l oy oz">compare_cl.exact('date_of_birth', 'date_of_birth', label='date_of_birth')</span><span id="ed8c" class="ne lr iu ny b gz pb ox l oy oz">compare_cl.exact('suburb', 'suburb', label='suburb')</span><span id="d0de" class="ne lr iu ny b gz pb ox l oy oz">compare_cl.exact('state', 'state', label='state')</span><span id="6230" class="ne lr iu ny b gz pb ox l oy oz">compare_cl.string('address_1', 'address_1', threshold=0.85, label='address_1')</span><span id="4411" class="ne lr iu ny b gz pb ox l oy oz">features = compare_cl.compute(candidate_links, dfA, dfB)</span></pre><ul class=""><li id="c835" class="nz oa iu mk b ml nq mo nr mr ob mv oc mz od nd oe of og oh bi translated"><code class="fe nv nw nx ny b"><strong class="mk je">Exact</strong></code> <strong class="mk je"> </strong>精确比较记录对。如果完全匹配，则相似度为1，否则为0。</li><li id="6ea1" class="nz oa iu mk b ml oi mo oj mr ok mv ol mz om nd oe of og oh bi translated"><code class="fe nv nw nx ny b"><strong class="mk je">string</strong></code>计算字符串之间的相似度。它使用列表中的不同算法:<code class="fe nv nw nx ny b">jaro</code>、<code class="fe nv nw nx ny b">jarowinkler</code>、<code class="fe nv nw nx ny b">levenshtein</code>、<code class="fe nv nw nx ny b">damerau_levenshtein</code>、<code class="fe nv nw nx ny b">qgram</code>或<code class="fe nv nw nx ny b">cosine</code>。默认为<code class="fe nv nw nx ny b">levenshtein</code>。</li><li id="6c2e" class="nz oa iu mk b ml oi mo oj mr ok mv ol mz om nd oe of og oh bi translated"><code class="fe nv nw nx ny b"><strong class="mk je">numeric</strong></code>用于计算数值之间的相似度。可以从列表中选择不同的算法:<code class="fe nv nw nx ny b">step</code>、<code class="fe nv nw nx ny b">linear</code>、<code class="fe nv nw nx ny b">exp</code>、<code class="fe nv nw nx ny b">gauss</code>或<code class="fe nv nw nx ny b">squared</code>。默认为<code class="fe nv nw nx ny b">linear</code>。</li></ul><p id="5de8" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">接下来，我们需要找出哪些记录属于同一个实体(匹配过程)。下面是比较后的输出。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pc"><img src="../Images/d006aacad69636e2cc077ecb513a98b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ha-tsK0bLNJD4hZT7thDCg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="ec2f" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">通过简单的逻辑，我们可以筛选出如下相似和不相似的记录。有6列/特征，因此过滤匹配记录的一个选项是每行取总和，并根据总和&gt; 3过滤掉(这意味着至少有4列匹配)。同样，sum ≤3会是非相似记录。</p><p id="1dd2" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">下面的代码告诉dfA和dfB之间有1566条记录，其中所有6列都匹配/相似，1332条相似记录，等等。总共有2898条记录，其中至少有4列匹配。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pd"><img src="../Images/2f739007e568f761182c868f74317a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tSNtJLn4gyJ-c7mOWDHxg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="0dea" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">该数据帧显示了dfA中的哪个记录与dfB中的记录相匹配。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pe"><img src="../Images/d88dcaf724958ce8da9f7c3a19f45872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zurH230_AYqUXYOfEPJ7uQ.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="51ff" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">下面的屏幕截图显示了上图中第一个匹配记录的dfA和dfB的单个记录。正如您在这个匹配记录中看到的，所有六列都是匹配的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pf"><img src="../Images/bb54e8b47ff45fb231ced27c610f0400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Rl0pdB4EyIdkp8Xfb-zMA.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="886b" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">一旦我们有了相似和不相似的记录，我们就可以实现业务逻辑来处理这些记录以生成报告等。</p><h1 id="ac02" class="lq lr iu bd ls lt on lv lw lx oo lz ma kj op kk mc km oq kn me kp or kq mg mh bi translated">完整代码</h1><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pg ph l"/></div></figure><h1 id="50d7" class="lq lr iu bd ls lt on lv lw lx oo lz ma kj op kk mc km oq kn me kp or kq mg mh bi translated">结论</h1><p id="407d" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated"><code class="fe nv nw nx ny b">Recordlinkage</code>是我发现的最好的用于记录链接和重复数据删除的开源库。在本文中，我们研究了记录链接的例子。如果您希望对单个文件进行重复数据删除，请浏览<a class="ae li" href="https://recordlinkage.readthedocs.io/en/latest/notebooks/data_deduplication.html#Data-deduplication" rel="noopener ugc nofollow" target="_blank">此</a>链接，并注意它遵循与记录链接几乎相同的流程。</p><p id="7244" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated"><em class="np">阅读更多关于Python和数据科学的此类有趣文章，</em> <a class="ae li" href="https://pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="mk je"> <em class="np">订阅</em> </strong> </a> <em class="np">到我的博客</em><a class="ae li" href="http://www.pythonsimplified.com" rel="noopener ugc nofollow" target="_blank"><strong class="mk je"><em class="np">www.pythonsimplified.com</em></strong></a><strong class="mk je"><em class="np">。</em> </strong>你也可以通过<a class="ae li" href="https://www.linkedin.com/in/chetanambi/" rel="noopener ugc nofollow" target="_blank"> <strong class="mk je"> LinkedIn </strong> </a>联系我。</p></div><div class="ab cl lj lk hy ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="in io ip iq ir"><h1 id="bf5b" class="lq lr iu bd ls lt lu lv lw lx ly lz ma kj mb kk mc km md kn me kp mf kq mg mh bi translated">参考</h1><p id="946a" class="pw-post-body-paragraph mi mj iu mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd in bi translated">[1].<a class="ae li" href="https://recordlinkage.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://recordlinkage.readthedocs.io/en/latest/</a></p><p id="d19a" class="pw-post-body-paragraph mi mj iu mk b ml nq ke mn mo nr kh mq mr ns mt mu mv nt mx my mz nu nb nc nd in bi translated">[2].<a class="ae li" href="https://pbpython.com/record-linking.html" rel="noopener ugc nofollow" target="_blank">https://pbpython.com/record-linking.html</a></p></div></div>    
</body>
</html>