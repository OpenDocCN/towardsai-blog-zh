<html>
<head>
<title>AI, Predicting Wine Prices with Regression, 99% r-squared</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能，回归预测葡萄酒价格，99% r平方</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/ai-predicting-wine-prices-with-regression-99-r-squared-259ae9af298a?source=collection_archive---------2-----------------------#2020-06-17">https://pub.towardsai.net/ai-predicting-wine-prices-with-regression-99-r-squared-259ae9af298a?source=collection_archive---------2-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fa49" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="d18b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用机器学习估计葡萄酒价格。<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20200613_Wine_Price_Estimator" rel="noopener ugc nofollow" target="_blank">Github上有完整的代码。</a></h2></div><p id="33f9" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在我的上一篇文章中，我已经对我的第一个网站进行了网络抓取，获得了一个包含相关信息的酒瓶数据集。在这篇文章中，我将尝试创建一个可以估计任何一瓶葡萄酒价格的人工智能(使用机器学习模型)。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/612059d19ba1c54f8a77ac5f34bfcaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-7NbCr7HY5Wah_o0"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@tomonine?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托马斯·谢弗</a>在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="7b68" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">步伐</h1><p id="857a" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">在本文中，我将遵循以下步骤:</p><ol class=""><li id="ef2c" class="nb nc it ku b kv kw ky kz lb nd lf ne lj nf ln ng nh ni nj bi translated">编辑Excel文件</li><li id="df86" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">导入模块</li><li id="3343" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">导入数据集</li><li id="5e15" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">预处理</li><li id="886d" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">提取标签</li><li id="024b" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">剧烈的</li><li id="5642" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">支持向量回归机</li><li id="9933" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">比较结果</li></ol><h2 id="e5bb" class="np mf it bd mg nq nr dn mk ns nt dp mo lb nu nv mq lf nw nx ms lj ny nz mu iz bi translated">一个小小的错误…</h2><p id="2e14" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">不幸的是，我在下载数据集时犯了一个小小的错误。通过下载列表，我在提取它们的内容之前将它们转换成字符串。现在，我将享受解决它的乐趣。我创建了一系列函数来预处理第一部分数据。</p><p id="502b" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">查看数据集，我立即注意到我(再次为错误道歉)将列表直接编码为字符串，而没有先取出它们。作为预处理步骤的一部分，我需要访问每个元素，去掉括号，提取内容。在价格等连续数据的情况下，我需要将其转换为浮点数。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oa"><img src="../Images/d4775c515e7c4f085506a8fb54a0bc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCCuNmO0m22p1WYxyUu_9g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">原始数据集的样本</figcaption></figure><h1 id="570d" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">1.编辑Excel文件</h1><p id="f27f" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">在开始编码之前，我不得不处理数据集中的一列，这实在让我抓狂。我决定使用Excel函数来快速解决问题。在存储库中，编辑后的数据集被命名为<strong class="ku jd"> wines_。csv </strong>。这是我将在代码中导入的数据集。我分享这个过程是为了更详细地说明我为解决这个问题所采取的步骤。</p><p id="8910" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated"><strong class="ku jd"> Excel函数:</strong> =IF(J6= " "，K6，J6)</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ob"><img src="../Images/30e7c3890c69c2d754f250a2d614cd21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHALm0ZZ01DFcSjfaoJxDQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">应用于最后一行的函数</figcaption></figure><p id="b7c0" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我将把这个函数应用到最后一列的每一行。</p><p id="3b6e" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这就是代码的含义:如果缺少原始价格(蓝色列)，则使用右边一个单元格的价格，否则使用原始价格。我这样做是为了避免使用有偏见的折扣价。</p><h1 id="1a15" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">2.导入模块</h1><p id="f9be" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">为了简化分类数据的编码，我将使用Github上的一个工具，<a class="ae kr" href="https://github.com/arditoibryan/General/blob/master/tf_dataset_extractor_v1.2.py" rel="noopener ugc nofollow" target="_blank">TF _ dataset _ extractor _ v 1.2 . py</a>。这将允许我对多个列执行one_hot编码，而无需手动分离和重新附加它们。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="bdc0" class="np mf it od b gy oh oi l oj ok">import sys<br/>sys.path.append('/content/drive/My Drive/Colab Notebooks/TensorFlow 2.0/modules')<br/>import pandas as pd<br/>import tf_dataset_extractor as e<br/>#import grapher_v1_1 as g<br/>#import LSTM_creator_v1_0 as l<br/>v = e.v<br/>g = e.g<br/>l = e.l</span></pre><h1 id="4735" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">3.导入数据集</h1><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="9efc" class="np mf it od b gy oh oi l oj ok">import pandas as pd<br/>X = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Projects/20200612_Wine_Price_Estimator/wines_.csv')</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ol"><img src="../Images/2e2e6a696aa73016709fb70da9dbb25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATSkCgB5MSi7GUweEUFnNw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">葡萄酒_。战斗支援车</figcaption></figure><h1 id="79df" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">4.预处理</h1><p id="b7b1" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我可以开始预处理数据了。我将首先删除包含旧价格的列，因为我已经选择了要在新列中分析的列(“未命名:11”)。我还将删除不同葡萄的百分比列；它有随机缺失值，可能会破坏结果。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="3686" class="np mf it od b gy oh oi l oj ok">X = X.drop(['Unnamed: 0', '8', '9', '5'], axis=1)</span></pre><p id="2d34" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">为了清理我的数据集，我将使用以下函数。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="1fc6" class="np mf it od b gy oh oi l oj ok">def clean_string(string1):<br/>  char1 = "["<br/>  char2 = "]"<br/>  mystr = string1<br/>  return mystr[mystr.find(char1)+1 : mystr.find(char2)]</span><span id="dc4a" class="np mf it od b gy om oi l oj ok">def clean_commas(string1):<br/>  string1 = string1[1:]<br/>  string1 = string1[:-1]<br/>  return string1</span><span id="703f" class="np mf it od b gy om oi l oj ok">def clean(string1):<br/>  string1 = clean_string(string1)<br/>  string1 = clean_commas(string1)<br/>  return string1</span><span id="93b4" class="np mf it od b gy om oi l oj ok">def clean_price(string1):<br/>  string1 = clean_string(string1)<br/>  string1 = clean_commas(string1)<br/>  string1 = string1.split(' ')[1]<br/>  string1 = string1.replace(',', '.', 1)<br/>  return string1</span><span id="faa5" class="np mf it od b gy om oi l oj ok">def comma_dot(string1):<br/>  string1 = string1.replace(',', '.', 1)<br/>  return string1</span><span id="46cc" class="np mf it od b gy om oi l oj ok">def delete_n(string1):<br/>  string1 = string1.replace('\n', '')<br/>  return string1</span></pre><p id="f455" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我现在可以处理数据集中的字符串了。我将使用一个应用于每一列的lambda函数来编辑它的所有内容，根据我想要进行的更改，使用我在上面声明的函数。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="77f2" class="np mf it od b gy oh oi l oj ok">X['0'] = X['0'].apply(lambda x : clean(x))<br/>X['1'] = X['1'].apply(lambda x : clean(x))<br/>X['2'] = X['2'].apply(lambda x : clean(x))<br/>X['3'] = X['3'].apply(lambda x : clean(x))<br/>X['3'] = X['3'].apply(lambda x : delete_n(x))<br/>X['4'] = X['4'].apply(lambda x : clean(x))<br/>X['5'] = X['5'].apply(lambda x : clean(x))<br/>X['6'] = X['6'].apply(lambda x : clean(x))<br/>X['7'] = X['7'].apply(lambda x : clean(x))<br/>X['Unnamed: 11'] = X['Unnamed: 11'].apply(lambda x : clean_price(x))<br/>X['Unnamed: 11'] = X['Unnamed: 11'].apply(lambda x : float(x))</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi on"><img src="../Images/453e045966fbe693a8e705c9822d982d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kyP_f43Wpxp2mCE_jPVog.png"/></div></div></figure><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="8629" class="np mf it od b gy oh oi l oj ok">X.columns = ['Producer', 'Kind', 'Year', 'Location', 'Region', 'Alchohol', 'Volume', 'Price']</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oo"><img src="../Images/5b2dee0b5ac20eab31888f4f42a87f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_Smb1yIgzAnBGej9cUUdg.png"/></div></div></figure><h2 id="8a88" class="np mf it bd mg nq nr dn mk ns nt dp mo lb nu nv mq lf nw nx ms lj ny nz mu iz bi translated">编辑剩余的列</h2><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="4639" class="np mf it od b gy oh oi l oj ok">#drop N/A column in Year<br/>X = X[~X['Year'].isin(['N/A'])]</span><span id="42df" class="np mf it od b gy om oi l oj ok">#drop "\\n', '\\n" column in Location<br/>X = X[~X['Location'].isin(["\\n', '\\n"])]</span><span id="dfba" class="np mf it od b gy om oi l oj ok">X['Alchohol'] = X['Alchohol'].apply(lambda x : x[0:4])<br/>X['Alchohol'] = X['Alchohol'].apply(lambda x : float(comma_dot(x)))</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi op"><img src="../Images/079e0785cbe703f045fdd55ed282a258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3PprYIHnWoa2lU17P6Ibw.png"/></div></div></figure><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="dd41" class="np mf it od b gy oh oi l oj ok">e.X = X<br/>v.partition.one_hot(['Location', 'Producer', 'Kind', 'Year', 'Region','Volume'])</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oq"><img src="../Images/313dee753e9802e0365b9f7b34ca3c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Duw3UOuw99lf9BFY8z_s8A.png"/></div></div></figure><h1 id="2de5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">5.提取标签</h1><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="194b" class="np mf it od b gy oh oi l oj ok">y = X.pop('Price')<br/>y = pd.DataFrame(y)</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi or"><img src="../Images/1859941e2ea788ff03b8d08b157f93bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*2FBBgobMsGpli1q1C0XHcg.png"/></div></figure><h1 id="6f17" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">6.剧烈的</h1><p id="2eea" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我终于可以将数据分成训练集和测试集了。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="5565" class="np mf it od b gy oh oi l oj ok">#splitting<br/>import numpy as np<br/>from sklearn.model_selection import train_test_split</span><span id="d726" class="np mf it od b gy om oi l oj ok">X_train, X_test, y_train, y_test = train_test_split(e.X, y, test_size=0.1, random_state=42)</span></pre><h1 id="a908" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">7.支持向量回归机</h1><p id="b888" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">因为这是一个回归问题，我将使用一个非线性支持向量回归机作为模型，使用下面的调优。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="8924" class="np mf it od b gy oh oi l oj ok">#SVR, manual procedure<br/>from sklearn.svm import SVR<br/>clf = SVR(kernel='poly', C=1, gamma='auto', degree=3, epsilon=.1, coef0=1)</span></pre><h2 id="4625" class="np mf it bd mg nq nr dn mk ns nt dp mo lb nu nv mq lf nw nx ms lj ny nz mu iz bi translated">训练模型</h2><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="eaa1" class="np mf it od b gy oh oi l oj ok">clf.fit(X_train, y_train)<br/>y_pred = clf.predict(X_test)<br/>from sklearn.metrics import r2_score</span></pre><h2 id="5993" class="np mf it bd mg nq nr dn mk ns nt dp mo lb nu nv mq lf nw nx ms lj ny nz mu iz bi translated">评估绩效</h2><p id="1328" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我将使用r的平方来计算预测结果和真实结果之间的平方相关。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="73c8" class="np mf it od b gy oh oi l oj ok">#r2 score<br/>from sklearn.metrics import r2_score<br/>print(r2_score(y_test, y_pred))</span></pre><h2 id="42d3" class="np mf it bd mg nq nr dn mk ns nt dp mo lb nu nv mq lf nw nx ms lj ny nz mu iz bi translated">交叉验证</h2><p id="f432" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">因为我对结果相当惊讶，所以我想进行交叉验证，看看该模型在不同比例的数据集上的表现如何:</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="f8da" class="np mf it od b gy oh oi l oj ok">#performance evalutation<br/>v.cross_validation(clf, e.X, y, 10)</span><span id="599a" class="np mf it od b gy om oi l oj ok">Accuracy: 1.00 (+/- 0.00),<br/>array([<br/>0.99990355, <br/>0.99996721, <br/>0.99996876, <br/>0.99994828, <br/>0.99996389,         <br/>0.99998166, <br/>0.99996577, <br/>0.99994188, <br/>0.99988042, <br/>0.99996255<br/>]))</span></pre><p id="20fa" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">准确度似乎令人吃惊。</p><h1 id="92f7" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">8.比较结果</h1><p id="e887" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">因为我被这个模型不可思议的准确性震惊了，所以我必须亲眼看看。我把预测结果附上了模型从未见过的y_test。他们几乎一模一样！！！</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="8ac4" class="np mf it od b gy oh oi l oj ok">#comparing results<br/>y_test = y_test.reset_index()<br/>y_test.pop('index')</span><span id="ba57" class="np mf it od b gy om oi l oj ok">y_pred = pd.DataFrame(y_pred)<br/>total = pd.concat([y_test, y_pred], axis=1)<br/>total.columns = ['Price', 'Predicted']</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/6f56a60cdcb15fa01ef7aafdc70ce4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*GSyNBFlQnaCPwfvA9WFWYA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">原始价格和预测价格的比较</figcaption></figure><p id="1c98" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我对这种惊人准确性的解释是，价格之间的差异是最小的。给定相似的变量(例如，同一个生产商)，卖方可能会使用相同的价格。</p></div></div>    
</body>
</html>