<html>
<head>
<title>A Full Introduction on Text Summarization using Deep Learning With Sample Code (Ft. Huggingface)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习的文本摘要的完整介绍，带有示例代码(Ft。拥抱脸)</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-full-introduction-on-text-summarization-using-deep-learning-with-sample-code-ft-huggingface-d21e0336f50c?source=collection_archive---------0-----------------------#2021-11-16">https://pub.towardsai.net/a-full-introduction-on-text-summarization-using-deep-learning-with-sample-code-ft-huggingface-d21e0336f50c?source=collection_archive---------0-----------------------#2021-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b645" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a></h2><div class=""/><p id="5711" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="kx">用HuggingFace的示例代码介绍抽象文本摘要任务(seq 2 seq/编码器-解码器架构)中的推理过程。一系列中的第一个！</em></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/adb77ff7339fa34d663005a2d3f2c657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zkbMoBZ3l4EBUa7H"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">照片由<a class="ae lo" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚伦·伯顿</a>在<a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="lp lq lr"><p id="3084" class="jz ka kx kb b kc kd ke kf kg kh ki kj ls kl km kn lt kp kq kr lu kt ku kv kw im bi translated"><strong class="kb jd">更新“2021年12月14日”</strong>:我发表了系列的<a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/how-to-train-a-seq2seq-text-summarization-model-with-sample-code-ft-huggingface-pytorch-8ba97492f885">第二部分，解释了基于变压器的编码器-解码器模型的训练循环。</a></p></blockquote><h1 id="7628" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">什么是自动文本摘要？</h1><p id="2eb2" class="pw-post-body-paragraph jz ka it kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw im bi translated">这是一个获取文档中最重要的部分(如新闻、书籍、文章等)并生成包含这些信息的较短文本的过程。有两种类型的文本摘要:</p><ul class=""><li id="85b5" class="my mz it kb b kc kd kg kh kk na ko nb ks nc kw nd ne nf ng bi translated"><strong class="kb jd">提取</strong>:从源文档中选择若干句子，作为摘要。通常使用一个排名函数来评估每个句子，并挑选得分最高的。</li><li id="fc37" class="my mz it kb b kc nh kg ni kk nj ko nk ks nl kw nd ne nf ng bi translated"><strong class="kb jd"> Abstractive </strong>:在这种方法中，我们将使用生成模型来形成描述文档的新句子。(就像人类做的一样！)</li></ul><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nm"><img src="../Images/10c687e352a0180fa47fb289efe9b71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcGIwpnuSQYxr1rwckNtkw.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">图一。提取和抽象概括方法的区别。提取算法选择文档的第一句作为摘要，但是抽象模型使用文档中的单词(如名称、位置等)和它自己的单词(如克服)来形成摘要。</figcaption></figure><p id="4acf" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">⚠️:这篇文章的主要焦点是抽象概括。</p><h1 id="d3ff" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用什么架构？</h1><p id="1962" class="pw-post-body-paragraph jz ka it kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw im bi translated">文本摘要任务的主要体系结构被称为序列对序列(seq2seq ),它具有图2所示的六个主要组成部分，如下所述。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nn"><img src="../Images/89ee899775fb8ac2e7c6912a4aea3b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFztWXwTiqml7pyHApuipw.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">图二。编码器-解码器架构。</figcaption></figure><ul class=""><li id="05c2" class="my mz it kb b kc kd kg kh kk na ko nb ks nc kw nd ne nf ng bi translated"><strong class="kb jd">输入</strong>:我们要汇总的是标记化的源文档。什么是标记化？将文件中的每个字转换成代表它的数字的过程。(<a class="ae lo" href="https://nlpiation.medium.com/how-to-use-huggingfaces-transformers-pre-trained-tokenizers-e029e8d6d1fa" rel="noopener">此处阅读更多内容</a>)</li><li id="d66a" class="my mz it kb b kc nh kg ni kk nj ko nk ks nl kw nd ne nf ng bi translated"><strong class="kb jd">编码器/表示</strong>:这个模块处理源文档并创建一个固定大小的高维张量来表示它。这种表示包含关于文本的上下文信息，这些信息也可以用于不同的下游任务，如分类(在编码器上使用线性层，而不是解码器)。编码器在训练中学习语言和单词之间的关系。(阅读<a class="ae lo" href="https://medium.com/mlearning-ai/what-are-the-differences-in-pre-trained-transformer-base-models-like-bert-distilbert-xlnet-gpt-4b3ea30ef3d7" rel="noopener">此处</a>了解不同的培训目标)</li><li id="0342" class="my mz it kb b kc nh kg ni kk nj ko nk ks nl kw nd ne nf ng bi translated"><strong class="kb jd">解码器/线性层/输出</strong>:一个生成模型，使用所述表示一次一个令牌地写一个摘要。解码器的输出将是与包含每个索引成为下一个预测记号的概率的记号赋予器词汇大小相同的张量(使用线性层)。</li></ul><p id="69c7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">seq2seq架构可以使用不同的构建模块来形成编码器/解码器模型。不久前，我们主要使用LSTM/GRU设备，而现在，<a class="ae lo" href="http://jalammar.github.io/illustrated-transformer/" rel="noopener ugc nofollow" target="_blank">变压器</a>网络是显而易见的选择。</p><h1 id="f487" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">它是如何工作的？(让我们看看代码)</h1><p id="07fe" class="pw-post-body-paragraph jz ka it kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw im bi translated">我将使用Huggingface库和预先训练的BART [1]模型来展示一个模型如何生成每个令牌以形成一个摘要，而不涉及关于该模型的实现和子模块的太多细节。第一步是加载编码器、解码器和线性图层部分。让我们加载模型并将其打印出来，以找到所有子模块的名称。</p><p id="6778" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">⚠️我们通常必须使用<code class="fe no np nq nr b">eval()</code>函数将模型的模式改为评估，同时进行推断以获得更一致的结果。在处理Huggingface库时，这不是强制性的，因为默认情况下，它以提到的模式加载模型。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="de4a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">可以看到，BART模型有三个主要组件:编码器(12层)、解码器(12层)和lm_head(我们称之为线性层)。您可以通过像<code class="fe no np nq nr b">model.model.encoder</code>、<code class="fe no np nq nr b">model.model.decoder</code>和<code class="fe no np nq nr b">model.lm_head</code>那样调用它们来轻松使用架构的特定部分。但是，Huggingface有一些内置函数，可以更灵活地访问编码器和解码器，如下所示:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e214" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">最后一个准备步骤是加载一个示例文章，并使用BART tokenizer对其进行标记。这可以通过加载预先训练好的标记器并调用它来完成。(阅读<a class="ae lo" href="https://nlpiation.medium.com/how-to-use-huggingfaces-transformers-pre-trained-tokenizers-e029e8d6d1fa" rel="noopener">此处</a>了解更多详情)</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ce51" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，我们已经具备了开始生成摘要的所有要素。这个过程从使用编码器对文章进行编码开始，以创建我们的表示。这一步只做一次，因为文章不会改变！<em class="kx">(相同的表示将用于生成所有的令牌。)</em></p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2d29" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">解码器组件是负责生成摘要的单元。请记住，生成过程从传递<bos>(句子开头)标记开始，以启动该过程，然后一次传递一个标记来完成摘要。以下代码的含义是<em class="kx">“根据文章的编码表示预测出现在&lt; bos &gt;标记之后的单词”。</em></bos></p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9a62" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><code class="fe no np nq nr b">logits.argmax(1)</code>将从所有概率中挑选最可能的令牌，并返回令牌id。在我们的例子中，它将返回与BART词汇表中的标记'<strong class="kb jd"> se </strong>'相对应的<strong class="kb jd"> 1090 </strong>。🤔(稍后将详细介绍)</p><p id="edd7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们成功地生成了摘要的第一个令牌。通过将<code class="fe no np nq nr b">start_token</code>从仅仅&lt; bos &gt;改变为具有两个[ &lt; bos &gt;，se]的张量，也很容易预测第二个表征。这种方法被称为贪婪搜索，是最简单的推理方法。(我推荐在这里阅读<a class="ae lo" href="https://huggingface.co/blog/how-to-generate" rel="noopener ugc nofollow" target="_blank">以获得更多关于不同策略的信息</a></p><p id="1ea5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们使用Huggingface内置的<code class="fe no np nq nr b">generate()</code>功能来处理这个重复的任务。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="830b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">有意思！因此，该模型试图通过预测单词“<strong class="kb jd"> se </strong>”来生成名称“<strong class="kb jd"> sebastian </strong>”。一些分词器会将单词分解成更小的块，以使词汇量更小，因此，保持模型的参数计数更低。</p><p id="051b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">正如您所看到的，BART(最好的预先训练好的总结模型之一)正在正确的轨道上生成一个好的总结。它已经从文章中提取了一些关键信息。您可以通过使用像<code class="fe no np nq nr b">max_length</code>(生成更长的文本)、<code class="fe no np nq nr b">num_beam</code>(使用光束搜索而不是贪婪)和<code class="fe no np nq nr b">no_repeat_ngram_size</code>(避免重复)这样的变量来提高模型输出的质量。</p><blockquote class="lp lq lr"><p id="99a3" class="jz ka kx kb b kc kd ke kf kg kh ki kj ls kl km kn lt kp kq kr lu kt ku kv kw im bi translated">⚠️代码可以在GitHub的<a class="ae lo" href="https://github.com/NLPiation/tutorial_notebooks/blob/main/summarization/hf_BART_inference_breakdown.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>中找到。</p></blockquote><h1 id="0d51" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">最后的话，</h1><p id="d863" class="pw-post-body-paragraph jz ka it kb b kc mt ke kf kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw im bi translated">我使用示例代码演示了在文本摘要任务中序列对序列建模推理文本的方法。(如果你仔细想想，同样的事情正在两个不同的标记器的翻译任务中发生！)本文主要关注推理。下一步是了解如何在您的数据集上训练/微调更适合您的应用的摘要模型。</p><blockquote class="nu"><p id="4c38" class="nv nw it bd nx ny nz oa ob oc od kw dk translated">我每周给NLP的书呆子发一份时事通讯。如果您想了解自然语言处理的最新发展，可以考虑订阅。<br/> <a class="ae lo" href="https://nlpiation.github.io/" rel="noopener ugc nofollow" target="_blank">阅读更多，订阅</a> —加入酷孩子俱乐部，立即报名！</p></blockquote><p id="8803" class="pw-post-body-paragraph jz ka it kb b kc oe ke kf kg of ki kj kk og km kn ko oh kq kr ks oi ku kv kw im bi translated"><strong class="kb jd">参考文献</strong></p><p id="d130" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">[1] Lewis，Mike，等人，“Bart:自然语言生成、翻译和理解的去噪序列间预训练”<em class="kx"> arXiv预印本arXiv:1910.13461 </em> (2019)。</p></div></div>    
</body>
</html>