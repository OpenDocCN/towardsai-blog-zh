<html>
<head>
<title>House Price Predictions Using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras进行房价预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/house-price-predictions-using-keras-3c6accee8a09?source=collection_archive---------1-----------------------#2021-02-24">https://pub.towardsai.net/house-price-predictions-using-keras-3c6accee8a09?source=collection_archive---------1-----------------------#2021-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3831" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="465e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用Keras和超参数调整实现神经网络以预测房价。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/00d7fa459024132071b862e915f92709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7a9pPbWHHfVf7qUxbIjFVg.jpeg"/></div></div></figure><p id="4c10" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是一个关于使用Keras建模的入门教程，包括超参数调整和回调。</p><h1 id="7b82" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">问题陈述</h1><blockquote class="mo"><p id="e78c" class="mp mq iq bd mr ms mt mu mv mw mx lv dk translated">创建一个Keras回归模型，该模型可以准确地分析给定房屋的特征，并相应地预测价格。</p></blockquote><h1 id="83ea" class="lw lx iq bd ly lz ma mb mc md me mf mg kf my kg mi ki mz kj mk kl na km mm mn bi translated">涉及的步骤</h1><ol class=""><li id="9306" class="nb nc iq lc b ld nd lg ne lj nf ln ng lr nh lv ni nj nk nl bi translated">缺失值的分析和插补</li><li id="3a2f" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">分类特征的一键编码</li><li id="9c99" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">探索性数据分析(EDA)和异常值检测。</li><li id="66fb" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">keras-回归建模以及超参数调整。</li><li id="dd1f" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">训练模型以及提前停止回调。</li><li id="3233" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">预测和评估</li></ol><h2 id="9a98" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated"><a class="ae oc" href="https://www.kaggle.com/pratiyushmishra/house-predictions-keras/" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> Kaggle笔记本链接</strong> </a></h2><h1 id="aad2" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">导入库</h1><p id="5d8c" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">我们将使用numpy和pandas处理我们的数据集，使用matplotlib和seaborn进行数据可视化，使用Keras实现我们的神经网络。此外，我们将使用Sklearn进行异常值检测和扩展我们的数据集。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="88c8" class="nr lx iq oh b gy ol om l on oo">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set()<br/>from sklearn.preprocessing import StandardScaler <em class="op"># Standardization</em><br/>from sklearn.ensemble import IsolationForest <em class="op"># Outlier Detection</em><br/>from keras.models import Sequential <em class="op"># Sequential Neural Network</em><br/>from keras.layers import Dense<br/>from keras.callbacks import EarlyStopping <em class="op"># Early Stopping Callback</em><br/>from keras.optimizers import Adam <em class="op"># Optimizer</em><br/>from kerastuner.tuners import RandomSearch <em class="op"># HyperParameter Tuning</em><br/>import warnings<br/>warnings.filterwarnings('ignore') # To ignore warnings.</span></pre><h1 id="1449" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">加载数据集</h1><p id="6a86" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">这里我们使用了来自<a class="ae oc" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" rel="noopener ugc nofollow" target="_blank">房价——高级回归技术</a>的数据集</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="e4fe" class="nr lx iq oh b gy ol om l on oo">train = pd.read_csv('../input/house-prices-advanced-regression-techniques/train.csv')<br/>test = pd.read_csv('../input/house-prices-advanced-regression-techniques/test.csv')<br/>y = train['SalePrice'].values<br/>data = pd.concat([train,test],axis=0,sort=False)<br/>data.drop(['SalePrice'],axis=1,inplace=True)<br/>data.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/7214f456893f42a650285af211aa5602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x58jWL6BCfrHyZmOBmFugg.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">数据集的前10列</figcaption></figure><h1 id="1290" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">缺失值的分析和插补</h1><p id="45d7" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">我们首先会看到所有缺少值的特征。这将包括来自训练和测试数据的数据。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="982b" class="nr lx iq oh b gy ol om l on oo">missing_values = data.isnull().sum()<br/>missing_values = missing_values[missing_values &gt; 0].sort_values(ascending = False)<br/>NAN_col = list(missing_values.to_dict().keys())<br/>missing_values_data = pd.DataFrame(missing_values)<br/>missing_values_data.reset_index(level=0, inplace=True)<br/>missing_values_data.columns = ['Feature','Number of Missing Values']<br/>missing_values_data['Percentage of Missing Values'] = (100.0*missing_values_data['Number of Missing Values'])/len(data)<br/>missing_values_data</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/4d6c628e69fdfdf08b96fda878a95ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*AZgHsT2MaXmLuF0Y79LOuQ.png"/></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">缺失功能的前20列</figcaption></figure><p id="a8f1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">总共有33个特征具有缺失值。虽然在一些以缺失值百分比表示的顶级功能中，如PoolQC，缺失值表示房屋根本没有该功能(在这种情况下，房屋没有游泳池)，这一点从Pool Area功能中可以明显看出，PoolQC功能的所有缺失值对应的值为0。我们用以下方式填充缺失值:</p><ul class=""><li id="51f7" class="nb nc iq lc b ld le lg lh lj ow ln ox lr oy lv oz nj nk nl bi translated"><strong class="lc ja">基底:</strong>这包括BsmtFinSF1、BsmtFinSF2、TotalBsmtSF和BsmtUnfSF <strong class="lc ja">。</strong>我们将用0填充所有缺失的值，因为此处的NAN值只是表示房子没有地下室，因此地下室的面积将为0。</li><li id="c053" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv oz nj nk nl bi translated"><strong class="lc ja">电气:</strong>只有一行缺少该特性的值。因此，在人工检查后，我们会将其值设为“FuseA”</li><li id="0041" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv oz nj nk nl bi translated"><strong class="lc ja"> KitchenQual </strong>:同样，由于只有一行缺少该值，因此我们将该值设为“TA”，这是数据集中该特性最常见的值。</li><li id="f7de" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv oz nj nk nl bi translated"><strong class="lc ja"> LotFrontage </strong>:这里我们将首先通过取具有相同值1stFlrSF的所有组的LotFrontage值的平均值来填充所有缺失值。这是因为LotFrontage与1stFlrSF的相关性很高。但是，可能会有这样的情况，即对应于特定1stFlrSF值的所有LotFrontage值都可能会丢失。为了解决这种情况，我们将使用pandas的插值函数来线性填充缺失值。</li><li id="3345" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv oz nj nk nl bi translated"><strong class="lc ja"> MasVnrArea </strong>:我们将再次应用与前面相同的类比。</li><li id="d983" class="nb nc iq lc b ld nm lg nn lj no ln np lr nq lv oz nj nk nl bi translated"><strong class="lc ja">其他</strong>:对于其他特征，我们将遵循最通用的方法，也就是说，我们将通过该特征的所有值的平均值来填充数字，对于分类，我们将通过NA来填充。</li></ul><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="8cb2" class="nr lx iq oh b gy ol om l on oo">data['BsmtFinSF1'].fillna(0, inplace=True)<br/>data['BsmtFinSF2'].fillna(0, inplace=True)<br/>data['TotalBsmtSF'].fillna(0, inplace=True)<br/>data['BsmtUnfSF'].fillna(0, inplace=True)<br/>data['Electrical'].fillna('FuseA',inplace = True)<br/>data['KitchenQual'].fillna('TA',inplace=True)<br/>data['LotFrontage'].fillna(data.groupby('1stFlrSF')['LotFrontage'].transform('mean'),inplace=True)<br/>data['LotFrontage'].interpolate(method='linear',inplace=True)<br/>data['MasVnrArea'].fillna(data.groupby('MasVnrType')['MasVnrArea'].transform('mean'),inplace=True)<br/>data['MasVnrArea'].interpolate(method='linear',inplace=True)</span><span id="4e2b" class="nr lx iq oh b gy pa om l on oo">for col <strong class="oh ja">in</strong> NAN_col:<br/>    data_type = data[col].dtype<br/>    if data_type == 'object':<br/>        data[col].fillna('NA',inplace=True)<br/>    else:<br/>        data[col].fillna(data[col].mean(),inplace=True)</span></pre><h1 id="391e" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">添加新功能</h1><p id="02c0" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">在彻底理解数据之后，我们还通过组合给定的特性创建了一些新的特性。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="8643" class="nr lx iq oh b gy ol om l on oo">data['Total_Square_Feet'] = (data['BsmtFinSF1'] + data['BsmtFinSF2'] + data['1stFlrSF'] + data['2ndFlrSF'] + data['TotalBsmtSF'])<br/><br/>data['Total_Bath'] = (data['FullBath'] + (0.5 * data['HalfBath']) + data['BsmtFullBath'] + (0.5 * data['BsmtHalfBath']))<br/><br/>data['Total_Porch_Area'] = (data['OpenPorchSF'] + data['3SsnPorch'] + data['EnclosedPorch'] + data['ScreenPorch'] + data['WoodDeckSF'])<br/><br/>data['SqFtPerRoom'] = data['GrLivArea'] / (data['TotRmsAbvGrd'] + data['FullBath'] + data['HalfBath'] + data['KitchenAbvGr'])</span></pre><h1 id="3117" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">分类特征的一种热编码</h1><p id="77a5" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">我们将首先看到数字和分类之间的特征分布。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="1eae" class="nr lx iq oh b gy ol om l on oo">column_data_type = []<br/>for col <strong class="oh ja">in</strong> data.columns:<br/>    data_type = data[col].dtype<br/>    if data[col].dtype <strong class="oh ja">in</strong> ['int64','float64']:<br/>        column_data_type.append('numeric')<br/>    else:<br/>        column_data_type.append('categorical')<br/>plt.figure(figsize=(15,5))<br/>sns.countplot(x=column_data_type)<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/a74c8dedb9bf61134480d9efe305327d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8reefSH7K_FAvQbhAB2r_A.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">分类和数字特征条形图</figcaption></figure><p id="1fcd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里我们看到分类特征的数量实际上超过了数字特征的数量，这表明这些特征是多么重要。这里我们选择了一种热编码来将这些分类特征转换成数字。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="09c4" class="nr lx iq oh b gy ol om l on oo">data = pd.get_dummies(data)</span></pre><p id="11bf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">经过这次操作，我们原来的80个功能扩展到了314个功能。基本上，分类要素的每个标签都会变成一个具有二进制值的新要素(1表示存在，0表示不存在)。现在，我们将把合并的数据分成训练和测试数据，对训练数据进行一些探索性分析。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="752f" class="nr lx iq oh b gy ol om l on oo">train = data[:1460].copy()<br/>test = data[1460:].copy()<br/>train['SalePrice'] = y</span></pre><h1 id="32a8" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">探索性数据分析和异常值检测</h1><p id="a7ea" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">我们将首先从我们的训练数据集中提取与销售价格具有最高相关性的顶级特征。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="8354" class="nr lx iq oh b gy ol om l on oo">top_features = train.corr()[['SalePrice']].sort_values(by=['SalePrice'],ascending=False).head(30)<br/>plt.figure(figsize=(5,10))<br/>sns.heatmap(top_features,cmap='rainbow',annot=True,annot_kws={"size": 16},vmin=-1)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/6c5ca6a7974d1750809283b74278217e.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*9Zh6OG9zcOm6xB_MK-__CQ.png"/></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">与数据集正相关的前30个特征</figcaption></figure><p id="af6d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，我们按照降序提取了与销售价格具有最高正相关性的前30个特征。现在，我们将根据SalePrice绘制其中一些特征，以找出数据集中的异常值。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="0d2e" class="nr lx iq oh b gy ol om l on oo">def plot_data(col, discrete=False):<br/>    if discrete:<br/>        fig, ax = plt.subplots(1,2,figsize=(14,6))<br/>        sns.stripplot(x=col, y='SalePrice', data=train, ax=ax[0])<br/>        sns.countplot(train[col], ax=ax[1])<br/>        fig.suptitle(str(col) + ' Analysis')<br/>    else:<br/>        fig, ax = plt.subplots(1,2,figsize=(12,6))<br/>        sns.scatterplot(x=col, y='SalePrice', data=train, ax=ax[0])<br/>        sns.distplot(train[col], kde=False, ax=ax[1])<br/>        fig.suptitle(str(col) + ' Analysis')</span></pre><p id="77ef" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是我们用来绘制各种特征的图形的绘图函数。</p><h2 id="053f" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">总体平等</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="d9ee" class="nr lx iq oh b gy ol om l on oo">plot_data('OverallQual',True)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/3331f14acb27f72d1f847e64090d7b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAdspzUe_75SjCliGFdCAg.png"/></div></div></figure><h2 id="f8dc" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">我们看到有两个异常值，总体质量为10，销售价格低于200000。</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="97fa" class="nr lx iq oh b gy ol om l on oo">train = train.drop(train[(train['OverallQual'] == 10) &amp; (train['SalePrice'] &lt; 200000)].index)</span></pre><p id="8d91" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，我们从数据集中剔除了这些异常值。现在我们继续分析另一个特征。</p><h2 id="8c7a" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">总平方英尺</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="977e" class="nr lx iq oh b gy ol om l on oo">plot_data('Total_Square_Feet')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/54969a6f556ef4403f046d9fe8440295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0Y15-fZ_qNgCm_xS-lP1g.png"/></div></div></figure><p id="298d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这似乎或多或少是合适的分布，没有任何异常值。</p><h2 id="5ce7" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">格里瓦雷亚</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="d04d" class="nr lx iq oh b gy ol om l on oo">plot_data('GrLivArea')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/492c75348c5c8fe8b7d2f4b19aa50a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQrXpSzgcih8e3SdxnVN1g.png"/></div></div></figure><p id="0d14" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">同样，没有离群值可以消除。</p><h2 id="2847" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">总浴室</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="ed11" class="nr lx iq oh b gy ol om l on oo">plot_data('Total_Bath')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi gj"><img src="../Images/2c1ff2785e5f017ebfc0429f6ee3730d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_Prr4ZvEXjhX1gNPIi3hA.png"/></div></div></figure><h2 id="fdef" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">这里我们看到两个离群值，它们的Total_Bath大于4，但销售价格小于200000。</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="d250" class="nr lx iq oh b gy ol om l on oo">train = train.drop(train[(train['Total_Bath'] &gt; 4) &amp; (train['SalePrice'] &lt; 200000)].index)</span></pre><p id="f6d5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此我们去除了这些异常值。</p><h2 id="c016" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">总计BsmtSF</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="beea" class="nr lx iq oh b gy ol om l on oo">plot_data('TotalBsmtSF')</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi gj"><img src="../Images/2c1ff2785e5f017ebfc0429f6ee3730d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_Prr4ZvEXjhX1gNPIi3hA.png"/></div></div></figure><h2 id="a942" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">在这里，我们也看到1个明显的异常值，其总BsmtSF超过3000，但销售价格低于300000。</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="48c3" class="nr lx iq oh b gy ol om l on oo">train = train.drop(train[(train['TotalBsmtSF'] &gt; 3000) &amp; (train['SalePrice'] &lt; 400000)].index)</span><span id="b374" class="nr lx iq oh b gy pa om l on oo">train.reset_index() # To reset the index</span></pre><p id="dd54" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">既然我们已经处理了数据集的主要特征，我们将使用隔离森林算法进一步移除异常值。我们使用这种算法是因为很难检查所有的特征并手动消除异常值，但是对于与销售价格高度相关的特征，手动进行这种操作是很重要的。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="7673" class="nr lx iq oh b gy ol om l on oo">clf = IsolationForest(max_samples = 100, random_state = 42)<br/>clf.fit(train)<br/>y_noano = clf.predict(train)<br/>y_noano = pd.DataFrame(y_noano, columns = ['Top'])<br/>y_noano[y_noano['Top'] == 1].index.values<br/><br/>train = train.iloc[y_noano[y_noano['Top'] == 1].index.values]<br/>train.reset_index(drop = True, inplace = True)<br/>print("Number of Outliers:", y_noano[y_noano['Top'] == -1].shape[0])<br/>print("Number of rows without outliers:", train.shape[0])</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/fe309f54e20d6f25446dd3e68d061030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-e5BAbmx5i0QLYgi64o5A.png"/></div></div></figure><p id="7d32" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们将最终使用来自sklearn的标准标量来缩放我们的数据。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="e212" class="nr lx iq oh b gy ol om l on oo">X = train.copy()<br/>X.drop(['SalePrice'],axis=1,inplace=True) # Dropped the y feature<br/>y = train['SalePrice'].values</span></pre><p id="ba69" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这处理了我们的数据集预处理，我们最终为下一步做好了准备，那就是对我们的数据建模。</p><h1 id="b485" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">系统模型化</h1><h2 id="a067" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">我们将使用来自Keras的随机搜索算法进行模型的超参数调整。</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="01cc" class="nr lx iq oh b gy ol om l on oo">def build_model(hp):<br/>    model = Sequential()<br/>    for i <strong class="oh ja">in</strong> range(hp.Int('layers', 2, 10)):<br/>        model.add(Dense(units=hp.Int('units_' + str(i),<br/>                                            min_value=32,<br/>                                            max_value=512,<br/>                                            step=32),<br/>                               activation='relu'))<br/>    model.add(Dense(1))<br/>    model.compile(<br/>        optimizer=Adam(<br/>            hp.Choice('learning_rate', [1e-2, 1e-3, 1e-4])),<br/>        loss='mse',<br/>        metrics=['mse'])<br/>    return model</span><span id="f529" class="nr lx iq oh b gy pa om l on oo">tuner = RandomSearch(<br/>    build_model,<br/>    objective='val_mse',<br/>    max_trials=10,<br/>    executions_per_trial=3,<br/>    directory='model_dir',<br/>    project_name='House_Price_Prediction')<br/><em class="op"> <br/>tuner.search(X[1100:],y[1100:],batch_size=128,epochs=200,validation_data=validation_data=(X[:1100],y[:1100]))</em></span><span id="7a95" class="nr lx iq oh b gy pa om l on oo"><em class="op">model = tuner.get_best_models(1)[0]</em></span></pre><p id="f042" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">上面的代码用于调整参数，以便我们可以为数据集生成一个有效的模型。运行上述代码后，我得到了能够为我的数据集提供最有效结果的超参数。我写了一个单独的函数来展示这个模型，因为运行上面的代码会花费很多时间。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="5121" class="nr lx iq oh b gy ol om l on oo">def create_model():<br/>    <em class="op"># create model</em><br/>    model = Sequential()<br/>    model.add(Dense(320, input_dim=X.shape[1], activation='relu'))<br/>    model.add(Dense(384, activation='relu'))<br/>    model.add(Dense(352, activation='relu'))<br/>    model.add(Dense(448, activation='relu'))<br/>    model.add(Dense(160, activation='relu'))<br/>    model.add(Dense(160, activation='relu'))<br/>    model.add(Dense(32, activation='relu'))<br/>    model.add(Dense(1))<br/>    <em class="op"># Compile model</em><br/>    model.compile(optimizer=Adam(learning_rate=0.0001), loss = 'mse')<br/>    return model<br/>model = create_model()<br/>model.summary()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/57a70176fb89155f6566efe8c41b2488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*jaL6AEiboZoEBLepstNK6g.png"/></div></figure><h2 id="44e7" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">我们将使用提前停止回调，并将使用1/10的训练数据作为验证，以估计防止过度拟合的最佳时期数</h2><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="512f" class="nr lx iq oh b gy ol om l on oo">early_stop = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=10)<br/>history = model.fit(x=X,y=y,<br/>          validation_split=0.1,<br/>          batch_size=128,epochs=1000, callbacks=[early_stop])<br/>losses = pd.DataFrame(model.history.history)<br/>losses.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/b22f0bb024b621ea13440dd0ea62f411.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*1E6es5dKK0eyZaONPd2Tog.png"/></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">历元数v/s损失函数</figcaption></figure><p id="37e4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这段代码显示了在大约160处的早期停止，由于我们只使用了90%的训练数据，因此我们将向它添加10作为粗略估计，并将时期数作为170。因此，我们将再次重置我们的模型，并在完整的训练数据集上训练我们的模型。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="707f" class="nr lx iq oh b gy ol om l on oo">model = create_model() <em class="op"># Resetting the model.<br/></em>history = model.fit(x=X,y=y,<br/>          batch_size=128,epochs=170)<br/>losses = pd.DataFrame(model.history.history)<br/>losses.plot()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/254c4167178ff904d1d13d575d615900.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*dJ1ZAKNe3YkqbIe1EwMX4Q.png"/></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">历元数v/s损失函数</figcaption></figure><h1 id="6e72" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">预测和评估</h1><p id="1872" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">我们现在将根据测试数据集运行我们的模型。但在此之前，我们需要以处理训练数据的相同方式缩放测试数据，为此，我们将再次使用Sklearn的StandardScaler函数。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="d265" class="nr lx iq oh b gy ol om l on oo">X_test = scale.transform(test) # Scaling the testing data.<br/>result = model.predict(X_test) # Prediction using model<br/>result = pd.DataFrame(result,columns=['SalePrice']) # Dataframe<br/>result['Id'] = test['Id'] # Adding ID to our result dataframe.<br/>result = result[['Id','SalePrice']]<br/>result.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/e3437c2676407f45bb8a921c25180ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*AknyqNybdUtZxLIdrxEHYw.png"/></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">我们模型的预测</figcaption></figure><p id="96ad" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，我们得到了我们的结果，我们可以提交给kaggle，看看我们的表现如何。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/6ecdca1c303dc8228e79846c84e3365f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8-x11ZBnGqjVRLeX8nZXw.png"/></div></div><figcaption class="or os gj gh gi ot ou bd b be z dk translated">我在Kaggle上的提交</figcaption></figure><h2 id="5c29" class="nr lx iq bd ly ns nt dn mc nu nv dp mg lj nw nx mi ln ny nz mk lr oa ob mm iw bi translated">注意:最后，我只想说Keras不是这个问题最合适的模型，因为这里给出的数据集是不充分的。</h2><p id="b10e" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj od ll lm ln oe lp lq lr of lt lu lv ij bi translated">感谢您的阅读。这是我的第一篇关于媒体的文章，我希望听到你的反馈！！</p></div></div>    
</body>
</html>