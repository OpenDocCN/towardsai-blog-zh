<html>
<head>
<title>Time-Series Prediction of Bitcoin Price Using LSTM’s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用LSTM时间序列预测比特币价格</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/time-series-prediction-of-bitcoin-price-using-lstms-b8a6455d8143?source=collection_archive---------1-----------------------#2021-03-06">https://pub.towardsai.net/time-series-prediction-of-bitcoin-price-using-lstms-b8a6455d8143?source=collection_archive---------1-----------------------#2021-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c980" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/cryptography" rel="noopener ugc nofollow" target="_blank">密码学</a>，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="754c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">预测比特币价格的简单模型。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/30fe90a694598f08f66b7666c0df2e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWKTDXElpzLDMMnFLdn4Zw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@chrisliverani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>在<a class="ae lh" href="https://unsplash.com/s/photos/data-science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c0dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一名职业数据科学家和一名业余密码交易员，我一直对创建一个可以帮助我预测比特币价格的深度学习模型非常感兴趣。本文是基于我为创建这样一个模型所做的实验。</p><p id="e68d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我的Git项目的链接在这里:<a class="ae lh" href="https://github.com/msaleem18/Bitcoin-Price-Prediction-LSTM" rel="noopener ugc nofollow" target="_blank">https://github.com/msaleem18/Bitcoin-Price-Prediction-LSTM</a></p><h2 id="e8a9" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">LSTM的</h2><p id="891c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">长短期记忆，或更普遍的说法是LSTM氏症，是一种递归神经网络，帮助模型学习数据集中的长期序列。因为我在这里的重点更多的是它们的用法，如果你有兴趣知道更多关于什么是LSTM和它们如何工作的细节，你可以看看这篇很棒的文章来深入解释这一切。</p><h2 id="302a" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">资料组</h2><p id="371d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于这个项目，我使用了币安BTC/USDT的小时价格数据集，可以在这里找到:<a class="ae lh" href="http://www.cryptodatadownload.com/data/binance/" rel="noopener ugc nofollow" target="_blank">http://www.cryptodatadownload.com/data/binance/</a></p><p id="3c51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将数据导入到我的本地驱动器，并使用pandas以CSV格式读取。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="c819" class="me mf it nc b gy ng nh l ni nj"><em class="nk">#READ DATA FROM FILE STORED IN YOUR LOCAL DDRIVE (DOWNLOAD CSV FILE SHARED IN THE PROJECT)</em><br/>df = pd.read_csv("//Users//saad//Desktop//Bitcoin LSTM//bitcoin_hourly.csv")</span><span id="d3bd" class="me mf it nc b gy nl nh l ni nj">print(df.dtypes)</span><span id="f6cd" class="me mf it nc b gy nl nh l ni nj">print("<strong class="nc jd">\n</strong>*** DF ***")<br/>df_copy = df.copy()</span><span id="c2d1" class="me mf it nc b gy nl nh l ni nj">df_copy.head(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/2a72362e1c77fb19414c61eb492ad37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iV8-9B4cY7UG9N8qbjeGRw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">币安BTC/USDT数据集</figcaption></figure><h2 id="60b1" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">预处理</h2><p id="036c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">币安提供的数据集需要清理，原因如下:</p><ol class=""><li id="8593" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md ns nt nu nv bi translated">自2017年以来，他们一直在收集数据，自那以来，数据集中一些字段的格式发生了变化。</li><li id="efd9" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">数据集中的“日期”字段非常无用，我们需要创建自己的字段。</li><li id="9c44" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md ns nt nu nv bi translated">这样我们可以添加一些额外的字段来帮助我们建模。</li></ol><p id="f4d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这个模型，我创建了字段来跟踪一天中的小时和工作日。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="0c87" class="me mf it nc b gy ng nh l ni nj"><em class="nk">#CLEAN DATA - SPECIFICALLY CLEAN TIMESTAMP</em><br/><br/><strong class="nc jd">def</strong> change_timestamp (ts):<br/>    digit_count = len(str(ts))<br/>    <strong class="nc jd">if</strong> digit_count == 12:<br/>        <strong class="nc jd">return</strong> (datetime.datetime.utcfromtimestamp(ts)).strftime('%Y-%m-<strong class="nc jd">%d</strong> %H:%M:%S')<br/>    <strong class="nc jd">else</strong>:<br/>        <strong class="nc jd">return</strong> (datetime.datetime.utcfromtimestamp(ts/1000)).strftime('%Y-%m-<strong class="nc jd">%d</strong> %H:%M:%S')<br/><br/>df_copy['unix_count'] = df.unix.apply(<strong class="nc jd">lambda</strong> x: len(str(x)))        </span><span id="b80d" class="me mf it nc b gy nl nh l ni nj">df_copy['dt_correct'] = df.unix.apply(<strong class="nc jd">lambda</strong> x: change_timestamp(x))</span><span id="95c0" class="me mf it nc b gy nl nh l ni nj">df_copy['dt'] = pd.to_datetime(df_copy.dt_correct.values)</span><span id="1abd" class="me mf it nc b gy nl nh l ni nj">df_copy['hour'] = df_copy.dt.apply(<strong class="nc jd">lambda</strong> x: x.hour)</span><span id="0a12" class="me mf it nc b gy nl nh l ni nj">df_copy['week_day'] = df_copy.dt.apply(<strong class="nc jd">lambda</strong> x: x.weekday())</span><span id="f62a" class="me mf it nc b gy nl nh l ni nj">df_copy.sort_values(by=['unix'],ascending=[<strong class="nc jd">True</strong>],inplace=<strong class="nc jd">True</strong>)<br/></span></pre><h2 id="116a" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">正常化</h2><p id="351c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">标准化对于LSTM建模非常重要。自诞生以来，比特币的价格变化很大，最近几个月从近0美元涨到57000美元的历史高点；对模特来说不太好的东西。较高的数字将最终获得更多的权重，并将导致模型出现偏差。</p><p id="a81b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了避免这种偏斜，我们必须将数据标准化。在sklearn库中有很多可用的规范化方法，但是，我决定使用MinMax标量。我尝试了一些其他的方法，比如稳健标量，但是我的模型用最小最大标量表现最好，所以我最终决定用它。</p><p id="f158" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一点需要注意的是，最佳实践是只标准化您的训练数据，然后使用相同的方法标准化您的测试数据。然而，由于比特币的价格最近比往年上涨了很多，这就导致了标量方法的问题。由于我们正在进行时间序列预测，并且数据是按升序排序的，因此为训练数据集选取了早期的较低价格，而新的较高价格仅在测试数据集中可用。对于这个项目，我采取了捷径，以避免过多的编码，我将整个数据集标准化，并在标准化步骤后仅将其分为训练和测试。最佳实践是使用窗口缩放，如这里的<a class="ae lh" href="https://www.datacamp.com/community/tutorials/lstm-python-stock-market" rel="noopener ugc nofollow" target="_blank">所解释的</a>。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="f872" class="me mf it nc b gy ng nh l ni nj"><em class="nk">#SPLIT DATA INTO TEST AND TRAIN</em><br/>np.random.seed(7)<br/><br/>X = df_work[['hour','week_day','Volume BTC','close']]<br/>Y = df_work[['close']]<br/><em class="nk">#X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.3, shuffle = False)</em><br/><br/><br/><em class="nk">#NORMALIZATION</em><br/>f_transformer = preprocessing.MinMaxScaler((-1,1))<br/>f_transformer = f_transformer.fit(X)<br/><br/>cnt_transformer = preprocessing.MinMaxScaler((-1,1))<br/>cnt_transformer = cnt_transformer.fit(Y)<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, shuffle = <strong class="nc jd">False</strong>)<br/><br/>X_train_trans = f_transformer.transform(X_train)<br/>X_test_trans = f_transformer.transform(X_test)<br/><br/>y_train_trans = cnt_transformer.transform(y_train)<br/>y_test_trans = cnt_transformer.transform(y_test)<br/><br/><br/>print("*** SHAPES")<br/>print("X_train: <strong class="nc jd">%s</strong>, <strong class="nc jd">%s</strong>" % (X_train.shape[0],X_train.shape[1]))<br/>print("X_test: <strong class="nc jd">%s</strong>, <strong class="nc jd">%s</strong>" % (X_test.shape[0],X_test.shape[1]))<br/>print("y_train: <strong class="nc jd">%s</strong>, <strong class="nc jd">%s</strong>" % (y_train.shape[0],y_train.shape[1]))<br/>print("y_test: <strong class="nc jd">%s</strong>, <strong class="nc jd">%s</strong>" % (y_test.shape[0],y_test.shape[1]))<br/><br/>print("<strong class="nc jd">\n</strong>*** MIN MAX")<br/><br/>print("TRAIN COST: <strong class="nc jd">%d</strong>, <strong class="nc jd">%d</strong>" % (X_train.close.min(), X_train.close.max()))<br/>print("TEST COST: <strong class="nc jd">%d</strong>, <strong class="nc jd">%d</strong>" % (X_test.close.min(), X_test.close.max()))<br/>print("TRAIN VOL: <strong class="nc jd">%d</strong>, <strong class="nc jd">%d</strong>" % (X_train['Volume BTC'].min(), X_train['Volume BTC'].max()))<br/>print("TEST VOL: <strong class="nc jd">%d</strong>, <strong class="nc jd">%d</strong>" % (X_test['Volume BTC'].min(), X_test['Volume BTC'].max()))<br/><br/>print("<strong class="nc jd">\n</strong>*** MIN MAX PARAMETER")<br/>print(f_transformer.data_min_)<br/>print(f_transformer.data_max_)<br/>print(cnt_transformer.data_min_)<br/>print(cnt_transformer.data_max_)</span></pre><h2 id="6b26" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">滞后数据集</h2><p id="53eb" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">一旦我们有了干净的和标准化的数据，我们需要为LSTM时间序列预测创建一个滞后数据集。我说的滞后数据集是什么意思？</p><p id="5170" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基本上，LSTM时间序列预测的工作原理是回顾x小时的数据，并尝试预测x+1小时的价格。下图试图解释这个概念。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/3f5ea6dfd68d19ff81226166f771957b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Swl-fP3a73Y59uA_MfZ3jg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">为时序预测创建1小时滞后数据集</figcaption></figure><p id="d932" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我们的时间序列预测，我们将使用24小时的滞后。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="f92f" class="me mf it nc b gy ng nh l ni nj"><em class="nk">#CREATE LAGGING DATASET FOR TIMESERIES</em><br/><strong class="nc jd">def</strong> create_dataset(X, y, time_steps=1):<br/>    Xs, ys = [], []<br/>    <strong class="nc jd">for</strong> i <strong class="nc jd">in</strong> range(len(X) - time_steps):<br/>        v = X[i:(i + time_steps)]<br/>        Xs.append(v)<br/>        ys.append(y[i + time_steps])<br/>    <strong class="nc jd">return</strong> np.array(Xs), np.array(ys)<br/><br/>time_steps = 24</span><span id="6be4" class="me mf it nc b gy nl nh l ni nj"><em class="nk"># reshape to [samples, time_steps, n_features]</em><br/>X_train_f, y_train_f = create_dataset(X_train_trans, y_train_trans, time_steps)</span><span id="5550" class="me mf it nc b gy nl nh l ni nj">X_test_f, y_test_f = create_dataset(X_test_trans, y_test_trans, time_steps)<br/><br/>print("*** SHAPES")<br/>print(X_train_f.shape, y_train_f.shape)<br/>print(X_test_f.shape, y_test_f.shape)</span></pre><h2 id="6a32" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">系统模型化</h2><p id="b0e0" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在到了激动人心的部分——创建真正的LSTM模型。至少对我来说，这变得非常简单快捷。我最终在我的架构中使用了Keras的双向LSTM和批处理规范化层。</p><p id="0034" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我试验了许多其他复杂的架构，例如:</p><ul class=""><li id="4f21" class="nn no it lk b ll lm lo lp lr np lv nq lz nr md oc nt nu nv bi translated">具有不同激活功能的LSTM(tanh vs relu)</li><li id="37c3" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md oc nt nu nv bi translated">堆叠的LSTM层(2层和3层LSTM层)</li><li id="a66b" class="nn no it lk b ll nw lo nx lr ny lv nz lz oa md oc nt nu nv bi translated">CNN + LSTM模式</li></ul><p id="d7a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我的模型仅使用单个LSTM层时表现最佳(我的均方误差在该架构中是最低的)。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="a613" class="me mf it nc b gy ng nh l ni nj">model = keras.Sequential()</span><span id="cae7" class="me mf it nc b gy nl nh l ni nj">model.add(keras.Input(shape=((X_train_f.shape[1], X_train_f.shape[2]))))</span><span id="3af0" class="me mf it nc b gy nl nh l ni nj"><em class="nk">model.add(layers.Bidirectional(layers.LSTM(300, activation = 'tanh', return_sequences=False)))</em></span><span id="ed5f" class="me mf it nc b gy nl nh l ni nj">model.add(layers.BatchNormalization())</span><span id="0cd0" class="me mf it nc b gy nl nh l ni nj">model.add(keras.layers.Dense(units=1))</span><span id="cbce" class="me mf it nc b gy nl nh l ni nj">model.compile(loss='mean_squared_error', optimizer='adam')</span><span id="0f44" class="me mf it nc b gy nl nh l ni nj">model.summary()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6b47954cc9d2477112c0f46d37d0023f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*NSzVw2UmVXs9gtgLdGp2nw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">LSTM建筑模型</figcaption></figure><h2 id="e88e" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">预言；预测；预告</h2><p id="f2bf" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如下图所示，双向LSTM模型似乎运行得相当好，并且非常紧密地跟踪实际BTC价格</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/2e79ab9d52168e698c82cc167d271739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PpG5TBf7wmYMSA0zhrgd7Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">比特币价格预测</figcaption></figure><h2 id="f521" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">结论</h2><p id="b0af" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">尽管这个模型表现得很好，我仍然认为还有很大的改进空间。加密市场非常不稳定，这个模型没有使用任何来自当前新闻或趋势的信息。一个重要的改进是使用自然语言处理(NLP)并将新闻数据输入到这个模型中。</p><p id="0c74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在接下来的几周，我将在我的交易中使用这个模型，看看它的表现如何。你可以在我的Git页面上找到完整的项目:<a class="ae lh" href="https://github.com/msaleem18/Bitcoin-Price-Prediction-LSTM" rel="noopener ugc nofollow" target="_blank">https://github.com/msaleem18/Bitcoin-Price-Prediction-LSTM</a></p></div></div>    
</body>
</html>