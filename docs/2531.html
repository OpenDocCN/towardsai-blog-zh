<html>
<head>
<title>Common Data Cleaning Tasks in Everyday Work of a Data Scientist/Analyst in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中数据科学家/分析师日常工作中的常见数据清理任务</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/data-analysis-91a38207c92b?source=collection_archive---------0-----------------------#2022-02-01">https://pub.towardsai.net/data-analysis-91a38207c92b?source=collection_archive---------0-----------------------#2022-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c5f5fd3f09548bd8b23b4a787cef489f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rmgk7-hGhGWggR80"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">布鲁克斯·赖斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="a32d" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-analysis" rel="noopener ugc nofollow" target="_blank">数据分析</a></h2><div class=""/><div class=""><h2 id="f817" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">数据清理备忘单</h2></div><p id="9854" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你是数据科学家、数据分析师或机器学习工程师，数据清理是你生活中必不可少的一部分。在现实生活中，很难找到完全干净并可以立即使用的数据。在深入分析、可视化或机器学习之前，数据清理是几乎所有现实世界项目中非常常见的任务。</p><p id="1916" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本文将关注一般的和非常常见的数据清理任务。我们将使用几个不同的数据集来演示不同的数据清理过程。</p><p id="9a1a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不再介绍了。让我们开始行动吧！</p><p id="15a1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我将从olympics.csv数据集开始。这是一个用于实践的非常常见的数据集。我将使用的第一个数据集是奥林匹克数据集。我从Coursera的课程中找到了这个数据集。我必须在使用前做一些清洁工作。以下是数据集的链接:</p><div class="is it gp gr iu md"><a href="https://github.com/rashida048/Datasets/blob/master/olympics.csv" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">master rashida048/Datasets上的Datasets/olympics.csv</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">在GitHub上创建一个帐户，为rashida048/Datasets开发做出贡献。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ja md"/></div></div></a></div><p id="1ec2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我导入必要的包，使用“read_csv”函数将数据集读入DataFrame格式，并使用。head()函数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="def3" class="nb nc jj mx b gy nd ne l nf ng">import pandas as pd<br/>import numpy as np</span><span id="85aa" class="nb nc jj mx b gy nh ne l nf ng">olympics = pd.read_csv("olympics.csv")<br/>olympics.head()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/16784dbeaba7f023511566753cf1e208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iI5690RJ0krZ2eyA0qfVw.png"/></div></div></figure><blockquote class="nj nk nl"><p id="eb08" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">找到正确的标题</strong></p></blockquote><p id="aac3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在数据框中，第一行上面显然不是标题。标题实际上是行索引为1的下一行。因此，在read_csv方法中，可以使用一个额外的参数“header=1”来实现这一点。在这里，我再次读取数据集:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1205" class="nb nc jj mx b gy nd ne l nf ng">olympics = pd.read_csv("olympics.csv", header=1)<br/>olympics.head()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/fc2c1c1cde36b38ab5819b19fe3b91b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCy_KS_Di53ZeGR2rcyCAg.png"/></div></div></figure><blockquote class="nj nk nl"><p id="700d" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">重命名列</strong></p></blockquote><p id="4336" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里的列名看起来不太清楚，也不容易理解。第一列包含所有国家的名称。但是它有一个奇怪的名字！上面写着“01！”, '02!'，或者03年！，应该是‘金’、‘银’、‘铜’。因此，让我们使用“重命名”功能来重命名这些列。“rename”函数采用一个字典，其中键是原始列名，值是新列名。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cf81" class="nb nc jj mx b gy nd ne l nf ng">col_names = {'Unnamed: 0': 'Country',<br/>               '? Summer': 'Summer Olympics',<br/>               '01 !': 'Gold',<br/>               '02 !': 'Silver',<br/>               '03 !': 'Bronze',<br/>               '? Winter': 'Winter Olympics',<br/>               '01 !.1': 'Gold.1',<br/>               '02 !.1': 'Silver.1',<br/>               '03 !.1': 'Bronze.1',<br/>               '? Games': '# Games',<br/>               '01 !.2': 'Gold.2',<br/>               '02 !.2': 'Silver.2',<br/>               '03 !.2': 'Bronze.2'}</span><span id="9baa" class="nb nc jj mx b gy nh ne l nf ng">olympics.rename(columns=col_names, inplace=True)</span><span id="4d09" class="nb nc jj mx b gy nh ne l nf ng">#Checking the olympics DataFrame with the new column names<br/>olympics.head()</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/cfc27f07bb3998d9694798dd96f6aceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5d7V9yq0MyxqNPnOu6u3g.png"/></div></div></figure><p id="85cf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">列名是固定的！</p><blockquote class="nj nk nl"><p id="38e7" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">去掉文本中多余的尾部</strong></p></blockquote><p id="7720" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请看第一列中的国家名称。在国名之后，括号中有一个缩写。有时它甚至有两次。那是不必要的。它在可视化或任何分析中都不好看。这需要被删除。</p><p id="20dc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们将使用“应用地图”功能。“applymap”函数采用应该应用于我们打算执行更改的一列或多列的函数。这里我们定义一个函数，它将一个字符串作为参数，并在找到第一个括号“(”后删除所有内容。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7a58" class="nb nc jj mx b gy nd ne l nf ng">def get_country(st):<br/>    if ' (' in st:<br/>        return st[:st.find(' (')]<br/>    else:<br/>        return st</span></pre><p id="caee" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用该函数作为“applymap”函数中的参数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f398" class="nb nc jj mx b gy nd ne l nf ng">pd.DataFrame(olympics['Country']).applymap(get_country)</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/674bc9856c3b0896239d744bdeb1a7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*C31DYUrTgwZwJfXJ73Wrcw.png"/></div></figure><p id="892e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如您所见，在国家一栏中，我们现在只有国家名称。如果我们有多个具有相同清洗要求的色谱柱，我们可以同时在所有色谱柱上使用“applymap”。</p><p id="4353" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个数据集现在可以进行分析或可视化了！</p><p id="368f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我的下一个数据集将是关节炎数据集。这个数据集是我在硕士课程中的一门课的作业。它是“飞机救援消防”格式。这是这个数据集的链接。</p><div class="is it gp gr iu md"><a href="https://github.com/rashida048/Datasets/blob/master/project-2018-BRFSS-arthritis.arff" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">数据集/项目-2018-BRFSS-关节炎。rashida048大师的飞机救援消防/数据集</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">在GitHub上创建一个帐户，为rashida048/Datasets开发做出贡献。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="nt l mo mp mq mm mr ja md"/></div></div></a></div><p id="9f06" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您不熟悉这种格式，也不用担心。我们的重点是数据清理。下面是如何将这个“arff”格式的数据集加载到pandas数据帧中:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="306c" class="nb nc jj mx b gy nd ne l nf ng">from scipy.io import arff</span><span id="a358" class="nb nc jj mx b gy nh ne l nf ng">d = arff.loadarff("project-2018-BRFSS-arthritis.arff")<br/>df = pd.DataFrame(d[0])</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/9e07f25d3de81782dd8e9527eada42eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-fDbXejcCJnQo8ctB5yUw.png"/></div></div></figure><p id="a4fe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个数据集有108列和11933行。所以，相当大的数据集！</p><blockquote class="nj nk nl"><p id="90c1" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">将字节型数据转换为数值型数据</strong></p></blockquote><p id="c949" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个数据集中的第一个敌人是b'2 '类型的数据。这些是字节类型的数据，对任何与数据相关的项目都不友好。我们想要简单的数字数据。即使我们得到文本数据，我们也要以某种方式将它们转换成数字数据，对吗？因此，这种字节类型的数据需要转换成某种更易于管理的格式。</p><p id="e83f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我将它们解码成字符串形式。</p><p id="16f5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下函数将DataFrame作为参数，检查是否有包含字节类型数据的列，然后将它们解码为字符串类型。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e111" class="nb nc jj mx b gy nd ne l nf ng">def convert_str(df):<br/>    for i in df.columns:<br/>        if type(df[i][0]) == bytes:<br/>            df[i] = df[i].str.decode("utf-8")<br/>    return df</span><span id="230b" class="nb nc jj mx b gy nh ne l nf ng">df = convert_str(df)<br/>df</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/3110c7425a3d59bfd4fe42e2624fef1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4WAN65BMscPDITnvAmBGQ.png"/></div></div></figure><p id="8e90" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">字节类型的数据被转换成字符串类型。但是，仍然有一个问题。看上面一列的最后一个值。是一个“？”。可能还有更多呢？就像在不同的位置，我们不能在一个大的数据集中逐一检查。使用一个循环，我们将检查每一列。如果有的话？，它将被一个空字符串替换。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6e10" class="nb nc jj mx b gy nd ne l nf ng">for i in df.columns:<br/>    if type(df[i][0]) == str:<br/>        df[i] = df[i].str.replace('?', '')<br/>        <br/>df</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/7698430cabacd57893a44975a201babb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIB7zluwjOK_QwUBZTK26w.png"/></div></div></figure><p id="6f31" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">再看第一列的最后一个值，那个'？'不见了！</p><p id="d9ec" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但这也不能解决问题。因为所有这些字节类型的数据都被转换为字符串类型。理想情况下，我们需要数字数据。现在让我们把它们转换成数字数据。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="3fa4" class="nb nc jj mx b gy nd ne l nf ng">col = []<br/>for i in df.columns:<br/>    if type(df[i][0]) == str:<br/>        col.append(i)<br/>df[col] = df[col].apply(pd.to_numeric, errors = 'coerce')</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/aabb743938eb43f873dc02c69fff7877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJl3t4dt1ASZF3inA-ITgA.png"/></div></div></figure><p id="13ac" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后一行显示了几个空值，整个数据集可能包含更多的空值。我们应该检查每一列中null值的数量。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4c4a" class="nb nc jj mx b gy nd ne l nf ng">df.isnull().sum()</span></pre><p id="1aa5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c5d6" class="nb nc jj mx b gy nd ne l nf ng">x.aidtst3    805<br/>employ1       34<br/>income2      114<br/>weight2      180<br/>height3      198<br/>            ... <br/>x.michd      114<br/>x.ltasth1      0<br/>x.casthm1      0<br/>x.state        0<br/>havarth3       0<br/>Length: 108, dtype: int64</span></pre><p id="00f4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们有很多空值要处理。</p><blockquote class="nj nk nl"><p id="2263" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">处理空值</strong></p></blockquote><p id="a4f9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有几种常用的方法来处理空值。一种方法是使用这段简单的代码删除所有的空值，这段代码将删除所有包含空值的行:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f923" class="nb nc jj mx b gy nd ne l nf ng">df.dropna()</span></pre><p id="63d2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">问题是，这样你可能只剩下几行数据。如果数据集真的很大，甚至在删除空值后，您有足够的数据来分析，它可能是好的。但是我不鼓励你像那样删除整行数据。您可能会丢失重要信息。</p><p id="c8c4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一种方法是用零填充所有空值，如下所示:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5b0f" class="nb nc jj mx b gy nd ne l nf ng">df.fillna(0)</span></pre><p id="b39f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这将用零填充所有的空值。如果这符合你的目的，那就去做吧。</p><p id="6cab" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">空值也可以用之前的值填充:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7167" class="nb nc jj mx b gy nd ne l nf ng">df.fillna(method = "bfill")</span></pre><p id="a288" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样，您可以用紧随其后的值填充空值:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0494" class="nb nc jj mx b gy nd ne l nf ng">df.fillna(method="ffill")</span></pre><p id="60c8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些是所有可用的选项。最后，我将展示一种我最喜欢的方式。我通常用中间值填充空值。用平均值或标准正常值填充空值也很常见。因此，我们将遍历所有列，并使用它们的中值填充所有列的空值。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1383" class="nb nc jj mx b gy nd ne l nf ng">for i in df.columns:<br/>    df[i].fillna(df[i].median(), inplace=True)</span></pre><p id="4aa9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们再次检查每一列中null值的数量:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0b67" class="nb nc jj mx b gy nd ne l nf ng">df.isnull().sum()</span></pre><p id="037f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ed5c" class="nb nc jj mx b gy nd ne l nf ng">x.aidtst3    0<br/>employ1      0<br/>income2      0<br/>weight2      0<br/>height3      0<br/>            ..<br/>x.michd      0<br/>x.ltasth1    0<br/>x.casthm1    0<br/>x.state      0<br/>havarth3     0<br/>Length: 108, dtype: int64</span></pre><p id="4799" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不再有空值！</p><p id="9ae5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个数据集现在应该可以使用了。</p><p id="b86e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我将有一个数据集，其中的每一列都需要清理。这个数据集是专门为本教程准备的。我在这里添加了一些非常常见的问题类型来解决。</p><p id="a994" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下是数据集的链接:</p><div class="is it gp gr iu md"><a href="https://github.com/rashida048/Datasets/blob/master/people.csv" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">master rashida048/Datasets上的Datasets/people.csv</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="nx l mo mp mq mm mr ja md"/></div></div></a></div><p id="34ba" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它看起来是这样的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="036e" class="nb nc jj mx b gy nd ne l nf ng">ppl = pd.read_csv("people.csv")<br/>ppl</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/1ed99ca1233622f33332111951b113e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*4m09NuyD2DgB1iqnNNZnfg.png"/></div></div></figure><p id="f382" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可以看到几乎每个专栏都有一些工作要做。</p><blockquote class="nj nk nl"><p id="fa82" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">删除重复数据</strong></p></blockquote><p id="c31d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你注意到，有些人进来了两次。“爱丽丝”和“鲁米”的数据是重复的。这很常见。它可能被输入两次，或者两个不同的人取走了他们的数据。在进行任何其他数据清理之前，让我们先清除重复数据:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cdd8" class="nb nc jj mx b gy nd ne l nf ng">people = people.drop_duplicates(subset="Name")<br/>people</span></pre><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0b63aea92c4155980c4a3ccbfec553c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*x4YfhXLe40ulQKgNn2n65w.png"/></div></figure><p id="36cf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">重复的不见了！让我们一个接一个地研究柱子。</p><blockquote class="nj nk nl"><p id="b8ba" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">获取简单的四位数年份数据</strong></p></blockquote><p id="1494" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从“年份”列开始，有些值不是4位数的年份。它有一些额外的值，应该在分析前删除。</p><p id="dfcd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用正则表达式仅获取4位数的年份值:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1b35" class="nb nc jj mx b gy nd ne l nf ng">year_ex = people["Year"].str.extract(r'^(\d{4})',<br/>                                    expand=False)<br/>year_ex</span></pre><p id="95c8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="69d3" class="nb nc jj mx b gy nd ne l nf ng">0    1980<br/>1    1978<br/>2    1982<br/>3    1992<br/>4    1987<br/>Name: Year, dtype: object</span></pre><p id="7545" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们有简单的四位数年份！</p><blockquote class="nj nk nl"><p id="25e7" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">用普通数值评估收入</strong></p></blockquote><p id="98d0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在是“收入”列，其中有包含“K”、“M”的字符串值。对于带有收入值的分析或可视化，数值会更有用。所以，这个“K”和“M”需要用三个0和六个0来代替:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="14ad" class="nb nc jj mx b gy nd ne l nf ng">people["Income"].replace({"K": "*1e3", "M": "*1e6"}, regex=True).map(pd.eval).astype(int)</span></pre><p id="8a6e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8dfd" class="nb nc jj mx b gy nd ne l nf ng">0     2000000<br/>1       40000<br/>2      120000<br/>3    10000000<br/>4     6000000<br/>Name: Income, dtype: int32</span></pre><p id="42d8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在教育栏中，哈佛、斯坦福或牛津这几个词带有一些额外的单词或字符。如果你想在分析中使用这些数据，两个哈佛的数据将被认为是两个不同的数据。因此，我们需要去掉那些额外的字符，只为同一所大学提供简单且完全相同的字符串。我是这样做的。</p><p id="b90f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，为三所不同的大学创建三个布尔变量。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cb36" class="nb nc jj mx b gy nd ne l nf ng">edu = people["Education"]<br/>harvard = edu.str.contains("Harvard")<br/>stanford = edu.str.contains("Stanford")<br/>oxford = edu.str.contains("Oxford")</span></pre><p id="9995" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，如果字符串包含“Harvard ”,我们将使用“Harvard ”,如果字符串包含“Stanford ”,则使用“Stanford ”,以此类推，并使用嵌套的np.where()函数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="753d" class="nb nc jj mx b gy nd ne l nf ng">people["Education"] = np.where(harvard, "Harvard",<br/>                              np.where(stanford, "Stanford",<br/>                                      np.where(oxford, "Oxford", people["Education"])))</span></pre><p id="f2ed" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fd02" class="nb nc jj mx b gy nd ne l nf ng">0     Harvard<br/>1      Oxford<br/>2      Oxford<br/>3    Stanford<br/>4     Harvard<br/>Name: Education, dtype: object</span></pre><p id="eb0b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看啊！我们现在有非常简单的一个单词的名字。没有其他困惑！</p><blockquote class="nj nk nl"><p id="59f9" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">将时间序列数据转换为日期时间格式</strong></p></blockquote><p id="a1df" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，“毕业”一栏。要分析pandas中的时间或日期数据，使用“datetime”格式很有用。我觉得这也更清楚了。如果有时序数据，这是一个常见的数据清理任务。很多时候，它们并不是以友好的方式出现的。</p><p id="a56d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将其转换为“日期时间”格式非常简单:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="05a7" class="nb nc jj mx b gy nd ne l nf ng">pd.to_datetime(people['Graduation'])</span></pre><p id="fec5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7d9e" class="nb nc jj mx b gy nd ne l nf ng">0   2020-03-12<br/>1   2020-04-14<br/>2   2020-08-01<br/>3   2020-05-18<br/>4   2021-05-10<br/>Name: Graduation, dtype: datetime64[ns]</span></pre><p id="a873" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">搞定了。</p><blockquote class="nj nk nl"><p id="e689" class="lh li nm lj b lk ll kt lm ln lo kw lp nn lr ls lt no lv lw lx np lz ma mb mc im bi translated"><strong class="lj jt">清除数字或特殊字符，只有纯文本</strong></p></blockquote><p id="4c9f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，这个“站立”栏。几乎总是，文本数据需要一些数据清理。打字错误、不必要的数字和字符无时无刻不在出现。几乎从未发生过，你得到文本数据非常干净。首先，我们将使所有的字符串小写。这样‘低’和‘低’就不会有什么不同。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1aad" class="nb nc jj mx b gy nd ne l nf ng">people["Standing"] = people["Standing"].str.lower()</span></pre><p id="f86a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我将使用一个简单的正则表达式去掉所有数字和其他字符:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b561" class="nb nc jj mx b gy nd ne l nf ng">people["Standing"].map(lambda x: re.sub('([^a-z]+)', '', x))</span></pre><p id="3196" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="354d" class="nb nc jj mx b gy nd ne l nf ng">0       medium<br/>1          low<br/>2    excellant<br/>3          low<br/>4    excellant<br/>Name: Standing, dtype: object</span></pre><p id="698b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">干净简单！</p><h2 id="e431" class="nb nc jj bd oa ob oc dn od oe of dp og lq oh oi oj lu ok ol om ly on oo op jp bi translated"><strong class="ak">结论</strong></h2><p id="dacd" class="pw-post-body-paragraph lh li jj lj b lk oq kt lm ln or kw lp lq os ls lt lu ot lw lx ly ou ma mb mc im bi translated">数据可能以多种不同的方式出现。有这么多不同的数据清理选项。在本文中，我想列出一些日常数据清理的常见数据清理任务。有这样一个清单可以节省很多时间。在未来，我会增加更多的数据清理选项。</p><p id="64b6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请随时关注我的<a class="ae jg" href="https://twitter.com/rashida048" rel="noopener ugc nofollow" target="_blank">推特</a>、脸书<a class="ae jg" href="https://www.facebook.com/Regenerative-149425692134498" rel="noopener ugc nofollow" target="_blank">页面</a>，并查看我的新<a class="ae jg" href="https://www.youtube.com/channel/UCzJgOvsJJPCXWytXWuVSeXw" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a></p><h2 id="b4e5" class="nb nc jj bd oa ob oc dn od oe of dp og lq oh oi oj lu ok ol om ly on oo op jp bi translated">更多阅读</h2><div class="is it gp gr iu md"><a href="https://towardsdatascience.com/all-the-datasets-you-need-to-practice-data-science-skills-and-make-a-great-portfolio-74f2eb53b38a" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">练习数据科学技能和制作优秀投资组合所需的所有数据集</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">大量不同种类的数据集</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="ov l mo mp mq mm mr ja md"/></div></div></a></div><div class="is it gp gr iu md"><a href="https://towardsdatascience.com/30-very-useful-pandas-functions-for-everyday-data-analysis-tasks-f1eae16409af" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">30个非常有用的熊猫函数，用于日常数据分析任务</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">熊猫小型张</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="ow l mo mp mq mm mr ja md"/></div></div></a></div><div class="is it gp gr iu md"><a href="https://towardsdatascience.com/exploratory-data-analysis-with-some-cool-visualizations-in-pythons-matplotlib-and-seaborn-library-99dde20d98bf" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">利用Python的Matplotlib和Seaborn中的高级可视化进行探索性数据分析…</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">探索国际足联数据集</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="ox l mo mp mq mm mr ja md"/></div></div></a></div><div class="is it gp gr iu md"><a rel="noopener  ugc nofollow" target="_blank" href="/text-data-visualization-with-wordcloud-of-any-shape-in-python-8cec334e5c4f"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">用Python中任意形状的WordCloud实现文本数据可视化</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">学习生成任何形状的单词云</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">pub.towardsai.net</p></div></div><div class="mm l"><div class="oy l mo mp mq mm mr ja md"/></div></div></a></div><div class="is it gp gr iu md"><a href="https://towardsdatascience.com/a-beginners-guide-to-match-any-pattern-using-regular-expressions-in-r-fd477ce4714c" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">使用R中的正则表达式匹配任何模式的初学者指南</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">这比你想象的要容易</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="oz l mo mp mq mm mr ja md"/></div></div></a></div><div class="is it gp gr iu md"><a href="https://medium.com/illumination/i-tried-intermittent-fasting-for-a-month-and-here-is-my-experience-and-results-9d4adb8fbc48" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">我尝试了一个月的间歇禁食，以下是我的经验和结果</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">间歇性禁食是当今健康爱好者的时髦用语。已经不算太新了。人们知道这件事…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">medium.com</p></div></div><div class="mm l"><div class="pa l mo mp mq mm mr ja md"/></div></div></a></div></div></div>    
</body>
</html>