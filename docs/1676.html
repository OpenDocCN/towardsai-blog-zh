<html>
<head>
<title>Pre-processing Techniques in Image Processing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python图像处理中的预处理技术</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/pre-processing-techniques-in-image-processing-with-python-81e5c8babf09?source=collection_archive---------1-----------------------#2021-03-16">https://pub.towardsai.net/pre-processing-techniques-in-image-processing-with-python-81e5c8babf09?source=collection_archive---------1-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b927" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a></h2><div class=""/><div class=""><h2 id="df02" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">OpenCV下的图像处理技术</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ab90e291767a14e644974ad527b04d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U7UbYVLT6hjWIz4J"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安妮·斯普拉特</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0559" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将使用OpenCV工具进行图像处理。</p><h2 id="6c81" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">涵盖的主题:</h2><ul class=""><li id="ab8f" class="mw mx it lk b ll my lo mz lr na lv nb lz nc md nd ne nf ng bi translated"><strong class="lk jd">加载图像</strong></li><li id="06ed" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><strong class="lk jd">保存图像</strong></li><li id="b66f" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><strong class="lk jd">调整图像大小</strong></li><li id="7065" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><strong class="lk jd">裁剪图像</strong></li><li id="aef3" class="mw mx it lk b ll nh lo ni lr nj lv nk lz nl md nd ne nf ng bi translated"><strong class="lk jd">锐化图像</strong></li></ul><p id="54ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">图像分类是机器学习中最令人着迷和兴奋的话题。这是一个强大的工具包，计算机可以识别图像中的模式和对象。在将机器学习应用于图像之前，我们必须转换原始图像并提取对学习算法有用的特征。</p><p id="4ae8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有各种各样的库可以用来处理图像，但是开源计算机视觉(OpenCV)库对处理图像及其文档非常有帮助。</p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/become-a-data-scientist-in-2021-with-these-following-steps-5bf70a0fe0a1"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jd gy z fp nu fr fs nv fu fw jc bi translated">按照以下步骤，在2021年成为一名数据科学家</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">走上数据科学家之路需要具备的基本点</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pub.towardsai.net</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od lb np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/z-statistics-t-statistics-p-statistics-are-still-confusing-you-87557047e20a"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jd gy z fp nu fr fs nv fu fw jc bi translated">Z-统计量，T-统计量，P-统计量还在迷惑你？</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">机器学习统计学中的定义和概念</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pub.towardsai.net</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od lb np"/></div></div></a></div><h2 id="d746" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">加载图像</h2><p id="4be2" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated">对于图像的预处理，我们必须借助OpenCV的“imread”来加载图像</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="7fd0" class="me mf it oj b gy on oo l op oq"># Load library<br/>import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="9b06" class="me mf it oj b gy or oo l op oq"># Load image as grayscale<br/>image = cv2.imread(“images/plane.jpg”, cv2.IMREAD_GRAYSCALE)</span><span id="6894" class="me mf it oj b gy or oo l op oq">we can view the image using the “matplotlib” library</span><span id="6e73" class="me mf it oj b gy or oo l op oq"># Show image<br/>plt.imshow(image, cmap=”gray”), plt.axis(“off”)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/df499877db10a5efd7dc73b95216f20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/0*qgc7pPKxNnYc1H9x.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="fb72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们使用“imread”时，我们将图像数据转换为“Numpy”数组的数据类型。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="673d" class="me mf it oj b gy on oo l op oq"># Show data type<br/>type(image)</span><span id="94ed" class="me mf it oj b gy or oo l op oq">#output:<br/>numpy.ndarray</span></pre><p id="abb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，图像已经将图像转换成矩阵，元素对应于单个像素。矩阵值看起来像</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="10dd" class="me mf it oj b gy on oo l op oq"># Show dimensions<br/>image</span><span id="e8dd" class="me mf it oj b gy or oo l op oq">#output:</span><span id="7700" class="me mf it oj b gy or oo l op oq">array([[140, 136, 146, …, 132, 139, 134], [144, 136, 149, …, 142, 124, 126], [152, 139, 144, …, 121, 127, 134], …, [156, 146, 144, …, 157, 154, 151], [146, 150, 147, …, 156, 158, 157], [143, 138, 147, …, 156, 157, 157]], dtype=uint8)</span></pre><p id="a1ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，在浏览了结果之后，我们得到了一个基本的问题，比如这些矩阵值对我们意味着什么？</p><p id="b1c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在灰度图像中，单个元素的值是图像中的像素亮度。灰色图像的像素强度值范围从0到255，即分别从黑到白。</p><p id="a0f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，在下面代码的帮助下，我们可以看到图像右上角像素的亮度</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="c481" class="me mf it oj b gy on oo l op oq"># Show first pixel<br/>image[0,0]</span><span id="46af" class="me mf it oj b gy or oo l op oq">#output: <br/>140</span></pre><p id="255c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们使用非灰度图像时，在矩阵中，每个元素代表三个值，分别是蓝、绿、红值(BGR)。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="0058" class="me mf it oj b gy on oo l op oq"># Load image in color<br/>image_bgr = cv2.imread(“images/plane.jpg”, cv2.IMREAD_COLOR)</span><span id="291e" class="me mf it oj b gy or oo l op oq"># Show pixel<br/>image_bgr[0,0]</span><span id="a0ad" class="me mf it oj b gy or oo l op oq">#output: <br/>array([195, 144, 111], dtype=uint8)</span></pre><p id="5182" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">重要提示:默认OpenCV使用BGR模式，但许多图像应用程序，如Matplotlib库，使用红绿蓝(RGB)模式。换句话说，这里红、蓝值被交换。</p><p id="4dc2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们想在Matplotlib库(使用RGB)中显示OpenCV处理过的图像(BGR彩色图像)时，首先将BGR转换为RGB</p><p id="9128" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以通过以下方式完成:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="bcf9" class="me mf it oj b gy on oo l op oq"># Convert to RGB<br/>image_rgb = cv2.cvtColor(image_bgr, cv2.COLOR_BGR2RGB)</span><span id="993f" class="me mf it oj b gy or oo l op oq"># Show image<br/>plt.imshow(image_rgb), plt.axis(“off”)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/c01c8b42b8a43c22c8c83843add7fcf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*bKsdbBaFswRGEW95.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="894c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">图像的分辨率是3600 x 2270，为了得到矩阵的维数，我们可以使用下面的代码</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="9048" class="me mf it oj b gy on oo l op oq"># Show dimensions<br/>image.shape</span><span id="afb4" class="me mf it oj b gy or oo l op oq">#output: <br/>(2270, 3600)</span></pre><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/step-by-step-basic-understanding-of-neural-networks-with-keras-in-python-94f4afd026e5"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jd gy z fp nu fr fs nv fu fw jc bi translated">使用Python中的Keras逐步基本了解神经网络</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">具有定义的神经网络的学习</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pub.towardsai.net</p></div></div><div class="ny l"><div class="ou l oa ob oc ny od lb np"/></div></div></a></div><h2 id="4e1f" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">保存图像</h2><p id="b666" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated">我们可以使用“imwrite”方法保存图像进行预处理。这需要两个参数</p><p id="48bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一个代表指定用来保存图像的文件路径，第二个是图像本身。在这里，图像的格式可以由(定义。jpg，。png等)。</p><p id="d7d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的重要一点是,“imwrite”将会覆盖现有文件，而不会出现任何错误或要求确认</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="97d5" class="me mf it oj b gy on oo l op oq"># Load libraries<br/>import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="34af" class="me mf it oj b gy or oo l op oq"># Load image as grayscale<br/>image = cv2.imread(“images/plane.jpg”, cv2.IMREAD_GRAYSCALE)</span><span id="dea7" class="me mf it oj b gy or oo l op oq"># Save image<br/>cv2.imwrite(“images/plane_new.jpg”, image)</span><span id="df51" class="me mf it oj b gy or oo l op oq">#output: <br/>True</span></pre><h2 id="f695" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">调整图像大小</h2><p id="c810" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated">我们可以在预处理阶段使用“调整大小”来改变图像的大小，原因有二。第一个，把所有形状和大小的图像保持在相同的尺寸，这样它们就可以用来提取特征。这被称为图像大小的标准化，我们正在减少矩阵的大小和图像的信息。</p><p id="8aae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二种，在机器学习训练过程中，需要数百或数千张图像，消耗大量内存。为了减轻这种情况，我们可以调整它们的大小，从而减少内存使用。</p><p id="639d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用于机器学习算法的常见图像大小为32*32、64*64、96*96和256*256。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="6fd1" class="me mf it oj b gy on oo l op oq"># Load image<br/>import cv2<br/>import NumPy as np<br/>from matplotlib import pyplot as plt</span><span id="6b3c" class="me mf it oj b gy or oo l op oq"># Load image as grayscale<br/>image = cv2.imread(“images/plane_256x256.jpg”, cv2.IMREAD_GRAYSCALE)</span><span id="2fd7" class="me mf it oj b gy or oo l op oq"># Resizing the image to 50x50 pixels<br/>image_50x50 = cv2.resize(image, (50, 50))</span><span id="6948" class="me mf it oj b gy or oo l op oq"># View image<br/>plt.imshow(image_50x50, cmap=”gray”), plt.axis(“off”)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/20743c6800ed08034dfba3f795c7d238.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*07Wwq0wKWHdS44CB.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><h2 id="b852" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">裁剪图像</h2><p id="7943" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated">我们可以通过对数组进行切片来方便地裁剪图像，然后将图像编码为二维numpy数组，以去除图像的外部部分并改变它们的尺寸。</p><p id="09f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们知道OpenCV在元素矩阵中表示图像，我们可以选择行和列，并根据矩阵的元素进行裁剪。</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="77c2" class="me mf it oj b gy on oo l op oq"># Load image<br/>import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="0fc8" class="me mf it oj b gy or oo l op oq"># Load image in grayscale<br/>image = cv2.imread(“images/plane_256x256.jpg”, cv2.IMREAD_GRAYSCALE)</span><span id="d396" class="me mf it oj b gy or oo l op oq"># Select first 128 pixels of the image<br/>image_cropped = image[:,:128]</span><span id="1bb8" class="me mf it oj b gy or oo l op oq"># Show image<br/>plt.imshow(image_cropped, cmap=”gray”), plt.axis(“off”)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/304cba9d06989b223c37ab614751283e.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*_oBSdTUM1GWoNkoB.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><h2 id="c85f" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">锐化图像</h2><p id="f8d2" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated">首先让我们了解一下图像的锐化是什么意思？</p><p id="8b01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一种增加<strong class="lk jd">图像的表观<strong class="lk jd">锐度</strong>的技术。</strong>当我们从原始图像中减去模糊图像时，它用于检测图像中的边缘。</p><p id="abc2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们想要锐化图像时，首先创建一个突出目标像素的内核，然后使用“filter2D”将其应用于图像</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="e252" class="me mf it oj b gy on oo l op oq"># Load libraries<br/>import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="ed93" class="me mf it oj b gy or oo l op oq"># Load image as grayscale<br/>image = cv2.imread(“images/plane_256x256.jpg”, cv2.IMREAD_GRAYSCALE)</span><span id="af76" class="me mf it oj b gy or oo l op oq"># Create kernel<br/>kernel = np.array([[0, -1, 0],<br/> [-1, 5,-1],<br/> [0, -1, 0]])</span><span id="e083" class="me mf it oj b gy or oo l op oq"># Sharpen image<br/>image_sharp = cv2.filter2D(image, -1, kernel)</span><span id="87f5" class="me mf it oj b gy or oo l op oq"># Show image<br/>plt.imshow(image_sharp, cmap=”gray”), plt.axis(“off”)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6bcd3397a040065f17f8a62a0738b2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/0*i2ZJc2A4ASduO-eh.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><h2 id="a98e" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">结论:</h2><p id="f222" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated">图像处理在视觉问题中非常有用。大算法中总是需要基础预处理技术的知识。</p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/custom-statistical-details-of-data-frame-with-python-745d652b363f"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jd gy z fp nu fr fs nv fu fw jc bi translated">用Python定制数据框的统计细节</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">数据集中特征的统计分析</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pub.towardsai.net</p></div></div><div class="ny l"><div class="oy l oa ob oc ny od lb np"/></div></div></a></div><p id="b8c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="3305" class="oz mf it bd mg pa pb pc mj pd pe pf mm ki pg kj mp kl ph km ms ko pi kp mv pj bi translated">推荐文章</h1><p id="702c" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr of lt lu lv og lx ly lz oh mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-preprocessing-concepts-with-python-b93c63f14bb6?source=friends_link&amp;sk=5cc4ac66c6c02a6f02077fd43df9681a">数据预处理概念同Python </a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/principal-component-analysis-in-dimensionality-reduction-with-python-1a613006d531?source=friends_link&amp;sk=3ed0671fdc04ba395dd36478bcea8a55">用Python进行主成分分析降维</a> <br/> 5。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-k-means-clustering-with-python-e7caa573176a?source=friends_link&amp;sk=9c5c613ceb10f2d203712634f3b6fb28" rel="noopener">用Python全面讲解K-means聚类</a> <br/> 6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/basic-of-time-series-with-python-a2f7cb451a76?source=friends_link&amp;sk=09d77be2d6b8779973e41ab54ebcf6c5" rel="noopener">用Python实现时间序列的基础知识</a> <br/> 9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae lh" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>