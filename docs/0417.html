<html>
<head>
<title>3 Frequent Mistakes Data Scientists Make In Their Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家在代码中经常犯的3个错误</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/3-frequent-mistakes-i-see-data-scientists-make-in-their-code-6ae778ce20c?source=collection_archive---------2-----------------------#2020-04-20">https://pub.towardsai.net/3-frequent-mistakes-i-see-data-scientists-make-in-their-code-6ae778ce20c?source=collection_archive---------2-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8134" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是我遇到的一些最常见的错误。消除它们会让你写出更快的代码，更少的代码，以及具有清晰工作流程的代码。</p><h1 id="60f1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">不使用应用功能</h1><p id="ad88" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">无论您使用什么语言，如果您在数据框中迭代，您可能会做错一些事情。你的计算机可以同时处理多件事情，用for或while循环迭代意味着每件事情一次做一件。这里有两种方法可以将相同的函数应用于数据集。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="af2b" class="ma kp it lw b gy mb mc l md me">def function_to_apply(x):<br/>    y = x**2 + 5*x + 10<br/>    return y</span></pre><p id="3baa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缓慢:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="342d" class="ma kp it lw b gy mb mc l md me">for row_number in df.index:<br/>    df.iloc[row_number] = function_to_apply(df.iloc[row_number])</span></pre><p id="28ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">快速:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0677" class="ma kp it lw b gy mb mc l md me">df = df.apply(function_to_apply)</span></pre><p id="0cca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">apply函数内置在pandas中，并将您编写的函数作为参数。这将应用于数据框中的所有行或列，具体取决于可选的轴参数。</p><h1 id="7cbb" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">不使用列表理解</h1><p id="0e1a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这是一个类似于不使用apply函数的概念，但是在python中有一个特定于应用程序的列表。如果您确实在使用python，那么遍历一个列表可能相对较慢或较快，这取决于您的选择。下面是一个简单的例子，将列表中的元素加倍。</p><p id="2bc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缓慢:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2a56" class="ma kp it lw b gy mb mc l md me">for element in your_list:<br/>    element *= 2</span></pre><p id="5eb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">快速:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9451" class="ma kp it lw b gy mb mc l md me">your_list = [element*2 for element in your_list]</span></pre><p id="9a97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一个代码块中，操作一次应用于一个元素。在这个块中，程序被告知对每个元素一次应用一个操作。当应用于元素n的函数依赖于对元素n-1所做的操作时，这是正确的做法。当没有一个元素相互影响时，这是缓慢的。在第二个代码块中，您已经明确地告诉您的程序，没有一个元素依赖于其他元素，因此您的程序可以安全地同时执行所有这些操作。第一次看的时候，语法可能有些混乱，但是它要快得多，并且只占用一行。当您正在处理的列表很小时，这是一个微不足道的区别，但在处理大型数据集时，这是一个节省时间的好方法。如果你需要更深入的教程，这里有一个很好的<a class="ae mf" href="https://www.youtube.com/watch?v=5K08WcjGV6c" rel="noopener ugc nofollow" target="_blank"> one </a>。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mg"><img src="../Images/2932f0a4047bec855f7da32e4c082777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yquPVpKqZPNyRXMYu98NGA.png"/></div></div></figure><h1 id="4d12" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">不使用Sklearn管道</h1><p id="dd56" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这并没有从技术上<em class="mo">改善你的工作，但是它确实让你的工作更具可读性和组织性。以下是RedCarpet创始人Sandeep Srinivasa对此的看法:</em></p><p id="fc58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，您可以在不使用sklearn管道的情况下创建一些复杂的模型，但是如果您没有这样做过，这表明您对数据科学有些陌生。这里有一个来自<a class="ae mf" href="https://scikit-learn.org/stable/auto_examples/compose/plot_column_transformer_mixed_types.html" rel="noopener ugc nofollow" target="_blank"> sklearn文档</a>的例子。在本例中，管道用于拟合泰坦尼克号生存数据集的逻辑回归模型。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7ab6" class="ma kp it lw b gy mb mc l md me">import numpy as np</span><span id="8bbb" class="ma kp it lw b gy mp mc l md me">from sklearn.compose import ColumnTransformer<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.preprocessing import StandardScaler, OneHotEncoder<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.model_selection import train_test_split</span></pre><p id="1689" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用管道函数，我们将步骤作为元组数组输入。元组中的第一个值是作为字符串应用的转换的名称，第二个值是应用的函数。下面，为数字特征创建了一个管线。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7df3" class="ma kp it lw b gy mb mc l md me">numeric_features = ['age', 'fare']<br/>numeric_transformer = Pipeline(steps=[<br/>    ('imputer', SimpleImputer(strategy='median')),<br/>    ('scaler', StandardScaler())])</span></pre><p id="9d7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为分类特征创建了一个管道。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="4f2e" class="ma kp it lw b gy mb mc l md me">categorical_features = ['embarked', 'sex', 'pclass']<br/>categorical_transformer = Pipeline(steps=[<br/>    ('imputer', <br/>     SimpleImputer(strategy='constant', fill_value='missing')),<br/>    ('onehot', OneHotEncoder(handle_unknown='ignore'))])</span></pre><p id="123f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个管道一起用于创建一个称为预处理器的新函数，它进入最终的管道。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1dd2" class="ma kp it lw b gy mb mc l md me">preprocessor = ColumnTransformer(<br/>    transformers=[<br/>        ('num', numeric_transformer, numeric_features),<br/>        ('cat', categorical_transformer, categorical_features)])</span><span id="95e4" class="ma kp it lw b gy mp mc l md me">clf = Pipeline(steps=[('preprocessor', preprocessor),<br/>                      ('classifier', LogisticRegression())])</span><span id="c3bb" class="ma kp it lw b gy mp mc l md me">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)</span><span id="58d5" class="ma kp it lw b gy mp mc l md me">clf.fit(X_train, y_train)</span></pre><p id="3123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">利用这些管道不仅可以让您更好地记录工作，还可以让您更容易地编辑管道。向这些管道中的任何一个添加step都会很快。请利用以上所有！</p></div></div>    
</body>
</html>