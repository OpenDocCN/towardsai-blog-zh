<html>
<head>
<title>Outlier Detection and Treatment: A Beginner's Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异常值检测和处理:初学者指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/outlier-detection-and-treatment-a-beginners-guide-c44af0699754?source=collection_archive---------0-----------------------#2019-05-08">https://pub.towardsai.net/outlier-detection-and-treatment-a-beginners-guide-c44af0699754?source=collection_archive---------0-----------------------#2019-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a3ab" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/6a34d5dc21ed2200fa103300d3213e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N8BVwsKl505JGGZu"/></div></div></figure><p id="8547" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">数据预处理中最重要的步骤之一是异常值的检测和处理。机器学习算法对数据点的范围和分布非常敏感。数据异常值会欺骗训练过程，导致训练时间更长，模型更不准确。离群值被定义为与剩余数据显著不同的样本。这些点位于分布的整体模式之外。均值、方差和相关性等统计指标很容易受到异常值的影响。</p><p id="117e" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这里有一个简单的异常值的例子，一个偏离整体模式的点。</p><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi li"><img src="../Images/497b1a523dce3eba5330b0d89b76a1f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*_JO4KnEiQVRMH8uS.png"/></div></figure><h2 id="3ec4" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">异常值的性质:</h2><p id="6009" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">由于以下原因之一，数据集中可能会出现异常值，</p><ol class=""><li id="b57a" class="mk ml it km b kn ko kr ks kv mm kz mn ld mo lh mp mq mr ms bi translated">数据集中真正的极高值和极低值</li><li id="a7ad" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">由于人为或机械错误而引入</li><li id="9ec0" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">通过替换缺失值引入</li></ol><p id="0f99" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在某些情况下，异常值的存在是有益的，需要进一步研究。例如，异常值在与事务管理相关的用例中非常重要，在这些用例中，异常值可能用于识别潜在的欺诈性事务。</p><p id="9099" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在本文中，我将讨论以下方法来识别数据集中的异常值并处理它们。</p><h2 id="6b2e" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">离群点检测</h2><ul class=""><li id="497e" class="mk ml it km b kn mf kr mg kv my kz mz ld na lh nb mq mr ms bi translated">极值分析</li><li id="38ea" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">z分数法</li><li id="dc98" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">k表示基于聚类的方法</li><li id="5695" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">可视化数据</li></ul><h2 id="7e6c" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">异常值处理</h2><ul class=""><li id="9ad8" class="mk ml it km b kn mf kr mg kv my kz mz ld na lh nb mq mr ms bi translated">均值/中值或随机插补</li><li id="70f5" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">整理</li><li id="b54d" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">顶部、底部和零编码</li><li id="0d95" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">[数]离散化</li></ul><p id="b0b2" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">然而，这些方法都不能提供关于哪些观察值是异常值的客观事实。对于什么构成异常值，没有严格的数学定义；确定一个观察值是否是异常值最终是一项主观的工作，这在很大程度上取决于业务问题。因此，本文中讨论的方法可以作为识别数据中应该被视为异常值的点的起点。</p><h1 id="da46" class="nc lo it bd lp nd ne nf ls ng nh ni lv nj nk nl ly nm nn no mb np nq nr me ns bi translated">检测异常值的方法:</h1><p id="2033" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">有多种方法可以识别数据集中的异常值。我将在本文中讨论以下类型。</p><ol class=""><li id="8a9a" class="mk ml it km b kn ko kr ks kv mm kz mn ld mo lh mp mq mr ms bi translated">极值分析</li><li id="f323" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">z分数法</li><li id="cc9a" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">k表示基于聚类的方法</li><li id="f0d1" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">可视化数据</li></ol><p id="9603" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">重要的是要重申，这些方法不应该机械地使用。它们应该用于探索数据。它们让你知道哪些点可能值得仔细观察。</p><h2 id="ed0e" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">数据集:</h2><p id="57e6" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">我将使用来自Kaggle的<a class="ae nt" href="https://www.kaggle.com/wendykan/lending-club-loan-data" rel="noopener ugc nofollow" target="_blank"> Lending Club贷款数据集</a>来演示本文中的示例。</p><p id="9c67" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">导入库</strong></p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="2e38" class="ln lo it nv b gy nz oa l ob oc">import pandas as pd<br/>import numpy as np <br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><p id="4362" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">导入数据集</strong></p><p id="c445" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在，让我们从CSV文件中导入<em class="od">年收入(annual_inc) </em>列，并识别离群值。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="7c13" class="ln lo it nv b gy nz oa l ob oc">use_cols = ['annual_inc']<br/>data = pd.read_csv('loan.csv', usecols=use_cols, nrows = 30000)</span></pre><h2 id="a999" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">极值分析:</h2><p id="3ee5" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">异常值检测的最基本形式是极值分析。这种方法的关键是确定变量基本分布的统计尾部，并找到尾部最末端的值。</p><p id="6477" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在高斯分布的情况下，异常值将位于变量标准偏差的平均值正或负3倍之外。</p><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c115d5c31e6bacbf57c77fad7b5aeee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/0*5saB6Xk7nJUw5znA"/></div></figure><p id="b67b" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果变量不是正态分布(非高斯分布)，通常的方法是计算分位数，然后计算四分位间距。</p><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ceb11cd504551635344dca20f9fb34e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*--A4bIwuWmNjstRt.jpg"/></div></figure><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="7e0f" class="ln lo it nv b gy nz oa l ob oc">IQR (Inter quantiles range)= 75th quantile — 25th quantile</span></pre><p id="a32f" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">异常值将位于以下上限和下限:</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="8090" class="ln lo it nv b gy nz oa l ob oc">Upper Boundary = 75th quantile +(IQR * 1.5)</span><span id="49e6" class="ln lo it nv b gy og oa l ob oc">Lower Boundary = 25th quantile — (IQR * 1.5)</span></pre><p id="2918" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">或者在极端情况下:</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="db8a" class="ln lo it nv b gy nz oa l ob oc">Upper Boundary = 75th quantile +(IQR * 3)</span><span id="dd16" class="ln lo it nv b gy og oa l ob oc">Lower Boundary = 25th quantile — (IQR * 3)</span></pre><p id="5a06" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果数据点在上边界之上或在下边界之下，它可以被认为是异常值。</p><p id="3a3b" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">代码:</strong></p><p id="1664" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">首先，让我们计算数据集的分位数区间，</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="9e9a" class="ln lo it nv b gy nz oa l ob oc">IQR = data.annual_inc.quantile(0.75) - data.annual_inc.quantile(0.25)</span></pre><p id="864c" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">使用IQR，我们使用上面提到的公式计算上边界，</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="d51e" class="ln lo it nv b gy nz oa l ob oc">upper_limit = data.annual_inc.quantile(0.75) + (IQR * 1.5)<br/>upper_limit_extreme = data.annual_inc.quantile(0.75) + (IQR * 3)</span><span id="4bc8" class="ln lo it nv b gy og oa l ob oc">upper_limit, upper_limit_extreme</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bfcd062af343b2119b6f661db454979c.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*t5tLk9O79vByt_CfIWeyxg.png"/></div></figure><p id="f010" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在，让我们看看高于上限&amp;极端上限的数据点的比率。即异常值。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="9afa" class="ln lo it nv b gy nz oa l ob oc">total = np.float(data.shape[0])<br/>print('Total borrowers: {}'.format(data.annual_inc.shape[0]/total))<br/>print('Borrowers that earn &gt; 178k: {}'.format(data[data.annual_inc&gt;178000].shape[0]/total))<br/>print('Borrowers that earn &gt; 256k: {}'.format(data[data.annual_inc&gt;256000].shape[0]/total))</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/417a246452ab756a0a1646d8220f8a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*pGxURa0pIomBCOdzVxj6Xg.png"/></div></figure><p id="256f" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们可以看到，大约有5%的数据在上限以上，1%的数据在极限上限以上。</p><h2 id="b0bb" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">标准分数(Z分数):</h2><p id="86ed" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">Z分数(或标准分数)表示给定测量值偏离平均值的标准偏差。换句话说，它只是重新调整或标准化您的数据。Z值用于指定分布中每个观测值的精确位置。Z分数的符号(+或—)表示分数是高于平均值(+)还是低于平均值(—)。</p><p id="810d" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">获取Z分数的目的是消除数据的位置和比例的影响，从而可以直接比较不同的数据集。异常值检测的Z分数方法背后的直觉是，一旦我们对数据进行了居中和重新调整，任何离零太远的东西(阈值通常是3或-3的Z分数)都应被视为异常值。</p><p id="c09a" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">计算Z分数的公式是:</p><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7132d05fd61c51e0786964b5402bce74.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*8T-SPIy32LbS1SdrL-obnw.png"/></div></figure><p id="134e" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">代号:</strong></p><p id="c89b" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">导入库</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="81f3" class="ln lo it nv b gy nz oa l ob oc">from scipy import stats</span></pre><p id="19f7" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">计算Z分数</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="afbc" class="ln lo it nv b gy nz oa l ob oc">z = stats.zscore(data)<br/>print(z)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7d6b61357cfa1244fe3852fe1258e3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*L9DRVSYxBLoHXZrXenmSbA.png"/></div></figure><p id="1d0e" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">阈值&gt; 3</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="13bb" class="ln lo it nv b gy nz oa l ob oc">threshold = 3<br/>print(np.where(z &gt; 3))</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/6cd51ea6183aff287a0017a00b2a8631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*UreImxd5-4Vc7nCuTx9cFg.png"/></div></figure><p id="b5fb" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在上面的输出中，第一个数组包含行号列表，第二个数组包含相应的列号。</p><h2 id="3daf" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">聚类方法:</h2><p id="d626" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">聚类是一种流行的技术，用于将相似的数据点或对象分组或聚类。它也可以作为异常值分析的重要工具。在这种方法中，我们首先将相似种类的对象分组。</p><p id="6c74" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们将使用K-Means聚类，这将帮助我们对数据点(在我们的例子中是年收入值)进行聚类。我们将用于KMeans的实现使用欧几里德距离来对相似的对象进行分组。让我们开始吧。</p><p id="05bd" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">代号:</strong></p><p id="d2e4" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">导入库</strong></p><p id="c771" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们现在将从scipy.cluster.vq导入kmeans模块。</p><p id="be66" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">SciPy <strong class="km jd"> </strong>代表<em class="od"> Sci </em> entific Python，为执行科学实验提供了各种方便的实用程序。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="d504" class="ln lo it nv b gy nz oa l ob oc">from scipy.cluster.vq import kmeans<br/>from scipy.cluster.vq import vq</span></pre><p id="efcd" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在，让我们将数据转换成一个numpy数组，并应用K-Means函数。我们必须给出两个输入——数据和要形成的集群的数量。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="7344" class="ln lo it nv b gy nz oa l ob oc">data_raw = data['disbursed_amount'].value<br/>centroids, avg_distance = kmeans(data_raw, 4)<br/>groups, cdist = vq(data_raw, centroids)</span></pre><p id="ce59" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">质心是由means()生成的聚类的中心，avg_distance是数据点和由kmeans()生成的质心之间的平均欧氏距离。下一步是调用vq()方法。它返回数据点的组(聚类)以及数据点与其最近的组之间的距离。</p><p id="2366" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在让我们画出我们得到的组。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="c284" class="ln lo it nv b gy nz oa l ob oc">y = np.arange(0,30000)<br/>plt.scatter(data_raw,  y , c=groups)<br/>plt.xlabel('Salaries')<br/>plt.ylabel('Indices')<br/>plt.show()</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2bb1aa437afe2a2700af0f163e983ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*DmkGim0xO-ABgFU-58ggPg.png"/></div></figure><p id="ac80" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我相信你能够从上面的图表中找出异常值。</p><h2 id="f8e4" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">图形方法:</h2><p id="438d" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">正如我在我的<a class="ae nt" href="https://towardsdatascience.com/exploratory-data-analysis-in-python-ebdf643a33f6" rel="noopener" target="_blank">上一篇文章</a>中提到的，箱线图、直方图和散点图主要用于识别数据集中的异常值。</p><p id="8813" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">箱线图</strong></p><p id="88e9" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">箱线图，也称为晶须图，是一种图形方法，通常用四分位数和四分位数间距来描述，有助于定义上限和下限，超出上限和下限的任何数据都将被视为异常值。</p><p id="3a42" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">简而言之，分位数是分布中与该分布中值的等级顺序相关的点。对于给定的样本，您可以通过对样本进行排序来找到任何分位数。排序样本的中间值是中间分位数或第50个百分位数(也称为样本的中位数)。</p><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi on"><img src="../Images/1b965455968fe3777d00f31042314463.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*3Q-UXuMVNtn3nR3rnydRmw.png"/></div></figure><p id="af0b" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">箱线图的真正目的是在进行任何进一步分析之前识别数据序列中的异常值，以便从研究中得出的结论给出更准确的结果，不受任何极端值或异常值的影响。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="38f2" class="ln lo it nv b gy nz oa l ob oc">sns.boxplot(y='annual_inc', data = data)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/352e8e25489c7f858c560bc4a4c63326.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*6YUd1RZtqO4lrdl54YJnIg.png"/></div></figure><p id="5d59" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在这里，异常值是在数值上远离其余数据的观察值。查看箱线图时，异常值是指位于箱线图围栏(“须”)之外的数据点。</p><p id="946e" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">直方图</strong></p><p id="1b8c" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">直方图是最常用的图表之一，用于显示数字数据和查找数据集的分布。离群值是位于总体分布模式之外的观察值。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="da8a" class="ln lo it nv b gy nz oa l ob oc">fig = data.annual_inc.hist(bins=500)<br/>fig.set_xlim(0,500000)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b5e48784e57e92b5e577ec78da1d0db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*ej44o3sH3-_5lSfelRL0bg.png"/></div></figure><p id="7485" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这里，x轴最右端的数据点可以视为异常值。</p><p id="5396" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">散点图</strong></p><p id="71da" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">散点图用于寻找两个变量之间的关联，这种关联通常有一个模式。如果一个数据点不符合模式，我们称之为异常值。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="1c44" class="ln lo it nv b gy nz oa l ob oc">data_raw<strong class="nv jd"> = d</strong>ata['annual_inc'].values<br/>y = np.arange(0,30000)<br/>plt.scatter(data_raw,  y)<br/>plt.xlabel('Annual Income')<br/>plt.ylabel('Indices')<br/>plt.show()</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi op"><img src="../Images/dbac58dd172fb86abe587984616b3052.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*KPD03p798k9duA7znSOpMg.png"/></div></figure><h1 id="e1b3" class="nc lo it bd lp nd ne nf ls ng nh ni lv nj nk nl ly nm nn no mb np nq nr me ns bi translated">预处理异常值的方法:</h1><ol class=""><li id="f096" class="mk ml it km b kn mf kr mg kv my kz mz ld na lh mp mq mr ms bi translated">均值/中值或随机插补</li><li id="2c6a" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">整理</li><li id="9d12" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">顶部、底部和零编码</li><li id="15d4" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated">[数]离散化</li></ol><h2 id="a219" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">平均值/中间值/随机抽样:</h2><p id="a829" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">假设我们有理由相信异常值是由于测量过程中的机械误差或问题造成的。这意味着，离群值在本质上类似于缺失数据，那么任何用于缺失数据插补的方法都可以用来替换离群值。离群值的数量很小(否则，它们就不会被称为离群值)，使用均值/中值/随机插补来代替它们是合理的。</p><p id="55b0" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我将在另一篇专门讨论缺失值的文章中讨论缺失值的插补。与此同时，如果你需要同样的任何来源，<a class="ae nt" href="https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779" rel="noopener" target="_blank">看看这个</a>。</p><h2 id="c77f" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">修整:</h2><p id="bfbc" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">在这种方法中，我们完全丢弃了异常值。也就是说，消除被认为是异常值的数据点。在不需要从数据集中移除大量值的情况下，修剪是一种快速有效的方法。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="8340" class="ln lo it nv b gy nz oa l ob oc">index = data[(data['annual_inc'] &gt;= 256000)].index<br/>data.drop(index, inplace=True)</span></pre><p id="c568" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这里，我们使用pandas的drop方法删除所有超过上限值的记录，这些记录是使用极值分析找到的。</p><h2 id="7edd" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">顶部/底部/零编码:</h2><p id="5359" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated"><strong class="km jd">顶部编码</strong>是指将分布的最大值限制在任意设定值。顶部编码变量是指上限以上的数据点被删除的变量。通过实施top编码，异常值被限制在某个最大值，看起来像许多其他观察值。</p><p id="142e" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">底部编码</strong>类似，但在分布的左侧。也就是说，低于某个阈值的所有值都以该阈值为上限。如果阈值为零，则称为<strong class="km jd">零编码</strong>。例如，对于像“年龄”或“收入”这样的变量，不可能有负值。因此，将最低值限制为零是合理的。</p><p id="f807" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">代码:</strong></p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="d9df" class="ln lo it nv b gy nz oa l ob oc">print('Annual Income &gt; 256000: {}'.format(data[data.annual_inc&gt;256000].shape[0]))<br/>print('Percentage of outliers: {}'.format(data[data.annual_inc&gt;256000].shape[0]/np.float(data.shape[0])))</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4d476273edd0ceba488cf845ada95ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*D5daurhwOhcQJQagdnSSuA.png"/></div></figure><p id="68e8" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在这一步中，我们用大于256000到256000的值来限制数据点。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="742e" class="ln lo it nv b gy nz oa l ob oc">data.loc[data.annual_inc&gt;256000,'annual_inc'] = 256000<br/>data.annual_inc.max()</span></pre><p id="45bd" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在，最大值将显示为256000。</p><h2 id="7d3e" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">离散化:</h2><p id="8715" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">离散化是通过创建一组跨越变量值范围的连续区间，将连续变量转换为离散变量的过程。因此，这些异常值不再与分布尾部的其余值不同，因为它们现在都在同一区间/时段中。</p><p id="4bae" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">有几种方法可以将连续变量转化为离散变量。这个过程也被称为<strong class="km jd">宁滨</strong>，每个面元就是每个区间。</p><h2 id="0c72" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">离散化方法</h2><ul class=""><li id="8ac6" class="mk ml it km b kn mf kr mg kv my kz mz ld na lh nb mq mr ms bi translated">等宽宁滨</li><li id="64d0" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh nb mq mr ms bi translated">等频宁滨</li></ul><h2 id="4636" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated"><strong class="ak">等频率离散化</strong></h2><p id="f03b" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">等频宁滨将变量的可能值分成N个箱，每个箱携带相同数量的观测值。这对于偏斜变量特别有用，因为它将观察值平均分布在不同的条柱上。通常，我们通过确定分位数来找到区间边界。这将有助于最大限度地减少信息损失，并产生更好的结果。</p><p id="bfec" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这里，我们使用pandas qcut函数(基于分位数的离散化函数)创建5个箱</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="8146" class="ln lo it nv b gy nz oa l ob oc">income_discretised, intervals = pd.qcut(data.annual_inc, 5, labels=None, retbins=True, precision=3, duplicates='raise')<br/>pd.concat([income_discretised, data.annual_inc], axis=1).head(5)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi or"><img src="../Images/5626481a394f1c13ed1d0c5e5adb8be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*uRW8E-j8eyuwvymU0vNJfA.png"/></div></figure><p id="cd53" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">间隔是，</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="6322" class="ln lo it nv b gy nz oa l ob oc">intervals</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi os"><img src="../Images/6580e16c756d9386f33a6891d6b443a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*oAlR40abRgmTl5DmT0eZBg.png"/></div></figure><p id="b0e6" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">下面我们可以看到，在每个区间中几乎有相同数量的观测值。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="4098" class="ln lo it nv b gy nz oa l ob oc">temp = pd.concat([income_discretised, data.annual_inc], axis=1)<br/>temp.columns = ['income_discretised', 'annual_inc']<br/>temp.groupby('income_discretised')['annual_inc'].count()</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/eaf4c8eaff0f86ec6b79bf73f06a7ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*zzsOLPTzckVgBKuguKOzpQ.png"/></div></figure><h2 id="6539" class="ln lo it bd lp lq lr dn ls lt lu dp lv kv lw lx ly kz lz ma mb ld mc md me iz bi translated">等宽离散化</h2><p id="1b61" class="pw-post-body-paragraph kk kl it km b kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh im bi translated">等宽宁滨将可能值的范围划分为N个等宽的条柱。宽度由变量中值的范围和我们希望用来划分变量的箱数决定。</p><p id="c9c3" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">宽度=(最大值-最小值)/ N</p><p id="95e1" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">例如，如果变量的值在0和100之间变化，我们创建5个这样的容器:宽度=(100–0)/5 = 20。第一个和最后一个箱(0–20和80–100)可以扩展以容纳异常值(也就是说，小于0或大于100的值也将放入这些箱中)。</p><p id="6119" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">没有定义n的经验法则，它取决于用例。</p><p id="e3db" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">代码:</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="fcb1" class="ln lo it nv b gy nz oa l ob oc">income_range = data.annual_inc.max() - data.annual_inc.min()<br/>min_value = int(np.floor(data.annual_inc.min()))<br/>max_value = int(np.ceil(data.annual_inc.max()))<br/> <br/># let's round the bin width<br/>inter_value = int(np.round(income_range/5))<br/> <br/>min_value, max_value, inter_value</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/97feacf30472c447c305fbb627eeb236.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*lQw9QMV29mgVNc7xUwO1vw.png"/></div></figure><p id="13c8" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在我们正在计算间隔，</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="e7b5" class="ln lo it nv b gy nz oa l ob oc">intervals = [i for i in range(min_value, max_value+inter_value, inter_value)]<br/>labels = ['Bin_'+str(i) for i in range(1,len(intervals))]<br/>print(intervals)<br/>print(labels)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/93a27258573504cf72b1c487dc9bb2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*kBMSVN66x-6_n1HUSZz3UQ.png"/></div></figure><p id="8b99" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">最后，我们使用pandas cut函数对数据值进行分段和分类。</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="35cd" class="ln lo it nv b gy nz oa l ob oc">data['annual_inc_labels'] = pd.cut(x = data.annual_inc, bins=intervals, labels=labels, include_lowest=True)<br/>data['annual_inc_interval'] = pd.cut(x = data.annual_inc, bins=intervals, include_lowest=True)<br/>data.head(5)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/abff835e0ec11b3acf9ac8e752d40f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*_Q5Vf0L_2HfJ-49J-PUcMA.png"/></div></figure><p id="c8ff" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们可以使用计数图对每个箱中的数据进行计数，如下所示。我们可以看到，在给定的样本数据集中，大多数人的年收入低于10000英镑</p><pre class="lj lk ll lm gt nu nv nw nx aw ny bi"><span id="31a3" class="ln lo it nv b gy nz oa l ob oc">sns.countplot(data.annual_inc_labels)</span></pre><figure class="lj lk ll lm gt kd gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/7a1b5755f1de129bb285f13d0d0c33b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*26idnVAc-Gi8Jx7z2WvyCA.png"/></div></figure><p id="d547" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我希望这篇文章对你有用。随意留下你的想法！</p><p id="f628" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">参考资料:</p><ol class=""><li id="03fe" class="mk ml it km b kn ko kr ks kv mm kz mn ld mo lh mp mq mr ms bi translated"><a class="ae nt" href="https://www.udemy.com/feature-engineering-for-machine-learning/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/feature-engineering-for-machine-learning/</a></li><li id="4e29" class="mk ml it km b kn mt kr mu kv mv kz mw ld mx lh mp mq mr ms bi translated"><a class="ae nt" href="https://blog.floydhub.com/introduction-to-anomaly-detection-in-python/" rel="noopener ugc nofollow" target="_blank">https://blog . floydhub . com/introduction-to-anomaly-detection-in-python/</a></li></ol></div></div>    
</body>
</html>