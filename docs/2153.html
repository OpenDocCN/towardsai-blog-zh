<html>
<head>
<title>Test for Normality Using Python: Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python测试正态性:完全指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/test-for-normality-using-python-complete-guide-5ae98fb24c2a?source=collection_archive---------0-----------------------#2021-09-05">https://pub.towardsai.net/test-for-normality-using-python-complete-guide-5ae98fb24c2a?source=collection_archive---------0-----------------------#2021-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="64e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，我们将探索如何使用Python测试正态性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c760d1e3c2156a460baa1c92dd01287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*cQSC7rRI0IqE3WzJfcpMiw.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://unsplash.com/@marcinjozwiak?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Marcin Jozwiak </a>在<a class="ae ku" href="https://unsplash.com/s/photos/distribution?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="58e2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">目录</strong></p><ul class=""><li id="68d0" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">介绍</li><li id="46f6" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">正态性检验的样本数据</li><li id="b9ea" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的Q-Q图</li><li id="44fb" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的Jarque-Bera测试</li><li id="fd7a" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的Kolmogorov-Smirnov测试</li><li id="451c" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的Anderson-Darling测试</li><li id="d944" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python中的夏皮罗-维尔克测试</li><li id="6b35" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">正态性检验结果比较</li><li id="fec2" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">结论</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e3c4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">介绍</h1><p id="f95d" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">在本教程中，我们将对微软股票回报的52个观察值的样本数据执行Python中的Jarque-Bera测试、Python中的Kolmogorov-Smirnov测试、Python中的Anderson-Darling测试和Python中的Shapiro-维尔克测试。</p><p id="84de" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们还会比较每个测试的结果，并提及它们的优缺点。</p><p id="e105" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要继续学习本教程，我们需要以下Python库:</p><p id="446f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="nj">熊猫</em>、<em class="nj"> numpy </em>、<em class="nj"> matplotlib </em>、<em class="nj"> seaborn </em>和<em class="nj"> scipy </em>。</p><p id="00b2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您没有安装它，请打开“命令提示符”(在Windows上)并使用以下代码安装它:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="aa2b" class="np mn it nl b gy nq nr l ns nt">pip install pandas<br/>pip install numpy<br/>pip install matplotlib<br/>pip install seaborn<br/>pip install scipy</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="fba7" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">正态性检验的样本数据</h1><p id="c6b5" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">在本文中，我们将研究微软股票的每周历史收益率。让我们考虑2018年1月1日到2018年12月31日之间的时间段。这些数据可以很容易地从雅虎上下载。财务。</p><p id="1dde" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">继续下载数据。csv格式，并将其保存在与。py文件和我们将要构建的代码。</p><p id="af04" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们已经下载了数据，让我们将它导入Python并选择具有观察日期和收盘价的列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4f76" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">显示带有股票价格的前几行数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="bf77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="859e" class="np mn it nl b gy nq nr l ns nt">   Date        Close<br/>0  2018-01-01  88.190002<br/>1  2018-01-08  89.599998<br/>2  2018-01-15  90.000000</span></pre><p id="94d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如您将看到的，该文件包含53周的微软股票价格数据。现在，我们想处理股票的回报，而不是价格本身，所以我们需要做一些数据处理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="785a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">显示股票收益数据的前几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6efd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="8c21" class="np mn it nl b gy nq nr l ns nt">   Date        return<br/>0  2018-01-01  0.015988<br/>1  2018-01-08  0.004464<br/>2  2018-01-15  0.045111</span></pre><p id="1792" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了更好地理解这些数据，特别是为什么我们要将价格转换为回报，然后我们要使用Python来测试其正态性，让我们使用直方图来可视化数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a22e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们得到了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/108072f54ac37a2f393d59f1de60615b.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/0*MoFEtAgolwCPpEb6"/></div></figure><p id="ab29" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，数据的分布看起来有点像正态分布。但真的是这样吗？这就是我们将在接下来的章节中使用不同的统计方法来回答的问题！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="86ca" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Python中的Q-Q图</h1><p id="b448" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">我们将从一种更直观、更少数学的方法开始，分位数-分位数图。</p><p id="9ba7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">什么是分位数-分位数图？该图显示了给定数据相对于正态分布的分布，即现有分位数相对于正态理论分位数。</p><p id="a682" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们使用Python为我们的数据创建Q-Q图，然后解释结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d323" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/aa0a0e8884a888e905a7d2ebe516526a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*KZlH7vq8mF4S13MX"/></div></figure><p id="5ff2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">看上面的图表，我们看到一个向上倾斜的线性关系。对于正态分布，观察值应该都出现在45度直线上。我们在上面看到这样的关系了吗？我们做了一部分。所以这可以告诉我们的是，我们正在研究的分布并不完全是正态分布，而是接近正态分布。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="9301" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Python中的Jarque-Bera测试</h1><p id="96a5" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">Jarque-Bera是一种正态性测试，或者具体来说是一种将<a class="ae ku" href="https://pyshark.com/skewness-in-python/" rel="noopener ugc nofollow" target="_blank">偏斜度</a>和<a class="ae ku" href="https://pyshark.com/kurtosis-in-python/" rel="noopener ugc nofollow" target="_blank">峰度</a>与正态分布相匹配的拟合优度测试。</p><p id="c5e9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它的统计量是非负的，大值表示明显偏离正态分布。</p><p id="4bdb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Jarque-Bera的测试统计量JB定义如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5785887c8756ff65bfe4808357f07859.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*sKyOoHixAPLblRGrf8mDxg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="bff0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中<strong class="kx iu"> S </strong>为样本<a class="ae ku" href="https://pyshark.com/skewness-in-python/" rel="noopener ugc nofollow" target="_blank">偏度</a>，<strong class="kx iu"> K </strong>为样本<a class="ae ku" href="https://pyshark.com/kurtosis-in-python/" rel="noopener ugc nofollow" target="_blank">峰度</a>，<strong class="kx iu"> n </strong>为样本量。</p><p id="f25b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi nz"><img src="../Images/a66cbc980eeea517a2d9012b0bd26944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEplVMO848cehzC-3t9mhg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="5ac7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们可以用Python计算Jarque-Bera测试统计量，并找到相应的p值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8e03" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="a2b9" class="np mn it nl b gy nq nr l ns nt">JB statistic: 1.937410519618088<br/>p-value: 0.37957417002405025</span></pre><p id="a25f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">查看这些结果，我们无法拒绝零假设，并得出样本数据遵循正态分布的结论。</p><p id="6381" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:Jarque-Bera检验在大样本(通常大于2000个观察值)中工作正常，其统计量具有2个自由度的卡方分布。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="df59" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Python中的Kolmogorov-Smirnov测试</h1><p id="147a" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">最常见的正态性检验之一是Kolmogorov-Smirnov检验(或K-S检验)。与其他检验相比，Kolmogorov-Smirnov检验的一个主要优点是非参数的，这意味着它是无分布的。</p><p id="661c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里我们关注单样本Kolmogorov-Smirnov检验，因为我们希望将一维概率分布与理论上指定的分布(在我们的例子中是正态分布)进行比较。</p><p id="f1bc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Kolmogorov-Smirnov检验统计量测量样本的经验分布函数(ECDF)和参考分布的累积分布函数之间的距离。</p><p id="cb61" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们的例子中，经验分布函数将来自我们之前收集的收益数据。由于我们将它与正态分布进行比较，我们将使用正态分布的累积分布函数。</p><p id="b2ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">到目前为止，这听起来非常专业，所以让我们试着把它分解并形象化，以便更好地理解。</p><p id="42c4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第一步:</strong></p><p id="622b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们用回报率数据的平均值和标准差从正态分布中创建一个值数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a983" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用<a class="ae ku" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.normal.html" rel="noopener ugc nofollow" target="_blank"> np.random.normal() </a>我们创建了<strong class="kx iu"> data_norm </strong>，这是一个具有与<strong class="kx iu">df[' return ']【T7]相同数量的观察值的数组，并且具有相同的平均值和标准偏差。</strong></p><p id="8d7c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里的直觉是，如果我们假设分布的一些参数(均值和标准差)，那么具有这些参数的数字将形成正态分布。</p><p id="7c86" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第二步:</strong></p><p id="0018" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们要做的是在两个数据集上使用<a class="ae ku" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram.html" rel="noopener ugc nofollow" target="_blank"> np.histogram() </a>对它们进行排序，并将其分配到箱中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1a27" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:默认情况下，该函数将使用<strong class="kx iu">bin = 10</strong>，您可以根据正在处理的数据进行调整。</p><p id="b200" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第三步:</strong></p><p id="4632" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用<a class="ae ku" href="https://numpy.org/doc/stable/reference/generated/numpy.cumsum.html" rel="noopener ugc nofollow" target="_blank"> np.cumsum() </a>计算上面创建的数组的累积和:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="effe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第四步:</strong></p><p id="6aeb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">绘制累积分布函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c81e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您应该得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cafae3a009560f4178a3db560084104d.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/0*_ZFiewVba2UNoEEX"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="53e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中蓝线是<strong class="kx iu">df[‘收益’]</strong>的ECDF(经验累积分布函数)，绿线是正态分布的CDF。</p><p id="144c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第四步备选</strong>:</p><p id="f061" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您可以使用seaborn更快地创建图形，并且只需要步骤1中的<strong class="kx iu"> df['return'] </strong>和<strong class="kx iu"> data_norm </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="377a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您应该得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/05ceb3ec4b89e4427f3af43ce9a0b1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/0*RrMB3J2DIR6aJg-3"/></div></figure><p id="f592" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在可视化这两个累积分布函数之后，现在让我们回到Kolmogorov-Smirnov测试。Kolmogorov-Smirnov检验基于这两条曲线(蓝色-绿色)之间的最大距离，并有以下假设:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4a5e4fc9891938f5f05dff1396fcb338.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*NqtsI-71dmbreNrNzII52Q.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="d92e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将ECDF定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/42b91bac75fb3e30a26904bd184cb8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*SLSZt1UYNV8ThozpMJhkpg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="bdab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它计算低于水平<strong class="kx iu"> x </strong>的样本观察值的比例。</p><p id="6203" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们定义一个给定的(理论上的)CDF为:<strong class="kx iu"> F(x) </strong>。在检验正态性的情况下，<strong class="kx iu"> F(x) </strong>是正态分布的CDF。</p><p id="40fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Kolmogorov-Smirnov统计量定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/3046ed250ff5a737e5be43b475d08ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*_Bxyh6KLXzr7FP088FFvsw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="249e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">直观地说，该统计测量所有<strong class="kx iu"> x </strong>值的两个分布函数之间的最大绝对距离。</p><p id="5be4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用上面的图表，这是我估计的上确界:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bb2bfeca20fcfabe90b88afaff7f54e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/0*6ObG0Ji42YK92XJu"/></div></figure><p id="46fa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">计算<strong class="kx iu"> D_n </strong>的值，并与<strong class="kx iu"> D_{0.05} </strong>的临界值(假设5%)进行比较，可以拒绝或者不拒绝零假设。</p><p id="41bc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">回到我们的例子，让我们用Python对微软股票回报数据执行K-S测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="55d4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6a87" class="np mn it nl b gy nq nr l ns nt">K-S statistic: 0.46976096086398267<br/>p-value: 4.788934452701707e-11</span></pre><p id="5560" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于p值明显小于0.05，我们拒绝零假设，接受另一个假设，即测试的两个样本不是来自同一个累积分布，这意味着微软股票的回报不是正态分布。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="2711" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Python中的Anderson-Darling测试</h1><p id="4861" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">安德森-达林试验(A-D试验)是对上述<a class="ae ku" href="https://pyshark.com/test-for-normality-using-python/#kolmogorov-smirnov-test-in-python" rel="noopener ugc nofollow" target="_blank">科尔莫戈罗夫-斯米尔诺夫试验</a>的改进。它测试给定的观察样本是否来自给定的概率分布(在我们的例子中，来自正态分布)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8880a275d0c85a4d3f6044604d259b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*6H7JINXOiFwNQzATv5K53g.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="c86d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">A-D检验比K-S检验更有效，因为它考虑了数据中的所有值，而不仅仅是产生最大距离的值(如K-S检验)。它还为拟合分布的尾部分配更多的权重。</p><p id="9af4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该检验属于二次经验分布函数(EDF)统计，由下式给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/5661ea3b1beeadac5138ee02a83ecd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*cSpVSfissT9k-ryQUS7DLg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="8b2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中<strong class="kx iu"> F </strong>是假设的分布(在我们的例子中是正态分布)，<strong class="kx iu"> F_n </strong>是ECDF(计算方法在<a class="ae ku" href="https://pyshark.com/test-for-normality-using-python/#kolmogorov-smirnov-test-in-python" rel="noopener ugc nofollow" target="_blank">前面的章节</a>中讨论过)，而<strong class="kx iu"> w(x) </strong>是加权函数。</p><p id="8fca" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">加权函数由下式给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/4b67ed2e80fe459c889fb61bec7658ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*abI58wpG7hSZ5r9Tl3hLMw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="0adf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这允许对分布尾部的观察值给予更大的权重。</p><p id="512d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">给定这样的加权函数，测试统计可以简化为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/93f0fb5c1ffb2c80259518d7721b963e.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*gfXW7c_cCxOOdXFQHK23WA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="af88" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们有一个数据样本\(X\)，我们想测试这个样本是否来自正态分布的累积分布函数(\(F(x)\)。</p><p id="c2d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们需要对数据进行排序，以便{x_1 &lt; x_2 &lt; … &lt; x_n} and then compute the <strong class="kx iu"> A </strong>统计为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/43c07109a6f80f65aa4111cae7713d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*xAGqQpMWhiVXcakagEksqQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="c3d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">回到我们的例子，让我们用Python对微软股票回报数据执行A-D测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e33a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3fb5" class="np mn it nl b gy nq nr l ns nt">A-D statistic: 0.3693823006816217<br/>Critical values: [0.539 0.614 0.737 0.86 1.023]<br/>Significance levels: [15. 10. 5. 2.5 1. ]</span></pre><p id="02f4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出的第一行是A-D检验统计量，大约为0.37；输出的第三行是具有不同显著性级别(从15%到1%)的列表；输出的第二行是相应显著性水平的临界值列表。</p><p id="319f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们想在5%的水平上测试我们的假设，这意味着我们将使用的临界值是0.737(来自上面的输出)。由于计算机A-D检验统计量(0.37)小于临界值(0.737)，我们无法拒绝零假设，并得出微软股票收益率的样本数据来自正态分布的结论。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="bb50" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Python中的夏皮罗-维尔克测试</h1><p id="e6d6" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">夏皮罗-维尔克检验(S-W检验)是统计学中的另一种正态性检验，假设如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi oo"><img src="../Images/e4fa449bbb30b332f074158012694d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KhXQWBKBtbrsCt7z.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="68dd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">与<a class="ae ku" href="https://pyshark.com/test-for-normality-using-python/#kolmogorov-smirnov-test-in-python" rel="noopener ugc nofollow" target="_blank"> Kolmogorov-Smirnov测试</a>和<a class="ae ku" href="https://pyshark.com/test-for-normality-using-python/#anderson-darling-test-in-python" rel="noopener ugc nofollow" target="_blank"> Anderson-Darling测试</a>不同，它不基于ECDF和CDF进行统计计算，而是使用从正态分布样本的矩生成的常数。</p><p id="79f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">沙皮罗-维尔克检验统计量定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ad6c5c129cb25f23c8cce71af9819acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*zv50ax_8g-LORe1BKiY65A.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><p id="d652" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中<strong class="kx iu"> x_{(i)} </strong>是样本中第(I)个最小的数(x _ { 1 }&lt;x _ { 2 }&lt;…&lt;x _ { n })；和<strong class="kx iu"> a_i </strong>是从<a class="ae ku" href="https://pyshark.com/compute-variance-covariance-matrix-using-python/" rel="noopener ugc nofollow" target="_blank"> var </a>、<a class="ae ku" href="https://pyshark.com/compute-variance-covariance-matrix-using-python/" rel="noopener ugc nofollow" target="_blank"> cov </a>生成的常数，表示正态分布样本。</p><p id="bb8b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">回到我们的例子，让我们用Python对微软股票回报数据执行S-W测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4a76" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="12da" class="np mn it nl b gy nq nr l ns nt">S-W statistic: 0.9772366881370544<br/>p-value: 0.41611215472221375</span></pre><p id="13fa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">给定大于0.05 (&gt;0.05)的大p值(0.42)，我们无法拒绝零假设并得出样本与正态分布没有显著差异的结论。</p><p id="87b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:这个测试的最大限制之一是大小偏差，这意味着样本越大，你越有可能得到一个有统计学意义的结果。</p><h1 id="0f35" class="mm mn it bd mo mp oq mr ms mt or mv mw jz os ka my kc ot kd na kf ou kg nc nd bi translated">正态性检验结果比较</h1><p id="12fb" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">下表列出了本文中讨论的正态性检验的结果，以及它们使用52个微软股票回报观察值的样本大小的表现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ov"><img src="../Images/5c012e4f54a97b9d13cacefc490ffa3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCTdolCF9Exc5hz0c-VNiA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="be27" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="e24c" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">在本文中，我们讨论了如何使用Python和scipy库测试正态性。</p><p id="73a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们用Python进行了Jarque-Bera检验，用Python进行了Kolmogorov-Smirnov检验，用Python进行了Anderson-Darling检验，用Python进行了Shapiro-维尔克检验。我们还比较了每个测试的结果，并提到了它们的优缺点。</p><p id="40ce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您有任何问题或对一些编辑有建议，请随时在下面留下评论，并查看更多我的<a class="ae ku" href="https://pyshark.com/category/python-programming/" rel="noopener ugc nofollow" target="_blank">统计</a>文章。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="70be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="nj">原载于2021年9月5日</em><a class="ae ku" href="https://pyshark.com/test-for-normality-using-python/" rel="noopener ugc nofollow" target="_blank"><em class="nj">【https://pyshark.com】</em></a><em class="nj">。</em></p></div></div>    
</body>
</html>