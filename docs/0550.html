<html>
<head>
<title>Beginner’s guide to Timeseries Forecasting with LSTMs using TensorFlow and Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TensorFlow和Keras的LSTMs时间序列预测初学者指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/beginners-guide-to-timeseries-forecasting-with-lstms-using-tensorflow-and-keras-364ea291909b?source=collection_archive---------1-----------------------#2020-06-03">https://pub.towardsai.net/beginners-guide-to-timeseries-forecasting-with-lstms-using-tensorflow-and-keras-364ea291909b?source=collection_archive---------1-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="960e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="1c20" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><strong class="ak">时间序列数据用于预测的A-Z解释</strong></h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/544dfe8fc2e9c92fd45767afa85c671d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oHNOCj416wMr4lY5"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">un plash</a>上拍摄的照片</figcaption></figure><p id="77df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> H </span>大家好，我欢迎你们加入TensorFlow和Keras深度学习初学者系列。本指南将帮助您理解时间序列预测的基础知识。您将学习如何对时间序列数据进行预处理，构建一个简单的LSTM模型，对其进行训练，并将其用于预测。</p><h1 id="7f6e" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">什么是时间序列数据？</strong></h1><p id="3f51" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">假设您正在处理定期捕获的数据，例如，如果您正在使用谷歌股票价格数据并试图预测未来的股票价格。我们每天连续记录这些价格。因此，它可以被称为时间序列数据。</p><p id="4c53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了让您更好地理解和深入了解如何预处理数据，将数据分为训练和测试，定义模型和进行预测，我们将开始使用简单的正弦波数据作为训练数据，训练深度学习模型，并使用它来预测值。</p><h1 id="42d4" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">复发性神经网络是如何工作的？</strong></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/e29d44669006dab6554110786a0ba482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8uGPTM3weUuQRRLd"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@chne_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塔奇娜·李</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1d5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从数学角度来看，我们可以将深度学习定义为一种使用可微函数将一种类型的变量映射到另一种类型的变量的方法。</p><p id="8a32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，如果您正在执行回归，它会将<strong class="lk jd">向量映射到浮点数</strong>类似地，如果您正在处理分类问题，那么它可能是<strong class="lk jd">向量到向量的</strong>映射，其中输出向量可能是属于多个类的概率。</p><h1 id="c90d" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">什么是媒介？</strong></h1><p id="3d80" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们可以把向量定义为矩阵。当您向深层神经网络馈送图像时，它会将图像转换为相应像素值的矢量，该矢量将进一步传入前馈网络。在这里，向量代表了图像的含义，通常是人类无法理解的。</p><h1 id="54f2" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">什么是序列？</h1><p id="b65f" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">当你听到单词序列时，一个让你理解这个概念的简单例子是考虑一个句子，它由一系列单词组成，赋予它完整的含义，或者考虑谷歌股票价格数据，它包含每天间隔记录的数据序列。</p><p id="e3bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> RNNs </strong>可以将<strong class="lk jd">序列映射到向量</strong>，将<strong class="lk jd">向量映射到序列</strong>或者将<strong class="lk jd">序列映射到序列。</strong>最后<strong class="lk jd">，</strong>如果我们将其与我们当前的时间序列问题联系起来，该模型将获取一系列输入数据，并使用它来预测下一个值。</p><h1 id="2c03" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">设置</strong></h1><p id="a7aa" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">首先，导入库。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="ab5c" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">产生正弦波</strong></h1><p id="fc44" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们将使用NumPy<a class="ae lh" href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">linspace</strong></a>来生成范围在0到50之间的x值，并使用NumPy <a class="ae lh" href="https://numpy.org/doc/stable/reference/generated/numpy.sin.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> sine </strong> </a>函数来生成对应x的正弦值。最后，让我们将数据可视化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f752c40c315f1a6a5f554e2abdc35b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Hyn9fwxevf0T7Im7VmtQOQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供:生成的正弦波图。</figcaption></figure><h1 id="ce00" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">训练，测试分割</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3a88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们不会使用来自<strong class="lk jd"> sklearn </strong>的传统<a class="ae lh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">train _ test _ split</strong></a>函数将数据拆分为训练和测试数据集，而是使用简单的python库来拆分数据集，以便更好地理解幕后的过程。</p><p id="7efb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们将检查数据帧的长度，并使用10%的训练数据来测试我们的模型。现在，如果我们将数据帧的长度乘以<strong class="lk jd"> test_percent </strong>并取整该值(因为我们用于索引目的)，我们将得到索引位置，即<strong class="lk jd"> test_index </strong>。最后，我们将使用<strong class="lk jd"> test_index </strong>分割训练和测试数据。</p><h1 id="f1f0" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">缩放比例</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="1e14" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">为什么我们需要衡量价值观？</strong></h1><p id="80a7" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">数据预处理中最关键的步骤之一是缩放值。以防你是机器学习和深度学习的绝对初学者，我用一个简单的例子给你解释一下。例如，考虑这样一个场景，在给定人的身高和体重的情况下，您需要预测身体质量指数(身体质量指数)。因此，身高中给出的值与体重在数量级和单位上有所不同，因为身高以<strong class="lk jd">厘米</strong>计量，而体重以<strong class="lk jd">千克</strong>计量。假设，您正在使用K-最近邻算法(同样，K-最近邻算法基于欧几里德距离原理工作)并绘制这些值，绘制的点彼此相距很远，这可能不会帮助我们的算法执行预测。</p><p id="1a4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">场景2: </strong>考虑我们是否要使用非常基本的线性回归算法。它的工作原理是<strong class="lk jd">梯度下降，即</strong>我们需要找到一个可微函数的局部极小值。如果我们不使用缩放技术来绘制数值，那么你可能会得到疯狂的预测。</p><p id="1659" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">场景3: </strong>类似地，如果您使用图像数据集，那么您需要执行单位缩放，其中像素值在0到1之间归一化。</p><p id="95f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简而言之,“执行缩放”会在确定的范围内对特征进行归一化。</p><h1 id="2606" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">使用Keras时间序列生成器</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="41c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用时间序列数据时，我们将面临的一个问题是，在将数据输入模型之前，我们必须将数据转换为具有输入和输出组件的样本序列。我们应该选择序列数据的<strong class="lk jd">长度</strong>,以便模型有足够的输入数据进行归纳和预测，也就是说，在这种情况下，我们必须至少向模型输入一个周期的正弦波值。</p><p id="14ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该模型将之前的50个数据点(一个周期)作为输入数据，并使用它来预测下一个点。如果我们手动执行，这个过程会非常耗时和困难，因此我们将使用<a class="ae lh" href="https://keras.io/api/preprocessing/timeseries/#timeseriesgenerator-class" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Keras时间序列生成器</strong> </a>，它会自动转换数据，并准备好训练模型，而无需繁重的工作。</p><p id="e708" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到,<strong class="lk jd"> scaled_train </strong>的长度为451，生成器的长度为401(451–50 ),也就是说，如果我们使用X，y作为变量来执行生成器函数的元组解包，则X包含从开始的50个数据点，y包含模型用于预测的第51个数据点。</p><h1 id="e39f" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">简单的RNN </strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5ef0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">定义的变量(<strong class="lk jd"> n_features </strong>)代表训练数据中的特征数量，即，当我们处理单变量数据时，我们将只有一个特征，而如果我们使用包含多个特征的数据，那么我们必须指定数据中的特征数量。</p><h1 id="21cb" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">测试模型</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ac45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用<strong class="lk jd"> first_eval_batch </strong>来测试我们的模型。<strong class="lk jd"> first_eval_batch </strong>包含缩放后的训练数据的最后50个点，并使用这些点进行预测。为了便于理解，上文对<strong class="lk jd"> scaled_data </strong>中的预测值和第一次观察结果进行了注释。我们的模型预测下一个点是0.927，而原始值是0.949。因此，我们可以说我们的模型已经完成了大量的训练。</p><p id="de01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以从测试数据中自动生成用于评估的批量数据。我们将定义一个为我们做繁重工作的函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c396" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没看懂功能？。我会帮你的。首先，我们将定义一个空列表(<strong class="lk jd"> test_predictions </strong>)，这样我们就可以追加预测值。第二步是定义(<strong class="lk jd"> first_eval_batch </strong>)，即需要发送到模型中的第一个评估批次，并对批次进行整形，使其与我们的模型的输入形状相匹配。<strong class="lk jd">我们的current_batch包含来自训练数据的所有最后50个值。</strong></p><p id="176d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们将定义一个循环，这个循环将一直持续到测试数据结束。<strong class="lk jd">预测值被附加到(current _ batch ), current _ batch中的第一个观察值被删除。即，我们的current_batch包含50个值，其中49个来自训练数据，第50个值是追加的模型预测值</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/94da9e9e94a958a7ad69a8e38b558dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RwkqKIB2fXtVd7paWX37g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供:该图显示了预测值和原始正弦值之间的差异。</figcaption></figure><p id="9ca4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的模特做得很好，对吧？。</p><p id="0ff9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在开始时，预测值和原始正弦波值之间的差异几乎可以忽略不计，因为我们发送用于模型评估的第一批包括来自训练数据的最后50个值，然而随着循环的继续，预测值被附加到输入模型的批中，即，50个值中的49个来自训练数据，最后一点是模型预测值。这一过程一直持续到测试数据结束，结果越来越多的预测值被附加到评估批次中，这可能会导致曲线与原始值略有偏差。</p><h1 id="cc0a" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">什么是LSTMs？</h1><blockquote class="nq nr ns"><p id="b10f" class="li lj np lk b ll lm kd ln lo lp kg lq nt ls lt lu nu lw lx ly nv ma mb mc md im bi translated">LSTM层包括一组循环连接的块，称为存储块。这些模块可以被认为是数字计算机中存储芯片的一个不同版本。每一个都包含一个或多个循环连接的存储单元和三个乘法单元——输入、输出和遗忘门——为单元提供连续的写、读和复位操作模拟。网络只能通过门与细胞相互作用[1]</p></blockquote><p id="b1a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还是那句话，如果你厌倦了这些正式的定义，我来解释一下。假设你正在学习一门新的外语，第一天你会学到一些基本的单词，比如称呼一个陌生人或者说<em class="np">你好、</em>等等。同样，第二天你将学习日常对话中使用的小而流行的单词。最后，要理解并形成一个完整的外语句子，你必须记住迄今为止你学过的所有单词。这就是LSTM类似于我们大脑的地方，据说它们含有“记忆细胞”,可以长时间保存信息。因此LSTMs对于语音识别任务或我们必须处理时间序列数据的任务是完美的，并且它们解决了在RNNs中看到的消失梯度问题。</p><p id="14f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">消失梯度问题的详细解释可以在下面的文章中找到。</p><div class="nw nx gp gr ny nz"><a href="https://towardsdatascience.com/the-vanishing-gradient-problem-69bf08b15484" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">消失梯度问题</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">问题、原因、意义及其解决方案</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">towardsdatascience.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lb nz"/></div></div></a></div><h1 id="29a2" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak"> LSTM </strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c285" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd"> SimpleRNN </strong>模型和LSTM模型之间没有区别，除了这里我们将在一个序列模型中使用LSTM层进行预测。</p><h1 id="9892" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">预测</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="365a" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">可视化模型的性能</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/efe6ba69e6cd7347d10331c0ef0bc49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5xQQVyGiLF6JRqYu1wpgQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="db30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们可以说LSTMs非常适合时间序列数据。</p><h1 id="b886" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">针对全部数据的培训(培训+测试)</h1><p id="7b3c" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">构建我们的深度学习模型的最后一步或座右铭是预测值，因为我们已经完成了我们的分析并对独特的模型架构进行了实验，我们可以得出结论，LSTMs实现了高精度。</p><p id="392d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们将使用整个数据和训练模型，并使用它们来预测未来。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="02c8" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">预测</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="2a21" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">绘制预测值</strong></h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/959b481f342501c505779751807efa6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*6ttzXA3iUkvcCdXQ-Ef_Xw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供:显示预测正弦波值的图。</figcaption></figure><h1 id="b4ae" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated"><strong class="ak">结论</strong></h1><p id="da2e" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">恭喜你！你做了你的第一个递归神经网络模型！您还学习了如何预处理时间序列数据，预测未来，这是许多人觉得棘手的事情。</p><h1 id="a833" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">参考</h1><ol class=""><li id="acac" class="op oq it lk b ll nf lo ng lr or lv os lz ot md ou ov ow ox bi translated"><a class="ae lh" href="https://machinelearningmastery.com/gentle-introduction-long-short-term-memory-networks-experts/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/gentle-introduction-long-short-short-memory-networks-experts/</a></li><li id="6e6f" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated">Andrej Karpathy的博客+代码(你现在大概可以从这个了解更多了！):<a class="ae lh" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" rel="noopener ugc nofollow" target="_blank">http://karpathy.github.io/2015/05/21/...</a></li></ol></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><p id="3a12" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章能帮助你理解递归神经网络的基础知识。如果你有问题，请在下面的评论中提出，或者在<a class="ae lh" href="https://www.linkedin.com/in/vishnudarshan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p><p id="489e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在那之前，我会在下一个里抓住你！</p></div></div>    
</body>
</html>