<html>
<head>
<title>Why Your Build Pipelines Always Fail Your Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你的构建管道总是让你的机器学习模型失败</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/why-your-build-pipelines-always-fail-your-machine-learning-model-a09484d551f6?source=collection_archive---------4-----------------------#2021-11-23">https://pub.towardsai.net/why-your-build-pipelines-always-fail-your-machine-learning-model-a09484d551f6?source=collection_archive---------4-----------------------#2021-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6143" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="f926" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">机器学习代码不确定的3种方式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6e19436055da69b64b2cd52bea635190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C9_tFEM10GUcG5td"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8a39" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="5b13" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">想象你在做一个机器学习模型(不管任务是什么)。在花费数周时间在您的本地机器上开发它之后，您终于能够让它在您的测试集上体面地执行了。现在，您发现当通过您的构建管道进行部署时，模型总是失败。这个模型是在您在本地开发时使用的同一个测试集上测试的，那么结果如何呢？</p><p id="35ce" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">本文将解释这种奇怪现象的原因，并在最后给出一个关于如何检测真正的模型回归的建议。</p><p id="c5c6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">重现这里描述的结果的代码可以在这个<a class="ae lh" href="https://github.com/hsm207/why_models_fail" rel="noopener ugc nofollow" target="_blank">报告</a>中找到。</p><h1 id="4b7b" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">一个故事</h1><p id="fcc4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们从局部发展阶段开始。</p><h2 id="38f7" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">本地模型</h2><p id="d615" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为简单起见，我们假设您正在构建一个模型来对MNIST数据集进行分类。你的目标是建立一个在测试集上至少95%准确的分类器。</p><p id="dddb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">经过几次尝试后，你终于做到了:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b4d281fe2ff61e1734584219dfe3686c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*_K_wbieNqwNMy1srNqZ0TA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图1:第一个超过95%准确率的模型</figcaption></figure><p id="2921" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，运行训练和评估逻辑再次产生不同的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/48929417c3bcb14714230bfe3ddd6012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*vlLVPehOIr2MYnLEvLziZA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图2:运行相同的模型训练和测试代码会产生不同的结果</figcaption></figure><p id="e012" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">结果略有不同，但这足以让你想知道变化的原因。完全相同的代码运行多次应该会产生相同的结果，不是吗？</p><p id="85f2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后你想起来你在训练的时候打开了数据洗牌。这是建立机器学习模型时的一种常见做法(参见<a class="ae lh" href="https://datascience.stackexchange.com/questions/24511/why-should-the-data-be-shuffled-for-machine-learning-tasks" rel="noopener ugc nofollow" target="_blank">此处</a>的解释)。也许如果你在训练中禁用了随机洗牌，那么在不同的跑步中，结果会保持不变？</p><p id="40a6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">以下是在训练期间禁用随机洗牌后的首次运行结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/90dde3982284f1382a6d24d5172f446a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*pOfjkWj906t8fgOoKhPDlw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图3:在训练期间关闭数据随机播放后的第一次运行</figcaption></figure><p id="3cd4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这是第二次运行的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0a45e9e3daa48827352a855cb26da330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*xuqGriO7IaHE0rBALECDhA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图4:训练期间关闭数据随机播放后的第二次运行</figcaption></figure><p id="3036" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">结果还是不一样！但至少现在差别变小了…</p><p id="19b2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，您记得您的模型在训练开始时随机初始化其参数！所以，<a class="ae lh" href="https://github.com/tensorflow/tensorflow/blob/c256c071bb26e1e13b4666d1b3e229e110bc914a/tensorflow/python/framework/random_seed.py#L215-L216" rel="noopener ugc nofollow" target="_blank">修复随机种子</a>就一定能修复这个问题，不是吗？</p><p id="878e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当您将随机种子设置为1:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3f8f37922bacebab0d77e3c0b67bb48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*WUCxXToVeBGt73VjOqFMYA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图5:在训练期间修复随机种子并禁用数据混洗后的第一次运行</figcaption></figure><p id="a120" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">第二轮，我们有:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/879883e0ebaed32ce679de375a1390f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*2TfR0hyXIddeRN90A2qPpg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图6:在训练期间修复随机种子并禁用数据混洗后的第二次运行</figcaption></figure><p id="8ed0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">太好了！结果是相同的，我们可以继续构建一个管道来训练和部署模型到生产中。</p><h2 id="ea19" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">管道模型</h2><p id="2f7e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">从构建管道中读取日志时，您会注意到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/43bf6c0f2b2ebb347ed06e5d7284756d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*VWyTH8T7SXMlpz8tQ9uULg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图7:来自构建管道的培训和测试日志</figcaption></figure><p id="52aa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">随机种子已被固定为1，训练数据洗牌已被禁用，就像你在本地机器上所做的一样。但是为什么结果不一样呢？</p><p id="49ba" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意到管道和本地模型之间的差异非常小，您怀疑这可能是硬件浮点运算实现中的一个错误。</p><p id="5767" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">好消息是，这个“bug”已经在互联网上被讨论了很多(例如，见这里的<a class="ae lh" href="https://discuss.pytorch.org/t/reproducibility-over-different-machines/63047" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae lh" href="https://github.com/tensorflow/tensorflow/issues/38197#issuecomment-637846372" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae lh" href="https://www.twosigma.com/articles/a-workaround-for-non-determinism-in-tensorflow/" rel="noopener ugc nofollow" target="_blank"/>)。坏消息是，这不是一个错误。简而言之，机器之间的差异是由于浮点规范的定义方式和硬件供应商实现它们的方式造成的。</p><p id="10a8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，你将不得不忍受这种差异。</p><h1 id="af46" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">实际例子</h1><p id="1be7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">值得注意的是，故事中使用的数据集是MNIST数据集。它有60，000个训练样本和10，000个测试样本。考虑到问题的复杂性，这足以确保机器学习模型能够在每次运行时收敛。</p><p id="116b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是实际上，你不太可能从这么大的数据集开始。</p><p id="317e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们考虑数据集大小对同一台机器上运行的变化的影响。</p><p id="cd4a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果我们只有1，000个训练示例和500个测试示例，则变化如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/c7433b1bc3c066727f17638afa78fb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*560bwn3vslh74sUuKugdwQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图8:假设有1000个训练样本，测试准确度的变化</figcaption></figure><p id="cdd0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">由于只有1，000个训练示例，我们预计该模型相对于在整个训练集上训练时表现不佳。图8证实了这一点(在整个测试集上进行测试时，中值测试准确度介于86.5 %和87.0 %之间，相比之下，在整个训练集上进行训练时，中值测试准确度为97 %)。</p><p id="5617" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">图8还显示，当只对500个测试实例进行评估时，测试精度的变化明显高于对整个测试集的评估。</p><p id="281d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">有了正确的数据集、固定的随机种子，并且没有数据重排，您可以在500个样本的测试集上获得89%的测试准确性，这并不是模型真实性能的真实反映。因此，来自随机种子和数据洗牌的随机性不应该被关闭，以便您可以估计您的模型性能的不确定性。</p><p id="13b6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是，如何确保模型的后续工作(例如，添加新特性、超参数调整)不会意外地引入回归呢？</p><h1 id="96ec" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">如何检查模型回归</h1><p id="848b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">上一节已经表明，在小数据集上训练和测试的模型在它们的评估指标上可以有很多变化。因此，如果您有一个准确率为90%的模型，下一次运行可能会偶然返回88%的准确率，这使得设置检测回归的最小阈值变得困难。</p><p id="0dd5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">人们可能会试图寻找一个随机种子，使本地模型和管道模型的结果差异尽可能小，但我不认为这是对时间的最佳利用。</p><p id="d886" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">相反，我建议在管道中运行几次训练和测试作业，并计算运行中评估指标的平均值和标准偏差。这些数字在机器之间是稳定的，因此可以用来可靠地确定是否引入了回归。</p><h1 id="454f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="9952" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">本文描述了机器学习模型每次在同一数据集上训练时会产生不同结果的3个原因，即:</p><ol class=""><li id="0304" class="nu nv it mc b md mw mg mx mj nw mn nx mr ny mv nz oa ob oc bi translated">输入:将训练数据成批输入模型的方式很重要</li><li id="1bbf" class="nu nv it mc b md od mg oe mj of mn og mr oh mv nz oa ob oc bi translated">模型架构:随机权重初始化、随机采样和丢弃等技术会通过设计将随机性引入模型的输出</li><li id="e851" class="nu nv it mc b md od mg oe mj of mn og mr oh mv nz oa ob oc bi translated">硬件:不同的硬件可以不同地实现浮点运算</li></ol><p id="35d7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">本文还推荐使用通过一系列训练和测试运行计算的评估指标的平均值和标准偏差作为检测模型回归的方法。</p><p id="45d8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我希望这对您有所帮助。</p></div></div>    
</body>
</html>