<html>
<head>
<title>Deploying a Keras Model as an API Using Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask将Keras模型部署为API</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/deploying-a-keras-model-as-an-api-using-flask-177583300073?source=collection_archive---------0-----------------------#2019-07-22">https://pub.towardsai.net/deploying-a-keras-model-as-an-api-using-flask-177583300073?source=collection_archive---------0-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7de3970311d6e6e5dcafd3376967bc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*0G5zu7CnXdMT9pGbYUTQLQ.png"/></div></div></figure><h2 id="75f0" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="8490" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">使用flask库将语言标识符Keras模型部署到web应用程序和基于URL的API中。</h2></div><p id="d203" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">训练一个神经网络来完成一项特定的任务非常有趣，但是当你对模型的表现感到满意时，这项工作不会停止。能够与其他可能想要使用它的人共享您构建的模型是非常有用的。这对个人项目和行业工作都很重要。这就是为什么我想学习如何部署我建立的模型来识别一个单词是用哪种语言写的。我在<a class="ae ly" href="https://medium.com/towards-artificial-intelligence/comparing-neural-network-architectures-through-language-classifier-using-google-colab-63167c18b919?source=post_page---------------------------" rel="noopener">之前的一篇博文</a>中解释了训练的细节，但是理解这篇文章后面的所有内容并不一定重要。</p><p id="d372" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我选择从我认为最简单的部署模型的方式开始。我发现在python中使用Flask库非常简单，并且提供了许多选项。这允许我将我的模型部署到API中。API是一个<em class="lz">应用程序编程接口</em>，它在不同的软件之间建立链接。例如，当开发人员想要制作一个用户可以拍照的手机应用程序时，他不必进行任何硬编码来访问手机的摄像头。有一个API在应用程序和相机之间建立连接。在数据科学领域，我们经常在网站上遇到API，它们允许我们以简单的方式访问网站的数据。</p><p id="1ba7" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我的例子中，使用这样的API部署模型还有另一个非常重要的原因。用户不需要了解任何关于深度学习的知识就可以使用该模型。他只需要最低限度地指定要分类的单词，API在后台调用模型，并只将结果发送给用户。这使得该模型可被广泛访问，更私密且易于修改。基本上可以使用任何编程语言访问API，所以没有什么真正取决于我的实现。</p><p id="cc2c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我在这里讨论的一切都是为了使API在本地可用，这样拥有该文件的人就可以使用它。当然，在现实生活中，下一步是让这个API在线可用。有各种方法可以做到这一点，但我还没有把重点放在这一点上。也许这将是未来博客的主题，或者是这篇博客的更新。</p><p id="5946" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">API的代码可以在项目的<a class="ae ly" href="https://github.com/yangobeil/language-identifier?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上的文件‘app _ v1 . py’，‘app _ v1 _ 1 . py’和‘app _ v2 . py’中找到。</p><h1 id="528e" class="ma mb je bd mc md me mf mg mh mi mj mk kt ml ku mm kw mn kx mo kz mp la mq mr bi translated">设置和背景</h1><p id="a194" class="pw-post-body-paragraph lc ld je le b lf ms ko lh li mt kr lk ll mu ln lo lp mv lr ls lt mw lv lw lx im bi translated">对于这个特殊的项目，我决定部署我以前训练过的模型来分类英语、法语或西班牙语单词。输入只是一个单词，它需要被转换成一个数组，以便输入到神经网络中。我已经为此创建了一个简单导入的函数“word_to_array”。事实上，我训练了四个不同的模型来完成这项任务，因此API可以选择使用哪一个来进行预测。使用的模型是简单连接网络(称为FF)、卷积神经网络(称为CNN)和递归神经网络(称为RNN)。每个模型都用Keras保存到名为“model？？？. hdf5 '。网络的输出是每种语言的概率。</p><p id="59c9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">除了上面提到的文件及其依赖项NumPy和Keras，唯一需要安装的额外包是Flask，使用pip可以很容易地完成。Tensorflow本身也是有必要的，原因很蠢。</p><p id="6c3a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我实现了一个API版本，它为用户创建了一个web表单，用户可以输入他们的单词并获得预测。我还做了一个更漂亮的版本。我终于做出了一个可以从编码环境直接访问的版本。</p><h1 id="859f" class="ma mb je bd mc md me mf mg mh mi mj mk kt ml ku mm kw mn kx mo kz mp la mq mr bi translated">烧瓶基础</h1><p id="e3f2" class="pw-post-body-paragraph lc ld je le b lf ms ko lh li mt kr lk ll mu ln lo lp mv lr ls lt mw lv lw lx im bi translated">首先要了解Flask是如何工作的，至少在这个项目的上下文中是这样的。当然，第一步是导入项目所需的方法。然后必须定义并启动Flask app。</p><p id="108f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">“请求”方法用于与应用程序通信，“jsonify”方法用于将python字典转换为JSON格式，“渲染模板”用于包含HTML模板。下一步是简单地定义应用程序要使用的功能。</p><p id="6e63" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是一个简单的函数，用于加载要使用的Keras模型并将它们存储在字典中。它们被定义为全局变量，因为该函数只被调用一次来加载模型。根据代码的结构方式，将模型作为输出并使用该输出会使应用程序在每次使用时加载模型，这是非常低效的。最后两行是为将来运行模型所必需的步骤准备的，因为Keras在与Flask结合使用时存在兼容性问题。</p><p id="8011" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在是应用程序的关键部分。</p><p id="b6b2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第一行定义了以下函数在web应用程序中的发布位置。路径可以是任何东西('/'只是指主页)，在一个应用程序中可以有许多不同的路径。“方法”选项用于指定路由作为请求应该期望得到什么。这个帖子最常见的是GET和post，GET表示用户从应用程序获取信息，POST表示用户向应用程序发送信息。还存在更新数据的PUT和删除数据的DELETE。定义了路由之后，就有了在该路由中使用的功能。其内容在很大程度上取决于上下文，这是我在下面详细描述的。最后，最后一点代码是API实际运行的地方。首先加载模型，然后启动应用程序。在应用程序之外加载模型是我在上面将它们定义为全局变量的原因。将它们放在应用程序中会导致每次加载页面时额外的加载时间。</p><h1 id="4603" class="ma mb je bd mc md me mf mg mh mi mj mk kt ml ku mm kw mn kx mo kz mp la mq mr bi translated">基本HTML</h1><p id="dd85" class="pw-post-body-paragraph lc ld je le b lf ms ko lh li mt kr lk ll mu ln lo lp mv lr ls lt mw lv lw lx im bi translated">为了理解API的第一个版本，其中涉及到网页，有必要对HTML有一个基本的了解。我试图在这里涵盖非常基本的内容，很多额外的信息可以在网上找到，例如在<a class="ae ly" href="https://www.w3schools.com/html/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/html/</a>。</p><p id="95b4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">HTML是网络浏览器用来制作网页的语言。在HTML中，每个对象都是由以下形式的标签组成的</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="fb2b" class="ng mb je nc b gy nh ni l nj nk">&lt;tagname option=...&gt; text &lt;/tagname&gt;</span></pre><p id="cf73" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最常见的标签在开头包含一个开始标签<name>，在结尾包含一个结束标签</name>。其中一些最重要的是:</p><ul class=""><li id="ea2d" class="nl nm je le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated">标题<h1>，…，<h6>:h1标签是最重要的一个，然后它的尺寸就变小了。</h6></h1></li><li id="0417" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">段落<p>:正文由段落组成。</p></li><li id="913d" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">超链接<a>:选项‘href’指定了链接，标签之间的文本就是链接的文本。</a></li><li id="fab0" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">:整个代码必须包含在HTML标签之间。</li><li id="290b" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">:经常出现在顶部，包含元数据。</li><li id="ac95" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">:网页本身的代码包含在body标签之间。</li><li id="3b48" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">换行符<br/>:在文本中创建一个换行符，以便在任何地方插入新的一行。它是单独的，所以不需要结束标签。</li></ul><p id="c0ee" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这个项目需要的最后一种标签是<strong class="le jo">表单</strong>。这些通常不是最重要的，但在这里它们变得非常有用。整个表单包含在&lt;表单&gt;标签之间。然后使用带有各种选项的&lt;输入&gt;标签编写表单的交互部分。每个输入都必须有一个“名称”选项值来标识它。“type”选项显然决定了标签是什么类型的输入。我用的三个是:</p><ul class=""><li id="f0ed" class="nl nm je le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated">文本:制作一个框来写文本。</li><li id="41ca" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">收音机:多项选择选择器。每个选项必须有一个“值”选项来标识它们，同一组中的每个选择器必须有相同的“名称”选项。</li><li id="20cf" class="nl nm je le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">提交:带有文本的按钮。使用“值”选项定义文本。</li></ul><p id="f8cc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">表单的其余部分是纯文本，用于填充交互部分之间的空隙。所有这些概念的例子将在后面的代码中给出。</p><h1 id="b597" class="ma mb je bd mc md me mf mg mh mi mj mk kt ml ku mm kw mn kx mo kz mp la mq mr bi translated">版本1:在网页上</h1><p id="8ec7" class="pw-post-body-paragraph lc ld je le b lf ms ko lh li mt kr lk ll mu ln lo lp mv lr ls lt mw lv lw lx im bi translated">我用来部署我的模型的第一种方法是构建一个简单的web应用程序，它接受用户的一些输入，调用Keras模型，并在浏览器中直接发送回结果。要使用的函数如下。</p><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f792" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">那里发生了一些事情。首先，web浏览器发出GET请求，从API获取信息。这意味着第一个代码块被忽略，因为它仅在发出POST请求时使用，如函数“request.method”所示。然后，该函数返回向用户显示以下表单的HTML代码。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/c5185fb683a2696f2703725b96f96a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qw76aSEGW9S21rg6rtORkg.png"/></div></div></figure><p id="1a7f" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">form标记中的“method”选项用于确保一旦按钮被单击，就会发出POST请求。然后执行代码的第一部分。“request.form.get()”函数通过名称在表单中查找元素并返回其值。这用于存储要使用的模型的单词和名称，然后从字典中选择。下一步是将单词转换成一个数组，该数组将被输入神经网络。不同的模型接受不同的形状，所以需要有条件。最后，使用该模型进行预测。这就是Keras的问题所在，使用TensorFlow命令可以解决这个问题。然后，该函数返回HTML代码，以下面的方式显示结果。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/5b173a0bf53920b1499d34afd5df95f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZR4qvn6OYADXn53ZEx9kFQ.png"/></div></div></figure><p id="4c52" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">要运行这个应用程序，只需在命令行中键入</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="916e" class="ng mb je nc b gy nh ni l nj nk">python app_v1.py</span></pre><p id="4fd6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">将显示一些信息，包括用于访问应用程序的链接(类似于“<a class="ae ly" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>”)。在web浏览器中复制它，结果将是上面显示的表单，您可以与之交互。调试模式在这个版本中是关闭的，因为它已经被测试过了，但是在app.run()部分中打开它可以访问一个不错的控制台，当错误发生时它会报告错误。</p><h2 id="922d" class="ng mb je bd mc oc od dn mg oe of dp mk ll og oh mm lp oi oj mo lt ok ol mq jk bi translated">1.1版:使用模板</h2><p id="c664" class="pw-post-body-paragraph lc ld je le b lf ms ko lh li mt kr lk ll mu ln lo lp mv lr ls lt mw lv lw lx im bi translated">令人印象深刻的是网页的HTML代码可以变得很大很快，所以以前的方法对更复杂的页面不是很有用。这就是为什么在Flask中调用预制模板并使用应用程序修改一些值是可能的。较大的网页也涉及CSS(可能还有javascript)代码，所以我们也需要知道如何处理。模板需要包含在一个名为“templates”的文件夹中，CSS和JS在一个“static”文件夹中。HTML模板只是普通的页面，但是在括号{{ }}之间定义了外部变量。我在结果页面中使用的例子如下。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="14e3" class="ng mb je nc b gy nh ni l nj nk">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;</span><span id="ceb6" class="ng mb je nc b gy om ni l nj nk">&lt;header&gt;<br/> &lt;link rel="stylesheet" href="static/style.css"&gt;<br/>&lt;/header&gt;</span><span id="eaeb" class="ng mb je nc b gy om ni l nj nk">&lt;body&gt;<br/>    &lt;div class="container"&gt;<br/>                 &lt;h1 class="word"&gt; The model used is {{ model }}&lt;/h1&gt;&lt;br&gt;<br/>          &lt;div class="results"&gt;<br/>                 &lt;h1 class="result"&gt; Francais: {{ fr }}%&lt;/h1&gt;<br/>                 &lt;h1 class="result"&gt; English: {{ en }}%&lt;/h1&gt;<br/>                 &lt;h1 class="result"&gt; Espanol: {{ es }}%&lt;/h1&gt;<br/>          &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;</span><span id="4ee2" class="ng mb je nc b gy om ni l nj nk">&lt;/html&gt;</span></pre><p id="00b2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">主页的代码大部分和以前一样，但是在一个单独的文件中。我还包含了一些基本的CSS，但这并不相关，所以你可以在GitHub库的style.css文件中看到它。实际python脚本中的代码现在非常简单，因为我只需要加载模板。</p><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="54d1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">唯一的新东西是我使用了函数“render_templates”来包含模板。我只需要根据变量在HTML文件中的名字给它参数。</p><p id="c6d1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在，生成的web应用程序看起来更好了。(其实不算太漂亮，但是比以前好多了。通过更多的工作，它可以做得更好。)</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/bc4070926fe1c500084c15856d192d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOle0PpeO92heuQTKioRWw.png"/></div></div></figure><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/5868bbf28c13446e2c944b251b62625a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkxG0fO6w-SPDj2Y8TJDcw.png"/></div></div></figure><p id="6560" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于更复杂的网页，知道可以访问输入方法、执行循环和在模板中定义变量可能是有用的。能够为页面创建一个框架并为站点上的每个网页继承它也是非常有用的。</p><h1 id="2e3d" class="ma mb je bd mc md me mf mg mh mi mj mk kt ml ku mm kw mn kx mo kz mp la mq mr bi translated">版本2:在URL中</h1><p id="d547" class="pw-post-body-paragraph lc ld je le b lf ms ko lh li mt kr lk ll mu ln lo lp mv lr ls lt mw lv lw lx im bi translated">共享我的模型的第二种方式是通过使用URL的查询。这对于希望从自己的代码中调用模型的开发人员来说非常有用。他们只需使用像python中的urllib请求这样的库来调用API并返回结果，而无需使用Keras。这种情况下使用的函数定义如下。</p><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ff82" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这一次没有在应用程序路由中指定方法，因为不涉及浏览器。用户通过修改他所请求的链接来指定选项，并且使用“request.args.get()”来获取选项的值。这里使用它来获取模型的单词和名称。然后选择模型并进行预测。所有的结果都保存在一个字典中，这个字典被转换成JSON格式返回，因为这是API要处理的事情。</p><p id="7ca5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">要访问API，只需像以前一样运行代码，并使用提供的链接发出GET请求。下面是一个使用请求库的例子</p><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ef74" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这个请求的输出是一个包含所请求信息的字典。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3aef" class="ng mb je nc b gy nh ni l nj nk">{'English': 28.93,<br/> 'Espanol': 4.5,<br/> 'Francais': 66.57,<br/> 'model': 'RNN',<br/> 'word': 'orignal'}</span></pre><p id="5fb1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这种通用选项请求的一般格式是</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="8c5a" class="ng mb je nc b gy nh ni l nj nk"><a class="ae ly" href="http://www.api.com/page?option1=value1&amp;option2=value2" rel="noopener ugc nofollow" target="_blank">www.api.com/page?option1=value1&amp;option2=value2</a></span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="5194" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">希望有些人会对此感兴趣。这是ML/DL中不太光彩的一部分，但是当人们真正使用你的模型时，这是非常重要的。我会试着写一些关于把API放到网上的东西。即使完成了这一步，知道这不一定是结束也是好的。例如，需要采取一些步骤从用户那里获取反馈，并进行自动测试以防止崩溃。</p></div></div>    
</body>
</html>