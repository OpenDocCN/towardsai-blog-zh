<html>
<head>
<title>The Combinatorial Purged Cross-Validation method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合清除交叉验证法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-combinatorial-purged-cross-validation-method-363eb378a9c5?source=collection_archive---------0-----------------------#2022-03-31">https://pub.towardsai.net/the-combinatorial-purged-cross-validation-method-363eb378a9c5?source=collection_archive---------0-----------------------#2022-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8af84db3286f6d7735886f41ef1e04d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anSlXCWbosqNKgD43lFxfA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由作者想象。</figcaption></figure><div class=""/><p id="4c7c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文由开源项目AI4Finance的核心团队成员Berend Gort &amp; <a class="ae la" href="https://ai4finance.medium.com/" rel="noopener"> Bruce Yang </a>撰写。这个项目是一个<strong class="ke jg">开源</strong>社区，共享金融AI工具，是纽约哥伦比亚大学的一部分。GitHub链接:</p><div class="ip iq gp gr ir lb"><a href="https://github.com/AI4Finance-Foundation" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd jg gy z fp lg fr fs lh fu fw je bi translated">ai4金融基金会</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">一个共享金融AI工具的开源社区。FinRL:第一个用于财务强化的开源项目…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp ix lb"/></div></div></a></div><h1 id="a56b" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Colab笔记本</h1><div class="ip iq gp gr ir lb"><a href="https://colab.research.google.com/gist/Burntt/f26e5414205542207949aeb9e9cc1ddb/demo_purgedkfoldcv.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd jg gy z fp lg fr fs lh fu fw je bi translated">谷歌联合实验室</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">编辑描述</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">colab.research.google.com</p></div></div><div class="lk l"><div class="mo l lm ln lo lk lp ix lb"/></div></div></a></div><h1 id="9c69" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">介绍</h1><p id="ce7a" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">本文讨论了一种稳健的时间序列数据回测方法，称为PurgedKFold交叉验证(CV)法。在互联网上，关于PurgedKFoldCV方法的信息有限。存在现有的代码，只是没有解释它们的用法。在Lopez de Prado，M. (2018)在《金融机器学习的进展》中很好地描述了PurgedKFoldCV的思想。因此，在本文中，我们将向您展示如何以正确的方式获取PurgedKFoldCV</p><h1 id="c1c2" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">为什么传统的交叉验证会失败</h1><p id="4425" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">该领域的许多论文显示了k倍交叉验证(CV)方法的有希望的结果。它们在互联网上如此丰富，以至于几乎再也找不到更具体的方法了。</p><p id="1260" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也许你现在在这里，已经看了一堆文献认为传统的k折CV效果很好。然而，几乎可以肯定的是，这些结果是错误的。原因:</p><ol class=""><li id="e36e" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">因为不能期望通过IID过程得出观察值，所以k倍CV在金融中是失败的。</li><li id="3af1" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">CV失败的另一个原因是测试集在模型开发过程中被多次使用，导致多重测试和选择偏差。</li></ol><p id="ba81" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们集中讨论第一部分的论点。当训练集包含出现在测试集中的信息时，就会发生泄漏。时间序列数据通常是串行相关的，例如加密的开盘-盘高-盘低-收盘(OHLCV)数据。考虑以下基于重叠数据链接到标签Y的串行相关特征X的示例:</p><ul class=""><li id="3ad8" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">连续相关的观察。这意味着接下来的几个观察值取决于当前观察值。</li><li id="9fcd" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">目标标签来自重叠的数据点。例如，我们在未来的10个样本中有一个目标标签，确定价格是下降、保持不变还是上升。我们的目标标签是[0，1，2]。这种标记是对未来值执行的。</li></ul><p id="dca4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，当我们将这些数据点放在不同的集合中时，我们会将信息从一个集合泄漏到另一个集合。让我们防止这种情况。</p><ul class=""><li id="af98" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">吹扫:在测试装置之前，在测试装置之后，从测试装置中取出10个样品，这样测试装置就不会发生泄漏。</li><li id="408f" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">禁运:适用于吹扫未能防止所有泄漏的情况。在测试集之后，在训练集之前从训练集中移除整数数量的样本。</li></ul><h1 id="9568" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">向前走回测试方法</h1><p id="a2ff" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">WF(walk-forward)方法是文献中最常用的回溯测试方法。WF是该战略过去表现的历史模拟。每个战略决策都基于决策前收集的信息。</p><p id="f883" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WF有两大优势:</p><ol class=""><li id="eba5" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">WF有一个清晰的历史解释和可比的表现，以纸交易。</li><li id="f0d9" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">历史是一种过滤；因此，使用端点数据可以保证测试集完全超出样本范围(OOS)。</li></ol><p id="9519" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和三个主要缺点:</p><ol class=""><li id="611d" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">只测试了一个场景，这很容易被过度拟合。</li><li id="6047" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">WF并不代表未来的表现，因为结果可能会因数据点的特定顺序而有所偏差(例如，仅在显著上升趋势中进行测试)。</li><li id="5ae8" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">WF的第三个缺点是，初始决策是在整个样本的一小部分上做出的。</li></ol><h1 id="653b" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">交叉验证法</h1><p id="7780" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">投资者经常会问，如果某种策略遭遇2008年的危机，它会有怎样的表现。回答这个问题的一个方法是将观察结果分成训练集和测试集，其中训练集不在2008年危机之内，而测试集恰好经历了危机。</p><p id="fd93" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，分类器可能从2009年1月1日到2017年1月1日被训练，然后从2008年1月1日到2008年12月31日被评估。因为分类器是根据2008年以后才可获得的数据训练的，我们在2008年获得的性能在历史上是不正确的。然而，测试的目的不是历史准确性。测试的目的是让一个没有2008年意识的方法经历一个类似于2008年的压力情境。</p><p id="f556" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过交叉验证(CV)进行回溯测试的目的不是获得历史上准确的绩效，而是从几个样本外(OOS)场景中推断未来的绩效。对于后验测试的每个阶段，我们模拟一个分类器的性能，该分类器知道除该阶段之外的所有信息。</p><p id="6fd6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是为什么亚马逊从第一天开始就痴迷于价格、选择和可用性，今天仍然如此。CV方法的优势:</p><ol class=""><li id="fae0" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">该测试不是基于特定的(历史)场景。CV评估k个不同的场景，其中只有一个与历史序列匹配。</li><li id="bebd" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">每个判断都是基于同等规模的群体。因此，可以根据决策所需的数据量来比较不同时期的结果。</li><li id="8c2f" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">每个观察都是一个且只有一个测试集的一部分。没有预热子集，允许最广泛的样本外模拟可行。</li></ol><p id="4c95" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">CV方法的缺点:</p><ol class=""><li id="a2aa" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">模拟单个回测路径，类似于WF。对于每个观察，只生成一个预测。</li><li id="6e4b" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">CV缺乏坚实的历史脉络。输出并不代表该策略在过去的表现，而是它在未来各种压力条件下的表现(这本身就是一个有用的结果)。</li><li id="cd5b" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">泄漏是可能的，因为训练集不遵循测试集。</li><li id="dd7f" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">避免将测试知识泄露给训练集，必须非常小心</li></ol><h1 id="2c8a" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">组合清除交叉验证回测算法</h1><p id="5124" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">CPCV提供了构建一组回测路径所需的训练/测试集组合的精确数量，同时在给定一组研究者所针对的回测路径的情况下清除包含泄漏信息的训练观察。</p><p id="3157" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们有数据，比如1000个数据点。假设我们想将这1000个数据点分成6组。在这6个组中，我们需要2个测试组(如下图所示)。</p><p id="936a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可能有多少个数据拆分？即nCr(6，(6–2))= 15。参见图1。</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/990f76488cb4f921240ab4ed48247f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*o20-RtV_I10J5PQjd5IBnQ.png"/></div></figure><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/53219c1b2bf579a7eb79f71958822fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGswlDSbsIO7nusd5ZkNQA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图1:由810个数据点组成的数据集的可能分割。组N=6，k=2。图片作者。</figcaption></figure><p id="31f1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每次拆分涉及k=2个测试组，这意味着测试组的总数是k * N_splits，即30。此外，由于我们已经计算了所有可能的组合，这些测试组均匀地分布在所有n上。因此，路径总数为30 / 6= 5个路径。</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div class="gh gi np"><img src="../Images/676ce97c39251c72f0eac73bb12fb10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*C2MS6O5ZIpcLLzk4nvZ81A.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在我们的示例5中，回溯测试路径数量的公式</figcaption></figure><p id="26fa" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">图1用x表示组成测试集的组，对于每个分割，组成训练集的组没有标记。这种训练/测试分离技术允许我们计算5个回测路径，因为每个组都是𝜑[6的成员，2] = 5个测试集。</p><p id="4502" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也许你在这一点上有点困惑，并有这样的问题:</p><ol class=""><li id="a10d" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated"><strong class="ke jg">你在为什么样的拆分培训什么样的模型，为什么？</strong></li></ol><p id="690f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们就一些符号达成一致，举几个例子:</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/902eadcee9241435c65455492bfca832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*-aiB-0ziYZlxkH16Vqy39w.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><em class="nr">作者图片</em></figcaption></figure><p id="9f8d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于每个垂直分割(S1，S2 … S15)，训练一个分类器来确定你的目标标签y(1，1)，y(1，2)，等等。<strong class="ke jg">这个分类器基础模型对于每次分裂都是一致的，但是它做出的预测是不同的。因此它仍然是一个不同的分类器！</strong></p><p id="0e88" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以举几个基本的例子(见图1):</p><ul class=""><li id="53ce" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">Split 1 ||训练:(G3，S1)，(G4，S1)，(G5，S1)，(G6，S1) ||测试:(G1，S1)，(G2，S1) || →分类器1 →预测y(1，1)，y(1，2) on (G1，S1)，(G2，S1)</li><li id="df7b" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">分裂2||训练:(G2，S2)，(G4，S2)，(G5，S2)，(G6，S2) ||测试:(G1，S2)，(G3，S1) || →分类器2 →预测y(1，2)，y(3，2) on (G1，S2)，(G3，S2)</li><li id="690d" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi">…….</li><li id="bfdf" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">Split 15||训练:(G1，S15)，(G2，S15)，(G3，S15)，(G4，S15) ||测试:(G5，S15)，(G6，S15) || →分类器15 →预测y(5，15)，y(6，15) on (G5，S15)，(G6，S15)</li></ul><p id="5cc0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> 2。为什么这些回溯测试路径是唯一的？</strong></p><p id="48f3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们已经训练了分类器，并计算了图1中所有(x)位置的所有预测。因此，我们现在可以根据这些预测来应用我们的策略。</p><p id="2caa" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请看图2。路径生成算法将测试组上的所有预测分配到5个唯一路径中的一个。可以以任何方式重新组合路径部分，并且不同的组合应该收敛到相同的分布。</p><p id="6d8e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">要点是:</strong>所有这些向前走的路径都是纯粹的样本外(OOS)。<strong class="ke jg"> </strong>你的分类器所做的预测并没有经过这些路径的训练！(图二)。</p><p id="fdb9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">示例，路径1:</p><ul class=""><li id="46fb" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">分类器1没有在(G1，S1)，(G2，S1)上训练，因此我们可以使用那些预测来得到我们的策略(无论那可能是什么)。</li><li id="bc4f" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">分类器2没有在(G3，S2)上训练，因此我们可以将这些预测用于下一位数据。</li><li id="3023" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi">…..</li><li id="d68b" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">分类器5没有在(G6，S5)上训练，因此…</li><li id="29d6" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">剩余的路径都是重复的</li></ul><p id="9376" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">结论</strong>:我们现在有5条前向回溯测试路径，而不是1条。因此，5夏普比率或任何您用来确定您的模型的性能的指标。这些多重指标允许“统计回溯测试”，并使错误发现的概率可以忽略不计(假设有足够多的路径)。</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/1a03a49b0df94db0216fd35754586c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imtXfyCqaBvAhOqgiM7x7Q.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图2:将测试组分配到5条路径中的每一条，洛佩兹·德·普拉多，M. (2018)。图片作者。</figcaption></figure><h1 id="155e" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">PurgedKFoldCV代码</h1><p id="0c3b" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">麻省理工的Sam31415为此做了一个包，经过一番挣扎，我们找到了使用方法。然而，CombPurgedKFoldCV类需要一些修复！所以我们推荐使用我的版本(在Colab中提供)。</p><p id="296d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想知道细节，你可以在GitHub上找到下面的细节:</p><div class="ip iq gp gr ir lb"><a href="https://github.com/sam31415/timeseriescv" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd jg gy z fp lg fr fs lh fu fw je bi translated">GitHub-Sam 31415/timeseriescv:sci kit-学习风格的时间序列数据交叉验证类</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">这个包实现了两个交叉验证算法，适用于评估基于时间的机器学习模型…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="ns l lm ln lo lk lp ix lb"/></div></div></a></div><p id="509c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">你的数据</strong></p><p id="2127" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您将要应用的数据框有两个要求:</p><ol class=""><li id="1a93" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">它必须是一个时间序列</li><li id="4439" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">它需要基于未来价值的目标标签</li></ol><p id="9dfe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">仅此而已；您可以在<strong class="ke jg">任何</strong>数据帧上这样做！</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/2e420bc5f43f27284d836f0e9e8b3a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pquIhu0gr98q7QD0OMP9ww.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">我的数据框架的例子。<em class="nr">作者图片</em></figcaption></figure><p id="be8e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个考虑到比特币特征的数据框架示例。它有一个时间戳，一些特性，以及一个基于未来<em class="nu"> t_final </em>的label_barrier。如果您想了解更多关于我们如何获得这个<strong class="ke jg">特定示例</strong>数据框的信息，请点击下面的故事:</p><div class="ip iq gp gr ir lb"><a href="https://medium.com/coinmonks/crypto-feature-importance-for-deep-reinforcement-learning-38416616c2a36-8416616c2a36" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd jg gy z fp lg fr fs lh fu fw je bi translated">加密特征对深度强化学习的重要性</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">本文由开源项目AI4Finance的核心团队成员Berend Gort &amp; Bruce Yang撰写。这个…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">medium.com</p></div></div><div class="lk l"><div class="nv l lm ln lo lk lp ix lb"/></div></div></a></div><p id="dd8c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">代码</strong></p><p id="31b2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请记住，我们有观察和评估。如果您对组合PurgedKFoldCV感兴趣，您的评估将在未来执行，并与您的观察时间相关联！例如，在我的例子中，我的评估是未来的+<em class="nu">t _ final</em><strong class="ke jg"><em class="nu"/>数据点。</strong></p><p id="648a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要观察和评估的时间，可以这样做。在下面的剪报中:</p><ol class=""><li id="5d9a" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">选择比特币数据。</li><li id="c998" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">获取比特币数据的索引，即时间戳(参见数据框向上)。</li><li id="d56d" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">从特征数据框X ( <em class="nu"> label_barrier </em>)中删除目标变量，并删除最后一个<em class="nu"> t_final </em>特征。这些是无用的，因为它们的预测值是NaN。图2:将测试组分配到5条路径中的每一条，洛佩兹·德·普拉多，M. (2018)。图片作者。</li><li id="8c0d" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">选择目标变量<em class="nu"> y </em>，给它旧数据帧的索引。</li><li id="4c9a" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">丢弃最后的<em class="nu"> t_final </em>预测(它们是NaN，因为没有其他数据可以预测)。</li><li id="b43b" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">设置进行观察的时间(预测时间)。</li><li id="41f1" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">设置对目标变量进行预测的时间(评估时间)。</li></ol><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="159e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">绘制您的组合PurgedKFoldCV </strong></p><p id="fcfd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以创建一个类CombPurgedKFoldCV的实例。为了简单起见，让我们坚持Lopez的例子，其中组N=6 (Python从0，因此5！)，试验组的k=2。</p><p id="f007" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">禁运取决于您的问题，但为了简单起见，我们将禁运视为与清除相同的值。</p><p id="a69d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">本文底部给出并描述了<em class="nu">back _ test _ paths _ generator</em>函数。</strong></p><pre class="nk nl nm nn gt ny nz oa ob aw oc bi"><span id="8aa0" class="od lr jf nz b gy oe of l og oh"># Constants<br/>num_paths = 5<br/>k = 2<br/>N = num_paths + 1<br/>embargo_td = pd.Timedelta(days=1)* t_final</span><span id="3102" class="od lr jf nz b gy oi of l og oh"># instance of class<br/>cv = CombPurgedKFoldCV(n_splits=N, n_test_splits=k, embargo_td=embargo_td)</span><span id="f729" class="od lr jf nz b gy oi of l og oh"># Compute backtest paths<br/>_, paths, _= back_test_paths_generator(X.shape[0], N, k)</span><span id="c376" class="od lr jf nz b gy oi of l og oh"># Plotting<br/>groups = list(range(X.shape[0]))<br/>fig, ax = plt.subplots()<br/>plot_cv_indices(cv, X, y, groups, ax, num_paths, k)<br/>plt.gca().invert_yaxis()</span></pre><p id="7c25" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我基于交叉验证页面的可视化<a class="ae la" href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_cv_indices.html" rel="noopener ugc nofollow" target="_blank">sk learning构建了以下绘图函数，修改了现有函数并添加了一些必要的项目。</a></p><p id="731a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">注意，在第13行中，for循环正是您的训练过程中的情况。这是您想要复制的行，以便最终训练每个分类器！</strong></p><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">绘制您的组合PurgedKFoldCV</figcaption></figure><h1 id="7ac7" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结果呢</h1><p id="0502" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">图3显示了所提供的绘图代码的结果。</p><p id="a987" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在图3中:</p><ul class=""><li id="cf5c" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">蓝色:训练周期</li><li id="ea67" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">禁运/清除期:深红色</li><li id="fec3" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">测试周期:浅红色</li></ul><p id="0a5b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，看看深红色的禁运/清除期:</p><ul class=""><li id="f060" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">在测试期之前和训练期<strong class="ke jg">之后有一个净化期。</strong></li><li id="37da" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">在一个测试期之后，我们有一个净化期和禁运期</li><li id="70cd" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">禁运期大于清除期</li></ul><p id="d463" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，在一个测试集的结尾将比在一个测试集的开始之前有更大的间隙。</p><p id="2b63" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，请花些时间比较图3和图4，注意相等性</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/1a03a49b0df94db0216fd35754586c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imtXfyCqaBvAhOqgiM7x7Q.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图2:将测试组分配到5条路径中的每一条，洛佩兹·德·普拉多，M. (2018)。图片作者。</figcaption></figure><p id="9b6c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">组合PurgedKFoldCV回溯测试路径生成器解释</strong></p><p id="8bbe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这个函数非常简单，它只需要三个参数(观察值、N和k)。目标是描述如下所示的路径1–5。快速通读，在代码下面，我们将解释这个函数的结果路径。</p><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c2f6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Colab数据集中，我们有813个观察值。输入大小对于解释这个函数并不重要；假设我们只有30个观察值，仍然有N=6个组和k=2个测试组。</p><p id="1fc9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了简化笔记本中路径输出的思考，我们增加了1！</p><pre class="nk nl nm nn gt ny nz oa ob aw oc bi"><span id="5694" class="od lr jf nz b gy oe of l og oh"># Compute backtest paths<br/>N_observations = 30 ## colab dataset 813</span><span id="c1b8" class="od lr jf nz b gy oi of l og oh">_, paths, _= back_test_paths_generator(N_observations, N, k, prediction_times, evaluation_times)</span><span id="5e05" class="od lr jf nz b gy oi of l og oh"># Add plus one to avoid pythonic 0 counting (more logical for you guys)<br/>paths + 1</span></pre><figure class="nk nl nm nn gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c334a4681329eeffabe73b1bc384e8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*AxavnCOv2DDDQJyU_P2qRg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图6:回溯测试路径生成器函数的输出“路径”示例。<em class="nr">作者的形象。</em></figcaption></figure><p id="bc90" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看到这个函数做什么了吗？图6中的每一列都是回溯测试路径。在这种情况下，我们的数据跨越30个数据点。因此，每组的大小是5个数据点(有6组)。我们已经用粉红色的水平线表示了组的分裂。这些数字表明您应该采取哪些预测(如图3所示)。</p><p id="4796" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，对于路径4:</p><ul class=""><li id="d417" class="mu mv jf ke b kf kg kj kk kn mw kr mx kv my kz ni na nb nc bi translated">从分类器4中预测数据点1-5</li><li id="ebce" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">从分类器8中预测数据点6–10</li><li id="f54d" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">从分类器11获取数据点11–15的预测</li><li id="85c2" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">从分类器13获取数据点16–20的预测</li><li id="40d8" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">对来自分类器13的数据点21–25进行预测</li><li id="80bf" class="mu mv jf ke b kf nd kj ne kn nf kr ng kv nh kz ni na nb nc bi translated">对来自分类器14的数据点25–25进行预测</li></ul><p id="c1c1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！</p><h1 id="5d39" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="f838" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">传统的时间序列回测是样本低效的，会出现泄漏。净化和禁运是必要的，以避免极端的信息泄漏。传统的前向回溯测试方法只测试单一场景，容易过度拟合。此外，WF并不代表未来的表现，因为数据点的特定顺序可能会影响结果。最后，WF的初始决策是基于总样本空间的一小部分。PurgedK-FoldCV通过对大小相等的组执行回溯测试来解决这些问题。此外，每个观察都是一个且只有一个测试集的一部分。最后，组合PurgedK-FoldCV允许许多独特的回溯测试路径，这降低了错误发现的可能性。</p><p id="647b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文提供了如何索引组合PurgedKFoldCV的代码和完整解释。总结了文献中最常用方法的优点(缺点),并与组合PurgedKFoldCV方法的优点(缺点)进行了比较。之后，对该方法进行了深入的研究，并阐述了几个难以掌握的要点。最后，对Colab代码进行了简单的讨论和解释。</p><p id="fa5b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望它以后能有很多开心的用户。</p><p id="dd76" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nu">感谢寻根“来自TA-lib的比特币最佳技术指标”！</em></p><p id="5e7a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nu"> ~贝伦德&amp;布鲁斯</em></p><h1 id="66c2" class="lq lr jf bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">参考</h1><p id="d587" class="pw-post-body-paragraph kc kd jf ke b kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz ij bi translated">普拉多医学博士。(2018).<em class="nu">金融机器学习的进展</em>。</p></div></div>    
</body>
</html>