<html>
<head>
<title>Best SQL Examples To Understand Self Join</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解自联接的最佳SQL示例</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/best-sql-examples-to-understand-self-join-905495f0f5a9?source=collection_archive---------1-----------------------#2022-07-16">https://pub.towardsai.net/best-sql-examples-to-understand-self-join-905495f0f5a9?source=collection_archive---------1-----------------------#2022-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2850" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用自连接、非等价连接和日期函数提高您的SQL技能！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/603e2c74ab5cff4754c28858a576309e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEuNkb6wmH6nTtxEkHOmuw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由freepik 创建的<a class="ae ky" href="https://www.freepik.com/vectors/human-illustration" rel="noopener ugc nofollow" target="_blank">人体插图矢量——www.freepik.com</a><a class="ae ky" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="d417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">作为我之前两篇文章的快速延续—</em><strong class="lb iu">T</strong><a class="ae ky" href="https://towardsdatascience.com/top-5-sql-date-functions-you-should-know-in-2022-2180328ab940" rel="noopener" target="_blank"><strong class="lb iu">op 5 2022年你应该知道的SQL日期函数</strong> </a>和<a class="ae ky" href="https://towardsdatascience.com/5-advanced-sql-concepts-you-should-know-in-2022-b50efe6c99" rel="noopener" target="_blank"><strong class="lb iu">2022年你应该知道的5个高级SQL概念</strong> </a></p><p id="8a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在Leetcode上发现了这个有趣的问题，它本质上是测试你如何实现SQL自连接和日期函数。</p><blockquote class="lw"><p id="99c9" class="lx ly it bd lz ma mb mc md me mf lu dk translated"><a class="ae ky" href="https://leetcode.com/problems/rising-temperature/" rel="noopener ugc nofollow" target="_blank">编写一个SQL查询，查找所有与之前日期(昨天)相比温度更高的日期。</a></p></blockquote><p id="65cb" class="pw-post-body-paragraph kz la it lb b lc mk ju le lf ml jx lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">因此，我在这里提出了一个完整的解决方案，并通过一个例子逐步解释了每个步骤。</p><p id="9e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章的结尾，你可以有效地使用—</p><p id="54b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✅自连接—将表与其自身连接起来</p><p id="5989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✅非相等连接—执行不带相等运算符的连接<code class="fe mg mh mi mj b"><strong class="lb iu">=</strong></code></p><p id="ce05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL中的✅日期函数-根据日期时间值过滤记录</p><blockquote class="mp mq mr"><p id="cb63" class="kz la lv lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">📍注意:我使用的MySQL Workbench &amp;地震数据集来自<a class="ae ky" href="https://www.kaggle.com/datasets/usgs/earthquake-database" rel="noopener ugc nofollow" target="_blank">ka ggle</a><a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">public</a>dataset&amp;，现在可以在我的<a class="ae ky" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Github </strong> </a> repo上免费获得<a class="ae ky" href="https://github.com/17rsuraj/data-curious/blob/master/LICENSE.md" rel="noopener ugc nofollow" target="_blank"> MIT许可</a>！</p></blockquote><p id="d41b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用的数据集如下所示..</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/0743a512be49f30ed4f689fb10c60c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*6MapYyrBucu7wnHA4Tcixg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">地震数据集|作者图片</figcaption></figure><p id="0f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的2000 x 7数据集！</p><blockquote class="mp mq mr"><p id="8d4a" class="kz la lv lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">为了更容易理解，请务必阅读开头提到的两篇文章</p></blockquote><p id="c852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们开始吧…🚀</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="9f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始这个实际的问题之前，让我们先了解它是如何与下面的例子一起工作的，我确信在看完这个例子之后，您将为Leetcode问题编写自己的查询。</p><p id="5d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我将这个问题转化为我们的地震数据集版本，如下所示—</p><blockquote class="mp mq mr"><p id="33f5" class="kz la lv lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated"><strong class="lb iu">编写一个查询，返回地震震级高于前一天(昨天)的所有id</strong></p></blockquote><p id="6583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点很清楚，你需要比较两个日期的地震震级。然而，你只有一个表，这意味着，这是自连接的问题。</p><p id="9bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在上一篇文章<a class="ae ky" href="https://towardsdatascience.com/5-advanced-sql-concepts-you-should-know-in-2022-b50efe6c99#3ad5" rel="noopener" target="_blank"> <strong class="lb iu"> 5高级SQL概念</strong> </a>中提到的，SELF JOIN是使用关键字<code class="fe mg mh mi mj b">JOIN</code>将一个表与其自身连接起来。</p><p id="5c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为两个表名相同，所以在自连接的情况下使用表别名是很重要的。💯</p><p id="43ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题中最重要的一步是如何执行连接操作。</p><p id="be64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先使用公共列ID连接两个表。</p><pre class="kj kk kl km gt nd mj ne nf aw ng bi"><span id="b585" class="nh ni it mj b gy nj nk l nl nm">SELECT t1.*, t2.*<br/>FROM sql_practice.earthquakes AS t1<br/><strong class="mj iu">JOIN sql_practice.earthquakes AS t2</strong><br/><strong class="mj iu">ON t1.ID = t2.ID</strong><br/>WHERE t1.Magnitude &gt; t2.Magnitude<br/>AND DATEDIFF(t1.Dates, t2.Dates) = 1;</span></pre><p id="18a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将空数据集作为输出返回。</p><blockquote class="mp mq mr"><p id="567e" class="kz la lv lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">注:别名T1和t2分别代表今天的<strong class="lb iu">和昨天的</strong>和<strong class="lb iu">两个表，这样当你说t1的时候。震级&gt; t2。震级，你实际上是在用昨天的震级来检验今天的震级。</strong></p></blockquote><p id="8b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我们先来了解一下为什么它什么都不返回。</p><p id="bc08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果仔细观察原始数据集，您会发现每个ID对应一个日期时间值和一个量值。</p><p id="aec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以当你把表和它本身连接在一起的时候，它永远不会有两个不同的量级。这意味着条件<code class="fe mg mh mi mj b"><strong class="lb iu">t1.Magnitude &gt; t2.Magnitude</strong></code>永远不会满足。因此，您会得到空数据集作为输出。</p><p id="683f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，❓有什么解决办法呢</p><p id="3a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与JOIN子句中常用的等式运算符<code class="fe mg mh mi mj b"><strong class="lb iu">=</strong></code>不同，您需要使用非等式运算符(从<code class="fe mg mh mi mj b"><strong class="lb iu">&gt;</strong></code>、<code class="fe mg mh mi mj b"><strong class="lb iu">&lt;</strong></code>、<code class="fe mg mh mi mj b"><strong class="lb iu">≤</strong></code>、<code class="fe mg mh mi mj b"><strong class="lb iu">≥</strong></code>、<code class="fe mg mh mi mj b"><strong class="lb iu">&lt;&gt;</strong></code>中的任何一个)。这种类型的连接称为<strong class="lb iu">非对等</strong>连接。</p><p id="82c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用修改后的JOIN子句重写解决方案。</p><pre class="kj kk kl km gt nd mj ne nf aw ng bi"><span id="ace1" class="nh ni it mj b gy nj nk l nl nm">SELECT t1.*, t2.*<br/>FROM sql_practice.earthquakes AS t1<br/><strong class="mj iu">JOIN sql_practice.earthquakes AS t2</strong><br/><strong class="mj iu">ON t1.Magnitude &gt; t2.Magnitude</strong>;</span></pre><p id="c610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您正在连接两个表，使得今天的数值总是高于昨天的数值。它很快返回输出，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/f3fe0c479cfe184e885f6cd9d989bd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xy22FA_isDPccTSfA5DcJQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">非对等SQL联接|按作者排列的图像</figcaption></figure><p id="38dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，今天部分的日期(<em class="lv">标为红色</em>)总是多于昨天部分的日期(<em class="lv">标为黄色</em>)。但是，同一行中两个日期之间的差值并不总是等于1，而是在大多数情况下大于1。</p><p id="f186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您需要使用<code class="fe mg mh mi mj b"><strong class="lb iu">DATEDIFF</strong></code>函数将两个日期之间的差异限制在1天之内。</p><pre class="kj kk kl km gt nd mj ne nf aw ng bi"><span id="d38d" class="nh ni it mj b gy nj nk l nl nm">SELECT t1.*, t2.*<br/>FROM sql_practice.earthquakes AS t1<br/>JOIN sql_practice.earthquakes AS t2<br/>ON t1.Magnitude &gt; t2.Magnitude<br/>AND <strong class="mj iu">DATEDIFF(t1.Dates, t2.Dates) = 1</strong>;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c4d179d8c638b7ec18aa0839b95fae8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgz2a1-G3f7LXbpTlOOvcA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">非对等SQL联接|按作者排列的图像</figcaption></figure><p id="cd18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可以看到任何记录中两个日期之间的差异只有一天，这是需要的。在最终输出中，您只需要震级高于前一天的id，您可以使用<code class="fe mg mh mi mj b">t1.ID</code>而不是<code class="fe mg mh mi mj b">t1.*, t2.*</code>来选择，如下所示。</p><pre class="kj kk kl km gt nd mj ne nf aw ng bi"><span id="9ed8" class="nh ni it mj b gy nj nk l nl nm">SELECT t1.ID<br/>FROM sql_practice.earthquakes AS t1<br/><strong class="mj iu">JOIN sql_practice.earthquakes AS t2<br/>ON t1.Magnitude &gt; t2.Magnitude<br/>AND DATEDIFF(t1.Dates, t2.Dates) = 1;</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b39debf27ca2fabf1b147ac35426851b.png" data-original-src="https://miro.medium.com/v2/resize:fit:172/format:webp/1*WdaLCXwx9btH685SID4gpA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最终输出|作者图片</figcaption></figure><p id="1430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以类似的方式，您也可以使用我在这里提到的非等价连接和SQL日期函数来编写对<a class="ae ky" href="https://leetcode.com/problems/rising-temperature/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>问题的解决方案。</p><blockquote class="mp mq mr"><p id="7680" class="kz la lv lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">编写一个SQL查询来查找所有与之前日期(昨天)相比温度更高的日期'<code class="fe mg mh mi mj b">Id</code>。</p></blockquote><pre class="kj kk kl km gt nd mj ne nf aw ng bi"><span id="f052" class="nh ni it mj b gy nj nk l nl nm">SELECT today.id FROM Weather AS today <br/>JOIN Weather AS yesterday<br/><strong class="mj iu">ON today.temperature &gt; yesterday.temperature</strong><br/><strong class="mj iu">AND TIMESTAMPDIFF(DAY, yesterday.recordDate, today.recordDate) = 1</strong></span></pre><p id="cd2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<code class="fe mg mh mi mj b">DATEDIFF</code>功能重新编写这个查询，并在这里  交叉检查您的答案<a class="ae ky" href="https://towardsdatascience.com/top-5-sql-date-functions-you-should-know-in-2022-2180328ab940" rel="noopener" target="_blank"> <strong class="lb iu"> <em class="lv">。</em></strong></a></p><p id="b231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="b6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您发现这个示例很有用，并学会了如何一起使用SQL <code class="fe mg mh mi mj b"><strong class="lb iu">SELF JOIN</strong></code>、<code class="fe mg mh mi mj b"><strong class="lb iu">Non-Equi </strong></code> Join和<code class="fe mg mh mi mj b"><strong class="lb iu">DATE</strong></code>函数。我发现总结高级SQL查询的经验非常有用。</p><p id="374c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于日期-时间运算和自连接的问题通常是数据科学工作的面试问题，因为它们在现实世界的分析中更有用。</p><blockquote class="lw"><p id="bc7c" class="lx ly it bd lz ma mb mc md me mf lu dk translated"><em class="nq">对阅读介质上的无限故事感兴趣？？</em></p></blockquote><p id="43cc" class="pw-post-body-paragraph kz la it lb b lc mk ju le lf ml jx lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">💡考虑<a class="ae ky" href="https://medium.com/@17.rsuraj/membership" rel="noopener"> <strong class="lb iu">成为媒体会员</strong></a><strong class="lb iu">访问媒体上无限的</strong>故事和每日有趣的媒体文摘。我会得到你的费用的一小部分，没有额外的费用给你。</p><p id="9f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">💡请务必<a class="ae ky" href="https://medium.com/subscribe/@17.rsuraj" rel="noopener"> <strong class="lb iu">注册我的电子邮件列表</strong> </a>，千万不要错过另一篇关于数据科学指南、技巧和提示、SQL和Python的文章。</p><p id="a5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢您的阅读！</strong></p></div></div>    
</body>
</html>