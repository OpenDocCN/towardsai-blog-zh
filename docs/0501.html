<html>
<head>
<title>Clash Royale API: Looping Query for Data Collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clash Royale API:循环查询数据收集</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/clash-royale-api-looping-query-for-data-collection-2a6ed6a505d4?source=collection_archive---------1-----------------------#2020-05-17">https://pub.towardsai.net/clash-royale-api-looping-query-for-data-collection-2a6ed6a505d4?source=collection_archive---------1-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="19e3" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><p id="02db" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">几天前，我有了一个想法，将因子分析应用于皇家冲突的玩家，以便将他们分成不同的等级。不幸的是，我意识到我无法在网上找到任何相关的数据，并且我找到的开源数据集都没有我正在搜索的信息:因此，我决定使用API从源下载原始数据。</p><p id="7c70" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">您可以使用本教程作为指南，指导您使用API和从在线数据库收集数据。在下一篇教程中，我将对结果进行因子分析，以识别收集到的数据中的层次结构。</p><blockquote class="ku"><p id="490f" class="kv kw iq bd kx ky kz la lb lc ld kt dk translated">我的GitHub repo 上有完整的代码。</p></blockquote><h1 id="00f9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">下载JSON文件中的Clash Royale匹配</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/769ae99b21b1e0efd58b9e48daf8afc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCKApBlANzTg5w-gYAiLRA.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图片来自壁纸洞穴</figcaption></figure><p id="a529" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">Clash Royale是一款智能手机游戏，允许每个玩家建立一套8张不同的卡片来与其他玩家战斗。通过https://developer.clashroyale.com/#/<a class="ae le" href="https://developer.clashroyale.com/#/" rel="noopener ugc nofollow" target="_blank">网站，我可以看到一名球员最近25场比赛的信息。我想收集并存储顶级玩家在最近25场战斗中打出的每副牌的数据，以便我以后可以使用这些数据来训练一个AI。为此，我需要:</a></p><p id="b40e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">1.在developer.clashroyale.com<a class="ae le" href="https://developer.clashroyale.com/#/" rel="noopener ugc nofollow" target="_blank">注册并获得一个API令牌</a></p><p id="c6e9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">2.通过API建立到数据集的连接</p><p id="357c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">3.下载一组特定的数据(我不能下载所有的数据，我需要明确我想要收集的数据)</p><p id="6e91" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">4.遍历每一个。json，从。json文件并存储它们</p><p id="79d0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">5.将所有存储的数据做成相同的形状，然后创建一个数据帧</p><p id="bfff" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">6.导出数据帧</p><h1 id="8515" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">实际问题</h1><p id="147e" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">实际上，当使用API下载数据时，我们会遇到很多限制:</p><ul class=""><li id="c637" class="nb nc iq jy b jz ka kd ke kh nd kl ne kp nf kt ng nh ni nj bi translated">有时间限制:我们可以下载与时间相关的小批量数据</li></ul><p id="ff4c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这个问题使得使用这个数据库非常具有挑战性。我知道对于我的AI来说，我需要成千上万的匹配来执行任何类型的分析，然而，我可以每4分钟下载多达25个匹配，其中15个可能是有效的(我只想存储‘梯子’游戏，丢弃所有其他的):这设置了每小时225个匹配的下载限制，假设算法完全运行并且每个请求都是有效的(即使在执行有效的请求时，你也不会相信会发生多少问题)。</p><p id="b9b1" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">通过这篇文章，我将指导你构建一个算法，它能够<strong class="jy ja">周期性地</strong>连接到一个在线数据库来提取信息，将它们收集到一个数据帧中，你可以将它导出为一个. csv文件。</p><ul class=""><li id="bd5a" class="nb nc iq jy b jz ka kd ke kh nd kl ne kp nf kt ng nh ni nj bi translated">我们需要知道要搜索什么数据</li></ul><p id="07e1" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这个特定的例子中，我需要输入参加过我想要收集数据的比赛的球员的标签。我将选择7个玩X弓原型的顶级玩家(使用这个原型的顶级玩家被称为柠檬树68，他的名字将会在时间中回响…)。如前所述，我只想保存在“天梯”中玩的游戏，所以我需要删除所有其他游戏:在25个原始游戏中，我可能只能存储15个。</p><ul class=""><li id="2463" class="nb nc iq jy b jz ka kd ke kh nd kl ne kp nf kt ng nh ni nj bi translated">我们需要处理。json文件</li></ul><p id="89cb" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">API将为我们提供一个字典列表，每个字典代表一个匹配。然而，我们不能仅仅将它转换成. csv:我们需要确定我们想要保存的特性，然后将它们存储到一个列表中。我们下载的json字典:我们需要为此创建一个个性化的算法。</p><p id="03f8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果你的目标是更专业的数据科学方法，你将需要习惯于使用API直接从特定网站下载数据，而不是在一些开源存储库中找到已经结构化的数据。</p><h1 id="ea57" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">连接到数据库</h1><p id="898e" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">让我们开始浏览步骤列表:首先，我已经在上面的网站中注册，并请求与我的IP地址相关联的开发者密钥:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nk"><img src="../Images/a372684f8f1411e563b4226caba8b34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rU4Ov9gi4W8bcBCh2_iRIA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">在<a class="ae le" href="https://developer.clashroyale.com/#/" rel="noopener ugc nofollow" target="_blank">https://developer.clashroyale.com/#/</a>创建的密钥</figcaption></figure><p id="7ed4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当我在我的代码中使用这个密钥时，如果查询(请求)是正确的并且IP地址是对应的，数据库将授权我，并允许我下载数据。现在，我将建立一个与数据库的连接:</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="3105" class="nq lg iq nm b gy nr ns l nt nu">import requests<br/>import json<br/>from urllib.parse import quote<br/>import time</span><span id="484f" class="nq lg iq nm b gy nv ns l nt nu">headers = {<br/>'Accept': 'application/json',<br/>'authorization': 'Bearer &lt;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiIsImtpZCI6IjI4YTMxOGY3LTAwMDAtYTFlYi03ZmExLTJjNzQzM2M2Y2NhNSJ9.eyJpc3MiOiJzdXBlcmNlbGwiLCJhdWQiOiJzdXBlcmNlbGw6Z2FtZWFwaSIsImp0aSI6ImFkODhlY2NjLTM2YjUtNDUwZi1hODI0LTY3ZWIyZjc0MzY5YSIsImlhdCI6MTU4OTQ4MzUyMiwic3ViIjoiZGV2ZWxvcGVyLzJkZGRhOGI4LTEyY2YtMzQzNy05N2FjLTQxNTBhMTMzNGI1MiIsInNjb3BlcyI6WyJyb3lhbGUiXSwibGltaXRzIjpbeyJ0aWVyIjoiZGV2ZWxvcGVyL3NpbHZlciIsInR5cGUiOiJ0aHJvdHRsaW5nIn0seyJjaWRycyI6WyIxMDQuMTU1LjIxOC4xNzgiXSwidHlwZSI6ImNsaWVudCJ9XX0.PdB9ycHIcIkKRs246zKLNdRJleUiXV9u-szeMj9qm02Rz-wS4OkkfOaafWRMXos_LVLmZe1VeUBCpr6fIiMvRw&gt;'<br/>}</span></pre><h1 id="015d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">准备请求</h1><p id="c753" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">如前所述，我需要非常具体地说明我要下载哪些数据。我将下载世界上7个顶级X-bow玩家最近的比赛(每个玩家25场比赛)。因此，我将存储以下标签。</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="353f" class="nq lg iq nm b gy nr ns l nt nu">#has to be run only once, otherwise the dataset we are going to create will reset<br/>battles_list = list()</span><span id="8f5c" class="nq lg iq nm b gy nv ns l nt nu">tag_list = [<br/>'#929URQCL8', '#RC2JGVVG', '#R9QC0QUQ', <br/>'#9JPL980Y2', '#YU8R0VPP', '#RPURG9GR', <br/>'#2GYRQJRR8']</span><span id="4240" class="nq lg iq nm b gy nv ns l nt nu">tag_list_scavenged = list()<br/>columns = [<br/>'gamemode', 'battletime',<br/>'p1.name', 'p2.name',<br/>'p1.crowns', 'p2.crowns',<br/>'p1.card_1', 'p1.card_2', 'p1.card_3', 'p1.card_4', <br/>'p1.card_5','p1.card_6', 'p1.card_7', 'p1.card_8',<br/>'p2.card_1', 'p2.card_2', 'p2.card_3', 'p2.card_4', <br/>'p2.card_5', 'p2.card_6', 'p2.card_7', 'p2.card_8'<br/>]</span></pre><p id="780e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">因为我已经查看了数据，所以我还将保存我希望应用到最新版本的。我们将要创建的csv数据集:基本上是游戏模式(我们将使用这些信息来丢弃所有未在‘天梯’中玩的游戏)、战斗时间和两个玩家的姓名(为了丢弃重复的游戏)、计算谁赢了这场比赛的冠数，以及每个玩家选择的牌组。</p><h1 id="a68e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">为每个标签转发一个查询</h1><p id="cada" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">现在，我将创建一个允许我对数据库执行GET请求的函数:对于每个玩家标记，我将下载一个. json文件，进行适当的修改，最后得到一个包含25个元素的列表:每个元素只包含我想要作为战斗摘要的数据。</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="8eb6" class="nq lg iq nm b gy nr ns l nt nu">import pandas as pd<br/>from pandas.io.json import json_normalize</span><span id="ee5b" class="nq lg iq nm b gy nv ns l nt nu">def p1_dataset(player_tag):<br/>  df_list_complete = list()</span><span id="1b0d" class="nq lg iq nm b gy nv ns l nt nu">  #downloading json<br/>  r =   requests.get('https://api.clashroyale.com/v1/players/'+player_tag+'/battlelog', headers=headers)<br/>  #a contains 25 dicts in a list<br/>  try:<br/>  a = r.json()</span><span id="717f" class="nq lg iq nm b gy nv ns l nt nu">  ###IN CASE OF UNRESOLVED ERROR: EXIT<br/>  except Exception as e:<br/>    return 1</span><span id="3c34" class="nq lg iq nm b gy nv ns l nt nu">  ###IN CASE OF FAILED REQUEST: EXIT<br/>  if a == {'reason': 'accessDenied', 'message': 'Invalid authorization'}:<br/>    return 0</span></pre><p id="85b9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果数据集返回错误，函数将退出并返回0或1。</p><h1 id="882f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">将每个JSON构造成一个数据帧</h1><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="dc74" class="nq lg iq nm b gy nr ns l nt nu">  #for each of the 25 dicts in the list<br/>  for n in a:</span></pre><h2 id="df24" class="nq lg iq bd lh nw nx dn ll ny nz dp lp kh oa ob lt kl oc od lx kp oe of mb iw bi translated">将所有数据下载到变量</h2><p id="f439" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">到目前为止，最大的问题是构造每个. json。正如你从我下载的内容中看到的，它是一组字典中的字典。我要做的是使用pandas.io.json.json_normalize，这个工具允许我将一个单元格中包含的字典转换成另一个数据帧。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi og"><img src="../Images/a6738c3bf721e61db4d8b7e4421abdb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HspKMUzuNLOpgo1IP_M17g.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">怎么会。json看起来会像</figcaption></figure><p id="6770" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">本质上，我将处理几个嵌套的字典:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oh"><img src="../Images/663ee5bb8d85afdad83fe4a00340ed38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdEhgKUWQGjaxqmmagtQaw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">DataFrame的. json将会是什么样子</figcaption></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oi"><img src="../Images/676df4f92d4db44b91ddf1246357677b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9S6ipuVsz3xnR1wzmollw.png"/></div></div></figure><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="af99" class="nq lg iq nm b gy nr ns l nt nu">    df1 = json_normalize(n)<br/>    df_opponent = json_normalize(df1['opponent'][0])</span><span id="9d0e" class="nq lg iq nm b gy nv ns l nt nu">    df_opponent_name = df_opponent['name'][0]<br/>    df_opponent_crowns = df_opponent['crowns'][0]<br/>    df_opponent_cards = json_normalize(df_opponent['cards'][0])<br/>    df_opponent_cards = df_opponent_cards['name'].tolist()</span><span id="3f79" class="nq lg iq nm b gy nv ns l nt nu">    df_team = json_normalize(df1['team'][0])<br/>    df_team_name = df_team['name'][0]<br/>    df_team_crowns = df_team['crowns'][0]<br/>    df_team_cards = json_normalize(df_team['cards'][0])<br/>    df_team_cards = df_team_cards['name'].tolist()</span><span id="7a2d" class="nq lg iq nm b gy nv ns l nt nu">    battletime = df1['battleTime'][0]<br/>    gamemode = df1['gameMode.name'][0]</span></pre><h2 id="a943" class="nq lg iq bd lh nw nx dn ll ny nz dp lp kh oa ob lt kl oc od lx kp oe of mb iw bi translated">将所有变量放在一个列表中</h2><p id="db6f" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">我将把数据帧的每个元素存储在一个变量中，同时我需要扩展嵌套的字典来找出它们还包含哪些变量。最后，我会给出一个变量列表。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oj"><img src="../Images/d0f453a0b2bea3b21f5adf5b0754ff08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHVNmukzt6-5v4B9y1Y__g.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">在将所有嵌套数据存储到单个列表中之后</figcaption></figure><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="7beb" class="nq lg iq nm b gy nr ns l nt nu">    df_list = list()<br/>    #append individual variables<br/>    df_list = [<br/>               gamemode, <br/>               battletime,<br/>               df_team_name, <br/>               df_opponent_name,<br/>               df_team_crowns, <br/>               df_opponent_crowns<br/>              ]<br/>    #append lists<br/>    for team_card_n in df_team_cards:<br/>      df_list.append(team_card_n)<br/>    for opponent_card_n in df_opponent_cards:<br/>      df_list.append(opponent_card_n)</span></pre><h2 id="5488" class="nq lg iq bd lh nw nx dn ll ny nz dp lp kh oa ob lt kl oc od lx kp oe of mb iw bi translated">将列表附加到我们的数据框架中</h2><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="8b8c" class="nq lg iq nm b gy nr ns l nt nu">    df_list_complete.append(df_list)<br/>    return df_list_complete</span></pre><h1 id="46b8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">循环查询</h1><p id="61af" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">我们已经创建了一个功能，让我们下载和正确存储每个球员标签25场比赛。现在我们必须以某种方式激活它，给定7个玩家标签的列表，算法不会停止，直到它下载了所有的数据(175行)。为了做到这一点，我们将让它循环，直到它完成它的任务:</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="54e9" class="nq lg iq nm b gy nr ns l nt nu">first_round = True<br/>#looping through queries until all our requests are filled<br/>while len(tag_list_scavenged) &lt; len(tag_list):<br/>  #we cannot substitute existing tags<br/>  for m in tag_list:<br/>    if m in tag_list_scavenged:<br/>      print(‘Tag already in list:’, m)<br/>    else:<br/>      #the first round skip the waiting<br/>      if first_round == True:<br/>        first_round = False<br/>      else:<br/>        #wait 240 seconds<br/>        time.sleep(240)<br/>      print('timer_ended')</span><span id="abf0" class="nq lg iq nm b gy nv ns l nt nu">      #GET request<br/>      csv = p1_dataset(quote(m))</span><span id="7795" class="nq lg iq nm b gy nv ns l nt nu">#manage errors<br/>    if csv == 0 or csv == []:<br/>      print('unable to download:', m)<br/>      pass<br/>    elif csv == 1:<br/>      print('unable to download due error:', m)<br/>      pass<br/>    else:<br/>      print(‘scavenged:’, m)<br/>      csv = pd.DataFrame(csv)<br/>      #we won't ne editing the columns until the end, here is only a reference<br/>      #csv.columns = columns<br/>      #we add the csv to the dataset<br/>      battles_list.append(csv)<br/>      #we save the tag so that the algorithm will not repeat the request for this tag<br/>      tag_list_scavenged.append(m)</span></pre><h1 id="fc41" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">处理错误</h1><p id="86e4" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">我们算法运行的最大风险是错误，因为它们迫使算法停止，需要手动重新激活。为了防止这种情况发生，在出现错误或空数据集(这种情况可能导致错误)时，我将返回一个条件(0或1)，算法将忽略该条件以继续循环。你可以用许多其他的方法来做这件事，我选择这件是因为我发现它是最舒适的。常见错误:</p><ul class=""><li id="8be7" class="nb nc iq jy b jz ka kd ke kh nd kl ne kp nf kt ng nh ni nj bi translated">下载的文件为空，结果为[]，导致JSONDecodeError</li><li id="0014" class="nb nc iq jy b jz ok kd ol kh om kl on kp oo kt ng nh ni nj bi translated">{ '原因':'拒绝访问'，'消息':'无效授权' }</li></ul><h1 id="0910" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">…28分钟后</h1><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="671c" class="nq lg iq nm b gy nr ns l nt nu">timer_ended<br/>scavenged: #RPURG9GR<br/>timer_ended<br/>scavenged: #2GYRQJRR8<br/>...</span></pre><p id="821d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果出现错误，算法会发出信号，但会继续工作并执行请求。如果我们检查tag_list_scavenged:</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="4918" class="nq lg iq nm b gy nr ns l nt nu">tag_list_scavenged<br/>[‘#929URQCL8’, <br/>‘#RC2JGVVG’, <br/>‘#R9QC0QUQ’, <br/>‘#9JPL980Y2’, <br/>‘#YU8R0VPP’, <br/>‘#RPURG9GR’, <br/>‘#2GYRQJRR8’]</span></pre><p id="5dc9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">上面，我们已经创建了一个数据集，其中包含了带有上述标签的所有玩家的战斗，使用了一个算法而不是几个手动请求。所有的匹配都被保存在战斗列表中。</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="c740" class="nq lg iq nm b gy nr ns l nt nu">#before editing further, we make a copy<br/>q = battles_list.copy()</span></pre><p id="2430" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">* * *如果由于任何原因算法会停止，因为在Jupiter笔记本上操作，变量将被临时存储:任何成功的请求都不会丢失</p><h1 id="fee0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">编辑战斗数据帧</h1><p id="faad" class="pw-post-body-paragraph jw jx iq jy b jz mw kb kc kd mx kf kg kh my kj kk kl mz kn ko kp na kr ks kt ij bi translated">我们现在必须放弃所有未被归类为“天梯”的游戏:</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="9c87" class="nq lg iq nm b gy nr ns l nt nu">#we only conserve ladder plays<br/>for i in range(0, len(q)):<br/>  #lista con i nomi delle colonne exra che volgiamo eliminare<br/>  list1 = [22 + x for x in range(0, q[i].shape[1]-22)]<br/>  print(list1)<br/>  #only maintain ladder games<br/>  q[i] = q[i].loc[q[i][0] == ‘Ladder’]</span></pre><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi op"><img src="../Images/a3d4eaf62618e23272aec155d9f48917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOgRVKx8IJtFHj2WVGSThg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">我们唯一想保留的游戏模式(第0列)是天梯</figcaption></figure><p id="9cb4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在有另一个问题:我们存储的列表长度不相等:因为有可能玩一个允许18副牌的游戏模式，所以一些列表比其他的要长。因为我们一直将它们存储为唯一的数据帧，所以我们需要删除所有额外的列:</p><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="7d18" class="nq lg iq nm b gy nr ns l nt nu">  #deleting all the extra columns<br/>  if q[i].shape[1] &gt; 22:<br/>  #if there are no extra columns, do not even bother, otherwise error<br/>    q[i] = q[i].drop(list1, axis=1)</span></pre><h1 id="df11" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">编辑最终数据帧</h1><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="fed5" class="nq lg iq nm b gy nr ns l nt nu">CRL = pd.DataFrame()<br/>CRL = pd.concat(q[0:len(q)], axis=0)<br/>#rinominiamo l’intero dataset alla fine<br/>CRL.columns = columns<br/>CRL</span></pre><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oq"><img src="../Images/a224b09d32538b9181f8b6c1ac5d817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQJD_E9AyKQYnWxqPybhOw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">最终数据集的屏幕截图</figcaption></figure><h1 id="4ee1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">导出到CSV</h1><pre class="me mf mg mh gt nl nm nn no aw np bi"><span id="a568" class="nq lg iq nm b gy nr ns l nt nu">CRL.to_csv(‘CRL.csv’)</span></pre></div></div>    
</body>
</html>