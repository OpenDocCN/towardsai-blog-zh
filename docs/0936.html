<html>
<head>
<title>What is Perspective Warping? | OpenCV and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是透视翘曲？| OpenCV和Python</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/what-is-perspective-warping-opencv-and-python-750e7a13d386?source=collection_archive---------1-----------------------#2020-09-17">https://pub.towardsai.net/what-is-perspective-warping-opencv-and-python-750e7a13d386?source=collection_archive---------1-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3a1f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a></h2><div class=""/><div class=""><h2 id="312c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">对图像应用透视变换的分步指南</h2></div><p id="cf17" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">计算机视觉现在非常热门。各地的人们都在从事某种形式的基于深度学习的计算机视觉项目。但是在深度学习出现之前，图像处理技术被用来操纵和转换图像，以获得帮助我们完成手头任务的洞察力。今天，让我们看看如何实现一种简单而有用的技术，即透视投影来扭曲图像。</p><p id="7a51" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是等等！扭曲图像是什么意思？我可以用许多花哨的词语和专业术语来解释它。但是，展示最终结果会很容易，这样你就可以通过观察来学习。反正你在看计算机视觉的文章:)</p><div class="ln lo lp lq gt ab cb"><figure class="lr ls lt lu lv lw lx paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/f60ed48dc2f1e96828650d2cae2df360.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*mAz3hmjnG03rnD9MacYGng.jpeg"/></div></figure><figure class="lr ls me lu lv lw lx paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/7177fb2a459e198ae98d84b8edb406c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*AE_faab3HWeif7aPgbeq6g.jpeg"/></div></figure><figure class="lr ls lt lu lv lw lx paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/0dc1f84b804d838b087d089045d8f3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*VBC37s6C0e4XFgy4tvvv_w.jpeg"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk mj di mk ml translated">基础图像(<a class="ae mm" href="https://unsplash.com/photos/Dnkr_lmdKi8" rel="noopener ugc nofollow" target="_blank">来源</a> ) —主题图像(<a class="ae mm" href="https://unsplash.com/photos/demvKRNvtLY" rel="noopener ugc nofollow" target="_blank">来源</a> ) —扭曲输出(图片由作者提供)</figcaption></figure></div><p id="85e0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以基本上，你拿一个图像，剪切它，使它适合任何想要的形状的画布。注意，反过来也是可能的。现在，这个问题已经解决了，让我们看看如何使用OpenCV和我们值得信赖的朋友Python(❤).来实现它</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="3f17" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于那些只想要代码的人，不用担心，我会帮你们搞定的:P这里是我的GitHub <a class="ae mm" href="https://github.com/GSNCodes/Image_Overlaying_Using_Perspective_Transform" rel="noopener ugc nofollow" target="_blank">库</a>的链接。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="801e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们进入代码的主要部分之前，我们必须首先导入必要的库。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="e646" class="mz na it mv b gy nb nc l nd ne">import cv2<br/>import numpy as np</span></pre><p id="051a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，让我们如下读入基础图像和主体图像。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="c8cd" class="mz na it mv b gy nb nc l nd ne">base_image = cv2.imread('base_img.jpg')<br/>base_image_copy = base_image.copy()<br/>subject_image = cv2.imread('subject.jpg')</span></pre><div class="ln lo lp lq gt ab cb"><figure class="lr ls nf lu lv lw lx paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/0266edd790589ce1f44a45e22745a4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*mAz3hmjnG03rnD9MacYGng.jpeg"/></div></figure><figure class="lr ls ng lu lv lw lx paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/e53b98b000ccb33bb18a6a3ea37e7953.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*AE_faab3HWeif7aPgbeq6g.jpeg"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk nh di ni ml translated"><a class="ae mm" href="https://unsplash.com/photos/Dnkr_lmdKi8" rel="noopener ugc nofollow" target="_blank">基础图像</a>(左)——<a class="ae mm" href="https://unsplash.com/photos/demvKRNvtLY" rel="noopener ugc nofollow" target="_blank">被摄体图像</a>(右)</figcaption></figure></div><p id="232e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">初始化一个数组来存储我们想要覆盖主题图像的四个角的坐标。我们可以使用如下所示的<strong class="kt jd"> setMouseCallback() </strong>函数手动选择这4个点。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="4ddf" class="mz na it mv b gy nb nc l nd ne">def click_event(event, x, y, flags, params):<br/>    if event == cv2.EVENT_LBUTTONDOWN:<br/>        cv2.circle(base_image_copy, (x, y), 4, (0, 0, 255), -1)<br/>        points.append([x, y])<br/>        if len(points) &lt;= 4:<br/>            cv2.imshow('image', base_image_copy)</span><span id="42b9" class="mz na it mv b gy nj nc l nd ne">points = []</span><span id="793d" class="mz na it mv b gy nj nc l nd ne">base_image = cv2.imread('base_img.jpg')<br/>base_image_copy = base_image.copy()<br/>subject_image = cv2.imread('subject.jpg')<br/><br/>cv2.imshow('image', base_image_copy)<br/>cv2.setMouseCallback('image', click_event)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="0a45" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在上面给出的代码片段中，我们定义了一个名为<strong class="kt jd"> click_event() </strong>的函数，并将其作为参数传递给<strong class="kt jd"> setMouseCallback() </strong>函数。使用这种方法，我们将首先显示基础图像。然后，我们可以手动选择图像中的四个点作为目标。我们的主体图像将被扭曲到这个目标上。当鼠标左键被按下时，坐标被记录。这些存储在我们之前初始化的点数组中。选定的点以红点突出显示，如下所示。</p><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/535a6201a19d97618b52509cf78181ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NbJGW6mAyYllQ_LafavKZw.gif"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">选择角点(作者GIF)</figcaption></figure><p id="cacf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">众所周知，我们每个人可能会以任意顺序选择4个点。因此，需要在选择的点之间保持恒定的顺序。我选择了按顺时针方向排序，即从左上到右上，从右下到左下。这是通过下面显示的<strong class="kt jd"> sort_pts() </strong>方法实现的。我们利用了这样一个事实，即x和y坐标之和在左上角最小，在右下角最大。同样，它们之间的差异在右上角最小，在左下角最大。花点时间自己验证一下是不是真的。<strong class="kt jd">请记住，对于图像，原点在图像的左上角。</strong></p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="26df" class="mz na it mv b gy nb nc l nd ne">def sort_pts(points):<br/>    sorted_pts = np.zeros((4, 2), dtype="float32")<br/>    s = np.sum(points, axis=1)<br/>    sorted_pts[0] = points[np.argmin(s)]<br/>    sorted_pts[2] = points[np.argmax(s)]<br/><br/>    diff = np.diff(points, axis=1)<br/>    sorted_pts[1] = points[np.argmin(diff)]<br/>    sorted_pts[3] = points[np.argmax(diff)]<br/><br/>    return sorted_pts</span><span id="8dfe" class="mz na it mv b gy nj nc l nd ne">sorted_pts = sort_pts(points)</span></pre><p id="173e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">把点排序后，我们用它们来计算变换矩阵。我们创建了一个名为“<strong class="kt jd"> pts1 </strong>的numpy数组，它保存了主题图像的四个角的坐标。类似地，我们创建一个名为“<strong class="kt jd"> pts2 </strong>的列表来保存排序后的点。“<strong class="kt jd"> pts1 </strong>的坐标顺序应与“<strong class="kt jd"> pts2 </strong>的坐标顺序相匹配。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="fbe3" class="mz na it mv b gy nb nc l nd ne">h_base, w_base, c_base = base_image.shape<br/>h_subject, w_subject = subject_image.shape[:2]<br/><br/>pts1 = np.float32([[0, 0], [w_subject, 0], [w_subject, h_subject],                     [0, h_subject]])</span><span id="783e" class="mz na it mv b gy nj nc l nd ne">pts2 = np.float32(sorted_pts)</span></pre><p id="f9ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们现在获得了扭曲目标图像所需的变换矩阵。这是使用函数<strong class="kt jd">cv2 . getperspective transform()</strong>获得的。因为我们想以这样一种方式转换主题图像，使其适合我们在基础图像中选择的框，所以"<strong class="kt jd"> src </strong>"应该是"<strong class="kt jd"> pts1 </strong>",而"<strong class="kt jd"> dst </strong>"应该是"<strong class="kt jd"> pts2 </strong>"。生成的图像的大小可以指定为一个元组。我们确保结果图像具有基本图像的尺寸。使用生成的矩阵，我们可以使用<strong class="kt jd"> cv2.warpPerspective() </strong>方法扭曲图像，如给定片段所示。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="b547" class="mz na it mv b gy nb nc l nd ne">transformation_matrix = cv2.getPerspectiveTransform(pts1, pts2)<br/><br/>warped_img = cv2.warpPerspective(subject_image, transformation_matrix, (w_base, h_base))</span><span id="7635" class="mz na it mv b gy nj nc l nd ne">cv2.imshow('Warped Image', warped_img)</span></pre><p id="2abf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">扭曲的图像看起来像这样</p><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/29b8efce240876ad05374ce3fb7ee829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DkuLxHnJ7ICFcQCKkNZ80w.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">扭曲的图像(作者提供的图像)</figcaption></figure><p id="f2bf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下一步是创建一个蒙版，我们用基础图像的形状创建一个空白图像。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="070c" class="mz na it mv b gy nb nc l nd ne">mask = np.zeros(base_image.shape, dtype=np.uint8)</span></pre><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nl"><img src="../Images/bd808879196ca46296096f4b7b87c72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*SnD4LJn16QdfLGPh3IiRIQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">初始遮罩(图片由作者提供)</figcaption></figure><p id="9e09" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这个空白蒙版上，我们画一个多边形，它的角由“<strong class="kt jd"> sorted_pts </strong>给出，并使用<strong class="kt jd">cv2 . fillcungpoly()</strong>方法填充白色。最终的遮罩看起来会像这样。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="baa6" class="mz na it mv b gy nb nc l nd ne">roi_corners = np.int32(sorted_pts)<br/><br/>cv2.fillConvexPoly(mask, roi_corners, (255, 255, 255))</span></pre><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/3a1e3604edb6cb7bc355bac95aa5d8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSt04jsVgfJSwJogwvULhA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">填充遮罩(图片由作者提供)</figcaption></figure><p id="5faf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们使用<strong class="kt jd"> cv2.bitwise_not() </strong>方法反转遮罩颜色。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="4882" class="mz na it mv b gy nb nc l nd ne">mask = cv2.bitwise_not(mask)</span></pre><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/19d87bad8ee5fe360e6d9945db93d1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJV-0wj8IWQ94Rnog7Q7Ow.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">反转遮罩(图片由作者提供)</figcaption></figure><p id="f012" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们使用<strong class="kt jd"> cv2.bitwise_and() </strong>方法获取蒙版和基础图像并执行逐位and运算。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="b9d9" class="mz na it mv b gy nb nc l nd ne">masked_image = cv2.bitwise_and(base_image, mask)</span></pre><p id="e13f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这将给我们一个如下图所示的图像。您可以看到单独放置主题图像的区域是黑色的。</p><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/e0b6a8a002b1c2953f8c5efd07e8c96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2MFGMqsE5lrvLgklHBipA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">蒙版基础图像(作者提供的图像)</figcaption></figure><p id="bdf5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后一步是使用<strong class="kt jd"> cv2.bitwise_or() </strong>方法获取扭曲的图像和遮罩的图像，并执行按位“或”运算。这将生成我们想要完成的融合图像。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="3114" class="mz na it mv b gy nb nc l nd ne">output = cv2.bitwise_or(warped_img, masked_image)<br/>cv2.imshow('Fused Image', output)<br/>cv2.imwrite('Final_Output.png', output)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="780f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们做到了！我们已经成功地将一幅图像叠加到另一幅图像上。</p><figure class="ln lo lp lq gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/002effe5c1df41d157ce5a6f462ab743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBC37s6C0e4XFgy4tvvv_w.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">融合图像(作者提供的图像)</figcaption></figure><p id="0358" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是透视转换的一个非常简单的用例。当您在帧中跟踪对象/人的移动时，您可以使用它来生成一个区域的鸟瞰图。唯一的限制是你的想象力。</p><p id="bf3e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">本文的全部代码可以通过这个<a class="ae mm" href="https://github.com/GSNCodes/Image_Overlaying_Using_Perspective_Transform" rel="noopener ugc nofollow" target="_blank">链接</a>在我的GitHub存储库中找到。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="ebf2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="nm">~ ~</em><em class="nm">SowmiyaNarayanan G</em></p><p id="6570" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> PS:- </strong></p><p id="65f9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你有任何疑问，请随时联系我，我很乐意帮助你。我随时欢迎建设性的批评，因此请不要犹豫让我知道你对我的工作的看法。也可以在<a class="ae mm" href="https://www.linkedin.com/in/sowmiyanarayanan-g/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p><p id="05dc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">心灵字节:- </strong></p><p id="b123" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="nm">“你能想象的一切都是真实的”</em>——巴勃罗·毕加索</p></div></div>    
</body>
</html>