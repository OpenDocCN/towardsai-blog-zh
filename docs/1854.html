<html>
<head>
<title>OOPs Concept in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的OOPs概念</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/oops-concept-in-python-b5f5833d57db?source=collection_archive---------0-----------------------#2021-05-17">https://pub.towardsai.net/oops-concept-in-python-b5f5833d57db?source=collection_archive---------0-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bfab" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="a311" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">OOPs是编写程序的一种高效方式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0d8adb00bf1ac857f68b2ff982843b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Shn4jn90fDbX3Yca9UNvWw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">哎呀，范式。作者的照片</figcaption></figure><blockquote class="lh li lj"><p id="d8a9" class="lk ll lm ln b lo lp kd lq lr ls kg lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><strong class="ln jd">T3】简介T5】</strong></p></blockquote><p id="0ff0" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">面向对象编程或称为OOPs是一种编程范式，由抽象、封装、继承、模块化和多态等原则组成。OOPs主要有5个概念。使用OOPs的概念是编写程序的高效方式。</p><blockquote class="lh li lj"><p id="c070" class="lk ll lm ln b lo lp kd lq lr ls kg lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><strong class="ln jd"> <em class="it">哎呀的优点</em> </strong></p></blockquote><p id="5162" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">1.程序的可重用性</p><p id="3b29" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">2.数据冗余</p><p id="61ba" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">3.代码易于维护</p><p id="8512" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">4.安全性</p><blockquote class="lh li lj"><p id="0b04" class="lk ll lm ln b lo lp kd lq lr ls kg lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><strong class="ln jd"> <em class="it">哎呀的6个概念</em> </strong></p></blockquote><p id="f95e" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">1.班级</p><p id="41fb" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">2.目标</p><p id="9e06" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">3.数据抽象</p><p id="849d" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">4.数据封装</p><p id="3cde" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">5.遗产</p><p id="a927" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">6.多态性</p><h2 id="7325" class="mk ml it bd mm mn mo dn mp mq mr dp ms mh mt mu mv mi mw mx my mj mz na nb iz bi translated"><strong class="ak">对象:</strong></h2><p id="4bc0" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated">对象是具有某些特征和行为的实体，可以用来存储函数和值。</p><p id="b6bb" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">举例</strong>:笔、纸、小费、车、销售等。</p><p id="48a1" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">语法</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="6211" class="mk ml it ni b gy nm nn l no np">obj = object_name()</span></pre><p id="ad36" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="0c40" class="mk ml it ni b gy nm nn l no np">obj1 = pen()</span><span id="18ef" class="mk ml it ni b gy nq nn l no np">print(obj1)</span></pre><h2 id="fe52" class="mk ml it bd mm mn mo dn mp mq mr dp ms mh mt mu mv mi mw mx my mj mz na nb iz bi translated"><strong class="ak">类:</strong></h2><p id="9744" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated">一个类定义并共享一个公共模板，行为对象共享公共属性和关系。</p><p id="5665" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">语法</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="ef49" class="mk ml it ni b gy nm nn l no np">class class_name :</span><span id="c580" class="mk ml it ni b gy nq nn l no np">    class_content</span></pre><p id="aed8" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="9f21" class="mk ml it ni b gy nm nn l no np">class stationery :<br/>    pen = “hero”<br/>    def __init__(object, cat, color) :<br/>        object.cat = cat<br/>        object.color = color</span><span id="265c" class="mk ml it ni b gy nq nn l no np">    def description(object) :<br/>        return f”The {object.cat} pen is {object.color} in color”</span><span id="24bc" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="9cdc" class="mk ml it ni b gy nq nn l no np">obj = stationery(“hero”, “blue”)<br/>print(obj.description())</span><span id="89d4" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="6a91" class="mk ml it ni b gy nq nn l no np">The hero pen is blue in color</span></pre><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/7-beginners-tips-to-help-you-get-better-at-learn-python-33149417b447"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd jd gy z fp nz fr fs oa fu fw jc bi translated">帮助你更好地学习Python的7个初学者技巧</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">成为python专家的分步主题</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">pub.towardsai.net</p></div></div><div class="od l"><div class="oe l of og oh od oi lb nu"/></div></div></a></div><h2 id="4179" class="mk ml it bd mm mn mo dn mp mq mr dp ms mh mt mu mv mi mw mx my mj mz na nb iz bi translated"><strong class="ak">数据抽象</strong></h2><p id="a765" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated">数据抽象是指只显示基本信息，而不显示任何背景细节。</p><p id="34fd" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">简而言之，它是用来让用户的事情变得不那么复杂。至少有一个抽象函数的类称为抽象类。</p><p id="22c5" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><p id="9810" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">下面的例子展示了一个抽象类是如何在python中实现的。</p><p id="910d" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">第一个要求是从abc模块导入ABC类，这样我们就可以在其中创建抽象方法。</p><p id="e01f" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">这里，文具是从abc类继承的抽象类，来自ABC模块。这个abc模块是用抽象方法创建的另一个python文件，即@abstractmethod。</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="c56c" class="mk ml it ni b gy nm nn l no np">from abc import ABC, abstractmethod</span><span id="9f23" class="mk ml it ni b gy nq nn l no np">class stationery(ABC) :<br/>    def pen(self) :<br/>        pass</span><span id="bdcd" class="mk ml it ni b gy nq nn l no np">class S2(stationery) :<br/>    def pen(self) :<br/>        print(“It is of good quality”)</span><span id="f084" class="mk ml it ni b gy nq nn l no np">class S3(stationery) :<br/>    def pen(self) :<br/>        print(“ It is of amazing quality”)</span><span id="ec7d" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User Code</strong> :</span><span id="6cd7" class="mk ml it ni b gy nq nn l no np">s = S2()<br/>s.pen()<br/>t = S3()<br/>t.pen()</span><span id="70a7" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output </strong>:</span><span id="fe5c" class="mk ml it ni b gy nq nn l no np">It is of good quality<br/>It is of amazing quality</span></pre><h2 id="5a37" class="mk ml it bd mm mn mo dn mp mq mr dp ms mh mt mu mv mi mw mx my mj mz na nb iz bi translated"><strong class="ak">数据封装:</strong></h2><p id="e1f3" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated">数据封装是指将相似的数据打包成一个单元。这也意味着，隐藏有价值的信息，以防止未经授权的用户访问。</p><p id="a9bb" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><p id="15f5" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">为了使变量或方法不可访问，使用双下划线作为前缀。</p><p id="2f54" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">在这里(自我。__type)是受保护的变量，不能由外部类访问。</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="46c0" class="mk ml it ni b gy nm nn l no np">class activity :<br/>    def __init__(self, type, hours)<br/>        self.__type = type<br/>        self.hours = hours</span><span id="9883" class="mk ml it ni b gy nq nn l no np">    def description(self) :<br/>        return f”The boy is {self.__type} for {self.hours} hours</span><span id="dc24" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="17f4" class="mk ml it ni b gy nq nn l no np">obj = activity(“running”, 2)<br/>print(obj.description())<br/>print(obj.__type)<br/>print(obj.hours)</span><span id="3262" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="6841" class="mk ml it ni b gy nq nn l no np">The boy is running for 2 hours</span><span id="1a66" class="mk ml it ni b gy nq nn l no np">running</span><span id="6099" class="mk ml it ni b gy nq nn l no np">2</span></pre><div class="nr ns gp gr nt nu"><a rel="noopener  ugc nofollow" target="_blank" href="/machine-learning-16c8ccc2c7b8"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd jd gy z fp nz fr fs oa fu fw jc bi translated">无监督学习中不同类型的聚类方法</h2><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">pub.towardsai.net</p></div></div><div class="od l"><div class="oj l of og oh od oi lb nu"/></div></div></a></div><h2 id="9283" class="mk ml it bd mm mn mo dn mp mq mr dp ms mh mt mu mv mi mw mx my mj mz na nb iz bi translated"><strong class="ak">继承</strong>:</h2><p id="f175" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated">子类(子类)从其父类(超类)继承数据的过程称为继承。</p><p id="46b3" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">共有5种类型的继承</strong>:</p><ol class=""><li id="26fb" class="ok ol it ln b lo lp lr ls mh om mi on mj oo mg op oq or os bi translated"><strong class="ln jd">单一继承</strong>:在单一继承中，单一子类(子类)是从单一超类(父类)继承而来的。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/987b2c0d72b2b27f8992ed18b2fae5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*4WOyIK3zdkT3wH43c20Jow.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="cd05" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">节目示例</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="2a9c" class="mk ml it ni b gy nm nn l no np">class father :<br/>    def func1(self) :<br/>        print(“This is father’s class”)</span><span id="6862" class="mk ml it ni b gy nq nn l no np">class daughter(father) :<br/>    def func2(self) :<br/>        print(“This is my daughter’s class”)</span><span id="3165" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="5123" class="mk ml it ni b gy nq nn l no np">obj =daughter()<br/>obj.func1<br/>obj.func2</span><span id="f9fe" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="f3a8" class="mk ml it ni b gy nq nn l no np">This is father’s class</span><span id="ac13" class="mk ml it ni b gy nq nn l no np">This is my daughter’s class</span></pre><p id="feb5" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">2.多重继承:在多重继承中，一个子类可以从多个超类中继承。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/afbd8cc99e3c6e2e6892a9369c299c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*AIm7DPFv_SoNXwM6PVAwwg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="b773" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><ul class=""><li id="e5ef" class="ok ol it ln b lo lp lr ls mh om mi on mj oo mg ov oq or os bi translated">考虑2类铅笔、油漆。这里，颜色是继承的类。</li><li id="af80" class="ok ol it ln b lo ow lr ox mh oy mi oz mj pa mg ov oq or os bi translated">类颜色来自两个类(铅笔和油漆)。</li></ul><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="e7e1" class="mk ml it ni b gy nm nn l no np">class pencil :<br/>    colorname = “ “<br/>    def pencil(self) :<br/>        print(self.pencilname)</span><span id="8518" class="mk ml it ni b gy nq nn l no np">class paint :<br/>    paintname = “”<br/>    def paint(self) :<br/>        print(self.paintname)</span><span id="257d" class="mk ml it ni b gy nq nn l no np">class colors(pencil, paint) :<br/>    def stationary(self) :<br/>      print(“Brand name1 :”, self.pencilname)<br/>      print(“Brandname2 :”, self.paintname)</span><span id="99b7" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="7171" class="mk ml it ni b gy nq nn l no np">c = colors()<br/>c.pencilname = “Faber Castle”<br/>c.paintname = “Pelican”<br/>c.stationary()</span><span id="1488" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="bd34" class="mk ml it ni b gy nq nn l no np">Brandname1 : Faber Castle</span><span id="4e91" class="mk ml it ni b gy nq nn l no np">Brandname2 : Pelican</span></pre><p id="6709" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">3.<strong class="ln jd">多级继承</strong>:在多级继承中，一个新类可以从一个派生类中继承。派生类充当新类的源类。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/42475f098eabaf14444743bac69e6a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*ztPK4CZWymG4-pfI8Z2tJA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="c948" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="426d" class="mk ml it ni b gy nm nn l no np">class S1 :<br/>    def __init__(self, S1name) :<br/>        self. S1name = S1name</span><span id="b8f8" class="mk ml it ni b gy nq nn l no np">class S2 :<br/>    def __init__(self, S2name, S1name)<br/>        self.S2name = S2name<br/>        s!.__init__(self, S1name)</span><span id="049a" class="mk ml it ni b gy nq nn l no np">#derived class</span><span id="bb15" class="mk ml it ni b gy nq nn l no np">class friend(S2) :<br/>    def __init__(self, friendname, S2name, S1name)<br/>    def print_name(self) :<br/>        print(“Student1 :”, self.S1name)<br/>        print(“Student2 :”, self.S2name)<br/>        print(“Friend name :”, self.friendname)</span><span id="30ad" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="1098" class="mk ml it ni b gy nq nn l no np">s1 = friend(‘Amal’, ‘Jayan’, ‘Parul’)<br/>print(s1.S1name)<br/>s1.print_name()</span><span id="8756" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output </strong>:</span><span id="154f" class="mk ml it ni b gy nq nn l no np">Student1 : Parul</span><span id="f726" class="mk ml it ni b gy nq nn l no np">Student2 : Jayan</span><span id="e802" class="mk ml it ni b gy nq nn l no np">Friend name : Amal</span></pre><p id="27e2" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">4.<strong class="ln jd">层次继承</strong>:在层次继承中，多个类可以从一个类继承。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/3e420194bb0c4fc467ca6e338e1b0f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*neQYmYCw0BnJAQMnnJuOZw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="4f3f" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="191e" class="mk ml it ni b gy nm nn l no np">class A :<br/>    def func1(self) :<br/>        print(“This is class A”)</span><span id="9aee" class="mk ml it ni b gy nq nn l no np">class B(A) :<br/>    def func2(self) :<br/>    print(“This is class B”)</span><span id="a0bf" class="mk ml it ni b gy nq nn l no np">class C(A) :<br/>    def func3(self) :<br/>    print(“This is class C”)</span><span id="c5e6" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="2e65" class="mk ml it ni b gy nq nn l no np">obj1 = B()<br/>obj2 = C()</span><span id="e193" class="mk ml it ni b gy nq nn l no np">obj1.func1()<br/>obj1.func2()</span><span id="72ca" class="mk ml it ni b gy nq nn l no np">obj2.func1()<br/>obj2.func3()</span><span id="285b" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="3af8" class="mk ml it ni b gy nq nn l no np">This is class A</span><span id="71a6" class="mk ml it ni b gy nq nn l no np">This is class B</span><span id="95b8" class="mk ml it ni b gy nq nn l no np">This is class A</span><span id="83fc" class="mk ml it ni b gy nq nn l no np">This is class C</span></pre><p id="0788" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">5.<strong class="ln jd">混合遗传</strong>:单一遗传和多重遗传的结合称为混合遗传。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/45f3eb4f606c0fafd00b33222183fa62.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*PTiMqtjGu4OZR2qGDd_Elg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="e934" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例:</strong></p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="7211" class="mk ml it ni b gy nm nn l no np">class marks :<br/>    def func1(self) :<br/>        print(“This is marks class”)</span><span id="7c66" class="mk ml it ni b gy nq nn l no np">class S1(marks) :<br/>    def func2(self) :<br/>        print(“This is student 1 marks”)</span><span id="bbdf" class="mk ml it ni b gy nq nn l no np">class S2(marks) :<br/>    def func3(self) :<br/>        print(“This is student 2 marks”)</span><span id="edc7" class="mk ml it ni b gy nq nn l no np">class S3(S1,S2) :<br/>    def func4(self) :<br/>        print(“This id student 3 marks”)</span><span id="cf5b" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User code</strong> :</span><span id="7021" class="mk ml it ni b gy nq nn l no np">obj = S3()</span><span id="34ff" class="mk ml it ni b gy nq nn l no np">obj.func1()</span><span id="4ede" class="mk ml it ni b gy nq nn l no np">obj.func2()</span><span id="31ab" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="2b25" class="mk ml it ni b gy nq nn l no np">This is marks class</span><span id="8419" class="mk ml it ni b gy nq nn l no np">This is student 1 marks</span></pre><h2 id="d6dc" class="mk ml it bd mm mn mo dn mp mq mr dp ms mh mt mu mv mi mw mx my mj mz na nb iz bi translated"><strong class="ak">多态性</strong>:</h2><p id="330b" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated">多态是面向对象编程中最重要的概念之一。当一个类的一个对象被一个消息或一个动作处理时，它以不同的方式表现的能力被称为多态。</p><p id="87bb" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated"><strong class="ln jd">程序示例</strong>:</p><pre class="ks kt ku kv gt nh ni nj nk aw nl bi"><span id="5cf4" class="mk ml it ni b gy nm nn l no np">class square :<br/>    def description(self) :<br/>        print(“This is a Square”)</span><span id="9bb8" class="mk ml it ni b gy nq nn l no np">class rectangle :<br/>    def description(self) :<br/>        print(“This is a Rectangle”)</span><span id="dbbd" class="mk ml it ni b gy nq nn l no np">class triangle :<br/>    def description(self) :<br/>        print(“This is a triangle”)</span><span id="7b97" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">User Code</strong> :</span><span id="214e" class="mk ml it ni b gy nq nn l no np">s = square()</span><span id="ef78" class="mk ml it ni b gy nq nn l no np">r = rectangle()</span><span id="3c9b" class="mk ml it ni b gy nq nn l no np">t = triangle()</span><span id="4001" class="mk ml it ni b gy nq nn l no np">for shapes in (s,r,t) :</span><span id="336b" class="mk ml it ni b gy nq nn l no np">shapes.description()</span><span id="f8bc" class="mk ml it ni b gy nq nn l no np"><strong class="ni jd">Output</strong> :</span><span id="0015" class="mk ml it ni b gy nq nn l no np">This is a Square</span><span id="e18a" class="mk ml it ni b gy nq nn l no np">This is a Rectangle</span><span id="6b6d" class="mk ml it ni b gy nq nn l no np">This is a triangle</span></pre><blockquote class="lh li lj"><p id="c64e" class="lk ll lm ln b lo lp kd lq lr ls kg lt lu lv lw lx ly lz ma mb mc md me mf mg im bi translated"><strong class="ln jd"> <em class="it">结论</em> </strong></p></blockquote><p id="d909" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">OOPs概念在软件开发项目中非常重要。</p><p id="be8c" class="pw-post-body-paragraph lk ll it ln b lo lp kd lq lr ls kg lt mh lv lw lx mi lz ma mb mj md me mf mg im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae pe" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae pe" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="7f61" class="pf ml it bd mm pg ph pi mp pj pk pl ms ki pm kj mv kl pn km my ko po kp nb pp bi translated">推荐文章</h1><p id="2f58" class="pw-post-body-paragraph lk ll it ln b lo nc kd lq lr nd kg lt mh ne lw lx mi nf ma mb mj ng me mf mg im bi translated"><a class="ae pe" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae pe" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae pe" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae pe" rel="noopener ugc nofollow" target="_blank" href="/principal-component-analysis-in-dimensionality-reduction-with-python-1a613006d531?source=friends_link&amp;sk=3ed0671fdc04ba395dd36478bcea8a55">用Python进行主成分分析降维</a> <br/> 5。<a class="ae pe" href="https://medium.com/towards-artificial-intelligence/fully-explained-k-means-clustering-with-python-e7caa573176a?source=friends_link&amp;sk=9c5c613ceb10f2d203712634f3b6fb28" rel="noopener">用Python全面讲解K-means聚类</a> <br/> 6。<a class="ae pe" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae pe" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae pe" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae pe" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae pe" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>