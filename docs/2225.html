<html>
<head>
<title>Ten Time-saving R Hacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">十个省时的R Hacks</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/ten-time-saving-r-hacks-d5aa7866c456?source=collection_archive---------0-----------------------#2021-10-06">https://pub.towardsai.net/ten-time-saving-r-hacks-d5aa7866c456?source=collection_archive---------0-----------------------#2021-10-06</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><h2 id="7321" class="it iu iv bd b dl iw ix iy iz ja jb dk jc translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming/r" rel="noopener ugc nofollow" target="_blank"> R </a></h2><div class=""/><div class=""><h2 id="312d" class="pw-subtitle-paragraph kb je iv bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">我经常用这些来尽量减少干扰，保持我的生产进度</h2></div><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/3761bdc7bcb0fc0c7adcb72267be54a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ybu9fEJ8EG4SY9JGpycwmA.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">照片由<a class="ae lj" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a>在<a class="ae lj" href="https://unsplash.com/s/photos/fast-coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1e5f" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">我做的编码越多，对低效率就越敏感。对我来说，涅槃就是你可以超快地编码，而不需要在你最喜欢的代码编辑器之外做任何事情。</p><p id="537a" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">因此，当我不能使用精简、高效的代码做我想做的事情时，或者当我必须进入我的文件系统或另一个程序来配置某些东西，或者任何我认为占用了不必要的时间和精力的事情时，我会感到非常沮丧。</p><p id="e371" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">以下是我经常使用的十个方法，以尽量减少干扰，保持我的生产进度。当我把这些告诉一些人时，我经常会得到一些类似<em class="mg">‘为什么我不知道这件事？’</em>。所以我希望至少其中一些对你来说是新的和有用的。</p><h1 id="8c12" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">1.直接从源文件下载和读取文件</h1><p id="9598" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">这个技巧将帮助您最大限度地减少管理本地数据文件的时间，并使您的整个项目更容易被其他人复制。如果你有一个数据文件在网上的某个地方，比如在Google Drive或其他URL中，<code class="fe ne nf ng nh b">readr</code>包允许你使用<code class="fe ne nf ng nh b">read_csv()</code>或<code class="fe ne nf ng nh b">read_rds()</code>之类的函数直接从URL读取到一个数据帧中。例如:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="b8ef" class="nm mi iv nh b gy nn no l np nq">my_df &lt;- readr::read_csv(url("https://www.website.com/data.csv"))</span></pre><p id="3339" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">如果数据在Github回购中，你可以通过在URL中添加<code class="fe ne nf ng nh b">?raw=true</code>来下载原始文件，所以下面是你如何从我的Github回购中获得一些关于快速约会的数据:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="0651" class="nm mi iv nh b gy nn no l np nq">speed_dating_data &lt;- readr::read_rds("https://github.com/keithmcnulty/speed_dating/blob/master/speed_data_data.RDS?raw=true")</span></pre><p id="dd34" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">如果你有一个奇怪的文件类型，<code class="fe ne nf ng nh b">readr</code>不能处理，你可以简单地使用base R的<code class="fe ne nf ng nh b">download.file()</code>函数把它放到你的会话中，然后你可以使用任何合适的包来读取它。你不需要这个url函数，所以用它来下载我的速配数据:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="29da" class="nm mi iv nh b gy nn no l np nq">download.file("https://github.com/keithmcnulty/speed_dating/blob/master/speed_data_data.RDS?raw=true", destfile = "speed_dating_data.RDS") </span><span id="82a5" class="nm mi iv nh b gy nr no l np nq">speed_dating_data &lt;- readRDS("speed_dating_data.RDS")</span></pre><p id="7664" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">这样做的好处是，其他人现在可以运行您的项目，而无需担心数据在本地可用。</p><p id="307d" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">对于需要认证的托管服务，比如Box，你会发现越来越多的R包处理认证和文件下载，所以如果你从这些服务中进行大量的手动下载，你可能会浪费不必要的时间。如果你在Box工作，这是一个很好的包。它存储您的凭据，这样您就不必为每笔交易进行身份验证，并且像<code class="fe ne nf ng nh b">readr</code>一样，它内置了读取功能，这样您就可以下载您的数据，并在一个命令中将它读入数据帧。</p><h1 id="1f6c" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">2.存储您的凭据以供常规使用</h1><p id="3725" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">如果你频繁地输入数据库或其他服务的密码，那么你就是在浪费时间，如果它们暴露在你的代码中，那就是不好的做法。r有一个名为<code class="fe ne nf ng nh b">.Renviron</code>的隐藏文件，你可以将凭证存储到你的全局环境中，这样你就不必不停地输入或暴露它们。</p><p id="2044" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">使用<code class="fe ne nf ng nh b">.Renviron</code>的最好方式是使用<code class="fe ne nf ng nh b">usethis</code>包的<code class="fe ne nf ng nh b">edit_r_environ()</code>功能。这将立即在您的会话中打开您的<code class="fe ne nf ng nh b">.Renviron</code>文件，以便您可以添加环境变量。例如，假设您有一个经常使用的数据库密码。在<code class="fe ne nf ng nh b">.Renviron</code>中会在新的一行中输入这个:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="8a8f" class="nm mi iv nh b gy nn no l np nq">MY_DB_PWD="[your password]"</span></pre><p id="d742" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">然后，在您的代码中，您只需输入以下内容来代替您的密码:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="ded7" class="nm mi iv nh b gy nn no l np nq">Sys.getenv("MY_DB_PWD")</span></pre><p id="125b" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">记住，每当你保存一个新的环境变量到<code class="fe ne nf ng nh b">.Renviron</code>中时，你需要重启R来使它生效。你可以用它来做各种事情，比如数据库登录、API证书、博客证书等等。</p><h1 id="7598" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">3.RStudio的快捷键</h1><p id="b85a" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">很多人不知道RStudio中的快捷键。他们可以节省很多编码时间。</p><p id="7d23" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">一个大问题是管道函数<code class="fe ne nf ng nh b">%&gt;%</code>的Ctrl-Shift-M。我总是得到至少一个“我怎么不知道这件事？”当我告诉别人这件事的时候。另一个是用于赋值<code class="fe ne nf ng nh b">&lt;-</code>的Option- <code class="fe ne nf ng nh b">-</code>(或Alt- <code class="fe ne nf ng nh b">-</code>)。(我真的希望你没有为此使用<code class="fe ne nf ng nh b">=</code>！).</p><p id="2f13" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">如果你在不同的文件中处理大量的代码，尝试Ctrl- <code class="fe ne nf ng nh b">.</code>打开一个文件或函数的搜索窗口，输入你的文件名或函数名，它会直接带你到你的项目中的位置。你不知道这为我节省了多少时间。</p><p id="83b5" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">你可以在这里找到RStudio键盘快捷键<a class="ae lj" href="https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts" rel="noopener ugc nofollow" target="_blank">的完整列表。对程序员来说就像一包零食。</a></p><h1 id="45fd" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">4.RMarkdown中的全局块选项</h1><p id="b4fb" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">如果我在RMarkdown中写作，我经常发现无论我为我的文档决定了什么块选项，它们对所有的块都是一样的。所以在一个文档中，我可能想要回显我的代码，或者我可能不想显示警告或消息。</p><p id="e245" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">我可以在第一个代码块中将这些选项设置为全局块选项，而不必在文档的每个块中键入这些选项。下面是一个如何做到这一点的示例:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="f67a" class="nm mi iv nh b gy nn no l np nq">knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)</span></pre><h1 id="9199" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">5.用<code class="fe ne nf ng nh b">patchwork</code>包轻松粘贴gg图</h1><p id="bba8" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">如果你把多个ggplots放在一起，<code class="fe ne nf ng nh b">patchwork</code>包使用直观简单的语法，这样你就不必使用像<code class="fe ne nf ng nh b">grid.arrange()</code>这样更复杂的函数。它还拥有比<code class="fe ne nf ng nh b">cowplot</code>更多的处理复杂布局的能力。</p><p id="afa7" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">将每个图分配给一个对象后，您可以使用像<code class="fe ne nf ng nh b">|</code>和<code class="fe ne nf ng nh b">/</code>这样的字符来指定您想要的列对齐和行对齐，软件包会为您进行对齐。这里有一个使用<code class="fe ne nf ng nh b">mtcars</code>的<a class="ae lj" href="https://github.com/thomasp85/patchwork" rel="noopener ugc nofollow" target="_blank">包Github repo </a>的例子:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="ec20" class="nm mi iv nh b gy nn no l np nq">library(ggplot2)<br/>library(patchwork)<br/>p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))<br/>p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))<br/>p3 &lt;- ggplot(mtcars) + geom_smooth(aes(disp, qsec)) <br/>p4 &lt;- ggplot(mtcars) + geom_bar(aes(carb)) </span><span id="6f90" class="nm mi iv nh b gy nr no l np nq">(p1 | p2 | p3) / <br/>      p4</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/886826fbd3306c6e28bfdf77b7b039b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*8vHhye82hoMxzplZ.png"/></div></figure><h1 id="3b2c" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">6.使用<code class="fe ne nf ng nh b">Renv</code>进行更平滑的依赖管理</h1><p id="65c7" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">对于一个R程序员(和许多其他语言的程序员)来说，从别人那里拿起一个项目是很常见的经历，当他们试图让它工作时，他们意识到他们必须花很长时间来决定使用哪个包，解决版本控制问题和进行其他形式的依赖管理。</p><p id="b78c" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">与以前的包依赖管理解决方案<code class="fe ne nf ng nh b">packrat</code>相比，<code class="fe ne nf ng nh b">Renv</code>包提供了一种更简单、更干净的方式来解决这个问题。</p><p id="9b5e" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">当您将项目开发到某一点，并且您认为您或其他人将来可能不得不再次回到它时，通过运行<code class="fe ne nf ng nh b">renv::init()</code>，您可以发现所有您的包和版本依赖，并将其存储在一个名为<code class="fe ne nf ng nh b">renv.lock</code>的文件中，您应该将它保存在项目repo中。随后，通过运行<code class="fe ne nf ng nh b">renv::restore()</code>，你将能够从<code class="fe ne nf ng nh b">renv.lock</code>重新安装所有的依赖项，以确保你已经在尽可能接近你离开的地方设置了你的项目，并且极大地减少了遇到与包版本相关的问题的机会。如此简单，如此重要，如此高效。</p><h1 id="5dff" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">7.利用RStudio的工作进行多任务处理</h1><p id="4a2f" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">你可能听说过R是单线程的，这会引起问题。确实，如果您在控制台中执行一个计算密集型命令，您可能会在命令执行完毕之前锁定R会话。</p><p id="cff9" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">在Javascript异步编程的基础上，最近在用R构建函数方面有了很大的发展，允许程序员编写处理未来对象的异步代码。<a class="ae lj" href="https://rstudio.github.io/promises/" rel="noopener ugc nofollow" target="_blank">如果你对此感兴趣，这里有一个很好的来源</a>。</p><p id="3653" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">但是对于大多数日常的R程序员来说，可能最有用的开发是在RStudio 1.2中引入了Jobs。</p><p id="e9a4" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">如果你有一个很长的R脚本需要完全执行，但你仍然想在你的控制台上做其他的事情，你会看到从RStudio的1.2版本开始，Source按钮现在有一个下拉菜单，你可以在那里将脚本作为一个“本地作业”来获取。这将基本上在一个不同的R会话中运行您的脚本，允许您在现有的会话中工作。</p><p id="83c8" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">请记住，一旦作业完成，它创建的所有对象都将消失，因此，如果您没有将需要的内容写入数据库或文件系统，您就已经丢失了它。如果您想浏览在本地作业期间创建的对象，您必须使用<code class="fe ne nf ng nh b">save()</code>函数将会话工作空间的图像保存到脚本末尾的<code class="fe ne nf ng nh b">Rdata</code>文件中。</p><p id="ee39" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">当脚本运行时，您可以使用“作业”窗口中显示的绿色条来监视其进度，如果您用代码部分(至少有三个尾随破折号的注释)对脚本进行注释，作业窗口将在脚本移动时显示注释，以便您可以确切地看到它的位置。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nt"><img src="../Images/ef6edd33f787e49ac56567d323c0e541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kGqjXmJLThfdUfTs"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">在RStudio 1.2+中使用注释运行本地作业</figcaption></figure><p id="0bfc" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">(如果您在RStudio server/workbench上工作，您还可以使用启动器作业在计算基础架构上运行您的脚本，如果您有机会的话——非常方便！)</p><p id="ff83" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">更多关于工作的信息<a class="ae lj" href="https://blog.rstudio.com/2019/03/14/rstudio-1-2-jobs/" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><h1 id="5311" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">8.重命名范围内的所有变量</h1><p id="dba8" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">这可能符合RStudio键盘快捷键的早期章节，但我认为它应该有自己的一节。所以你决定重命名你的一个对象，然后你意识到这个对象在你的代码中出现了20次，所以你必须去编辑那20个实例——听起来熟悉吗？</p><p id="9918" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">尝试高亮显示对象名称，然后按Ctrl-Alt-Shift-M(或Ctrl-Option-Shift-M)。您将立即看到，您现在对对象所做的任何更改都将在该对象出现在您当前作用域中的任何地方被更改。不客气😊</p><h1 id="8365" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">9.使用<code class="fe ne nf ng nh b">.</code>保持管道畅通</h1><p id="f0a7" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">随着现在管道在R代码中的广泛使用，以及大多数tidyverse函数将对象作为第一个参数的事实，人们似乎已经忘记了如何在R代码中使用<code class="fe ne nf ng nh b">.</code>。例如，我经常看到编码人员一遇到不以对象作为第一个参数的函数就停止管道。他们移动到新的代码行并断开管道。</p><p id="30e2" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">对于那些已经忘记了<code class="fe ne nf ng nh b">.</code>，或者从来没有在第一时间了解过它的人来说，您可以使用<code class="fe ne nf ng nh b">.</code>来表示您想要将之前的输出通过管道传输到您的函数中的位置。这使您可以通过管道传递不以对象作为第一个参数的函数。这里有一个例子:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="5bd0" class="nm mi iv nh b gy nn no l np nq">vec &lt;- c("hello", "jello", "is", "great") <br/>vec %&gt;% grepl("lo", .) </span><span id="3c02" class="nm mi iv nh b gy nr no l np nq">[1] TRUE TRUE FALSE FALSE</span></pre><h1 id="264c" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kk ms kl mt kn mu ko mv kq mw kr mx my bi translated">10.立即调用显示</h1><p id="19a3" class="pw-post-body-paragraph lk ll iv lm b ln mz kf lp lq na ki ls lt nb lv lw lx nc lz ma mb nd md me mf io bi translated">我见过相当多的R程序员给一个命名的对象赋值，然后输入该对象的名称，然后立即查看它。您可以避免这一额外的步骤。如果你既想给一个对象赋值，又想同时查看它，只要把你的代码用括号括起来就行了。当您想检查代码中的一系列步骤，试图准确地找出它没有按照您的预期去做的地方时，这在调试中会很方便。我发现它还避免了我必须毫无意义地键入对象名来让它们显示在我的RMarkdown文档中。我的意思是:</p><pre class="ku kv kw kx gt ni nh nj nk aw nl bi"><span id="da32" class="nm mi iv nh b gy nn no l np nq">## What I usually see <br/>mt_count &lt;- mtcars %&gt;% dplyr::count(cyl) <br/>mt_count </span><span id="88c8" class="nm mi iv nh b gy nr no l np nq"># A tibble: 3 x 2<br/>    cyl     n<br/>  &lt;dbl&gt; &lt;int&gt;<br/>1     4    11<br/>2     6     7<br/>3     8    14</span><span id="3eea" class="nm mi iv nh b gy nr no l np nq">## Immediately invoked display <br/>(mt_count &lt;- mtcars %&gt;% dplyr::count(cyl)) </span><span id="b9a8" class="nm mi iv nh b gy nr no l np nq"># A tibble: 3 x 2<br/>    cyl     n<br/>  &lt;dbl&gt; &lt;int&gt;<br/>1     4    11<br/>2     6     7<br/>3     8    14</span></pre><p id="674c" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">你有时间拯救R hacks吗？欢迎在评论中添加它们。</p></div><div class="ab cl nu nv hz nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="io ip iq ir is"><p id="374a" class="pw-post-body-paragraph lk ll iv lm b ln lo kf lp lq lr ki ls lt lu lv lw lx ly lz ma mb mc md me mf io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本RPG的超级粉丝。在 <a class="ae lj" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> LinkedIn </em> </a> <em class="mg">或</em><a class="ae lj" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="mg">Twitter</em></a><em class="mg">上找我。也可以看看我在</em><a class="ae lj" href="http://drkeithmcnulty.com/" rel="noopener ugc nofollow" target="_blank"><em class="mg">drkeithmcnulty.com</em></a><em class="mg">的博客。</em></p></div></div>    
</body>
</html>