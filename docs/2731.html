<html>
<head>
<title>7 Data Pre-Processing Methods With SciKit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SciKit-Learn的7种数据预处理方法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/7-data-pre-processing-methods-with-scikit-learn-7b49b11e1d08?source=collection_archive---------0-----------------------#2022-05-04">https://pub.towardsai.net/7-data-pre-processing-methods-with-scikit-learn-7b49b11e1d08?source=collection_archive---------0-----------------------#2022-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6390" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python和Google Colab</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6aadb8a45f9832b6b95c2b72529b8d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-4n-n56vamRxBnJv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·哈里逊在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据预处理是为进一步分析或机器学习模型工程准备、组织和结构化数据的重要部分。这是一个基本步骤，旨在组织数据，以便可以通过我们打算应用的数学和计算模型进行解释。</p><p id="9f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据不是现成的分析格式时，遇到的主要问题通常与数据类型(string vs float或int)、不同的标度、异常值、不同的编码、非正态(或非高斯)分布或异常值的存在有关。</p><p id="e110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，将讨论通过Google Colab解释器使用Python的SciKit-Learn库来解决这些问题的一些技术。这将是一篇很长的文章，所以做好准备！</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3e17" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Table of contents:</strong></span><span id="b75e" class="ma mb it lw b gy mg md l me mf">(1)Standard Scaler<br/>(2)MinMax Scaler<br/>(3)Robust Scaler<br/>(4)Quantile Transformer<br/>(5)Power Transformer:<br/>   a)Box-Cox<br/>   b)Yeo-Johnson<br/>(6)Normalize<br/>(7)Encoding categorical features:<br/>   a)Ordinal Encoder<br/>   b)One Hot Encoder</span></pre><p id="eb9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们导入一些我们将用于所有预处理技术的库。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3d84" class="ma mb it lw b gy mc md l me mf">import pandas as pd<br/>import numpy as np<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from sklearn import preprocessing</span></pre><p id="23c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文使用的数据集可以从<a class="ae ky" href="https://www.kaggle.com/datasets/zaraavagyan/weathercsv" rel="noopener ugc nofollow" target="_blank">T5这里 </a>下载。</p><h2 id="9310" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">1.标准缩放器</h2><p id="1295" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用StandardScaler，所有值将以仅在-1和1之间变化的方式进行转换，分布将尽可能标准化。这意味着对于某个变量，我们将有<strong class="lb iu">均值= 0 </strong>，和<strong class="lb iu">标准差= 1 </strong>。</p><p id="54f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1460" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and read data:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/c3bdbf4fe830c98e0c6d4869c9143e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjNQjLEZe79IalfmipjwrA.png"/></div></div></figure><p id="6293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们有一些非数值变量，我们将去掉所有这些变量，因为<strong class="lb iu"> StandardScaler </strong>函数只能应用于数值变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3a75" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Drop non-numerical features:</strong><br/>df = df.drop(df.columns[[5, 7, 8, 19]], axis = 1)</span></pre><p id="4ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们正在用我们的数据构建一个机器学习模型，最好的做法是创建X和y变量，其中<strong class="lb iu"> X </strong>包含要包含在模型中的特征，而<strong class="lb iu"> y </strong>表示结果或标签数据。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1718" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Define X and y:</strong><br/>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span></pre><p id="5f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们进一步检查<strong class="lb iu"> y </strong>，我们会发现它被编码为带有值‘Yes’和‘No’的字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2483f92b04776dd1159f797d79057412.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*yXQfpuRhnqPQWSUTLMGfuA.png"/></div></figure><p id="aafe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过应用以下公式将<strong class="lb iu"> y </strong>重新编码为数字:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ebec" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#y transform from string to numerical:</strong><br/>y = np.array(y)<br/>y[y=='No']=0<br/>y[y=='Yes']=1</span></pre><p id="efa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是将X转换成一个数组。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f29f" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Create array:</strong><br/>X = np.array(X)</span></pre><p id="b8b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们定义要应用于数组的预处理方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ca05" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Define preprocessing method:</strong><br/>scaler = preprocessing.StandardScaler().fit(X)</span></pre><p id="9dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要通过应用StandardScaler函数来转换我们的X数组，我们还需要执行一个步骤:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="79f4" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Transform X:</strong><br/>X_scaled = scaler.transform(X)</span></pre><p id="8fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以检查X数组缩放后的样子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7bfd" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Inspect X_scaled:</strong><br/>X_scaled</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0b504240ebe67b6bfdb45ab5897ba558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*0jDvvOVTDSo0h907oiwoXQ.png"/></div></figure><p id="3925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以看到，我们大部分的X值都在-1到1之间。我们还可以检查变量X_scaled的平均值和标准偏差:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="58ea" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#X_scaled mean:</strong><br/>X_scaled.mean(axis=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cd54607caaa614f0dcae767d275b26fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*l6XGdTZyTFXewypcwzDT6g.png"/></div></figure><p id="1078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有特征的值都非常接近于零。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d974" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#X_scaled standard deviation:</strong><br/>X_scaled.std(axis=0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9e93c025683d5773844ed30fb5dba191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*AMvx2cOEubXn_5OFpMlTbg.png"/></div></figure><p id="3ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有特征的标准偏差为1。</p><blockquote class="ni nj nk"><p id="e311" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">但是这种转变如何影响结果变量呢？</p></blockquote><p id="6195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将通过检查一些变量对于结果'<strong class="lb iu"> RainTomorrow </strong>'的表现来检查它。第一步是将X_scaled数组再次转换为pandas数据框:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9ae0" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Convert np.array to pd.DataFrame:</strong><br/>df_scaled = pd.DataFrame(X_scaled)</span></pre><p id="1b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查我们的df_scaled，我们将看到我们丢失了列名。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/62fdf668875698b057b9c1567610c8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wMooEND2xhU1aontbVSig.png"/></div></div></figure><p id="3261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使我们的数据框架更容易理解，我们需要重命名列。只需输入以下命令，我们就可以从没有非数字变量的原始数据帧中获得列名:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="418c" class="ma mb it lw b gy mc md l me mf">df.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c75de65d9fe00dd47b313b9877e28f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*CT8nb1Sk69HlhHQNC9INRQ.png"/></div></figure><p id="931c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要重命名列，我们将应用:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9210" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Rename columns:</strong><br/>df_scaled.columns = ['MinTemp', 'MaxTemp', 'Rainfall',<br/>         'Evaporation', 'Sunshine', 'WindGustSpeed', 'WindSpeed9am',<br/>         'WindSpeed3pm', 'Humidity9am', 'Humidity3pm','Pressure9am',<br/>         'Pressure3am', 'Cloud9am', 'Cloud3am', 'Temp9am', <br/>         'Temp3am', 'RISK_MM']</span></pre><p id="7bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将检查我们的数据如何随着StandardScaler转换而改变，以及这种转换如何影响结果'<strong class="lb iu"> RainTomorrow </strong>'。为此，我们将使用散点图，用变量'<strong class="lb iu"> MinTemp </strong>'和'<strong class="lb iu"> MaxTemp </strong>'表示结果中的“是”和“否”组。我们还将构建一个密度图来查看这两个变量在转换前后的分布。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1c04" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Scatter Plot before transformation:</strong><br/>sns.lmplot(data= df, x="MinTemp", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span><span id="be15" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Density chart before transformation:</strong><br/>fig = sns.kdeplot(df['MinTemp'], shade=True, color="r")<br/>fig = sns.kdeplot(df['MaxTemp'], shade=True, color="b")<br/>plt.show()</span><span id="dcd7" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Add outcome variable to df_scaled:</strong><br/>df_scaled['RainTomorrow'] = y</span><span id="6540" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter Plot after transformation:<br/></strong>sns.lmplot(data=df_scaled, x="MinTemp", y="MaxTemp", fit_reg=False, hue='RainTomorrow')</span><span id="dc02" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Density chart after transformation:<br/></strong>fig = sns.kdeplot(df_scaled['MinTemp'], shade=True, color="r")<br/>fig = sns.kdeplot(df_scaled['MaxTemp'], shade=True, color="b")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/9a9d9659b3c646eb9228d545b7ca53c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKI_6hxGcL_JwrxFpg_VbQ.png"/></div></div></figure><p id="8cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边的图像来自转换前的数据，右边的图像来自应用<strong class="lb iu"> StandardScaler </strong>函数后的数据。可以看出，这两个变量在结果'<strong class="lb iu"> RainTomorrow </strong>'方面具有相似的行为(尽管颜色发生了转换)。在密度图中，我们可以在左边看到'<strong class="lb iu"> MinTemp </strong>'和'<strong class="lb iu"> MaxTemp </strong>'具有不同的分布(如预期的那样)，但是经过数据转换后，这两个变量的分布是相似的，<strong class="lb iu">均值= 0 </strong>和<strong class="lb iu">标准差= 1 </strong>。</p><h2 id="f910" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">2.最小最大缩放器</h2><p id="fc66" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最小最大缩放器类似于标准缩放器，但是默认情况下所有的值都从0到1进行缩放。如果我们想使用其他最小值和最大值来缩放数据，我们也可以设置这个函数来完成。</p><p id="a5b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要应用<strong class="lb iu">最小最大缩放器</strong>功能，第一步类似:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dd14" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and read DataFrame:<br/></strong>df = pd.read_csv('/content/weather.csv')<br/>df</span><span id="2692" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop non-numerical variables:</strong><br/>df = df.drop(df.columns[[5, 7, 8, 19]], axis = 1)</span><span id="73e1" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Create X and y:</strong><br/>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span><span id="0922" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform X in np.array:</strong><br/>X = np.array(X)</span></pre><p id="ac2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要改变的是:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3280" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Define MinMaxScaler function:</strong><br/>min_max_scaler = preprocessing.MinMaxScaler()</span><span id="e1c8" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Apply transformation and check data:</strong><br/>df_minmax = min_max_scaler.fit_transform(X)<br/>df_minmax</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5c96d477baf6816fabcdd6469da281aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*mILv6Iblet6b_ARkzTU62g.png"/></div></figure><p id="0546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在图中看到的，现在数组中的所有值都在0和1之间。我们还可以构建一个图形可视化来检查结果'<strong class="lb iu"> RainTomorrow </strong>'和变量分布是如何受到影响的。流程和我们之前转型做的差不多。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7ac3" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Convert np.array to pd.DataFrame:</strong><br/>df_minmax = pd.DataFrame(df_minmax)</span><span id="c6a3" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Rename columns:</strong><br/>df_minmax.columns = ['MinTemp', 'MaxTemp', 'Rainfall', <br/>         'Evaporation', 'Sunshine', 'WindGustSpeed', 'WindSpeed9am', <br/>         'WindSpeed3pm', 'Humidity9am', 'Humidity3pm','Pressure9am',<br/>         'Pressure3am', 'Cloud9am', 'Cloud3am', 'Temp9am', <br/>         'Temp3am', 'RISK_MM']</span><span id="9959" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Add outcome variable:</strong><br/>df_minmax['RainTomorrow'] = y</span><span id="6d28" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter Plot before transformation:</strong><br/>sns.lmplot(data= df, x="MinTemp", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span><span id="027d" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Density chart before transformation:</strong><br/>fig = sns.kdeplot(df['MinTemp'], shade=True, color="r")<br/>fig = sns.kdeplot(df['MaxTemp'], shade=True, color="b")<br/>plt.show()</span><span id="f692" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter Plot after transformation:<br/></strong>sns.lmplot(data= df_minmax, x="MinTemp", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span><span id="1c5c" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Density chart after transformation:<br/></strong>fig = sns.kdeplot(df_minmax['MinTemp'], shade=True, color="r")<br/>fig = sns.kdeplot(df_minmax['MaxTemp'], shade=True, color="b")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a15ce5b9f7651603b2edef155079831f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZ47SlZ1NCnqmDXBVMiW2Q.png"/></div></div></figure><p id="3c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边的图像来自未转换的数据，右边的来自转换后的图像。在密度图中可以看到差异，其中'<strong class="lb iu"> MinTemp </strong>'和'<strong class="lb iu"> MaxTemp </strong>'的分布从原始值变为仅在0和1之间变化的分布。在散点图中看不到关于结果变量'<strong class="lb iu"> RainTomorrow </strong>'的影响。</p><h2 id="8cf6" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">3.鲁棒定标器</h2><p id="f661" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在数据集中发现的一个典型问题是离群值，离群值可以通过偏离数据均值来负面影响机器学习模型的结果。RobustScaler函数试图通过应用数据转换来解决这一问题，该数据转换会移除中值并根据分位数范围缩放数据。与之前介绍的方法相比，对中数据独立于每个特征。</p><p id="4d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将此应用于我们的数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f719" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and read DataFrame:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span><span id="04db" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop non-numerical columns:</strong><br/>df = df.drop(df.columns[[5, 7, 8, 19]], axis = 1)</span><span id="4e86" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:<br/></strong>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span><span id="4cb3" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform X in np.array:</strong><br/>X = np.array(X)</span><span id="6257" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define Robust Scaler function:</strong><br/>robustscaler = preprocessing.RobustScaler()</span><span id="aeb9" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform and inspect X:</strong><br/>df_robsca = robustscaler.fit_transform(X)<br/>df_robsca</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/80922a757b10c2d1ee013eb70789c77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*Wyl8-5vQzkYQPjniG0wqGg.png"/></div></figure><p id="8059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用<strong class="lb iu"> RobustScaler </strong>函数，只有数据缩放会受到影响，我们将检查变量“<strong class="lb iu">日照</strong>”:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f7ca" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Transform np.array to pd.DataFrame:</strong><br/>df_robsca = pd.DataFrame(df_robsca)</span><span id="21f7" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Add column names:</strong><br/>df_robsca.columns = ['MinTemp', 'MaxTemp', 'Rainfall',<br/>       'Evaporation', 'Sunshine', 'WindGustSpeed', 'WindSpeed9am',<br/>       'WindSpeed3pm', 'Humidity9am', 'Humidity3pm','Pressure9am', <br/>       'Pressure3am', 'Cloud9am', 'Cloud3am', 'Temp9am', 'Temp3am',<br/>       'RISK_MM']</span><span id="03e5" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Add the outcome:</strong><br/>df_robsca['RainTomorrow'] = y</span></pre><p id="b89f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将使用箱线图和直方图来检查分布是否相似，并且不会影响结果变量:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7ad7" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Box-plot before transformation:<br/></strong>sns.boxplot(x="RainTomorrow", y="Sunshine", data=df)</span><span id="abb4" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Histogram before transformation:<br/></strong>sns.histplot(data=df, x="Sunshine", hue="RainTomorrow", kde=True, color="skyblue")</span><span id="2633" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Box-plot after transformation:<br/></strong>sns.boxplot(x="RainTomorrow", y="Sunshine", data=df_robsca)</span><span id="de06" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Histogram after transformation:<br/></strong>sns.histplot(data=df_robsca, x="Sunshine", hue="RainTomorrow", kde=True, color="skyblue")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5e7aac616071d644cc285ea6848f8b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8r3GmApmgMd8WsRAkjqcIQ.png"/></div></div></figure><p id="616b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左边，我们可以看到转换前数据的图形表示，在右边，是转换后数据的图形可视化。我们在这里发现的唯一区别是图形的比例。注意变换前，<strong class="lb iu"/>日照数据在0-14之间变化，变换后在-2-1之间变化。请记住，尽管这种规模上的变化可能会对数据可视化产生反作用，但我们在这里的重点是为构建机器学习模型进行数据准备，而不是数据可视化。</p><h2 id="7bf5" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">4.分位数变压器</h2><p id="37a0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">分位数转换函数最适合二项式分布，并将数据转换为值介于0和1之间的均匀分布。</p><p id="7d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试一下我们的样本数据集:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4028" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and read DataFrame:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span></pre><p id="7759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将检查我们的变量，以检查它们是否有二项分布:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5220" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Plot histograms for numerical variables:</strong><br/>fig, axs = plt.subplots(4, 4, figsize=(14, 14))</span><span id="4482" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=df, x="MinTemp", kde=True, color="skyblue", ax=axs[0, 0])<br/>sns.histplot(data=df, x="MaxTemp", kde=True, color="skyblue", ax=axs[0, 1])<br/>sns.histplot(data=df, x="Rainfall", kde=True, color="skyblue", ax=axs[0, 2])<br/>sns.histplot(data=df, x="Evaporation", kde=True, color="skyblue", ax=axs[0, 3])</span><span id="ba93" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=df, x="WindGustSpeed", kde=True, color="skyblue", ax=axs[1, 0])<br/>sns.histplot(data=df, x="WindSpeed9am", kde=True, color="skyblue", ax=axs[1, 1])<br/>sns.histplot(data=df, x="WindSpeed3pm", kde=True, color="skyblue", ax=axs[1, 2])<br/>sns.histplot(data=df, x="Humidity9am", kde=True, color="skyblue", ax=axs[1, 3])</span><span id="c88b" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=df, x="Humidity3pm", kde=True, color="skyblue", ax=axs[2, 0])<br/>sns.histplot(data=df, x="Pressure9am", kde=True, color="skyblue", ax=axs[2, 1])<br/>sns.histplot(data=df, x="Pressure3pm", kde=True, color="skyblue", ax=axs[2, 2])<br/>sns.histplot(data=df, x="Cloud9am", kde=True, color="skyblue", ax=axs[2, 3])</span><span id="556a" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=df, x="Cloud3pm", kde=True, color="skyblue", ax=axs[3, 0])<br/>sns.histplot(data=df, x="Temp9am", kde=True, color="skyblue", ax=axs[3, 1])<br/>sns.histplot(data=df, x="Temp3pm", kde=True, color="skyblue", ax=axs[3, 2])<br/>sns.histplot(data=df, x="RISK_MM", kde=True, color="skyblue", ax=axs[3, 3])</span><span id="b222" class="ma mb it lw b gy mg md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/cdb7b5d4f9d7bb73465dce671e51212d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNArntS3-2Sakojjrsg4Gg.png"/></div></div></figure><p id="82f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发现“蒸发量”和“温度9am”呈二项式分布。我们不会使用“Cloud9am”和“Cloud3pm”，因为这些变量不是连续的。现在我们将放下非数值变量，定义X和y。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6661" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Drop non-numerical variables:</strong><br/>df = df.drop(df.columns[[5, 7, 8, 19]], axis = 1)</span><span id="9682" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:</strong><br/>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span><span id="2437" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform X in np.array:</strong><br/>X = np.array(X)</span><span id="e02b" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define Quantile Transformer function:</strong><br/>quantiletransformer = preprocessing.QuantileTransformer()</span><span id="623f" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Apply transformation to X, and inspect results:</strong><br/>df_qt = quantiletransformer.fit_transform(X)<br/>df_qt</span></pre><p id="0722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将检查这些转换如何影响数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c3d4" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Convert again to pandas DataFrame:</strong><br/>df_qt = pd.DataFrame(df_qt)</span><span id="f11a" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Rename columns:</strong><br/>df_qt.columns = ['MinTemp', 'MaxTemp', 'Rainfall', 'Evaporation',<br/>        'Sunshine', 'WindGustSpeed', 'WindSpeed9am', 'WindSpeed3pm',<br/>        'Humidity9am', 'Humidity3pm','Pressure9am', 'Pressure3pm',<br/>        'Cloud9am', 'Cloud3pm', 'Temp9am', 'Temp3pm', 'RISK_MM']</span><span id="2ed7" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Add outcome variable:</strong><br/>df_qt['RainTomorrow'] = y</span><span id="64f6" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Build graphical visualizations:<br/>#Scatter plot before transformation:<br/></strong>sns.lmplot(data= df, x="Evaporation", y='Temp9am', fit_reg=False, hue='RainTomorrow')</span><span id="2923" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Histogram before transformation:<br/></strong>sns.histplot(data=df, x="Evaporation", hue="RainTomorrow", kde=True, color="skyblue")</span><span id="0063" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=df, x="Temp9am", hue="RainTomorrow", kde=True, color="skyblue")</span><span id="1105" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter plot before transformation:<br/></strong>sns.lmplot(data= df_qt, x="Evaporation", y='Temp9am', fit_reg=False, hue='RainTomorrow')</span><span id="f14a" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Histogram before transformation:<br/></strong>sns.histplot(data=df_qt, x="Evaporation", hue="RainTomorrow", kde=True, color="skyblue")</span><span id="33d8" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=df_qt, x="Temp9am", hue="RainTomorrow", kde=True, color="skyblue")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6cbd69f9f48947851e70dd461b1676d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*NMWNGetvMilvvW0BLOv_3Q.png"/></div></figure><p id="fe06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在转换数据(右边的图像)后，可以获得两个变量的均匀分布(右边的两个直方图)。通过检查散点图，我们可以看到这种转换也影响了变量与结果的关系，这意味着这种转换可能会影响任何预测。</p><h2 id="669f" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">5.电力变压器</h2><p id="8a56" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><strong class="lb iu"> PowerTransformer </strong>函数用于转换非高斯数据，使其更符合正态分布。这种转换对于一些假设数据是正态分布的测试和建模方法特别重要。</p><h2 id="2777" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated"><strong class="ak"> a)Box-Cox </strong></h2><p id="ca6f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Box-Cox是转换倾斜数据的好方法，并且适用于严格的正值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c310" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and load data:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span><span id="4e08" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Explore data to check for negative values:</strong><br/>df.describe()</span></pre><p id="dce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Box-Cox方法只能应用于严格为正的数据，所以我们将丢弃具有负值和零值的变量。我们也将放弃非数字变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="159c" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Drop negative, zero, and non-numerical variables:</strong><br/>df = df.drop(['WindGustDir', 'WindDir9am', 'WindDir3pm', <br/>              'RainToday', 'MinTemp', 'Rainfall', 'Sunshine', <br/>              'WindSpeed9am', 'WindSpeed3pm', 'Cloud9am', <br/>              'Cloud3pm', 'RISK_MM'], axis =1)</span><span id="ba18" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:</strong><br/>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span><span id="8393" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Plot X:</strong><br/>fig, axs = plt.subplots(3, 3, figsize=(14, 14))</span><span id="3c48" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=X, x="MaxTemp", kde=True, color="skyblue", ax=axs[0, 0])<br/>sns.histplot(data=X, x="Evaporation", kde=True, color="skyblue", ax=axs[0, 1])<br/>sns.histplot(data=X, x="WindGustSpeed", kde=True, color="skyblue", ax=axs[0, 2])</span><span id="e23e" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=X, x="Humidity9am", kde=True, color="skyblue", ax=axs[1, 0])<br/>sns.histplot(data=X, x="Humidity3pm", kde=True, color="skyblue", ax=axs[1, 1]<br/>sns.histplot(data=X, x="Pressure9am", kde=True, color="skyblue", ax=axs[1, 2])</span><span id="8785" class="ma mb it lw b gy mg md l me mf">sns.histplot(data=X, x="Pressure3pm", kde=True, color="skyblue", ax=axs[2, 0])<br/>sns.histplot(data=X, x="Temp9am", kde=True, color="skyblue", ax=axs[2, 1])<br/>sns.histplot(data=X, x="Temp3pm", kde=True, color="skyblue", ax=axs[2, 2])</span><span id="9dd2" class="ma mb it lw b gy mg md l me mf">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/8136490ee6464c39b6d412d2bf490673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SlP_w6kxEhOxhMn6rAdig.png"/></div></div></figure><p id="6b8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意,“MaxTemp”和“Humidity3pm”是右偏的。让我们来看看在Box-Cox变换之后发生了什么。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d22c" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Create np.array:</strong><br/>X = np.array(X)</span><span id="04a6" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define PowerTransform function:</strong><br/>pt = preprocessing.PowerTransformer(method='box-cox', standardize=False)</span><span id="e291" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Apply function to our data:</strong><br/>X_pt = pt.fit_transform(X)</span><span id="e05d" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Recode data to pandas DataFrame:</strong><br/>X_pt = pd.DataFrame(X_pt)</span><span id="5e0e" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Rename columns:</strong><br/>X_pt.columns = ['MaxTemp', 'Evaporation', 'WindGustSpeed', <br/>          'Humidity9am', 'Humidity3pm','Pressure9am', 'Pressure3am',<br/>          'Temp9am', 'Temp3am']</span><span id="b806" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#And predictive variable:<br/></strong>X_pt['RainTomorrow'] = y</span></pre><p id="2a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在再次检查分布和与预测变量相关的行为:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="083f" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Plotting distibutions on the same figure before transformation:<br/></strong>fig = sns.kdeplot(df['Humidity3pm'], shade=True, color="r")<br/>fig = sns.kdeplot(df['MaxTemp'], shade=True, color="b")<br/>plt.show()</span><span id="b5e1" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter plot before transformation:<br/></strong>sns.lmplot(data= df, x="Humidity3pm", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span><span id="afae" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Plotting distibutions on the same figure aftertransformation:<br/></strong>fig = sns.kdeplot(X_pt['Humidity3pm'], shade=True, color="r")<br/>fig = sns.kdeplot(X_pt['MaxTemp'], shade=True, color="b")<br/>plt.show()</span><span id="9c51" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter plot after transformation:<br/></strong>sns.lmplot(data= X_pt, x="Humidity3pm", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7506c1587810b2e1f89d93cf43cd7248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJfrDlSTkEOY29M98GKT1A.png"/></div></div></figure><p id="79f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图像在左侧显示转换前的数据，在右侧显示转换后的数据。请注意，只有分布发生了变化，而没有影响变量如何影响“明天下雨”的结果。</p><h2 id="ed79" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">b)约-约翰逊公司</h2><p id="fb7f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Yeo-Johnson与Box-Cox相似，最适用于扭曲数据的标准化分布，但适用于正值和负值。过程是相同的，只是改变(方法='Box-Cox '到方法='Yeo-Johnson ')。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="79fb" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Read and load data:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span><span id="2fc9" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop columns:<br/></strong>df = df.drop(['WindGustDir', 'WindDir9am', 'WindDir3pm', <br/>              'RainToday', 'MinTemp', 'Rainfall', 'Sunshine', <br/>              'WindSpeed9am', 'WindSpeed3pm', 'Cloud9am', <br/>              'Cloud3pm', 'RISK_MM'], axis =1)</span><span id="09eb" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:<br/></strong>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span><span id="db97" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define PowerTransform function:</strong><br/>pt = preprocessing.PowerTransformer(method='yeo-johnson', standardize=False)</span><span id="d462" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform X:</strong><br/>X_pt = pt.fit_transform(X)</span></pre><p id="ef7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余步骤与Box-Cox相似。记住，如果你有严格的正数据，你可以用Box-Cox。否则，选择Yeo-Johnson。</p><h2 id="4530" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">6.使标准化</h2><p id="f0ba" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">将输入向量单独缩放到单位范数，这意味着所有值将介于0和1之间。与StandardScaler和RobustScaler不同，因为变量将保持不同的平均值，并且不接受NaN值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b479" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and load dataset:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span><span id="5a8f" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop non-numerical columns:</strong><br/>df = df.drop(df.columns[[5, 7, 8, 19]], axis = 1)</span><span id="6cfb" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:<br/></strong>y = df['RainTomorrow']<br/>X = df.drop('RainTomorrow', axis=1)</span><span id="83c1" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop NaN from X:</strong><br/>X = X.dropna()</span><span id="76ac" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Convert X to np.array:</strong><br/>X = np.array(X)</span><span id="1c08" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define Normalize function:</strong><br/>X_normalized = preprocessing.normalize(X)</span><span id="6eca" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Reconvert to pandas DataFrame:</strong><br/>X_normalized = pd.DataFrame(X_normalized)</span><span id="3903" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Rename columns:</strong><br/>X_normalized.columns = ['MinTemp', 'MaxTemp', 'Rainfall', <br/>         'Evaporation', 'Sunshine', 'WindGustSpeed', 'WindSpeed9am', <br/>         'WindSpeed3pm', 'Humidity9am', 'Humidity3pm','Pressure9am', <br/>         'Pressure3pm', 'Cloud9am', 'Cloud3pm', 'Temp9am', <br/>         'Temp3pm', 'RISK_MM']</span><span id="69c3" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Add y:</strong><br/>X_normalized['RainTomorrow'] = y</span></pre><p id="d526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们检查一下我们的转变的效果:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="87b8" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Scatter plot before transformation:<br/></strong>sns.lmplot(data= df, x="MinTemp", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span><span id="78a3" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Plotting both distibutions before transformation:<br/></strong>fig = sns.kdeplot(df['MinTemp'], shade=True, color="r")<br/>fig = sns.kdeplot(df['MaxTemp'], shade=True, color="b")<br/>plt.show()</span><span id="caee" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Scatter plot after transformation:<br/></strong>sns.lmplot(data= X_normalized, x="MinTemp", y='MaxTemp', fit_reg=False, hue='RainTomorrow')</span><span id="9c7f" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Plotting both distibutions after transformation:<br/></strong>fig = sns.kdeplot(X_normalized['MinTemp'], shade=True, color="r")<br/>fig = sns.kdeplot(X_normalized['MaxTemp'], shade=True, color="b")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/5261da666dd27f6d9c23a0e84e455ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TlNSgU5FhcmIoMMbEAUWw.png"/></div></div></figure><p id="945b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图像在左侧显示转换前的数据，在右侧显示转换后的数据。请注意，只有数据缩放受到影响，而不影响变量如何影响结果“RainTomorrow”或变量如何分布，以及保持不同的均值。</p><h2 id="c889" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">7.编码分类特征</h2><p id="45df" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时，将分类特征转换为整数会很有用。</p><h2 id="de46" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">a)顺序编码器</h2><p id="7beb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">序数编码器的工作原理是将序数分类特征转换成整数。例如，我们可以将“空”、“中”和“满”转换为0、1和2。顺序编码器假定值有一个顺序。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e3cc" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and load data:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span></pre><p id="470a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将需要丢弃数字数据，并维护类别特征。我们将检查数据类型和需要删除的变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bbf2" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Check data types:</strong><br/>df.dtypes</span><span id="e520" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop numerical features:<br/></strong>df = df.drop(['MaxTemp', 'Rainfall', 'Evaporation', 'Sunshine', <br/>              'WindGustSpeed', 'WindSpeed9am', 'WindSpeed3pm',<br/>              'Humidity9am', 'Humidity3pm', 'Pressure9am', <br/>              'Pressure3pm', 'Cloud9am', 'Cloud3pm', 'Temp9am', <br/>              'Temp3pm', 'RISK_MM'], axis =1)</span><span id="8f34" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:<br/></strong>y = df['MinTemp']<br/>X = df.drop('MinTemp', axis=1)</span><span id="f99c" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Check X:</strong><br/>X</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e4141d752ae3af92d713799f1b8fdf07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*-bHwZ-H_tUFsak1i82FeYQ.png"/></div></figure><p id="bd59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到<strong class="lb iu"> X </strong>只包含分类变量。我们可以进一步探索这些变量:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2c93" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Count the number of different categories in each feature:</strong><br/>print("WindGustDir:\n", X["WindGustDir"].value_counts())<br/>print("\nWindDir9am:\n", X["WindDir9am"].value_counts())<br/>print("\nWindDir3pm:\n", X["WindDir3pm"].value_counts())<br/>print("\nRainToday:\n", X["RainToday"].value_counts())<br/>print("\nRainTomorrow:\n", X["RainTomorrow"].value_counts())</span><span id="51a5" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Visualize data:</strong><br/>X['WindGustDir'].value_counts().plot(kind='bar')<br/>X['WindDir9am'].value_counts().plot(kind='bar')<br/>X['WindDir3pm'].value_counts().plot(kind='bar')<br/>X['RainToday'].value_counts().plot(kind='bar')<br/>X['RainTomorrow'].value_counts().plot(kind='bar')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a0d80e9ce265a03f24213a1a73be23a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uioRxPbfd7cUSfBVFb8Kag.png"/></div></div></figure><p id="9e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一段代码将实现序号编码器转换:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="df92" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Transform X in np.array:</strong><br/>X = np.array(X)</span><span id="9f07" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define Ordinal Encoder function:</strong><br/>enc = preprocessing.OrdinalEncoder()<br/>enc.fit(X)</span><span id="8e5b" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform X:</strong><br/>X_enc = pd.DataFrame(X_enc)</span><span id="bce2" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Rename columns:</strong><br/>X_enc.columns = ['WindGustDir', 'WindDir9am', 'WindDir3pm', <br/>                 'RainToday', 'RainTomorrow']</span><span id="ef04" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Check X:</strong><br/>X_enc</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d7bb460482499643e6720921bb52b895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*3mym5wgSydtzT0P7zLQUWQ.png"/></div></figure><p id="d617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据框现在只有数字要素。现在我们可以根据不同的需要使用数值变量。例如，现在我们可以执行相关性测试或绘制散点图。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="940a" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Add y to data frame:</strong><br/>X_enc['MinTemp'] = y</span><span id="87d1" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drawn a heatmap with correlations (impossible to do with categorical features):</strong><br/>corr_matrix=X_enc.corr()</span><span id="984e" class="ma mb it lw b gy mg md l me mf">mask = np.zeros_like(corr_matrix)<br/>mask[np.triu_indices_from(mask)] = True</span><span id="4e57" class="ma mb it lw b gy mg md l me mf">sns.heatmap(corr_matrix, mask=mask, square=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2e891c5174a6cc901fe3647913562e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*TnVLVksdFAix6k2nUP2xXw.png"/></div></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="57eb" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Build pair-plot:</strong><br/>sns.pairplot(X_enc_sns, hue="RainTomorrow", height=2.5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d7278873b1bc7d8a4ce64585e5ab5642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0E4-q2N1KDtDAXdtzOqYkA.png"/></div></div></figure><h2 id="24fd" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">b)一个热编码器</h2><p id="9ad9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">One Hot编码器功能将所有名义类别转换为二进制类别(虚拟变量)。这样，函数将在原始变量中创建任何可用的特性。所有新要素都将被编码为0，只有一个除外，它将被编码为1并表示原始变量值。</p><p id="e11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><p id="5324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有<strong class="lb iu"> 5个主题</strong>和<strong class="lb iu"> 4个位置</strong>，我们可以使用名义特征:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fead" class="ma mb it lw b gy mc md l me mf">[Louis, New York]<br/>[Maria, London]<br/>[Peter, New York]<br/>[Ann, Hong Kong]<br/>[John, Tokyo]</span></pre><ul class=""><li id="527d" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">路易斯、玛丽亚、彼得、安、约翰(5类)</li><li id="6865" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">伦敦、纽约、香港、东京(4个类别)</li></ul><p id="a583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码这些变量的另一种方法是:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cc5c" class="ma mb it lw b gy mc md l me mf">[<strong class="lw iu">1</strong> #Louis, 0 #Maria, 0 #Peter, 0 #Ann, 0 #John, 0 #London, <strong class="lw iu">1</strong> #New York, 0 #Hong Kong, 0 #Tokyo]</span></pre><ul class=""><li id="5a1a" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">请注意，对于路易斯和纽约，我们只有“1”</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b015" class="ma mb it lw b gy mc md l me mf">[0, 1, 0, 0, 0, 1, 0, 0, 0]</span></pre><ul class=""><li id="3428" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">1辆开往玛丽亚和伦敦</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d4f9" class="ma mb it lw b gy mc md l me mf">[0, 0, 1, 0, 0, 0, 1, 0, 0]</span></pre><ul class=""><li id="7c30" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">1为彼得和纽约</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7886" class="ma mb it lw b gy mc md l me mf">[0, 0, 0, 1, 0, 0, 0, 1, 0]</span></pre><ul class=""><li id="9df4" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">1用于安和香港</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c1a2" class="ma mb it lw b gy mc md l me mf">[0, 0, 0, 0, 1, 0, 0, 0, 1]</span></pre><ul class=""><li id="43c8" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated">1用于约翰和东京</li></ul><p id="48ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，生成的数据框架将比原始数据大得多，列数与每个要素中的不同类别一样多。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="353e" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Import and load data:</strong><br/>df = pd.read_csv('/content/weather.csv')<br/>df</span><span id="884b" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Drop numerical features:</strong><br/>df = df.drop(['MaxTemp', 'Rainfall', 'Evaporation', 'Sunshine', <br/>              'WindGustSpeed', 'WindSpeed9am', 'WindSpeed3pm',  <br/>              'Humidity9am', 'Humidity3pm', 'Pressure9am', <br/>              'Pressure3pm', 'Cloud9am', 'Cloud3pm', 'Temp9am', <br/>              'Temp3pm','RISK_MM'], axis =1)</span><span id="f31d" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define X and y:<br/></strong>y = df['MinTemp']<br/>X = df.drop('MinTemp', axis=1)</span><span id="f060" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Convert X to np.array:</strong><br/>X = np.array(X)</span><span id="3ef0" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Define OneHotEncoder function:</strong><br/>hotenc = preprocessing.OneHotEncoder()<br/>hotenc.fit(X)</span><span id="4340" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Transform X:</strong><br/>X_hotenc = hotenc.transform(X).toarray()</span></pre><p id="056f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以检查编码了哪些名词类别:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bf36" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Print encoded categories:</strong><br/>print(hotenc.categories_)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bb12664d131c08d4351b92741e3a916b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVt4Akb6BD-FxABYevw9jA.png"/></div></div></figure><p id="8682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以对新的编码数据进行一些分析:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d3f3" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Convert data to pandas DataFrame:</strong><br/>X_hotenc = pd.DataFrame(X_hotenc)<br/>X_hotenc</span></pre><p id="e283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次我们不会重命名列，因为列的数量比以前大得多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/95ba31cca2b69a3fe229eb81705cbbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ac0iTE8C6h7O3H2acyXwPA.png"/></div></div></figure><p id="d45a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些数据，我们可以对单个类别进行分析，例如，我们可以将一个风向与所有其他类别的最低温度进行比较:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6ef4" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Add y:</strong><br/>X_hotenc['MinTemp'] = y</span><span id="3e0c" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Build Box-Plot:</strong><br/>sns.boxplot( x=df[1], y=df["MinTemp"] )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/e16b38afcd9b84c4a8a50b973884bf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*dmw58CtXQR_zNadOxRZuIw.png"/></div></figure><p id="878c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nl">结论</em> </strong></p><p id="9591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据预处理是数据科学中的一个重要步骤，特别是如果我们的模型需要某种类型的数据(如果我们正在进行无监督的机器学习)，或者简单地说，如果我们需要以不同的方式可视化我们的数据。</p><p id="199e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！如果你有建议要添加到这个列表中，请告诉我，不要忘记订阅以接收关于我未来出版物的通知。</p><p id="b6ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果:你喜欢这篇文章，别忘了关注我，这样你就能收到所有关于新出版物的更新。</p><p id="ea7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多，你可以通过<a class="ae ky" href="https://cdanielaam.medium.com/membership" rel="noopener">我的推荐链接</a>订阅媒体会员。它不会花你更多的钱，但会支付我一杯咖啡。</p><p id="d0e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Else:谢谢！</p></div></div>    
</body>
</html>