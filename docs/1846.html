<html>
<head>
<title>Bitcoin Price Prediction with RNN and LSTM in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现RNN和LSTM的比特币价格预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/bitcoin-price-prediction-with-rnn-and-lstm-in-python-f912d57c483e?source=collection_archive---------0-----------------------#2021-05-14">https://pub.towardsai.net/bitcoin-price-prediction-with-rnn-and-lstm-in-python-f912d57c483e?source=collection_archive---------0-----------------------#2021-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4e9b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="3662" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><strong class="ak">利用深度学习预测比特币价格</strong></h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f8243d9363c3c78d074ecf438aeddab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrhCk-D2GqnT0paAS-ha9Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">比特币的预测。作者的照片</figcaption></figure><p id="dfa0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我们将讨论一个与比特币价格预测相关的程序。</p><p id="65b2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将讨论这里使用的图形表示的库。</p><h2 id="7b23" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">涵盖的主题:</h2><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="b332" class="md me it mw b gy na nb l nc nd">1. What is a Bitcoin<br/>2. How to use Bitcoin<br/>3. Prediction of Bitcoin Prices Using Deep Learning</span></pre><blockquote class="ne nf ng"><p id="35c6" class="lh li nh lj b lk ll kd lm ln lo kg lp ni lr ls lt nj lv lw lx nk lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">什么是比特币？</em> </strong></p></blockquote><p id="4aa9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">比特币是所有加密爱好者常用的加密货币之一。尽管有几种加密货币，如以太坊、Ripple、莱特币等，但比特币仍名列前茅。</p><p id="80f3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">加密货币通常被用作我们货币的加密形式，广泛用于购物、交易、投资等。</p><p id="72d0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它使用点对点技术。这种技术背后的原因是没有驱动力或任何第三方来干扰网络内进行的交易。此外，比特币是“开源”的，任何人都可以使用。</p><p id="8571" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一些功能包括:</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="a5e4" class="md me it mw b gy na nb l nc nd">1. Fast peer-to-peer transactions<br/>2. Worldwide payments<br/>3. Low processing fees</span></pre><p id="2da6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">使用的原理—密码术:</strong></p><p id="cde8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">加密货币(比特币)背后的工作原理是“密码学”。他们利用这一原理来保护和认证协商，并控制加密货币新组件的建立。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f392df8163fc12d5303516ce15091433.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*78RovkUnXi1uv7cwXEZBTw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">比特币流程图步骤。来源是<a class="ae nm" href="https://searchsecurity.techtarget.com/definition/cryptography" rel="noopener ugc nofollow" target="_blank">技术目标</a></figcaption></figure><blockquote class="ne nf ng"><p id="7be0" class="lh li nh lj b lk ll kd lm ln lo kg lp ni lr ls lt nj lv lw lx nk lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">如何使用比特币？</em>T15】</strong></p></blockquote><ul class=""><li id="2470" class="nn no it lj b lk ll ln lo lq np lu nq ly nr mc ns nt nu nv bi translated">保护钱包:比特币钱包应该更加安全，以便轻松顺利地进行交易</li><li id="d427" class="nn no it lj b lk nw ln nx lq ny lu nz ly oa mc ns nt nu nv bi translated">比特币的价格不稳定:比特币的价格可能会有波动。价格可以根据通货膨胀率、交易量等几个因素上升或下降。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ffd187c9696a19b75af9826c4a304546.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*Cwht8S8OtqbkgyeGOWp9Ag.png"/></div></figure><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-tensorflow-basic-with-python-87281e737db9"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jd gy z fp ok fr fs ol fu fw jc bi translated">使用Python了解TensorFlow Basic</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">张量流中使用的基本术语</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">pub.towardsai.net</p></div></div><div class="oo l"><div class="op l oq or os oo ot lb of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/step-by-step-basic-understanding-of-neural-networks-with-keras-in-python-94f4afd026e5"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jd gy z fp ok fr fs ol fu fw jc bi translated">使用Python中的Keras逐步基本了解神经网络</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">具有定义的神经网络的学习</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">pub.towardsai.net</p></div></div><div class="oo l"><div class="ou l oq or os oo ot lb of"/></div></div></a></div><blockquote class="ne nf ng"><p id="14fb" class="lh li nh lj b lk ll kd lm ln lo kg lp ni lr ls lt nj lv lw lx nk lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">利用深度学习预测比特币价格:</em> </strong></p></blockquote><p id="41e4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该项目中使用的步骤是:</p><p id="3b9e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> 1。</strong> <strong class="lj jd">数据采集:</strong></p><p id="99a7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">导入CSV文件数据集。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="6a41" class="md me it mw b gy na nb l nc nd">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="c42e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，导入熊猫和numpy的数据集。Numpy主要用于python中的科学计算</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="ddfd" class="md me it mw b gy na nb l nc nd">coindata = pd.read_csv(‘Dataset.csv’)<br/>googledata = pd.read_csv(‘DS2.csv’)</span></pre><p id="db9e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，加载的原始数据集被打印出来</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="a251" class="md me it mw b gy na nb l nc nd">coindata = coindata.drop([‘#’], axis=1)<br/>coindata.columns = [‘Date’,’Open’,’High’,’Low’,’Close’,’Volume’]<br/>googledata = googledata.drop([‘Date’,’#’], axis=1)</span></pre><p id="eeb9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">未使用的列放在这里。这里，我们从coin数据和google数据集中删除了两列，因为它们是未使用的列。</p><p id="6f55" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，在从数据集中删除了未使用的列之后，打印出两个数据集的最终结果。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="8677" class="md me it mw b gy na nb l nc nd">last = pd.concat([coindata,googledata], axis=1)</span></pre><p id="c56f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，两个数据集——硬币数据和谷歌数据连接在一起，并使用函数打印出来</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="66f9" class="md me it mw b gy na nb l nc nd">last.to_csv(‘Bitcoin3D.csv’, index=False)</span></pre><p id="0461" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，在连接两个数据集之后，最终数据集被导出。</p><p id="c22d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> 1。</strong> <strong class="lj jd"> RNN对1D: </strong></p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="62d3" class="md me it mw b gy na nb l nc nd">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="9381" class="md me it mw b gy ov nb l nc nd">import math</span><span id="2691" class="md me it mw b gy ov nb l nc nd">from sklearn.preprocessing import MinMaxScaler<br/>from sklearn.metrics import mean_squared_error</span><span id="d9cd" class="md me it mw b gy ov nb l nc nd">from keras.models import Sequential<br/>from keras.layers import Dense, Activation, Dropout<br/>from keras.layers import LSTM</span></pre><p id="fd8b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我们使用Keras库。Keras用于训练神经网络模型，只需几行代码就可以使用高效的计算库。MinMaxScaler将通过将每个要素映射到给定范围来转换要素。sklearn包将提供程序所需的一些实用函数。</p><p id="7f0d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">密集层将执行以下操作并返回输出。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="6f00" class="md me it mw b gy na nb l nc nd">output = activation(dot(input, kernel) + bias)</span><span id="6ece" class="md me it mw b gy ov nb l nc nd">def new_dataset(dataset, step_size):<br/>    data_X, data_Y = [], []<br/>    for i in range(len(dataset)-step_size-1):<br/>        a = dataset[i:(i+step_size), 0]<br/>        data_X.append(a)<br/>        data_Y.append(dataset[i + step_size, 0])<br/>    return np.array(data_X), np.array(data_Y)</span></pre><p id="d1f7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们将在数据预处理阶段收集的1D数据组织成时间序列数据</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="afcb" class="md me it mw b gy na nb l nc nd">df = pd.read_csv(“Bitcoin1D.csv”)<br/>df[‘Date’] = pd.to_datetime(df[‘Date’])<br/>df = df.reindex(index= df.index[::-1])</span></pre><p id="25ec" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据集已加载。该特征从Bitcoin1D.csv文件中读取。此外，我们将日期列转换为日期时间。按日期列重新索引所有数据集。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="457a" class="md me it mw b gy na nb l nc nd">zaman = np.arange(1, len(df) + 1, 1)<br/>OHCL_avg = df.mean(axis=1)</span></pre><p id="4285" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们直接分配一个新的索引数组。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="4ac5" class="md me it mw b gy na nb l nc nd">OHCL_avg = np.reshape(OHCL_avg.values, (len(OHCL_avg),1)) #7288 data<br/>scaler = MinMaxScaler(feature_range=(0,1))<br/>OHCL_avg = scaler.fit_transform(OHCL_avg)</span></pre><p id="01d4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">分配定标器后，归一化数据集</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="7a6f" class="md me it mw b gy na nb l nc nd">#print(OHCL_avg)</span><span id="ca64" class="md me it mw b gy ov nb l nc nd">train_OHLC = int(len(OHCL_avg)*0.56)<br/>test_OHLC = len(OHCL_avg) — train_OHLC</span><span id="398c" class="md me it mw b gy ov nb l nc nd">train_OHLC, test_OHLC = OHCL_avg[0:train_OHLC,:], OHCL_avg[train_OHLC:len(OHCL_avg),:]</span><span id="5e93" class="md me it mw b gy ov nb l nc nd">#Train the datasets and test it</span><span id="1873" class="md me it mw b gy ov nb l nc nd">trainX, trainY = new_dataset(train_OHLC,1)<br/>testX, testY = new_dataset(test_OHLC,1)</span></pre><p id="7d82" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们从平均OHLC(开盘-盘高-盘低-收盘)创建1D维度数据集</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="9b2c" class="md me it mw b gy na nb l nc nd">trainX = np.reshape(trainX, (trainX.shape[0],1,trainX.shape[1]))<br/>testX = np.reshape(testX, (testX.shape[0],1,testX.shape[1]))</span><span id="959d" class="md me it mw b gy ov nb l nc nd">step_size = 1</span></pre><p id="8927" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，在3D维度中重塑LSTM的数据集。将步长指定为1。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="8adc" class="md me it mw b gy na nb l nc nd">model = Sequential()<br/>model.add(LSTM(128, input_shape=(1, step_size)))<br/>model.add(Dropout(0.1))<br/>model.add(Dense(1))<br/>model.add(Activation(‘linear’))</span></pre><p id="0592" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，LSTM模式被创造出来</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="4d58" class="md me it mw b gy na nb l nc nd">model.compile(loss=’mean_squared_error’, optimizer=’adam’)<br/>model.fit(trainX, trainY, epochs=10, batch_size=25, verbose=2)</span></pre><p id="60be" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将历元数定义为10，batch_size定义为25</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="55db" class="md me it mw b gy na nb l nc nd">trainPredict = model.predict(trainX)<br/>testPredict = model.predict(testX)</span><span id="eca2" class="md me it mw b gy ov nb l nc nd">trainPredict = scaler.inverse_transform(trainPredict)<br/>trainY = scaler.inverse_transform([trainY])<br/>testPredict = scaler.inverse_transform(testPredict)</span><span id="2ade" class="md me it mw b gy ov nb l nc nd">testY = scaler.inverse_transform([testY])</span></pre><p id="dd20" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，反规范化是为了绘图</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="f5ff" class="md me it mw b gy na nb l nc nd">trainScore = math.sqrt(mean_squared_error(trainY[0], <br/>                       trainPredict[:,0]))</span><span id="9606" class="md me it mw b gy ov nb l nc nd">testScore = math.sqrt(mean_squared_error(testY[0], <br/>                       testPredict[:,0]))</span></pre><p id="de6f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为预测的测试数据集计算性能度量RMSE</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="f611" class="md me it mw b gy na nb l nc nd">trainPredictPlot = np.empty_like(OHCL_avg)</span><span id="e3f1" class="md me it mw b gy ov nb l nc nd">trainPredictPlot[:,:] = np.nan</span><span id="a181" class="md me it mw b gy ov nb l nc nd">trainPredictPlot[step_size:len(trainPredict)+step_size,:] =<br/>                                                  trainPredict</span></pre><p id="c434" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，转换后的训练数据集用于绘图</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="6e34" class="md me it mw b gy na nb l nc nd">testPredictPlot = np.empty_like(OHCL_avg)</span><span id="98a5" class="md me it mw b gy ov nb l nc nd">testPredictPlot[:,:] = np.nan</span><span id="9561" class="md me it mw b gy ov nb l nc nd">testPredictPlot[len(trainPredict)+(step_size*2)+1:len(OHCL_avg)-1,:]<br/>                    = testPredict</span></pre><p id="d3ef" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，转换后的预测测试数据集用于绘图</p><p id="5ce4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，预测值被可视化</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="b709" class="md me it mw b gy na nb l nc nd">OHCL_avg = scaler.inverse_transform(OHCL_avg)</span><span id="9c97" class="md me it mw b gy ov nb l nc nd">plt.plot(OHCL_avg, ‘g’, label=’Orginal Dataset’)<br/>plt.plot(trainPredictPlot, ‘r’, label=’Training Set’)<br/>plt.plot(testPredictPlot, ‘b’, label=’Predicted price/test set’)<br/>plt.title(“ Bitcoin Predicted Prices”)<br/>plt.xlabel(‘ Time’, fontsize=12)<br/>plt.ylabel(‘Close Price’, fontsize=12)<br/>plt.legend(loc=’upper right’)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/d03657330c722d641205c368d856b4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*Ve5wHIxlNWhFh672mW71bQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">1D — RNN的产量。作者的照片</figcaption></figure><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/data-preprocessing-concepts-with-python-b93c63f14bb6"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jd gy z fp ok fr fs ol fu fw jc bi translated">Python中的数据预处理概念</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">一种为机器学习估值器准备数据的稳健方法</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">pub.towardsai.net</p></div></div><div class="oo l"><div class="ox l oq or os oo ot lb of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-time-series-components-with-python-4bc3e2ba1189"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jd gy z fp ok fr fs ol fu fw jc bi translated">用Python理解时间序列组件</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">机器学习中预测模型的基本概念及实例</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">pub.towardsai.net</p></div></div><div class="oo l"><div class="oy l oq or os oo ot lb of"/></div></div></a></div><p id="cb30" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> 3。多变量的RNN:</strong></p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="5de2" class="md me it mw b gy na nb l nc nd">import pandas as pd<br/>from pandas import DataFrame<br/>from pandas import concat</span><span id="8ec9" class="md me it mw b gy ov nb l nc nd">from math import sqrt<br/>from numpy import concatenate</span><span id="d84b" class="md me it mw b gy ov nb l nc nd">import matplotlib.pyplot as pyplot<br/>import numpy as np</span><span id="1c1a" class="md me it mw b gy ov nb l nc nd">from sklearn.metrics import mean_squared_error<br/>from sklearn.preprocessing import MinMaxScaler</span><span id="53b3" class="md me it mw b gy ov nb l nc nd">from keras import Sequential<br/>from keras.layers import LSTM, Dense, Dropout, Activation</span><span id="a836" class="md me it mw b gy ov nb l nc nd">from pandas import read_csv</span></pre><p id="9e0e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我们使用Keras库。Keras用于训练神经网络模型，只需几行代码就可以使用高效的计算库。sklearn包将提供程序所需的一些实用函数。</p><p id="2709" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">密集层将执行以下操作并返回输出。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="a9a5" class="md me it mw b gy na nb l nc nd">dataset = read_csv(‘Bitcoin3D.csv’, header=0, index_col=0)<br/>print(dataset.head())</span><span id="61da" class="md me it mw b gy ov nb l nc nd">values = dataset.values</span></pre><p id="ddf3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用Pandas库加载数据集。这是为可视化准备的柱子。</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="a0db" class="md me it mw b gy na nb l nc nd">groups = [0, 1, 2, 3, 5, 6,7,8,9]<br/>i = 1</span></pre><p id="f33a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将系列转换为监督学习</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="6af6" class="md me it mw b gy na nb l nc nd">def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):<br/>    n_vars = 1 if type(data) is list else data.shape[1]<br/>    df = DataFrame(data)<br/>    cols, names = list(), list()<br/>    # Here is created input columns which are (t-n, … t-1)<br/>    for i in range(n_in, 0, -1):<br/>        cols.append(df.shift(i))<br/>        names += [(‘var%d(t-%d)’ % (j+1, i)) for j in range(n_vars)]</span><span id="f003" class="md me it mw b gy ov nb l nc nd">#Here, we had created output/forecast column which are (t, t+1, … t+n)<br/>    for i in range(0, n_out):<br/>        cols.append(df.shift(-i))<br/>        if i == 0:<br/>            names += [(‘var%d(t)’ % (j+1)) for j in range(n_vars)]<br/>        else:<br/>            names += [(‘var%d(t+%d)’ % (j+1, i)) for j in<br/>                                             range(n_vars)]</span><span id="a193" class="md me it mw b gy ov nb l nc nd">    agg = concat(cols, axis=1)<br/>    agg.columns = names<br/>    # drop rows with NaN values <br/>    if dropnan:<br/>        agg.dropna(inplace=True)<br/>    return agg</span></pre><p id="cbd6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">检查值是否为数字格式</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="870a" class="md me it mw b gy na nb l nc nd">values = values.astype(‘float32’)</span></pre><p id="bd0b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用最小最大值方法对数据集值进行归一化</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="4bcd" class="md me it mw b gy na nb l nc nd">scaler = MinMaxScaler(feature_range=(0,1))<br/>scaled = scaler.fit_transform(values)</span></pre><p id="7c06" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">归一化值被转换用于监督学习</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="6d67" class="md me it mw b gy na nb l nc nd">reframed = series_to_supervised(scaled,1,1)</span><span id="da35" class="md me it mw b gy ov nb l nc nd">#reframed.drop(reframed.columns[[9,10,11,12,13,14,15]], axis=1, inplace=True)</span></pre><p id="7e1d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据集被分成两组，即训练集和测试集</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="2112" class="md me it mw b gy na nb l nc nd">values = reframed.values<br/>train_size = int(len(values)*0.70)<br/>train = values[:train_size,:]<br/>test = values[train_size:,:]</span></pre><p id="5897" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">分割数据集被分割成trainX、trainY、testX和testY</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="f616" class="md me it mw b gy na nb l nc nd">trainX, trainY = train[:,:-1], train[:,13]<br/>testX, testY = test[:,:-1], test[:,13]</span></pre><p id="7cdc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">训练和测试数据集以3D尺寸重新整形，以用于LSTM</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="d2f3" class="md me it mw b gy na nb l nc nd">trainX = trainX.reshape((trainX.shape[0],1,trainX.shape[1]))<br/>testX = testX.reshape((testX.shape[0],1,testX.shape[1]))</span></pre><p id="c89f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">创建LSTM模型并调整神经元结构</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="d3ce" class="md me it mw b gy na nb l nc nd">model = Sequential()<br/>model.add(LSTM(128, input_shape=(trainX.shape[1], trainX.shape[2])))<br/>model.add(Dropout(0.05))<br/>model.add(Dense(1))<br/>model.add(Activation(‘linear’))<br/>model.compile(loss=’mae’, optimizer=’adam’)</span></pre><p id="ef0d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用trainX和trainY对数据集进行训练</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="60b3" class="md me it mw b gy na nb l nc nd">history = model.fit(trainX, trainY, epochs=10, batch_size=25, validation_data=(testX, testY), verbose=2, shuffle=False)</span></pre><p id="588e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为每个训练时期计算损失值，并将其可视化</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="bcb0" class="md me it mw b gy na nb l nc nd">pyplot.plot(history.history[‘loss’], label=’train’)<br/>pyplot.plot(history.history[‘val_loss’], label=’test’)<br/>pyplot.title(“Test and Train set Loss Value Rate”)<br/>pyplot.xlabel(‘Epochs Number’, fontsize=12)<br/>pyplot.ylabel(‘Loss Value’, fontsize=12)<br/>pyplot.legend()<br/>pyplot.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/47c5b6aa35f172f7d6e67625490c0a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*2NAjUlLnzChFEtBU2KnmVg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">损失图。作者的照片</figcaption></figure><p id="f9a5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对训练数据集执行预测过程</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="9c11" class="md me it mw b gy na nb l nc nd">trainPredict = model.predict(trainX)<br/>trainX = trainX.reshape((trainX.shape[0], trainX.shape[2]))</span></pre><p id="f6e3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对测试数据集执行预测过程</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="d17d" class="md me it mw b gy na nb l nc nd">testPredict = model.predict(testX)<br/>testX = testX.reshape((testX.shape[0], testX.shape[2]))</span></pre><p id="5573" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">训练数据集反转训练的缩放比例</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="641a" class="md me it mw b gy na nb l nc nd">trainPredict = concatenate((trainPredict, trainX[:, -9:]), axis=1)<br/>trainPredict = scaler.inverse_transform(trainPredict)<br/>trainPredict = trainPredict[:,0]</span></pre><p id="b720" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">测试数据集反转预测的缩放比例</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="99c0" class="md me it mw b gy na nb l nc nd">testPredict = concatenate((testPredict, testX[:, -9:]), axis=1)<br/>testPredict = scaler.inverse_transform(testPredict)<br/>testPredict = testPredict[:,0]</span><span id="e00f" class="md me it mw b gy ov nb l nc nd"># invert scaling for actual</span><span id="3ef6" class="md me it mw b gy ov nb l nc nd">testY = testY.reshape((len(testY), 1))<br/>inv_y = concatenate((testY, testX[:, -9:]), axis=1)<br/>inv_y = scaler.inverse_transform(inv_y)<br/>inv_y = inv_y[:,0]</span></pre><p id="771a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过使用训练和测试预测的均方误差来计算性能测量</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="6ba0" class="md me it mw b gy na nb l nc nd">rmse2 = sqrt(mean_squared_error(trainY, trainPredict))</span><span id="a02c" class="md me it mw b gy ov nb l nc nd">rmse = sqrt(mean_squared_error(inv_y, testPredict))</span></pre><p id="7c20" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">训练集和测试预测集被连接在一起</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="1e83" class="md me it mw b gy na nb l nc nd">final = np.append(trainPredict, testPredict)</span><span id="14e8" class="md me it mw b gy ov nb l nc nd">final = pd.DataFrame(data=final, columns=[‘Close’])<br/>actual = dataset.Close<br/>actual = actual.values<br/>actual = pd.DataFrame(data=actual, columns=[‘Close’])</span></pre><p id="e525" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，可视化训练和预测结果</p><pre class="ks kt ku kv gt mv mw mx my aw mz bi"><span id="360d" class="md me it mw b gy na nb l nc nd">pyplot.plot(actual.Close, ‘b’, label=’Original Set’)<br/>pyplot.plot(final.Close[0:16781], ‘r’ , label=’Training set’)</span><span id="3cb0" class="md me it mw b gy ov nb l nc nd">pyplot.plot(final.Close[16781:len(final)], ‘g’,<br/>            label=’Predicted/Test set’)</span><span id="8b52" class="md me it mw b gy ov nb l nc nd">pyplot.title(“ Bitcoin Predicted Prices”)<br/>pyplot.xlabel(‘ Time’, fontsize=12)<br/>pyplot.ylabel(‘Close Price’, fontsize=12)<br/>pyplot.legend(loc=’best’)<br/>pyplot.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f8243d9363c3c78d074ecf438aeddab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrhCk-D2GqnT0paAS-ha9Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">RNN多变量的输出。作者的照片</figcaption></figure><blockquote class="ne nf ng"><p id="e3eb" class="lh li nh lj b lk ll kd lm ln lo kg lp ni lr ls lt nj lv lw lx nk lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">结论:</em> </strong></p></blockquote><p id="17fe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我们使用历史比特币价格数据集开发了一个价格预测模型。我们使用RNN和LSTM算法来寻找价格预测。</p><p id="6e80" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae nm" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae nm" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="4388" class="pa me it bd mf pb pc pd mi pe pf pg ml ki ph kj mo kl pi km mr ko pj kp mu pk bi translated">推荐文章</h1><p id="1ef6" class="pw-post-body-paragraph lh li it lj b lk pl kd lm ln pm kg lp lq pn ls lt lu po lw lx ly pp ma mb mc im bi translated"><a class="ae nm" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae nm" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/principal-component-analysis-in-dimensionality-reduction-with-python-1a613006d531?source=friends_link&amp;sk=3ed0671fdc04ba395dd36478bcea8a55">用Python进行主成分分析降维</a> <br/> 5。<a class="ae nm" href="https://medium.com/towards-artificial-intelligence/fully-explained-k-means-clustering-with-python-e7caa573176a?source=friends_link&amp;sk=9c5c613ceb10f2d203712634f3b6fb28" rel="noopener">用Python全面讲解K-means聚类</a> <br/> 6。<a class="ae nm" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae nm" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae nm" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae nm" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>