<html>
<head>
<title>Predicting the Remaining Useful Life of Turbofan Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">涡扇发动机剩余使用寿命预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/predicting-the-remaining-useful-life-of-turbofan-engine-f38a17391cac?source=collection_archive---------0-----------------------#2021-03-22">https://pub.towardsai.net/predicting-the-remaining-useful-life-of-turbofan-engine-f38a17391cac?source=collection_archive---------0-----------------------#2021-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4692" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="155f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">NASA提供的PHM08挑战数据集的应用</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3bf07250e3d25de25f85913450c462cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKbO4je2-P1FnirBlp3oAg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者插图</figcaption></figure><p id="e7a5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">日益增长的数据量和技术进步导致机器维护策略的重大变化。监控机器状态的可能性出现了<strong class="lj jd">预测性维护</strong> (PM)。PM是在过去十年中发展起来的，其特点是使用通过<strong class="lj jd">传感器</strong>收集的机器历史时间序列数据。使用可用的数据，可以通过机器学习和深度学习方法提供有效的解决方案。预测性维护可以最大限度地减少停机时间，最大限度地延长设备寿命。</p><p id="21f7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">PM的一个关键部分是剩余使用寿命的预测<strong class="lj jd"/>(RUL)。这是什么？它是机器组件在失去功能之前执行其任务的剩余时间。它也可以定义为从当前时间到组件使用寿命结束的持续时间(可以是分钟、小时或天)。这种估计可以避免失败。事实上，在出现故障的情况下，修复受损零件的成本很高。出于这个原因，公司试图通过对设备进行定期检查来防患于未然。</p><p id="8e7f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我猜你在问自己为什么你会对预测性维护感兴趣。答案是，有各种各样的公司使用预测性维护来分析他们客户的数据，并做出允许做出决定性决策的预测。实际上，我在数据科学实习期间遇到了这个话题，我越来越意识到PM如何应用于许多环境中，例如制造业、汽车公司和飞机。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi md"><img src="../Images/685bce0634ea083f9c360e3dc4e6216a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqZq0MRtPEtI-r5nB718fA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">剩余使用寿命。作者插图。</figcaption></figure><p id="7b0c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这篇文章中，<strong class="lj jd">我将关注飞机</strong>。我将使用NASA数据仓库中的一个流行数据集，名为<a class="ae me" href="https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/#turbofan" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd"/></a>。这是2008年在第一届预测和健康管理会议上首次引入的挑战竞赛的数据集合。这是一个多变量时间序列，包含<strong class="lj jd"> 218个涡轮风扇发动机</strong>，其中每个发动机数据都有来自<strong class="lj jd"> 21个传感器</strong>的测量值。每台发动机开始正常运转，以故障告终。目标是预测组件的RUL。下面是建立预测性维护算法的步骤。如果你过去已经用不同的数据集创建了一个机器学习模型，你会发现唯一的区别是你需要一个额外的任务。<strong class="lj jd">您必须计算剩余使用寿命</strong>值，这些值需要与预测值进行比较。</p><h1 id="9ba6" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">目录:</h1><ol class=""><li id="01de" class="mx my it lj b lk mz ln na lq nb lu nc ly nd mc ne nf ng nh bi translated"><a class="ae me" href="#f7da" rel="noopener ugc nofollow"> <strong class="lj jd">导入数据</strong> </a></li><li id="1335" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc ne nf ng nh bi translated"><a class="ae me" href="#8bf1" rel="noopener ugc nofollow"> <strong class="lj jd">计算剩余使用寿命</strong> </a></li><li id="bd7c" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc ne nf ng nh bi translated"><a class="ae me" href="#74cf" rel="noopener ugc nofollow"> <strong class="lj jd">特征选择</strong> </a></li><li id="4157" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc ne nf ng nh bi translated"><a class="ae me" href="#297c" rel="noopener ugc nofollow"> <strong class="lj jd">最大最小归一化</strong> </a></li><li id="08e9" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc ne nf ng nh bi translated"><a class="ae me" href="#198f" rel="noopener ugc nofollow"> <strong class="lj jd">预测模型</strong> </a></li></ol></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="f7da" class="mf mg it bd mh mi nu mk ml mm nv mo mp ki nw kj mr kl nx km mt ko ny kp mv mw bi translated">1.输入数据</h1><p id="e2ed" class="pw-post-body-paragraph lh li it lj b lk mz kd lm ln na kg lp lq nz ls lt lu oa lw lx ly ob ma mb mc im bi translated">让我们导入以下步骤中需要的库:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5282" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦库被导入，我们就可以加载数据集PHM08。数据集在<a class="ae me" href="https://www.kaggle.com/behrad3d/nasa-cmaps" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>中可用，已经分为训练集和测试集，由26列组成:</p><ul class=""><li id="e3be" class="mx my it lj b lk ll ln lo lq oe lu of ly og mc oh nf ng nh bi translated">单位数</li><li id="38cb" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc oh nf ng nh bi translated">周期时间</li><li id="09dc" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc oh nf ng nh bi translated">操作设置1，2，3</li><li id="3b76" class="mx my it lj b lk ni ln nj lq nk lu nl ly nm mc oh nf ng nh bi translated">传感器测量值1，…，21</li></ul><p id="2b15" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每行代表一个操作周期中拍摄的快照。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="226e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在创建了包含所有列名的向量之后，我们可以导入训练集，该训练集以文本文件的形式提供，列之间用空格分隔。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/4add961f1e03cbeb7feb821f7be483f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIS0yF9sRquD8XDDzSzZlg.png"/></div></div></figure><p id="505a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从输出中，我们可以观察到<strong class="lj jd">有许多行具有相同的单元号</strong>，称为unit_id。例如，unit_id=1的行表示特定发动机的生命周期，直到在变量time_cycle引用的时间内观察到的降级状态。<strong class="lj jd">一般来说，每台发动机的最后一个循环代表故障点。</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/89261af385ecdec271538b1b89e04baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYDg4-o4NJF1U-1mzY9s7Q.png"/></div></div></figure><p id="f333" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当time_cycle等于1时，引擎总是健康的，而在其他时间周期中，引擎的性能会变得更差。然后，unit_id=1的发动机在时间周期192失效。所有训练集中总共有100个引擎。此外，已经可以观察到<strong class="lj jd">一些传感器测量值随着时间的推移而增加</strong>，这将有助于构建预测算法，而其他测量值保持不变或变化很小。</p><p id="331b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们对测试集和测试集的RUL值做同样的事情。测试数据与训练数据具有相似的结构。<strong class="lj jd">唯一的区别是，我们不知道故障何时发生。</strong>RUL _ FD 001 . txt仅提供每个发动机最后一个时间周期的RUL值。在unit_id等于1的引擎的情况下，它可以在发生故障之前运行其他112个时间周期。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/4a7ebbaa96c232a58535a73242904ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2aXXf3lkfxRQT6bkWrH2w.png"/></div></div></figure><p id="3748" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">定型集和测试集都包含特征变量，但缺少目标变量。我们需要它来完成我们的监督任务，以了解预测值与实际值之间的差距。</p><h1 id="8bf1" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">2.计算剩余使用寿命</h1><p id="0c80" class="pw-post-body-paragraph lh li it lj b lk mz kd lm ln na kg lp lq nz ls lt lu oa lw lx ly ob ma mb mc im bi translated">计算剩余使用寿命的方法有很多。一种方法是首先获得每个单元id的最大时间周期，然后进行以下差分:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/a8cef495d72dc3e62f2cef03782c4a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eNl6ZwA2UP6rUubqFZ9DVA.png"/></div></div></figure><p id="aa2f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了找到训练数据的每个单元id的最大时间周期，我们需要按照单元id对数据进行分组，并按照时间周期进行过滤。然后，我们创建一个由两列组成的数据帧，其中最大时间周期对应于一个唯一的单元id。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/4ddd707485e061846c0bc69ee4c64b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhHd602qsZ6yNzoLo9DHNA.png"/></div></div></figure><p id="9336" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们合并最后获得的数据帧和训练集之后。这样，我们可以将RUL作为目标变量。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/477809b88fb1ce92bc44ac9c24d85533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcsZUvt60CJUwpknIJq0hA.png"/></div></div></figure><p id="e520" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从输出中，我们可以看到单位id等于1的数据的RUL随着时间的推移而减小。RUL越小，失败的风险越高。当RUL为零时，意味着发动机出现故障。</p><p id="2e1b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦我们为训练数据计算了RUL，我们也需要为测试数据添加<strong class="lj jd"> RUL列。由于<strong class="lj jd"> RUL_FD001.txt仅提供每个发动机</strong>最后一个时间周期的RUL值，因此相应测试集的测试数据和RUL的大小不同。因此，我们的想法是将RUL值分配给每个单元id的最后一行，并在上面的每一行中增加一个值，直到到达该特定引擎的第一个时间周期。</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/27596f891e64878733bf35710b5b99ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63YMKvT6-5mYqVrbbhtt1g.png"/></div></div></figure><p id="4462" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要检查计算是否正确，最好将RUL真值与单位id等于某个数字的测试数据进行比较:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/978992dedf3e266bf1df9c00c2de4879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4Y50gvyMumyOuxnfijZiA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">y_true和test_df的比较</figcaption></figure><p id="616e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本例中，查看y_true数据帧，对于单位id=5的引擎的最后一个时间周期，RUL等于91。在更新的测试数据中，我们在特定发动机的最后一行中有相同的值，而在上面的行中，我们每次增加一个单位的RUL。</p><h1 id="74cf" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">3.特征选择</h1><p id="01fe" class="pw-post-body-paragraph lh li it lj b lk mz kd lm ln na kg lp lq nz ls lt lu oa lw lx ly ob ma mb mc im bi translated">为了快速显示训练集中的所有特征，我们可以绘制每个变量的直方图:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/305ec762e9587a7fea35c58eda5ec763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bk_lSlHO8PPA9RzeaCxWcQ.png"/></div></div></figure><p id="b2eb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从这个输出中，我们可以观察到有许多正态分布的特性。其他一些变量是右偏或左偏的。此外，很明显，操作设置3和传感器测量值1、5、6、10、16、18、19总是具有相同的值，这意味着它们不是重要的变量。检查最重要变量的另一种方法是查看相关矩阵:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/edcdd942f6dbb86ac372fd9e4bf4c3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McQZUGkBXbaL7RSHkG2nIg.png"/></div></div></figure><p id="0cf7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从相关矩阵中，我们可以观察到，有些变量与其他变量的系数始终为<strong class="lj jd">:操作设置3、传感器测量值1、5、10、16、18和19。这些NAN值可以解释为变量之间缺乏相关性。例如，时间周期和传感器测量值1之间的NAN相关系数意味着当时间周期改变时，sm 1不变。这意味着我们应该从训练集和测试集中移除这些变量，从而证实之前通过查看直方图获得的发现。为了突出这些方面，我们还可以绘制RUL与特征变量的关系。</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/ad3c173829663e7b6dc703cc017ea52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-8h6MtvOiMZHoZxHDPO3lw.png"/></div></div></figure><p id="fd50" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以上，我只展示了获得的部分情节。如果您看一下这些图形工具，很明显，当剩余使用寿命发生变化时，一些传感器测量值并没有显示出明显的变化。然后，这些传感器测量将不会在模型中被选择。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="297c" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">4.最大最小归一化</h1><p id="2127" class="pw-post-body-paragraph lh li it lj b lk mz kd lm ln na kg lp lq nz ls lt lu oa lw lx ly ob ma mb mc im bi translated">一旦我们只选择了数据集的重要特征，我们就可以对数据进行规范化。这一步对于避免依赖测量单位的选择很重要。事实上，特征变量具有不同的取值范围，可能会降低模型的性能。一种方法是将数据转换到-1和1之间的较小范围内。所应用的技术是sklearn模块中提供的最大-最小归一化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/3a0be1ec0f93c73495e01efcad14f32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxBWNrqAZU7ZmeVv96gQPw.png"/></div></div></figure><p id="a45b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在最大-最小归一化之后，我们可以将训练和测试集分成特征和目标变量。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="198f" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">5.预测模型</h1><p id="0401" class="pw-post-body-paragraph lh li it lj b lk mz kd lm ln na kg lp lq nz ls lt lu oa lw lx ly ob ma mb mc im bi translated">经过许多步骤，我们终于可以在训练数据上建立一个模型。选择的模型是梯度推进，这是一个决策树的集合。应用它很有趣，因为它的特点是强大的性能和高度的可解释性。让我们导入库:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a03a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们可以在训练集上训练模型，并在测试集上评估它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/6159e8234265a3920e8f9309b977aa83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ci5vBroFXchkm_cs3ksWw.png"/></div></div></figure><p id="8a4c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该模型的性能似乎相当好，即使在训练集和测试集上的性能之间存在差异。解释模型性能的另一个工具是“特征重要性”，这是表示每个特征变量如何对模型做出贡献的分数。因此，我们可以绘制特征重要性:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ce59877a8350f7d709f1110be1bab9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*Q8M7HoVPAhLeppIBrodNZA.png"/></div></figure><p id="c24a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对模型贡献最大的特征是time_cycle。其他重要变量是传感器测量值11、4、9，而其余特征在模型中不太相关。很明显，操作设置1和2在模型中并不重要，最好尝试将它们从训练集和测试集中删除。</p><p id="8098" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一种使模型表现更加公正的方法是进行k倍交叉验证。想法是将数据集分成k个部分，k-1个用于训练，剩下的一个用于测试，以避免过度拟合。事实上，肯定有数据集的部分不具有代表性，并可能导致误解的结果。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/9cfb1e8830065f843c73de7232fbd653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-iAtvB-x5bMVDRb3xm_bQ.png"/></div></div></figure><p id="abd7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">平均均方根误差似乎比之前获得的结果(60.4)好得多。然后，我们通过对数据集进行更多次的训练和测试，获得了更好的性能。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="266b" class="mf mg it bd mh mi nu mk ml mm nv mo mp ki nw kj mr kl nx km mt ko ny kp mv mw bi translated">最终想法:</h1><p id="5433" class="pw-post-body-paragraph lh li it lj b lk mz kd lm ln na kg lp lq nz ls lt lu oa lw lx ly ob ma mb mc im bi translated">恭喜你！现在您对预测性维护的真正含义有了一个概念。一个实际的例子是理解这些概念如何在现实中应用的唯一方法。</p><p id="8c0c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">困难的任务是了解如何管理数据集的许多要素，以及必须选择或移除哪些要素。有许多可能的解决方案，而不是只有一个。很多其他的机器学习和深度学习模型都可以用在这个回归问题上。</p><p id="57d0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里的GitHub代码是<a class="ae me" href="https://github.com/eugeniaring/PHM08-Challenge-Data-Set/blob/main/nasa-2%20(4).ipynb" rel="noopener ugc nofollow" target="_blank"/>。感谢阅读。祝您愉快！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="7f49" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">你喜欢我的文章吗？</strong> <a class="ae me" href="https://eugenia-anello.medium.com/membership" rel="noopener"> <strong class="lj jd"> <em class="ox">成为会员</em> </strong> </a> <strong class="lj jd"> <em class="ox">每天无限获取数据科学新帖！这是一种间接的支持我的方式，不会给你带来任何额外的费用。如果您已经是会员，</em> </strong> <a class="ae me" href="https://eugenia-anello.medium.com/subscribe" rel="noopener"> <strong class="lj jd"> <em class="ox">订阅</em> </strong> </a> <strong class="lj jd"> <em class="ox">每当我发布新的数据科学和python指南时，您都可以收到电子邮件！</em> </strong></p></div></div>    
</body>
</html>