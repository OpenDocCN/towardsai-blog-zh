<html>
<head>
<title>Can Rasa’s Action Server Do Asynchronous Calls?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rasa的动作服务器可以做异步调用吗？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/can-rasas-action-server-do-asynchronous-calls-48c45f2dceb0?source=collection_archive---------2-----------------------#2021-09-22">https://pub.towardsai.net/can-rasas-action-server-do-asynchronous-calls-48c45f2dceb0?source=collection_archive---------2-----------------------#2021-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0a86" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/fc86054e2eaf30011a65a42a3f59e92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*en7PMz0AhNpwKWKLbA3Ncg.png"/></div></div></figure><h1 id="7d2b" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">介绍</h1><p id="598a" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">在本文中，我们将尝试回答以下关于Rasa的<a class="ae mg" href="https://rasa.com/docs/action-server/" rel="noopener ugc nofollow" target="_blank">动作服务器</a>的问题:</p><blockquote class="mh mi mj"><p id="8fc9" class="li lj mk lk b ll ml ln lo lp mm lr ls mn mo lv lw mp mq lz ma mr ms md me mf im bi translated">假设我们有一个自定义操作，它将调用后端服务，这可能需要一段时间才能完成，例如检索客户过去的购买记录，检查预约的可用时间段，调用机器学习模型进行预测，等等。</p><p id="1ad0" class="li lj mk lk b ll ml ln lo lp mm lr ls mn mo lv lw mp mq lz ma mr ms md me mf im bi translated">在处理长时间运行的自定义操作时，操作服务器会被阻止为其他请求提供服务吗？</p></blockquote><p id="603e" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">我假设读者熟悉Python 中<a class="ae mg" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">异步函数调用的基础知识。</a></p><p id="ce8e" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">重现本文中描述的结果的代码可以在<a class="ae mg" href="https://github.com/hsm207/rasa_async_sdk" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="9b34" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">试图回答</h1><p id="7a1b" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">对上一节提出的问题的一个常见回答是:</p><blockquote class="mh mi mj"><p id="e712" class="li lj mk lk b ll ml ln lo lp mm lr ls mn mo lv lw mp mq lz ma mr ms md me mf im bi translated">动作服务器基于<a class="ae mg" href="https://sanic.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Sanic </a>。</p><p id="a84f" class="li lj mk lk b ll ml ln lo lp mm lr ls mn mo lv lw mp mq lz ma mr ms md me mf im bi translated">由于Sanic可以<a class="ae mg" href="https://sanicframework.org/en/guide/basics/handlers.html#a-word-about-async" rel="noopener ugc nofollow" target="_blank">同时处理许多请求</a>，这意味着动作服务器也可以同时服务许多请求。</p></blockquote><p id="1cee" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">因此，人们希望这个定制动作不会阻塞动作服务器:</p><figure class="mu mv mw mx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi mt"><img src="../Images/6633fd48abe90de2e55c40ee36f36713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzThl682z8sDT4cLp2Vkgg.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">图1:一个不希望阻塞动作服务器的自定义动作</figcaption></figure><p id="d57b" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">让我们做一些测试来验证这个答案的有效性。</p><h1 id="e8b2" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">实验</h1><h2 id="4384" class="nc kl it bd km nd ne dn kq nf ng dp ku lt nh ni ky lx nj nk lc mb nl nm lg iz bi translated">实验装置</h2><p id="b9ae" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我们将在16核机器上运行我们的实验。动作服务器将仅使用<strong class="lk jd"> 1个工作线程</strong>启动。</p><p id="9f54" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">在实验开始时，我们将对动作服务器进行16次并行调用，以运行相同的自定义动作。我们将计算所有呼叫完成后经过的时间。</p><h2 id="897e" class="nc kl it bd km nd ne dn kq nf ng dp ku lt nh ni ky lx nj nk lc mb nl nm lg iz bi translated">定时动作_长时间_后端_调用_同步</h2><p id="c271" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">由于<code class="fe nn no np nq b">action_long_backend_call_sync</code>自定义操作需要5秒钟才能完成，我们预计所有16个呼叫将在5秒钟左右完成。</p><p id="b3bc" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">结果如下:</p><figure class="mu mv mw mx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nr"><img src="../Images/ea058ad143855b4196474f10071d6c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8f-k58pfdA8MlaixBR3YA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">图2:16次并行调用action_long_backend_call_sync的结果</figcaption></figure><p id="0908" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">16次调用，每次5秒，总计80秒，因此图2中的结果表明动作服务器正在串行执行请求，即只有在前一个请求完成后才执行下一个请求。</p><p id="02a7" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">来自操作服务器的日志证实了这一点:</p><figure class="mu mv mw mx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ns"><img src="../Images/ea7b29ad981a401ddccc4a3329a1cbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGB4pvn-6wbJBjs24yLelw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">图3:服务action_long_backend_call_sync请求时的日志</figcaption></figure><p id="543d" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">图3示出了例如来自<code class="fe nn no np nq b">user_8</code>的新请求仅在例如来自<code class="fe nn no np nq b">user_9</code>的先前请求完成之后才被处理。接收到请求和完成请求之间的时间正好是5秒。</p><h2 id="9c7d" class="nc kl it bd km nd ne dn kq nf ng dp ku lt nh ni ky lx nj nk lc mb nl nm lg iz bi translated">编写异步自定义操作的正确方法</h2><p id="a8cd" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">下面是我们如何重写图1中的自定义动作，以便它不会阻塞动作服务器:</p><figure class="mu mv mw mx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nt"><img src="../Images/16370f13998abe6840523bb3585d98c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pOqNecBDbyqmt8RkIY0qQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">图4:图1中自定义动作的异步版本</figcaption></figure><p id="1ed0" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">注意，我们已经调用了<code class="fe nn no np nq b">sleep()</code> async(第51行),并将定制动作的<code class="fe nn no np nq b">run()</code>方法定义为异步(第41行)。</p><p id="5f06" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">以下是此自定义操作的计时结果:</p><figure class="mu mv mw mx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nu"><img src="../Images/987bdd223e0671ee2f0fde5bd2d6313f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUPh85rjJVTTOyyf4WHTZQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">图5:对action_long_backend_call_async的16次并行调用的结果</figcaption></figure><p id="b4ed" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">不出所料，所有通话都在5秒左右完成。</p><p id="37ce" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">日志还确认没有调用阻塞操作服务器:</p><figure class="mu mv mw mx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nv"><img src="../Images/51ab00161dd0eaf9b367b86fa8e21947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaZHcBEIXTSZm1PofjE95A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">图6:服务action_long_backend_call_async请求时的日志</figcaption></figure><p id="a72f" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">图6示出了动作服务器能够接受例如来自<code class="fe nn no np nq b">user_2</code>的其他请求，而例如来自<code class="fe nn no np nq b">user_1</code>的当前请求处于休眠状态。</p><h1 id="28d8" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">正确答案</h1><p id="e5ff" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">上一节中的实验表明，为了让自定义操作不阻止操作服务器为其他请求提供服务，我们需要:</p><ol class=""><li id="3e11" class="nw nx it lk b ll ml lp mm lt ny lx nz mb oa mf ob oc od oe bi translated">将自定义动作的<code class="fe nn no np nq b">run()</code>方法声明为<code class="fe nn no np nq b">async</code>，并且</li><li id="bd26" class="nw nx it lk b ll of lp og lt oh lx oi mb oj mf ob oc od oe bi translated">确保<code class="fe nn no np nq b">run()</code>方法的主体不调用任何阻塞函数</li></ol><p id="7562" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">第二点需要更多的解释。</p><p id="6117" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">即使我们将它的<code class="fe nn no np nq b">run()</code>方法声明为<code class="fe nn no np nq b">async</code>，对<code class="fe nn no np nq b">action_long_backend_call_sync</code>的16个并行调用仍然需要大约80秒才能完成。这是因为该方法调用了<code class="fe nn no np nq b">sleep()</code>，不幸的是这是一个阻塞调用。在这种情况下，解决方案很简单，因为在<code class="fe nn no np nq b">asyncio</code>库中有一个<code class="fe nn no np nq b">sleep()</code>的非阻塞版本。</p><h1 id="3ea5" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">实用技巧</h1><p id="503c" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">实际上，您的定制操作可能会使用<a class="ae mg" href="https://docs.python-requests.org/en/latest/" rel="noopener ugc nofollow" target="_blank">请求</a>库调用外部后端服务。如果您切换到<a class="ae mg" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> aiohttp </a>库来发出这些请求，您将从您的动作服务器获得更好的吞吐量。</p><p id="8615" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">当然，如果您的自定义动作实际上是在动作服务器的工作线程上受CPU限制的，那么这不会有什么不同。</p><h1 id="a925" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="df46" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">本文解释了如何编写一个I/O绑定的自定义操作，以便它不会阻止操作服务器为其他请求提供服务。</p><p id="9ee5" class="pw-post-body-paragraph li lj it lk b ll ml ln lo lp mm lr ls lt mo lv lw lx mq lz ma mb ms md me mf im bi translated">我希望你发现这很有见地。</p></div></div>    
</body>
</html>