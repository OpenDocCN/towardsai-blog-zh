<html>
<head>
<title>My Notes On Profiling A Python Microservice Using py-spy And VS Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我关于使用py-spy和VS代码剖析Python微服务的笔记</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/my-notes-on-profiling-a-python-microservice-using-py-spy-and-vs-code-bee5c9d98891?source=collection_archive---------2-----------------------#2022-01-31">https://pub.towardsai.net/my-notes-on-profiling-a-python-microservice-using-py-spy-and-vs-code-bee5c9d98891?source=collection_archive---------2-----------------------#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5f67" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/software-engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/31c26fceeb785f07734b5a2f0cdcea42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqsywZX2In-xn8k7NxMlPA.png"/></div></div></figure><h1 id="02a1" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">介绍</h1><p id="cd6e" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">本文是我上一篇文章[1]的后续，在那篇文章中，我介绍了使用VS代码分析python代码的工作流程。我们想要分析的应用程序是一个聊天机器人，这里使用的主要工具是<a class="ae mg" href="https://docs.python.org/3.8/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>。让我们称这种方法为cProfile方法。</p><p id="5ff2" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">现在，这篇文章将展示如何使用<a class="ae mg" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank"> py-spy </a>做同样的事情。</p><p id="9f26" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">为什么要再写一篇讨论同样问题的文章呢？因为正如我们将看到的，py-spy方法非常不同，足以保证它自己的解释，并且可能是快速确定性能问题原因的首选方法。</p><p id="ad5a" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">重现本文中描述的结果的代码在这个<a class="ae mg" href="https://github.com/hsm207/python_profile" rel="noopener ugc nofollow" target="_blank"> repo </a>中。</p><p id="4eb6" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">我们将从快速概述我们想要解决的问题开始。然后，我们将介绍使用py-spy来分析代码的步骤，并在最后讨论这种方法与cProfile方法相比的优势。</p><h1 id="b857" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">问题陈述</h1><p id="81cf" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">问题与[1]中的相同。</p><p id="2925" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">总结一下，你收到了一个错误报告，说你的聊天机器人每次处理一条来自用户的消息时都有不合理的高CPU负载。</p><p id="c97a" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">请记住一个重要的事实:</p><p id="52ba" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">您的聊天机器人是按照微服务架构构建的，因此很明显，问题出在处理用户消息的组件上，而不是其他地方，例如后端调用、数据库查询等。</p><h1 id="a79b" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">解决办法</h1><h2 id="0657" class="mm kl it bd km mn mo dn kq mp mq dp ku lt mr ms ky lx mt mu lc mb mv mw lg iz bi translated">概观</h2><p id="7ac8" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">以下是使用py-spy和VS代码分析有问题组件的主要步骤:</p><ol class=""><li id="0f1d" class="mx my it lk b ll mh lp mi lt mz lx na mb nb mf nc nd ne nf bi translated">使用VS代码在容器中部署组件</li><li id="db79" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated">重现问题</li><li id="c3a1" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated">确定处理请求时哪个(哪些)功能消耗的时间最多</li><li id="624a" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated">找出函数花费很长时间的原因</li><li id="0482" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated">尝试各种修复[可选]</li></ol><h2 id="3079" class="mm kl it bd km mn mo dn kq mp mq dp ku lt mr ms ky lx mt mu lc mb mv mw lg iz bi translated">步骤1使用VS代码在容器中部署组件</h2><p id="b0b0" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">和以前一样，我们将使用VS代码创建一个基于<code class="fe nl nm nn no b">rasa/rasa:2.8.22-full</code>图像的容器。我们还需要添加任何必要的设置来重新创建bug报告中描述的bot。</p><p id="34c0" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">一旦进入容器，我们将启动一个服务器来托管机器人(使用<code class="fe nl nm nn no b">rasa run</code>)。</p><p id="d13c" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">注意，为了让py-spy工作，容器需要使用<code class="fe nl nm nn no b">SYS_PTRACE</code>参数运行，因此我们需要将它添加到<code class="fe nl nm nn no b">devcontainer.json</code>配置中:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi np"><img src="../Images/f8a35922b4bc673341df6decbf19e769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yE_0J-5Q_MHien0kDIDDdg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图1:使py-spy在容器中工作的额外容器配置</figcaption></figure><h2 id="7b7c" class="mm kl it bd km mn mo dn kq mp mq dp ku lt mr ms ky lx mt mu lc mb mv mw lg iz bi translated">重现问题</h2><p id="dff5" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我们可以使用<code class="fe nl nm nn no b">curl</code>向服务器发送一个请求，并观察CPU负载是否出现峰值。然而，在shell中键入有效负载是很麻烦的。幸运的是，VS代码中有一个扩展使得发送REST请求变得容易:<a class="ae mg" href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" rel="noopener ugc nofollow" target="_blank"> REST客户端</a></p><p id="62ef" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">使用这个扩展，我们可以将请求的有效负载写在一个文件中，并通过单击一个按钮将它发送到服务器:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ny"><img src="../Images/4cd6d996743f36401056f3de7ba78669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZKsThizZdVkqvYl3mtpcAQ.gif"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图2:尝试重现问题</figcaption></figure><p id="19bb" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">图1向服务器发送了3次请求。请注意，每个请求需要大约1500毫秒才能完成，并且总是伴随着巨大的CPU峰值。</p><p id="3ce9" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">因此，我们成功地重现了错误报告中描述的问题。</p><h2 id="8c60" class="mm kl it bd km mn mo dn kq mp mq dp ku lt mr ms ky lx mt mu lc mb mv mw lg iz bi translated">步骤3确定在处理请求时哪个(哪些)功能消耗的时间最多</h2><p id="2611" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">py-spy的<code class="fe nl nm nn no b">top</code>命令可用于获得处理请求时哪个函数消耗时间最多的高级概述。不过，在这样做之前，我们需要知道进程的id。</p><p id="dc3e" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">我们可以使用<code class="fe nl nm nn no b">pgrep</code>命令找到服务器的进程id:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nz"><img src="../Images/120bc788f6a3e48d5ba49db83b1302d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZM5B9oAK9vNOJrQW14D8w.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图3:使用pgrep计算rasa服务器的pid</figcaption></figure><p id="3adc" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">图2显示<code class="fe nl nm nn no b">11463</code>是我们想要的进程id，因为这是用于启动服务器的命令。</p><p id="1efe" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">运行<code class="fe nl nm nn no b">py-spy top --pid 11463</code>给出:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oa"><img src="../Images/dc86d5288fba2b5921dcd10e320c04a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBVDsWJEPt1KpfcIiqa7hg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图4:启动时的py-spy top</figcaption></figure><p id="34d5" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">这是向服务器发送几个请求后的输出:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ob"><img src="../Images/3ae6b1985f12e9cdd9911e9d0363ce2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXLoxnPcxIu2PjXIPkjmag.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图5:向服务器发送几个请求后的py-spy top</figcaption></figure><p id="ba4b" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">我们看到最耗时的函数是来自<code class="fe nl nm nn no b">json</code>库的<code class="fe nl nm nn no b">raw_decode</code>,然后是来自<code class="fe nl nm nn no b">rasa</code>库的<code class="fe nl nm nn no b">_is_rule_applicable</code>,这是我们正在分析的库。</p><p id="a4c1" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">我们来看看这两个功能有没有关系。</p><h2 id="e665" class="mm kl it bd km mn mo dn kq mp mq dp ku lt mr ms ky lx mt mu lc mb mv mw lg iz bi translated">第四步，找出函数花费时间长的原因</h2><p id="1665" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">py-spy的<code class="fe nl nm nn no b">record</code>命令可以用来可视化所有函数调用之间的关系:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oc"><img src="../Images/2c27e4676a840d6d57b3a73834111afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bmxtedhfuTRWiUBgkvpjBA.gif"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图6:构建火焰图</figcaption></figure><p id="026c" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">图6的结果是一个名为<code class="fe nl nm nn no b">profile.svg</code>的svg文件中的火焰图，如下所示:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi od"><img src="../Images/fb9e4317118af1908a7229221ac5998d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVn6vepy3jmz31zcpKtVmA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图7:来自图6的火焰图</figcaption></figure><p id="dc0f" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">每个矩形是一个函数的名称，它的长度代表在该函数中花费的时间。[2]是学习如何解释火焰图的一个很好的资源。</p><p id="556c" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">显而易见的是:</p><ol class=""><li id="372b" class="mx my it lk b ll mh lp mi lt mz lx na mb nb mf nc nd ne nf bi translated"><code class="fe nl nm nn no b">raw_decode</code>是最耗时的功能</li><li id="b5ba" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated"><code class="fe nl nm nn no b">raw_decode</code>在<code class="fe nl nm nn no b">_predict_action_probabilities</code>函数中的两个不同位置被调用两次</li><li id="b402" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated"><code class="fe nl nm nn no b">_is_rule_applicable</code>依赖于<code class="fe nl nm nn no b">raw_decode</code>无论它是什么，前一个函数应该</li><li id="b414" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf nc nd ne nf bi translated">在调用<code class="fe nl nm nn no b">raw_decode</code>之前，rasa库中的最后一个函数是<code class="fe nl nm nn no b">_rule_key_to_state</code></li></ol><p id="ca87" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">最后一点值得注意，因为我们不能修复我们不维护的库。</p><p id="27c3" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">仔细查看来自<code class="fe nl nm nn no b">_predict_action_probabilities</code>的函数调用:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oe"><img src="../Images/ca7243680aea20b5075750009b886282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJfwcuhrTUjxIf9RJLJMhg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图8:来自<code class="fe nl nm nn no b">_predict_action_probabilities onwards</code>的函数调用</figcaption></figure><p id="a12c" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">注意，有一个lambda函数调用了<code class="fe nl nm nn no b">is_rule_applicable</code>。这基本上是代码耗时部分的起点，所以研究这个lambda做什么会很有趣:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi of"><img src="../Images/98fb3396207b0800814b6705f8174252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3UqsFobnT2VtRXqT3TCAA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图lambda函数的细节(第895行)</figcaption></figure><p id="106b" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">根据图9，我们可以得出高CPU负载的原因是:</p><ul class=""><li id="2a6d" class="mx my it lk b ll mh lp mi lt mz lx na mb nb mf og nd ne nf bi translated"><code class="fe nl nm nn no b">_is_rule_applicable</code>是一个计算密集型函数，或者</li><li id="0893" class="mx my it lk b ll ng lp nh lt ni lx nj mb nk mf og nd ne nf bi translated"><code class="fe nl nm nn no b">possible_keys</code>是一个非常大的集合，所以使用<code class="fe nl nm nn no b">filter</code>函数循环遍历它会消耗大量的CPU周期</li></ul><p id="010b" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">或者两者都是真的？</p><p id="98f4" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">如果不知道每个函数被调用的次数，很难判断。无论如何，我们已经隔离了性能问题的来源，并收集了足够的信息传递给开发人员进行修复。</p><h2 id="1579" class="mm kl it bd km mn mo dn kq mp mq dp ku lt mr ms ky lx mt mu lc mb mv mw lg iz bi translated">尝试各种修复方法[可选]</h2><p id="382d" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">由于<code class="fe nl nm nn no b">_rule_key_to_state</code>是在代码中最耗时的部分调用的最后一个与rasa库相关的函数，如果我们想找到一个快速解决方法，检查它的实现是一个很好的起点:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oh"><img src="../Images/16e897d1ad79861e4e2750d62922b2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7A8Fh_lfstxvULrNQ_Z0gg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图10: <code class="fe nl nm nn no b">_rule_key_to_state implementation</code></figcaption></figure><p id="b314" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">在这种情况下，我们真的很幸运。这个函数只做一件事(使用<code class="fe nl nm nn no b">json</code>库将字符串中的JSON对象解码成字典),并附带一个缓存来存储之前的结果。</p><p id="071a" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">因此，增加这个缓存的大小应该会减少CPU的负载，并增加响应时间，但代价是消耗更多的RAM。这是我们将<code class="fe nl nm nn no b">maxsize</code>设置为10，000时发生的情况:</p><figure class="nq nr ns nt gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oi"><img src="../Images/39ce797e335a426c33dfd33e0797e9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5h-Jo570k4QpnodHiOmkqw.gif"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">图maxsize = 10000时的CPU负载和响应时间</figcaption></figure><p id="5645" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">当<code class="fe nl nm nn no b">maxsize</code>设置为10，000时，只有第一个请求会导致CPU负载峰值。后续请求的负载可以忽略不计，并且在100毫秒内完成。</p><h1 id="3832" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">间谍方法的好处</h1><p id="96e9" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">我认为在微服务中使用py-spy来分析Python代码的主要好处是设置起来既快又容易。先决条件只是部署应用程序并找出它的进程id。一旦完成，我们就可以像最终用户一样与应用程序进行交互，但要打开py-spy来调查性能问题。</p><p id="8634" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">此外，如果发生性能问题的环境不容易重现，那么我们可以登录到bug报告者环境中的容器，使用py-spy进行分析。事实上，我们可以告诉bug报告者从<code class="fe nl nm nn no b">py-spy top</code>和<code class="fe nl nm nn no b">py-spy record</code>那里收集信息，并与我们分享结果。对于担任支持工程师角色的人来说，这是一个很好的选择，他们所支持的应用程序没有足够的工具来诊断问题。</p><h1 id="dcb5" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="5458" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">本文展示了我如何使用py-spy和VS代码来诊断python微服务中的性能问题。它还展示了如何使用火焰图来快速确定性能瓶颈，以便进一步调查。</p><p id="07b3" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">我希望你已经发现这是有用的。</p><h1 id="3307" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">参考</h1><p id="9794" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">[1] <a class="ae mg" rel="noopener ugc nofollow" target="_blank" href="/how-i-profile-python-code-using-vs-code-714d0ba71b6d">我使用VS代码剖析Python代码的工作流程</a>。____ .2022</p><p id="f6c7" class="pw-post-body-paragraph li lj it lk b ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf im bi translated">【2】<a class="ae mg" href="https://www.youtube.com/watch?v=D53T1Ejig1Q" rel="noopener ugc nofollow" target="_blank">USENIX ATC’17:用火焰图可视化表演</a>。布兰登·格雷格。2017</p></div></div>    
</body>
</html>