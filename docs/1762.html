<html>
<head>
<title>GAMs and Smoothing Splines (Part-2) — Tensor Product Splines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GAMs和光滑样条(第二部分)——张量积样条</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/gams-and-smoothing-splines-part-2-tensor-product-splines-97928f226a2c?source=collection_archive---------1-----------------------#2021-04-15">https://pub.towardsai.net/gams-and-smoothing-splines-part-2-tensor-product-splines-97928f226a2c?source=collection_archive---------1-----------------------#2021-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4f6d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/statistics" rel="noopener ugc nofollow" target="_blank">统计数据</a></h2><div class=""/><p id="8826" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本文中，我将把1D样条平滑的概念扩展到称为张量积平滑的高阶维函数逼近。如果你没有读过<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa">第一部，</a>请读一读。</p><p id="ee27" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这篇文章主要分为两部分:</p><ol class=""><li id="6902" class="ky kz it kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">张量积样条</li><li id="3919" class="ky kz it kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">在人工数据集上使用GAMs的2D张量插值</li></ol><h1 id="9be5" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">张量积样条；</h1><p id="1a21" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw im bi translated"><strong class="kb jd">张量:</strong></p><p id="c489" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">张量是1D阵列向更高维度的推广，这就是为什么它们被称为多维阵列。</p><p id="8425" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">张量积:</strong></p><p id="e7b9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">假设我们有V，一个n维向量，W，一个m维向量。在那种情况下，张量积V⊗W定义了m*n维的向量空间，其基跨越V_basis和W_basis的积(相当于外积，kronecker积)。</p><p id="00b1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">张量积在不同领域有许多应用，从量子物理到深度学习中的张量乘法，并有不同的解释方式。</p><p id="e52c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">但是在这篇文章中，我想提出曲线间张量积的观点，以及产生超曲面的张量积。</p><p id="be33" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们考虑绘制如下的两条函数曲线x1和x2(例如高斯曲线):</p><div class="mp mq mr ms gt ab cb"><figure class="mt mu mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><img src="../Images/8cd346f13d6e689c8bc0f73a1b215642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*O49wNpvBi0mjJqIjuD_E4g.png"/></div></figure><figure class="mt mu mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><img src="../Images/d818fdfd24f6d843f93b5942998c20ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*hHjqDqXkc85jupjHLpysiw.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk nk di nl nm translated">来源—作者提供的图片</figcaption></figure></div><p id="656d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">得到的张量积-&gt; x1⊗ x2(对于2D情况，这等同于外积)将是跨越x1和x2的基的多元函数。下图可视化</p><div class="mp mq mr ms gt ab cb"><figure class="mt mu mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><img src="../Images/df359be3088af8a613175df241eff806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*6xl29dnBmx9mHVm7Pa1oJA.png"/></div></figure><figure class="mt mu mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><img src="../Images/3026fc3e29f182c3c9cabcc06be12c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yqQxxrh9mBFiuupkaQHZEg.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk nk di nl nm translated">来源—作者提供的图片。第一个是2D等高线图，第二个是相同的三维可视化。</figcaption></figure></div><p id="19a8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我想在这里接受的主要思想是两条一维曲线的张量积代表一个二维的超空间。</p><h2 id="04b5" class="nn ln it bd lo no np dn ls nq nr dp lw kk ns nt ma ko nu nv me ks nw nx mi iz bi translated">张量积样条简介；</h2><p id="2587" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw im bi translated">在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa">第1部分中，</a>你对样条是什么以及它们如何工作有了大致的了解。在1D维度的情况下，我们关心的是将曲线拟合到一些数据点，但是如果响应是超平面表面呢？</p><p id="8b64" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">张量积样条是基于样条基曲面的张量积概念形成的。让我们看看同样的数学表示(如果你想了解样条基和函数形式，请看看<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa"> part-1 </a>文章)。</p><p id="0338" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">张量积基础:</strong></p><p id="1935" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">样条为什么要用张量基:我们可以在一元变量x上，在[x(i)，x(i+1)]的区间上构造一个光滑函数。但是如何定义一个光滑函数来表示相互作用协变量的基。张量积旨在构建一个基础，该基础对于任何或所有协变量的重新标度都是不变的。</p><p id="11d0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们考虑关于x、z、v变量的如下3个平滑函数(这些是在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa"> <em class="ny">第一部分</em> </a>中介绍的类似的单变量平滑)</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1c797518ccaaac2160fe0029d36b9016.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*hm5xIt9J2pgYukHSM-slkA.png"/></div></figure><p id="134f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">αi，δl，βk是系数，ai(x)，dl(z)，fv(v)是基函数。</p><p id="0330" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们要求f_x随z平滑变化，可以通过允许f_x的参数随z平滑变化来实现。</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ef52c6201062eb438a54cc74390150cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*F-OWwRyrSnPBA_9pVkm7gA.png"/></div></figure><p id="d2ff" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我们可以在x，z上定义一个光滑函数(这将是一个加性模型中的相互作用项)。</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/00f8c28ae001db06c20c15020bba03e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*bvKpW92wBvsFE7OP08_d1Q.png"/></div></figure><p id="a08d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">上述术语可以重新格式化为</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/02ad4468dd62bf7830ac2f377dc89d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Ja8AH75DT6klCWsEUhKPqA.png"/></div></figure><p id="4264" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">也就是fx和fz两个空间的张量积。两条一维线的张量积给你一个二维子空间。</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi od"><img src="../Images/d742c20654c159a8aa77624748d34e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuX7vrBi90IgCQDy8Od2gw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源——广义可加模型——西蒙·伍德《R导论》第4章。</figcaption></figure><p id="1aa0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">张量积是表示两个样条曲面之间的联合交互的自然数学方式。</p><h1 id="e14a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用GAMs的2D张量插值；</h1><p id="93c3" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw im bi translated">类似于<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa">第一部分</a>，我将创建一个人工回归问题，并使用张量积样条来解决它。我会尽力解释我所关注的重要部分。这里我们的目标是一个2D曲面，而不是一条曲线，因为我们正在处理高维空间中的样条插值。</p><p id="47a7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">好了，现在让我们定义问题并创建我们的目标数据。为了便于视觉理解，让我们用正弦曲线和它们的张量积来制作我们的目标曲面。</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="9e06" class="nn ln it of b gy oj ok l ol om">## This block is related to creating a target surface and involves ## a bit of data pre-processing.</span><span id="64db" class="nn ln it of b gy on ok l ol om">library(dplyr)<br/>library(ggplot2)<br/>library(mgcv)<br/>library(purrr)</span><span id="e99a" class="nn ln it of b gy on ok l ol om">#define the fine spatial grids for each GP, the spatial resolution<br/>#will be between -2 and 2 for all dimensions for simplicity</span><span id="1584" class="nn ln it of b gy on ok l ol om">num_fine_int &lt;- 40</span><span id="52da" class="nn ln it of b gy on ok l ol om">fine_grid_list &lt;- list(<br/>  x1 = seq(-2, 2, length.out = num_fine_int+1),<br/>  x2 = seq(-2, 2, length.out = num_fine_int+1)<br/>)</span><span id="3913" class="nn ln it of b gy on ok l ol om">### set the true relationships per factor</span><span id="ad59" class="nn ln it of b gy on ok l ol om">### set the functional expressions</span><span id="e942" class="nn ln it of b gy on ok l ol om">true_functions &lt;- list(<br/>  g1 = function(x, av){av$a0 + av$a1 * cos(av$a2 * pi * x)},<br/>  g2 = function(x, av){av$a0 + av$a1 * cos(av$a2 * pi * x)}<br/>)</span><span id="45f6" class="nn ln it of b gy on ok l ol om">### set the parameters of the functions<br/>true_hypers &lt;- list(<br/>  g1 = list(a0 = 0, a1 = 1, a2 = 1),<br/>  g2 = list(a0 = 0, a1 = 1, a2 = 1)<br/>)</span><span id="b120" class="nn ln it of b gy on ok l ol om">### define a wrapper function for executing the functions<br/>run_factors &lt;- function(myfunc, myx, myparams)<br/>{<br/>  myfunc(myx, myparams)<br/>}<br/></span><span id="2e43" class="nn ln it of b gy on ok l ol om">### calculate each of the factors over the fine grid<br/>fine_true_factors &lt;-pmap(list(true_functions,<br/>                              fine_grid_list,<br/>                              true_hypers),<br/>                         run_factors)<br/></span><span id="5ba9" class="nn ln it of b gy on ok l ol om">pmap_dfr(list(fine_grid_list,<br/>              fine_true_factors,<br/>              1:2),<br/>         function(x, g, glabel){tibble::tibble(x = x, g = g) %&gt;% <br/>             mutate(factor_name = glabel)}) %&gt;% <br/>  ggplot(mapping = aes(x = x, y = g)) +<br/>  geom_line(mapping = aes(group = factor_name), size = 1.15) +<br/>  facet_wrap(~factor_name) +<br/>  theme_bw()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oo"><img src="../Images/69e3b9d0eebb53c8cc4c361846471ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meXLNUTaNZyYvtSOul9NGw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。以上是2条单变量平滑曲线(正弦曲线),我们将用它们来创建一个张量积曲面</figcaption></figure><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi op"><img src="../Images/1c2b01701362fa655fd61c1b73706597.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*sZQAw1zB72s3FpgehxiHOg.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">上述单变量曲线的函数形式</figcaption></figure><p id="b7c3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们把两个正弦函数相乘，使它成为一个有点复杂的目标</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/1225d655606ba6023c873483809e9e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*kZRVYfr8KrapbajWcam2wg.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这是我们将要建模的函数</figcaption></figure><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="478d" class="nn ln it of b gy oj ok l ol om">fine_true_latent_dfs &lt;- <br/>  pmap(list(fine_grid_list,<br/>            fine_true_factors,<br/>            1:2),<br/>       function(x, g, glabel){tibble::tibble(x = x, g = g) %&gt;% <br/>           set_names(c(sprintf("x%d", glabel),<br/>                       sprintf("g%d", glabel))) %&gt;% <br/>           tibble::rowid_to_column(sprintf("x%d_id", glabel))})<br/></span><span id="9d09" class="nn ln it of b gy on ok l ol om">### create the tensor product of the two factors<br/>fine_latent_tensor &lt;- expand.grid(fine_grid_list,<br/>            KEEP.OUT.ATTRS = FALSE,<br/>            stringsAsFactors = FALSE) %&gt;% <br/>  as.data.frame() %&gt;% tbl_df() %&gt;% <br/>  left_join(fine_true_latent_dfs[[1]], by = "x1") %&gt;% <br/>  left_join(fine_true_latent_dfs[[2]], by = "x2") %&gt;% <br/>  select(ends_with("_id"), x1:x2, g1, g2) %&gt;% <br/>  tibble::rowid_to_column("fine_id")<br/></span><span id="673e" class="nn ln it of b gy on ok l ol om">### visualize the sum of the first two factors<br/>fine_latent_tensor %&gt;% <br/>  ggplot(mapping = aes(x = x1, y = x2)) +<br/>  geom_raster(mapping = aes(fill = g1 * g2)) +<br/>  coord_equal() +<br/>  scale_fill_viridis_c() +<br/>  theme_bw()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/3267380de6c6cda861aa74624a9790da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tY_McM0o201vLam3FKP8qw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。目标函数表面热图。</figcaption></figure><p id="5a96" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们看上面的视觉，它似乎是复杂的表面(你可以把这想象成图像)。因此，让我们简化一下，看看x1相对于x2是如何变化的(如下)</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="e7c2" class="nn ln it of b gy oj ok l ol om">### visualize the sum of the all 2 factors with marginal behavior<br/>fine_latent_tensor %&gt;% <br/>  mutate(go = g1 * g2) %&gt;% <br/>  ggplot(mapping = aes(x = x1, y = go)) +<br/>  geom_line() +<br/>  facet_wrap(~x2, labeller = "label_both") +<br/>  theme_bw() +<br/>  theme(axis.text = element_blank())</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/a5a71614ae4415d1edb2ec86ce59a4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vk8lrXlb1A1Q2bXrEETlPw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。X1与X2网格图</figcaption></figure><p id="f182" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，让我们给目标添加一些噪声(因为我们想检查模型是否能在噪声中找出潜在的平滑表面。)</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="dad5" class="nn ln it of b gy oj ok l ol om">### generate the noisy observations<br/>sd_noise &lt;- 0.2 # noise</span><span id="02ff" class="nn ln it of b gy on ok l ol om">set.seed(813123)<br/>fine_df &lt;- fine_latent_tensor %&gt;% <br/>  mutate(go = g1 * g2,<br/>         y = rnorm(n = n(), mean = go, sd = sd_noise))</span><span id="4135" class="nn ln it of b gy on ok l ol om"># Noisy target surface<br/>fine_df %&gt;% <br/>  ggplot(mapping = aes(x = x1, y = x2)) +<br/>  geom_raster(mapping = aes(fill = y)) +<br/>  scale_fill_viridis_c() +<br/>  coord_equal() +<br/>  theme_bw()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/a783207e4adb344cba1e61d40427c432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ye44KQV8eb8UEZyaMhIVeg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。噪声目标表面</figcaption></figure><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="fa73" class="nn ln it of b gy oj ok l ol om">### work with a coarse grid instead of all of the points in the fine grid<br/>num_coarse_int &lt;- 20</span><span id="5e87" class="nn ln it of b gy on ok l ol om">coarse_grid_list &lt;- list(<br/>  x1 = seq(-2, 2, length.out = num_coarse_int+1),<br/>  x2 = seq(-2, 2, length.out = num_coarse_int+1)<br/>)</span><span id="e613" class="nn ln it of b gy on ok l ol om">coarse_grid &lt;- expand.grid(coarse_grid_list,<br/>                           KEEP.OUT.ATTRS = FALSE,<br/>                           stringsAsFactors = FALSE) %&gt;% <br/>  as.data.frame() %&gt;% tbl_df()</span><span id="9cdd" class="nn ln it of b gy on ok l ol om">train_df &lt;- fine_df %&gt;% <br/>  right_join(coarse_grid, by = c("x1", "x2"))</span><span id="e1ef" class="nn ln it of b gy on ok l ol om">### look at the true latent function in the space with respect # to x2<br/>train_df %&gt;% <br/>  ggplot(mapping = aes(x = x1, y = go)) +<br/>  geom_line() +<br/>  geom_point(mapping = aes(y = y), color = "red") +<br/>  facet_wrap(~ x2, labeller = "label_both") +<br/>  theme_bw() +<br/>  theme(axis.text = element_blank())</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/fc88d76169cb5c4d633a173aab9895a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Xaj2irEDB6ufJAuJUM0iw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。嘈杂的目标边缘行为。</figcaption></figure><p id="de95" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们通过添加噪声复杂性和仅使用原始数据的一半进行训练，使目标尽可能难以建模。</p><p id="0e8f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">(上面的代码我已经做的有点复杂了，但是我想展示target的创建，你不需要理解代码；试着去诠释你想要的情节。这里的代码只基于gam()模型函数，会更简单。)</p><p id="189f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">张量积样条拟合:</strong>现在，mgcv gam()函数直接提供了使用函数ti()和te()直接创建张量平滑样条的手段。</p><p id="4843" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">ti()--&gt;这仅考虑通过ANOVA分解支持的没有边际效应的纯交互作用。因此，在假设它们将被单独包括的情况下，主要影响已经被消除。这有助于理解边际效应和交互作用(通过约束会有一些损失)。通常的公式是~ ti(x) + ti(z) + ti(x，z)</p><p id="c16c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">te() —这是考虑了余量和相互作用的全张量积，但不能单独研究影响</p><p id="3c27" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我知道从上面看不清楚ti()和te()平滑到底是什么，什么时候用哪个。让我们通过安装它们来讨论。</p><p id="681f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">首先，我将拟合ti()模型。</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="d6ab" class="nn ln it of b gy oj ok l ol om"># ti() model is usually fitted based on below formulation.</span><span id="e6df" class="nn ln it of b gy on ok l ol om"># I am giving max number of knots below because gam use #regularization so we don't to worry about overfitting here.<br/>ti_model_marginal_interaction &lt;- gam(y ~ ti(x1) + ti(x2) + ti(x1, x2, k = c(20,20)), data = train_df, method = 'ML')</span><span id="f753" class="nn ln it of b gy on ok l ol om">ti_model_marginal_interaction %&gt;% summary()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi os"><img src="../Images/52e0685034beb665c2f7a1b56dcc7df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8YnzwTU7E5LYJByFYzAUg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。ti()模型摘要</figcaption></figure><p id="1e07" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我想在这里集中讨论两件事。</p><ol class=""><li id="72bc" class="ky kz it kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">我首先拟合了“ti()”模型，因为通常在真实世界的数据中，我们不确定是否只有交互作用效应或交互作用增加了边际效应。因此，“ti()”模型有助于分解它们，并分别查看它们的影响，基于此，我们可以决定是要转向“te()”全张量积，还是坚持使用“ti()”</li><li id="edc5" class="ky kz it kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">如果我们查看显示特性重要性部分的模型摘要，我们可以看到边际的重要性较低(我们对x1的边际项具有重要性，但为了探究te()，我认为它的重要性不高，但如果您面对这些类型的结果，您应该坚持ti()，因为它比te()更稳定)。基于此，我们可以看到贡献主要是由于相互作用项。因此，在这种情况下，“te()”提供了更好的结果(并不总是取决于数据)，因为在“te()”中，“自由度”比“ti()”大(ti由于边缘项约束而失去了一些自由度)。</li></ol><p id="2e2c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在让我们看看“te()”模型的结果。</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="bc7b" class="nn ln it of b gy oj ok l ol om">te_model_interaction &lt;- gam(y ~ te(x1, x2, k = c(20,20)), data = train_df, method = 'ML')</span><span id="a702" class="nn ln it of b gy on ok l ol om">te_model_interaction %&gt;% summary()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi os"><img src="../Images/d612ac1cd6d8260f4f4d72a3e309cbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFz4GzXpGndy8BomzmQZHQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。te()模型摘要</figcaption></figure><p id="946c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">好吧，这个模型只是在性能上有一点点改进(但即使比ti()给定的相同节数要好)。在上面的总结中，如果你看一下edf(估计自由度)，这些对于“te()”比“ti()”更大，这给予“te()”甚至模拟复杂决策表面的优势(正如我上面提到的，ti()在处理边缘约束时损失了一些自由度)。</p><p id="e543" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">只是为了澄清一些疑问，te()和ti()是在建模同一个东西。在te()中我们不能清楚地看到边际效应-&gt; ti()是通过ANOVA分解作为近似值引入到te()中，以分离所有效应并提供稳定的公式。</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="7799" class="nn ln it of b gy oj ok l ol om"># A good library for visualizing the gam() model trends<br/>library(mgcViz)</span><span id="31dc" class="nn ln it of b gy on ok l ol om"># coverting gam object to a getViz object for plotting gam terms<br/>te_model_interaction &lt;- getViz(te_model_interaction)</span><span id="a3ed" class="nn ln it of b gy on ok l ol om">#plot method from mgcViz object helps in plotting 2D<br/>plot(sm(te_model_interaction, 1)) + l_fitRaster() + l_fitContour()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/5a9697a870ef421f38610b92ba860bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fYTzOW4rhzxhAvVuQENwA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。gam()模型以趋势为目标。</figcaption></figure><p id="d087" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">哇哦。！！我们已经拟合了一个2D超曲面，并且我们可以将这个概念类似地扩展到n维。</p><p id="d521" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">结尾…</p><p id="34ef" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">(开玩笑)！！！</p><p id="b5db" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在结束之前，我还想给你看一样东西。</p><p id="3eaa" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">你不觉得模型拟合太简单了吗？这是因为mgcv()包是一个很好的包装器函数，就像今天的大多数数据科学从业者一样，我们忘记了看一下幕后发生了什么。让我们不要让它那样。所以，我想向你们展示最后一件事——te()究竟是如何通过视觉来构建的。</p><p id="572d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我想让你们再看看下面的等式</p><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/00f8c28ae001db06c20c15020bba03e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*bvKpW92wBvsFE7OP08_d1Q.png"/></div></figure><p id="98c2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">d(z)和a(x)是曲线x和z的基函数，张量积样条是基于x和z的基的张量积形成的。</p><p id="cac5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">因此张量样条的基础也是高阶维数(我们有1D插值情况的1D曲线<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa">第一部分</a>试着以类似的方式思考；这是2D表面的2D插值的情况)。</p><p id="2db2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在让我们看看我们上面拟合的张量样条的基础。</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="e8cf" class="nn ln it of b gy oj ok l ol om">#predict.gam using type = 'lpmatrix' gives the basis matrix and if #this is removed and given 'newdata' argument it gives prediction #on new data</span><span id="c80c" class="nn ln it of b gy on ok l ol om">#te basis matrix <br/>te_basis_matrix &lt;- predict.gam(te_model_interaction, type = "lpmatrix")</span><span id="853a" class="nn ln it of b gy on ok l ol om">#Visualizing te() basis matrix (only top 40 basis out o 400)<br/>te_basis_matrix %&gt;% as.data.frame() %&gt;% tbl_df() %&gt;%<br/>  select(-'(Intercept)') %&gt;%<br/>  tibble::rowid_to_column() %&gt;%<br/>  left_join(coarse_grid %&gt;% tibble::rowid_to_column(), by = 'rowid') %&gt;%<br/>  tidyr::gather(key = "key", value = "value", -rowid, -x1, -x2) %&gt;%<br/>  tidyr::separate(key, <br/>                  c("te_word", "te_id"),<br/>                  sep = '\\.',<br/>                  fill = "right",<br/>                  remove = FALSE) %&gt;%<br/>  filter(te_id %in% seq(1, 40, by = 2)) %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = x2)) +<br/>  geom_raster(aes(fill = value)) +<br/>  facet_wrap(~ te_id, labeller = "label_both") +<br/>  scale_fill_viridis_b() +<br/>  theme_bw()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/59729a6f5d189dbe6e7476902a9c2fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-tNbMUFrCNsyL_tj0qbZzg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">来源—作者提供的图片。Te()基础可视化。</figcaption></figure><p id="2a81" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面，我们可以看到由te()样条创建的基础曲面。由于我们使用400个自由度，每个基础都是高度局部化的(从单个像素级别来看)。</p><p id="8c7d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa">第一部分</a>中，我已经向你展示了你可以使用smoothCon()来创建平滑样条，并使用线性模型来拟合结果基。这里我不会向您展示完整方法，但是让我们使用smoothCon()来看看低自由度的基础。</p><pre class="mp mq mr ms gt oe of og oh aw oi bi"><span id="2fc7" class="nn ln it of b gy oj ok l ol om">#te() spline smooth creation using smoothCon<br/>SmoothCon_te_basis = smoothCon(te(x1, x2, k=c(4,4)), data = train_df)[[1]]</span><span id="6c2f" class="nn ln it of b gy on ok l ol om">#visualizing the tensor product basis.<br/>SmoothCon_te_basis$X %&gt;% as.data.frame() %&gt;% tbl_df() %&gt;% <br/>  tibble::rowid_to_column() %&gt;% <br/>  left_join(coarse_grid %&gt;% tibble::rowid_to_column(),<br/>            by = "rowid") %&gt;%<br/>  tidyr::gather(key = "key", value = "value", -rowid, -x1, -x2) %&gt;%<br/>  mutate(id = factor(key, levels = as.vector(unique(key)))) %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = x2)) +<br/>  geom_raster(mapping = aes(fill = value)) +<br/>  facet_wrap(~ id, labeller = "label_both") +<br/>  scale_fill_viridis_b() +<br/>  theme_bw()</span></pre><figure class="mp mq mr ms gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi or"><img src="../Images/3f9d6603eb188a9189a5f754e749a96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fv3vzqVHGOQURTYaDiY2hg.png"/></div></div></figure><p id="1f52" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">上图看起来更有解释性。现在，当看到上图时，你会想到什么-&gt;在图像维度上移动的内核激活。我把它们看做在维度间移动的图像激活过滤器。你可以认为它们类似于一层CNN过滤器，但是过滤器设置为静态的(不要把它们直译为静态CNN过滤器。只是为了解释他们在某种程度上，我比较他们与CNN过滤器)。</p><p id="94c3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">好了，现在我真的要结束了。如果你想检查预测部分，我已经在下面链接的github中添加了代码。</p><h1 id="c3b9" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论:</h1><p id="0475" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw im bi translated">总之，我已经向您展示了张量积样条函数，以及如何使用mgcv gams函数拟合它们，并解释了其基本原理。</p><p id="e9ae" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">你一定在很多地方听说过这一点，我在这里也指出了这一点-&gt;张量积是在加法模型中表示平滑相互作用的自然数学方法。</p><p id="1f5d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我想分享的另一个想法是在示例数据中；我们能够仅使用20*20的缩减尺寸来适合尺寸为40*40的图像。因此，这种方法也可以用作降维技术，并在某种意义上优于PCA(只能产生离散值),因为这种方法为您提供了数据的功能等价物。所以，你甚至可以生成新的数据(高分辨率)。</p><p id="806a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">检查我的<a class="ae kx" href="https://github.com/saipradeep-peri/GAMs_Tensor_Products_fits" rel="noopener ugc nofollow" target="_blank"> Github </a>上面的代码，其中添加了关于预测的代码和一些与张量积样条相关的更多实验。</p><p id="3b61" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">参考资料:</p><ol class=""><li id="6f09" class="ky kz it kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">广义加性模型导论。</li><li id="c048" class="ky kz it kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated"><a class="ae kx" href="https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/smooth.terms.html" rel="noopener ugc nofollow" target="_blank">https://stat . ethz . ch/R-manual/R-devel/library/mgcv/html/smooth . terms . html</a></li></ol></div></div>    
</body>
</html>