<html>
<head>
<title>Input Image Files by Batch to Kickstart Training under TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">批量输入图片文件到TensorFlow下的Kickstart训练</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/input-image-files-by-batch-to-kickstart-training-under-tensorflow-e4ccce6ab64b?source=collection_archive---------0-----------------------#2022-08-10">https://pub.towardsai.net/input-image-files-by-batch-to-kickstart-training-under-tensorflow-e4ccce6ab64b?source=collection_archive---------0-----------------------#2022-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="404f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">由于内存错误，无法加载图像作为训练输入？这篇5分钟的文章可以为你节省5个小时甚至更多。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d4db7519eda33e703457a0140320514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Z_tH-lHrXSH4J3b"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a>拍摄的照片</figcaption></figure><h1 id="0821" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">背景</strong></h1><p id="42c7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">最近，我一直在尝试建立一个用于图像分类的机器学习模型。由于缺乏足够的真实数据，我首先创建了一个python脚本来生成一些人工图像，并用文件名作为标签显式地保存它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/d063a193e2f6fed4d1dc880bf9ff080e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piHzz_to0Da3vhk5E1Pb1g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">汉字的人工数据样本(在英语中，它表示数字一)</figcaption></figure><p id="dd47" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然而，后来，当我试图加载这些数据作为我的机器学习模型的训练输入时，弹出了内存错误的消息。可以看到图片总数已经超过40000张。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1e207938168a08eef3606cc3a682d5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*j2NpkxrfqAXgvrFBITph7Q.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一条错误消息显示计算机未能分配足够的RAM来保存/处理图像数组。</figcaption></figure><p id="3021" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">这个内存错误不容易解决，因为它在某种程度上与我们计算机的硬件设置有关。带着这个问题，我试着在网上搜索解决方案，下面是所有答案的汇总。不幸的是，没有一个能满足我的需求。</p><p id="3fac" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">(1) <strong class="lt iu">降低类别数和图像大小</strong>，但这可能不符合您的模型目标，并且当图像维度降低时，准确率可能会下降。</p><p id="2eb1" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">(2) <strong class="lt iu">应用</strong><a class="ae ky" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Pickle</strong></a><strong class="lt iu">库</strong>显式存储处理后的数组，然后使用另一台计算机或云服务器加载数据集并训练模型，但这并不总是可行的，尤其是当类的数量或图像的数量非常大时。</p><p id="be7f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">(3) <strong class="lt iu">使用<strong class="lt iu">TF . data . dataset . from _ generator，</strong>修改加载函数</strong>，该函数将人工图像直接传递给模型进行训练，无需明确保存。这种方法效果很好，也允许批量加载数据，但可能不是最佳选择。这是因为有时我们只是想通过显式地保存它们来对所有人工图像进行概述。此外，将图像保存在单独的文件夹中使得以后能够容易地调整，例如，将一些真实数据添加到文件夹中并重新训练它。如果你更喜欢用这种方法，这里的文章<a class="ae ky" href="https://medium.com/the-owl/creating-a-tf-dataset-using-a-data-generator-5e5564609e64" rel="noopener">提供了一个很好的参考。</a></p><p id="511d" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">尽管如此，第三种方法将我带到了<strong class="lt iu"> Tensorflow </strong>的<strong class="lt iu">数据集</strong>模块，这也是我想在本文中向大家介绍的内容。</p><h1 id="c610" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">加载训练数据的函数</h1><p id="5d8e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> B </span>在介绍这个模块之前，让我们快速看一下加载训练数据集的原始函数。它首先使用<strong class="lt iu"> OpenCV </strong>库将图像文件读取为NumPy数组，然后将所有图像和相应的标签存储在两个独立的NumPy数组<strong class="lt iu"> x_train、</strong>和<strong class="lt iu"> y_train </strong>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dfd0" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">然而，如上所述，在存储或处理这样的数组时存在存储器限制。有时错误出现在加载期间，有时出现在处理期间。</p><h1 id="b8c4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">tensor flow的数据集模块</strong></h1><p id="d67d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>那一瞬间，我就在想，为什么我们不能只在训练时需要的时候才加载图像的子集，这在<strong class="lt iu">TF . data . dataset . from _ generator的方法下是允许的。</strong>只是我也想在输入图像进行训练之前将其明确保存。</p><p id="e44d" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">在阅读了模块的<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank">文档</a>和这里的官方教程<a class="ae ky" href="https://www.tensorflow.org/tutorials/load_data/images" rel="noopener ugc nofollow" target="_blank">后，我终于想出了一个解决方案，并在不做任何妥协或对上述原始功能进行任何大的修改的情况下成功启动了培训。在下文中，我将解释新代码中的所有关键函数，它们看起来与numpy数组的处理非常相似，只是在<strong class="lt iu"> Tensorflow </strong>格式下。</a></p><h2 id="b334" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated"><strong class="ak"> Load_train_data() </strong></h2><p id="78f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是加载数据函数的主体。这与旧版本的主要区别在于，我们首先将图像路径加载到一个list<em class="nr">(</em><strong class="lt iu"><em class="nr">TF . data . dataset . list _ files</em></strong><em class="nr">)</em>中，而不是图像本身。这是<strong class="lt iu"> Tf.data.Dataset </strong>的关键特征，它最大限度地减少了加载过程中的内存需求。这些图像将在稍后的训练中根据它们各自的文件路径进行加载。</p><p id="f253" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">保存后，我们还会对列表<em class="nr">(</em><strong class="lt iu"><em class="nr">list _ ds . shuffle</em></strong><em class="nr">)</em>进行混排，因为通常我们保存图像数据时，都是按时间顺序排列的。随机播放功能确保图像被随机输入用于训练。</p><p id="bccf" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">最后，我们通过<strong class="lt iu">映射</strong>将函数<strong class="lt iu"> process_path() </strong>应用于训练数据集。这非常重要，因为现在，训练数据只是图像路径的列表。我们必须教程序如何加载图像和标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="22c8" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">进程路径()</h2><p id="b275" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在<strong class="lt iu"> process_path() </strong>内部，第一件事就是从文件路径中获取标签，也就是我们的<strong class="lt iu"> y_train，</strong>。接下来，我们通过<strong class="lt iu"><em class="nr">TF . io . read _ file</em></strong>按照路径<em class="nr">、</em>加载图像文件，后面是后处理<em class="nr">、</em> <strong class="lt iu"> decode_img() </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="8422" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated"><strong class="ak"> Get_label() </strong></h2><p id="7d24" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个函数从文件路径中获取标签。这些代码与通常的字符串处理非常相似，但在Tensorflow格式下—<strong class="lt iu"><em class="nr">TF . string . split</em></strong><em class="nr">。</em></p><p id="0178" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">该函数以<strong class="lt iu">一键编码</strong>结束，这是分类变量作为二进制向量的表示。分类值首先被映射到整数值。然后，每个整数值都表示为一个全为0的二进制向量，除了整数的索引标记为1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="65d2" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">Decode_img()</h2><p id="ce8f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个功能是调整图像，以适应我们的机器学习模型的输入。在我的例子中，我首先将图像转换为RGB格式，因为人工图像最初是黑白的，而我的模型的输入格式是彩色的。其次，我将图像调整为128 x 128的格式，并通过除以255进行标准化。</p><p id="dc20" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">这种处理功能在每种情况下都会发生变化。都取决于我们模型的输入要求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="c3fb" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">性能配置()</h2><p id="bd6a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，最后一步是设置函数来配置加载训练数据的性能。这也是一个非常重要的步骤，允许我们批量<strong class="lt iu"> <em class="nr"> ds.batch() </em> </strong>加载镜像文件，并允许在<strong class="lt iu">自动调优</strong>启用的情况下进行缓存和预取。Tensorflow将通过自动调整后端参数来帮助平滑训练过程。</p><p id="b55f" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">所有这些都降低了内存需求，因为只有在训练过程中需要时才加载图像的子集。否则，它们将以图像路径的形式存储。</p><p id="5686" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">所以这就是我们所需要的。现在，即使我们面对数百个类和大量的图像，我们仍然能够启动模型训练。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="10b8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">结论</strong></h1><p id="1356" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu"> Tensorflow </strong>不断修改和引入新的数据结构，以平滑训练过程。<strong class="lt iu">数据集</strong>模块是一个很好的例子，它帮助我们批量加载显式保存的图像作为训练输入。希望上面的代码可以为你节省一些时间，把你的重点和精力转移到如何提高你的模型的准确率上来。</p><p id="9e7d" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">谢谢您们。下次见~</p><h1 id="3aa7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">参考</strong></h1><ol class=""><li id="8387" class="ns nt it lt b lu lv lx ly ma nu me nv mi nw mm nx ny nz oa bi translated">Siladittya甘露。(2021).<a class="ae ky" href="https://medium.com/the-owl/creating-a-tf-dataset-using-a-data-generator-5e5564609e64" rel="noopener">使用数据生成器</a>创建TF数据集。</li></ol></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oi"><a href="https://medium.com/@hudsonko/membership" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">用我的推荐链接加入媒体-哈德森高</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">如果你对我写的东西感兴趣，不要错过成为Medium会员的机会。您将可以完全访问所有…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="6912" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">如果你有兴趣知道如何定制损失函数，使LSTM模型更适用于股票价格预测。下面看看我之前的文章。</p><div class="ox oy gp gr oz oi"><a href="https://towardsdatascience.com/customize-loss-function-to-make-lstm-model-more-applicable-in-stock-price-prediction-b1c50e50b16c" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">定制损失函数，使LSTM模型更适用于股票价格预测</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">损失函数不要只考虑价格差异，方向损失也很重要！！！</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="pa l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>