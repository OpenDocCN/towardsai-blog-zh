<html>
<head>
<title>Search Sorted Data Faster With the Binary Search Algorithm in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的二分搜索法算法更快地搜索排序后的数据</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/search-sorted-data-faster-with-the-binary-search-algorithm-in-python-699e82ae8560?source=collection_archive---------0-----------------------#2021-05-20">https://pub.towardsai.net/search-sorted-data-faster-with-the-binary-search-algorithm-in-python-699e82ae8560?source=collection_archive---------0-----------------------#2021-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ee1c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/96c8233bbfd3413584ef6e032aeaecb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vTXvDLIKCCRcOG1kojJx-w.jpeg"/></div></div></figure><h1 id="54bb" class="kk kl it bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">目录</h1><p id="2d3a" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">一.解释二分搜索法</p><p id="0695" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">二。示例代码</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="5c06" class="ms kl it bd km mt mu dn kq mv mw dp ku lt mx my ky lx mz na lc mb nb nc lg iz bi translated">一、解释二分搜索法教:</h2><p id="13ae" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">让我们取一组排序后的数据点。请注意，该搜索仅在对数组进行排序时有效:</p><p id="cb7a" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi">{1,2,3,4,5,6,7,8,9,10}</p><p id="44e9" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这里有10个元素。这些的指数从0到9。</p><p id="fa13" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">假设我们在这个数组中搜索元素4。如果找到元素，算法应该返回1。</p><p id="b242" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">二分搜索法算法本质上是使用(最高索引+最低索引)//2的下限划分，在中点将数据集分成两部分</p><p id="7ae5" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">例如(9+0)//2将等于4。arr[4]元素是5。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d619ac1425a7bccd0db4693aee8b3525.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*BqyQEVVfa6NfHy3W0ySBHg.png"/></div></figure><p id="d7bc" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">如果索引4处的元素等于我们正在搜索的元素，那么算法将返回答案并停止运行。在这种情况下，5不是我们要搜索的元素，因此，算法必须继续。为了做到这一点，我们必须检查我们正在搜索的元素是小于还是大于arr[mid]。在本例中，我们搜索的是小于5的4。因为二分搜索法只对排序后的数组起作用，这意味着我们可以丢弃5右边的所有索引，现在只对数组的左半部分起作用。为此，我们将high变量更新为mid-1。我们知道mid是前面(低+高)//2给出的索引号4。一旦我们将高点更新到1中，那么新的高点将是3。在这一点上，该算法将通过执行(低+高)//2或(0+3)//2(即1)来重复自身。</p><p id="744c" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">该算法现在将再次检查arr[1]是否小于或大于我们正在搜索的给定数字4。在这种情况下，arr[1]是小于4的2。</p><p id="4c40" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">因为2小于4，所以下限将更新为mid+1，因为我们知道我们要搜索的数字不能在mid的左边。现在低将是2。算法会再次计算mid，即(低+高)//2或(2+3)//2等于2。因为arr[2]是3，而3小于我们正在寻找的数字4，所以算法会将low更新为mid+1，这意味着low现在将是2+1 = 3。</p><figure class="ne nf ng nh gt kd gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/faa6a4e4ae3c2918f68ec5005387c4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*buoK4aYATxKm1KqeaS_5vw.png"/></div></figure><p id="db4d" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">如您所见，arr[3]是4，这是我们正在寻找的数字。此时，当我们找到要找的数字时，算法将停止并返回我们想要的结果。</p><p id="b141" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">请注意，如果找不到该数字，最终低不会小于或等于高。当下限大于上限时，循环也应该终止，这意味着我们要寻找的数字不在数组中。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="0637" class="ms kl it bd km mt mu dn kq mv mw dp ku lt mx my ky lx mz na lc mb nb nc lg iz bi translated">二。示例代码</h2><p id="8637" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf im bi translated">好的，让我们用一个例子来做一些编码。</p><p id="63c1" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">给定一个排序的数组，检查一个整数K是否在数组中。如果整数在数组中，输出1，否则输出-1。数组的大小为n。</p><p id="120a" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">以下是我的解决方案:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="4587" class="ms kl it nk b gy no np l nq nr">class Solution:<br/>    ##Complete this function<br/>    def searchInSorted(self,arr, N, K):<br/>        #Your code here<br/>        high = len(arr)-1<br/>        low = 0<br/>        while low&lt;=high:<br/>            mid=(low+high)//2<br/>            if arr[mid]==K:<br/>                return 1<br/>            elif arr[mid]&lt;K:<br/>                low = mid+1<br/>            else:<br/>                high = mid-1<br/>        return -1</span></pre><p id="9720" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们走一遍。我们有一个数组名为arr，大小为n。我们必须找到其中的整数K。</p><p id="06c0" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">首先，我们将high变量设置为len(arr)-1。Python使用从零开始的索引。</p><p id="2a96" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">这就是它的工作原理。如果数组是{1，2，3}，我键入len(arr)，python将返回will 3，这是数组中元素的个数。但是，数组中的最后一个索引实际上是12，因为索引是从零开始的。既然高位应该等于最后一个指数，我们必须做:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="439d" class="ms kl it nk b gy no np l nq nr">high = len(arr)-1</span></pre><p id="f3a4" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">同时，low=0也可以，因为索引从0开始。</p><p id="aaa1" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">让我们设置循环条件:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="768e" class="ms kl it nk b gy no np l nq nr">while low&lt;=high:</span></pre><p id="2a75" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">以上将终止循环，因为当low变得大于high时，我们就找不到元素了。</p><p id="4b60" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">一旦进入循环，我们就通过进行楼层划分来设置mid，然后对3个条件执行三个if语句，如下所示:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="51e2" class="ms kl it nk b gy no np l nq nr">mid=(low+high)//2<br/>            if arr[mid]==K:<br/>                return 1<br/>            elif arr[mid]&lt;K:<br/>                low = mid+1<br/>            else:<br/>                high = mid-1<br/>        return -1</span></pre><p id="4e0d" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">任何时候，我们找到元素K，它将返回1，否则，如果小于K，那么low将更新到mid+1，如果&gt; K，low将更新到mid-1。</p><p id="b1c2" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">最后，如果没有发现任何东西，即低变得大于高，它将返回-1。</p><p id="8b82" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">感谢阅读，</p><p id="bcb2" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">灰</p><p id="31f7" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">继续阅读我关于旅行推销员问题的文章，这是欧几里得版本唯一已知的数学解决方案:<a class="ae ns" rel="noopener ugc nofollow" target="_blank" href="/how-to-shortest-loop-any-euclidean-travelling-salesman-problem-c13c08841f94?source=friends_link&amp;sk=71ea64847d6c2664b0b4868d59f58188">https://pub . toward sai . net/how-to-shortest-loop-any-euclidean-traveling-Salesman-Problem-c13c 08841 f94？source = friends _ link&amp;sk = 71ea 64847 d6c 2664 b 0 b 4868d 59 f 58188</a></p><p id="8256" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">参考资料:</p><p id="8d47" class="pw-post-body-paragraph li lj it lk b ll mg ln lo lp mh lr ls lt mi lv lw lx mj lz ma mb mk md me mf im bi translated">1-geeksforgeeks.org</p></div></div>    
</body>
</html>