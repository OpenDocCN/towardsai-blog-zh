<html>
<head>
<title>Data Validation Framework in Apache Spark for Big Data Migration Workloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Spark中针对大数据迁移工作负载的数据验证框架</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/data-validation-framework-in-apache-spark-for-big-data-migration-workloads-44858b6050c?source=collection_archive---------1-----------------------#2020-08-24">https://pub.towardsai.net/data-validation-framework-in-apache-spark-for-big-data-migration-workloads-44858b6050c?source=collection_archive---------1-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6555" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><p id="6530" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">质量保证测试是大数据的关键领域之一</p><p id="c633" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">数据质量问题可能会毁掉许多大数据、数据湖、ETL项目的成功。无论数据是大是小，对数据质量的需求不会改变。高质量的数据是从中获得洞察力的绝对驱动力。数据的质量是根据它是否通过获得必要的洞察力来满足业务需求来衡量的。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/2432257f102bb8b35ace065853a542f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33UI5UdzXtom7b_s5ss-eQ.png"/></div></div></figure><blockquote class="lj lk ll"><p id="4008" class="jz ka lm kb b kc kd ke kf kg kh ki kj ln kl km kn lo kp kq kr lp kt ku kv kw im bi translated">在这篇博客中，我们将看到在将数据从源迁移到目的地时确保数据质量正确的步骤。</p></blockquote><h2 id="e157" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">涉及的步骤</h2><ol class=""><li id="4643" class="mi mj it kb b kc mk kg ml kk mm ko mn ks mo kw mp mq mr ms bi translated">行和列计数</li><li id="1f4b" class="mi mj it kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">列名检查</li><li id="222c" class="mi mj it kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">无哈希的子集数据检查</li><li id="d0d1" class="mi mj it kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">统计数据比较—最小值、最大值、平均值、中值、标准差、第25、第50、第75百分位</li><li id="ea01" class="mi mj it kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated"><strong class="kb jd">T5】sha 256对整个数据进行哈希验证T7】</strong></li></ol><h2 id="42b8" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">排除故障</h2><p id="68ad" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">当源和接收器不匹配时，如何在可能有3000+列和数百万条记录的整个数据中获取特定的损坏数据？</p><p id="cb58" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们看看每一步的行动…</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="6c51" class="ni lr it bd ls nj nk nl lv nm nn no ly np nq nr mb ns nt nu me nv nw nx mh ny bi translated">方案</h1><p id="8f8e" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">我们已经将数据从MySQL迁移到Data Lake。在下游应用程序使用数据之前，需要验证数据的质量。</p><p id="1538" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">出于演示目的，我在Spark Dataframe中读取了样本客户数据(1000条记录)。虽然演示的数据量很小，但是这个解决方案可以扩展到海量数据。</p><h2 id="085a" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">场景-1</h2><p id="7fd4" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">相同的数据在两个数据框架中，所以我们的验证框架将是一个绿色信号。</p><h2 id="fa35" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">场景2</h2><p id="b251" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">我特意修改了第二个数据帧中最后2条记录的数据，以便我们可以看到这个哈希验证框架是如何帮助我们的。</p><h2 id="fdea" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">本博客中使用的完整代码片段</h2><p id="99de" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">让我们以相反的顺序来看这些步骤，因为这是验证的核心部分。</p><h1 id="58f0" class="ni lr it bd ls nj nz nl lv nm oa no ly np ob nr mb ns oc nu me nv od nx mh ny bi translated">步骤5:对整个数据进行SHA256哈希验证</h1><p id="47ec" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">在本例中，我选择了SHA256，还有其他一些哈希算法，如MD5。</p><h2 id="14a0" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">哈希算法</h2><p id="9d14" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">哈希算法是从给定输入生成固定长度结果(哈希或哈希值)的函数。哈希值是原始数据的汇总。检查<a class="ae oe" href="https://emn178.github.io/online-tools/sha256.html" rel="noopener ugc nofollow" target="_blank">在线哈希生成器</a>中的SHA-256哈希值。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi of"><img src="../Images/7d116fdd359d2649c7620bd7753079d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaDEW5ZcqD0oR60ri33Idg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">示例散列内容和相应的散列值</figcaption></figure><p id="549c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lm">即使是最小的变化(一个字母)也会使整个散列不同</em></p><p id="3fa8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">广泛用于数字签名、认证、在散列表中索引数据、检测重复或作为校验和(检测发送的文件是否遭受意外或故意的数据损坏)。</p><blockquote class="ok"><p id="30e8" class="ol om it bd on oo op oq or os ot kw dk translated">但是，在这里，我们将了解如何在大数据验证中利用哈希的强大功能。</p></blockquote><h2 id="4f9c" class="lq lr it bd ls lt ou dn lv lw ov dp ly kk ow ma mb ko ox md me ks oy mg mh iz bi translated">哈希冲突</h2><p id="d64c" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated"><strong class="kb jd">冲突</strong>或<strong class="kb jd">冲突</strong>是指当两个不同的数据片段具有相同的哈希值、校验和、指纹或加密摘要时发生的情况。可以为不同的字符串生成相同的哈希代码。然而，两个字符串具有相同散列的概率非常低，除非存在暴力攻击。</p><p id="e3d7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lm">冲突的影响取决于应用程序，在我们的场景中，我们在另一个验证步骤中处理这些冲突(4 — </em> <strong class="kb jd"> <em class="lm">统计比较</em> </strong> <em class="lm">)。</em></p><h2 id="9dcf" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">哈希验证如何以及为什么有助于数据验证</h2><p id="7c8e" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">当我们拥有数百万条记录和3000多列时，很难比较源系统和目标系统的数据不匹配情况。为此，我们需要大量的内存和计算引擎。为了解决这个问题，我们使用哈希将所有3000+列连接成一个长度仅为64个字符的哈希值列。当您比较3000+柱长和大小时，这个体积可以忽略不计。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi oz"><img src="../Images/a70eb3305f09e25e1b586e3d3be2f229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCYeL5bkDHnKtsImYYIbKQ.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">Spark中创建哈希值的示例</figcaption></figure><h2 id="269e" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">通过组合除主键之外的所有列，对两个数据帧应用散列:</h2><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pa"><img src="../Images/af5670996e2c7d50c7de78ee71393b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PARIQLEn0_K7ZdQtHkclw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated"><strong class="bd ls">将所有3000+列转换为一个散列值列</strong></figcaption></figure><h2 id="5624" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">连接并获取不匹配记录的id:</h2><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pb"><img src="../Images/a36986c7d00b96aadf0a89e13be9bbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5MSaYbrAH4v7hXIWQ8caQ.png"/></div></div></figure><p id="1e4c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">通过利用散列的力量，而不是利用大量资源，我们知道有2个损坏的记录(<strong class="kb jd">主键— 999，1000 </strong>)。现在，通过只过滤这两个id，我们可以比较这两个数据帧以获得损坏的值。</p><h2 id="af3c" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">使用Join、eqNullSafe和Stack运算符获取不匹配的记录:</h2><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pc"><img src="../Images/6b0ccc3c7564acb95f5dd08c895df56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCa9ikUgSanSpucIi5mdPQ.png"/></div></div></figure><p id="6bbf" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">进一步钻取，仅获取两个数据框中不匹配的列及其相应的值。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pd"><img src="../Images/6d670fa59a678ce5a3486d89f194afb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Np0NjWTCKsXA_KgLb4xdg.png"/></div></div></figure><h1 id="dd19" class="ni lr it bd ls nj nz nl lv nm oa no ly np ob nr mb ns oc nu me nv od nx mh ny bi translated">步骤4:统计数据比较—最小值、最大值、平均值、中间值、标准偏差、第25、第50、第75百分位</h1><p id="afa3" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">在极少数情况下，哈希验证可能会发生冲突，从而导致数据损坏。这可以通过计算数据中每一列的统计数据来避免。</p><h2 id="5236" class="lq lr it bd ls lt lu dn lv lw lx dp ly kk lz ma mb ko mc md me ks mf mg mh iz bi translated">几列上的示例摘要</h2><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pe"><img src="../Images/5ad29c5f8d2d85887b3af2eabebff4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Of-Y5Fe0n_JlL1XhwNiA7A.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">获取所有列的统计数据的Dataframe summary方法</figcaption></figure><p id="35e6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">比较两个数据帧上的摘要统计信息，找出不匹配的情况。<code class="fe pf pg ph pi b">Numeric</code>列将计数、平均值、标准差、最小值、最大值和百分位数。<code class="fe pf pg ph pi b">String</code>列将根据Ascii值给出计数、最小值和最大值。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pj"><img src="../Images/1c8452178e882a71715c63a766d7dfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vg43i4WjEpsueLjgwBlCw.png"/></div></div></figure><h1 id="364b" class="ni lr it bd ls nj nz nl lv nm oa no ly np ob nr mb ns oc nu me nv od nx mh ny bi translated">步骤3:不进行哈希运算的子集数据检查</h1><p id="5e45" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">这种检查是苹果到苹果的比较，这意味着这将验证实际数据，而不应用哈希。但是，这将限于几个记录，因为如果我们处理大量数据，这可能会消耗更多资源。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pk"><img src="../Images/14d73ecc36065851ca1d83764ce48dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9fehquaKk1D-uCS2VPQWA.png"/></div></div></figure><p id="0b12" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">但是，这项检查的一个缺陷是，我们不能100%确定我们的数据是有效的。因为我们在第999和1000行中有无效数据。但是，当我们将支票与仅有的100条记录进行比较时，它返回我们的数据是有效的。</p><h1 id="c3e6" class="ni lr it bd ls nj nz nl lv nm oa no ly np ob nr mb ns oc nu me nv od nx mh ny bi translated">步骤2:列名检查</h1><p id="bd3e" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">这项检查将确保我们没有损坏或额外的列</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pl"><img src="../Images/96ba8d5a3b0f8919da08fc9198017d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loCG2G_vmoAEQjnvRLBjnw.png"/></div></div></figure><h1 id="e7b8" class="ni lr it bd ls nj nz nl lv nm oa no ly np ob nr mb ns oc nu me nv od nx mh ny bi translated">步骤1:行和列计数</h1><p id="fd70" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">这种检查将在典型的数据迁移管道中进行。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pm"><img src="../Images/60ebaada9e5310d301e16310b38069c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtHZ8Xif92pPEl-TDQWIwA.png"/></div></div></figure><h1 id="df10" class="ni lr it bd ls nj nz nl lv nm oa no ly np ob nr mb ns oc nu me nv od nx mh ny bi translated">包扎</h1><p id="3268" class="pw-post-body-paragraph jz ka it kb b kc mk ke kf kg ml ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">糟糕的数据质量会耗尽团队修复数据的宝贵时间。我希望这篇博客有助于解决使用Spark从源迁移到目的地后的数据质量问题。这个现成的解决方案不仅适合分布式系统，而且如果数据量较少，还可以复制到普通python中运行。</p><p id="a700" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果你喜欢这个博客，请分享给你的队友，朋友，鼓掌👏在1到50英寸的范围内。<a class="ae oe" href="https://help.medium.com/hc/en-us/articles/115011350967-Claps" rel="noopener">每篇帖子最多可以鼓掌50次</a>。</p></div></div>    
</body>
</html>