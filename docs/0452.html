<html>
<head>
<title>Time Series Forecasting for COVID-19</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新冠肺炎时间序列预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/time-series-forecasting-for-covid-19-c638688d8835?source=collection_archive---------1-----------------------#2020-05-02">https://pub.towardsai.net/time-series-forecasting-for-covid-19-c638688d8835?source=collection_archive---------1-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0268" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">使用来自约翰·霍普金斯大学中心的新冠肺炎数据对脸书先知进行时间序列预测的指南</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/8dc2647d08f0cd9c4080d00cb813b49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-b75WJOIqIAJuLHMjxiYw.png"/></div></div></figure><p id="9874" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">时间序列仅仅是一系列按固定时间间隔排列的数据点，其中时间通常是独立变量，目标是对未来进行预测。时间序列是一种常见的模式，在生活中有许多应用，例如股票价格、天气、销售。学习如何预测时间序列数据是数据科学领域的一项基本技能。</p><p id="c555" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">新型冠状病毒，又称新冠肺炎，是一种持续的疫情，自2019年12月以来在全球范围内广泛传播。使用时间序列预测来预测未来每天的新冠肺炎病例，无疑将有助于了解它的增长速度以及可能决定这种增长的因素。此外，它有助于了解物理距离或锁定等干预措施可能会随着时间的推移而影响增长。</p><p id="bbc6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Prophet是由脸书的数据科学工程团队提供的一个库，它是一个用于分析和预测周期性数据的强大而简单的工具，可用于Python和r</p><p id="b5c2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本文旨在解释如何使用来自约翰霍普金斯大学中心的新冠肺炎数据用Prophet进行时间序列预测。</p><h1 id="becd" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">工具</h1><p id="ca2f" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">本文的环境设置使用Python 3.7，并安装了以下包:</p><ul class=""><li id="0087" class="mo mp it kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">NumPy</li><li id="9a4c" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">熊猫</li><li id="f397" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">Matplotlib</li><li id="b39b" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">FB先知</li><li id="9f5b" class="mo mp it kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">sci kit-学习</li></ul><h1 id="fc14" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">加载数据集</h1><p id="2cd4" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">本文中使用的数据由约翰霍普金斯大学中心提供。它每天从官方来源更新全球新报告的新冠肺炎病例。该数据集可在https://github.com/CSSEGISandData/COVID-19<a class="ae nc" href="https://github.com/CSSEGISandData/COVID-19" rel="noopener ugc nofollow" target="_blank">的GitHub仓库</a>获得。</p><p id="eab8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于本文，我们将通过URL直接从存储库中访问原始CSV文件。首先，我们使用Pandas的read_csv()方法加载数据，该方法将csv数据从URL加载到DataFrame中。然后，我们使用head()显示前几行，以简要了解数据结构和组成。</p><p id="1eb7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据是从2020年1月22日到我们访问它的日期。每行代表一个省(州)，各列代表国家、纬度、经度和每天的确诊病例数。国家按字母顺序排列，每个日期都有一列存储确诊病例总数。</p><blockquote class="nd ne nf"><p id="5a8a" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">将熊猫作为pd <br/> %matplotlib内联导入</p><p id="affc" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#加载数据<br/>data _ URL = '<a class="ae nc" href="https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv'" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/CSSEGISandData/新冠肺炎/master/csse _ covid _ 19 _ data/csse _ covid _ 19 _ time _ series/time _ series _ covid 19 _ confirmed _ global . CSV '</a><br/>df = PD . read _ CSV(data _ URL)<br/>df . head()</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nk"><img src="../Images/f8ec6b69974a9d12f81f8a0e5b1a93f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45W-N65tYhP14raY_fycFA.png"/></div></div></figure><h1 id="d574" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数据准备</h1><p id="071d" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">下一步是准备和清理数据。首先，我们使用国家/地区列过滤数据，因为我们将按国家进行预测。loc[]通过传递一个包含过滤条件的布尔数组来访问一组行和列，在我们的例子中是df[' Country/Region ']= ' Germany。'请注意，您可以在这一行中更改国家名称，以预测不同国家的结果。接下来，我们删除不需要的列，例如省/州、纬度和经度。</p><blockquote class="nd ne nf"><p id="102e" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#使用国家名称过滤<br/> df = df.loc[df['国家/地区'] = '德国']#在此更改国家名称</p><p id="0e6e" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#删除未使用的列<br/> df.drop('省/州'，axis=1，inplace=True) <br/> df.drop('纬度'，axis=1，inplace=True) <br/> df.drop('长'，axis=1，inplace=True) <br/> df.head()</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nl"><img src="../Images/765fffd0412b5bf45c8f704c3158cdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImLjHEecZABecOYUN3DfsQ.png"/></div></div></figure><p id="9859" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，使用group by操作来组合使用Country/Region列的结果，即，一些国家的多个省/州可以有多个行。使用sum函数对每天的病例数求和。我们继续删除所有零值列(无案例)。然后，我们重置索引以删除未使用的国家列。</p><blockquote class="nd ne nf"><p id="2e78" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#对同一国家的所有行进行分组<br/> df = df.groupby('国家/地区')。总和()</p><p id="3f6d" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#删除零值<br/> df = df.loc[:，(df！= 0).任何(轴=0)]</p><p id="fbc8" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#删除未使用的国家列<br/>df . reset _ index(in place = True)<br/>df . drop(' Country/Region '，axis=1，inplace=True) <br/> df.head()</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nm"><img src="../Images/3ef39184664b36d367266604ceb1cd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VY0y_UXwvIFfe3W2_N1ow.png"/></div></div></figure><p id="fb4d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将需要我们的数据框有一个时间序列值的一行。我们使用transpose()函数将索引和列转置成所需的格式。此外，我们将日期列的数据类型转换为Timestamp，而不是string。</p><blockquote class="nd ne nf"><p id="5e50" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#转置矩阵，为每个日期条目创建一行<br/> df = df.transpose()</p><p id="3ac4" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#更改为日期时间<br/>d format = ' % m/% d/% y '<br/>df . index = PD。datetime index(PD . to _ datetime(df . index，format=dformat)) <br/> df.head()</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9484e2bd6e91bf4383cc5889b37ebc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*j1rl3toxNMKpdcOpsSMJOA.png"/></div></figure><p id="8212" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Prophet模型要求数据框具有特定的列格式，我们将列的名称更改为“ds”和“y ”,以匹配所需的格式。我们使用reset_index来重置我们的索引。</p><blockquote class="nd ne nf"><p id="ed87" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated"># prepare for Prophet<br/>df . reset _ index(in place = True)<br/>df . rename(columns = { ' index ':' ds '，0:'y'}，inplace=True) <br/> df.head()</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/fcaeb7432e1c79d271b1b69d28e314d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*54ikC4RUm5ei-HV5hRse1Q.png"/></div></figure><h1 id="d736" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">数据可视化</h1><p id="0b18" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">现在，我们的数据已经按照要求的格式准备好了，我们使用plot函数绘制数据，日期显示在x轴上，案例数显示在y轴上。这一步的目的是更深入地理解数据。这有助于我们以后选择用于我们模型的超参数。下图显示，病例数量随着时间的推移急剧增加。</p><blockquote class="nd ne nf"><p id="572c" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#plot跨时间的案例数<br/> ax = df.plot(x='ds '，y='y '，figsize=(12，6)，title= '新冠肺炎每日案例')<br/> ax.autoscale(axis='both '，tight = True)<br/>ax . set(xlabel = ' Date '，y label = ' Cases ')；</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi np"><img src="../Images/dc0050a3f6e2ceb4bd41125974ddc45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VeAPfJhEnLPEpuzdLmEnpg.png"/></div></div></figure><h1 id="a997" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">模特培训</h1><p id="07e4" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">接下来，我们将设置Prophet来开始建模我们的数据。我们导入所需的库。此外，我们将数据分为训练集和测试集。由于每次我们想要生成新的预测时，我们的模型都将被重新训练，因此我们将使用95%用于训练，5%用于测试来评估模型结果。</p><blockquote class="nd ne nf"><p id="5e31" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">从fbprophet导入prophet</p><p id="a60c" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#将数据分成训练集和测试集<br/>train _ to _ index = round(len(df)* 0.95)<br/>train _ data = df . iloc[:train _ to _ index]<br/>test _ data = df . iloc[train _ to _ index:]</p><p id="16f1" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">print('训练数据长度'，len(训练数据)，'测试数据长度'，len(测试数据))</p></blockquote><p id="6491" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们创建了先知模型的一个实例。由于我们的数据图显示了指数趋势，即数据在一段时间内增长的一般趋势，我们将输入参数seasonality _ mode设置为“乘法”和“线性”因为我们的数据是基于每日频率的，所以我们设置daily _ seasonality = True。调整参数changepoint_prior_scale将其设置为0.5。接下来，我们在训练集上训练我们的模型。此外，可以基于数据集和问题域调整参数调整。</p><p id="936f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用频率设置为“D”的“make_future_dataframe”生成一个包含未来日期的数据框，用于预测，因为我们的数据是每日数据。这些日期的长度被设置为与测试集的长度相同，因为我们将在稍后比较模型评估的结果。然后将数据帧传递给我们的模型，以预测这些日期的值。</p><blockquote class="nd ne nf"><p id="06c8" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#创建模型并在训练集上训练<br/>model = Prophet(growth = ' linear '，<br/>季节性_模式= '乘法'，<br/> changepoint_prior_scale=0.5，<br/>weekly _季节性=False，<br/>daily _季节性= True)<br/>model . fit(train _ data)</p><p id="c785" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#生成具有未来日期的数据帧，频率设置为每日<br/>future = model . make _ future _ data frame(periods = len(test _ data)，freq='D ')</p><p id="afb5" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#预测未来日期的值<br/>预测=模型.预测(未来)</p></blockquote><h1 id="4a1b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">绘制模型结果</h1><p id="c066" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">既然我们的模型已经训练好了，我们需要可视化结果。Prophet有一个名为plot的绘图功能，可以绘制原始数据(黑点)、模型(蓝线)和预测误差(蓝色阴影区域)。</p><blockquote class="nd ne nf"><p id="6729" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#plot模型结果<br/> m.plot(预测)；</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/a9c0a00bbc28b60e1c3814dbf2f23bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viMgGlw0J9X2q0Ael81NTQ.png"/></div></div></figure><h1 id="e619" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">模型评估</h1><p id="d2d7" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">为了帮助我们了解预测的准确性，我们将时间序列的预测病例数与实际病例数进行了比较。为此，我们需要使用来自预测的“yhat”和来自数据的原始“y”值构建一个组合数据框架。</p><blockquote class="nd ne nf"><p id="fc33" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#生成组合数据帧<br/>metric _ df = forecast . set _ index(' ds ')[[' yhat ']]。join(df.set_index('ds ')。y)。reset _ index()<br/>metric _ df . tail()</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/488038123d87397c516b6c3bb165a60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*sXIQRI6YrFPHiNeKvvwLlw.png"/></div></figure><p id="6d87" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们有了预测值和真实值的对比，我们使用sci-kit-learn中的r2_score()来生成我们的R平方。决定系数(用R2表示)被解释为可从自变量预测的因变量方差的比例。</p><p id="4988" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最好的可能得分是1.0，因此0.99的值对于我们的模型来说是非常好的。</p><blockquote class="nd ne nf"><p id="3ca9" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">从sklearn.metrics导入r2_score</p><p id="7fb0" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">r2_score(metric_df.y，metric_df.yhat)</p></blockquote><p id="be21" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，我们使用scikit-learn的mean_squared_error()来评估我们的结果。均方误差(MSE)是所有(预测值-实际值)的平方和除以数据点数。MSE是对估计量质量的一种度量。MSE越小，我们就越接近找到最佳拟合线。我们的MSE值是4455269，这是一个相当大的值，这意味着仍然有进一步改进的空间，可以对模型或更多数据使用超参数调整来获得更好的结果。</p><blockquote class="nd ne nf"><p id="8486" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">从sklearn.metrics导入均方误差</p><p id="4031" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">均方误差(metric_df.y，metric_df.yhat)</p></blockquote><h1 id="58cb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">预测未来日期</h1><p id="0492" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">在前面的章节中，我们根据已经有的测试数据日期的预测来评估我们的模型。现在，我们需要构建一些未来日期来进行预测。为了预测这些未来数据，我们生成一个包含未来10天的数据框架，然后通过Prophet模型的“预测”功能运行它，并显示结果。</p><blockquote class="nd ne nf"><p id="e93b" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#生成具有未来日期的数据帧，频率设置为每日<br/>future = m . make _ future _ data frame(periods = 10，freq = 'D ')</p><p id="20e5" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#预测未来日期的值<br/> forecast = m.predict(future)</p><p id="8799" class="kv kw ng kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">#仅打印所需的列ds、yhat、yhat_lower、yhat_upper <br/>预测[['ds '、' yhat '、' yhat_lower '、' yhat_upper']]。尾巴(10)</p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ns"><img src="../Images/fcf438cf806ed84dae45f709249e94f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8Qu_V5RrazkYxZCN1QDkw.png"/></div></div></figure><h1 id="271f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="efe5" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">我们已经解释了如何使用来自约翰霍普金斯大学中心的冠状病毒(Covid19)数据用Prophet进行时间序列预测。我们经历了加载数据、为Prophet模型准备数据、绘制数据、训练模型、绘制模型结果、模型评估和预测未来日期。我们注意到，不可能对所有的预测问题都提出一个通用的方法，因为每个问题都有其自身的特点，需要特殊的步骤。然而，本文旨在给出一个关于时间序列预测的基本指南和理解，可以根据问题领域进一步修改。</p><h1 id="e882" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">参考资料和进一步阅读</h1><p id="b46a" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">[1]<a class="ae nc" href="https://github.com/CSSEGISandData/COVID-19" rel="noopener ugc nofollow" target="_blank">https://github.com/CSSEGISandData/COVID-19</a><br/>【2】<a class="ae nc" href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/prophet/docs/quick_start.html</a><br/>【3】<a class="ae nc" href="https://nextjournal.com/eric-brown/forecasting-with-prophet" rel="noopener ugc nofollow" target="_blank">https://nextjournal.com/eric-brown/forecasting-with-prophet</a><br/>【4】<a class="ae nc" href="https://nextjournal.com/eric-brown/forecasting-with-prophet-part-4" rel="noopener ugc nofollow" target="_blank">https://next journal . com/Eric-brown/forecasting-with-prophet-part-4</a><br/>【5】<a class="ae nc" href="https://towardsdatascience.com/implementing-facebook-prophet-efficiently-c241305405a3" rel="noopener" target="_blank">https://towards data science . com/implementing-Facebook-prophet-efficient-c 241305405 a3</a></p></div></div>    
</body>
</html>