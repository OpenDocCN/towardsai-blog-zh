<html>
<head>
<title>Perceptron: A Basic Neural Network Model for Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">感知器:深度学习的基本神经网络模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/perceptron-a-basic-neural-network-model-for-deep-learning-21aea56e3216?source=collection_archive---------0-----------------------#2021-09-20">https://pub.towardsai.net/perceptron-a-basic-neural-network-model-for-deep-learning-21aea56e3216?source=collection_archive---------0-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2fe2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="c4b7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">二元类的分类方法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/9e988762d14642b06f1a2e7d74dfcb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*1Fvs7xlgf1p_D_EZmm5_vg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图片<a class="ae ld" href="https://www.javatpoint.com/single-layer-perceptron-in-tensorflow" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><blockquote class="le lf lg"><p id="3fc8" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">感知器</em> </strong></p></blockquote><p id="57dc" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">在过去的十年里，世界见证了机器和深度学习技术的爆炸，从个性化的世界到无处不在的专业活动。有了这些技术，我相信你一定听说过或读过神经网络中的术语“感知机”,这是人们可能开始学习神经网络的第一个概念。因此，通过这篇文章，我的重点是展示什么是感知器及其工作。</p><p id="75ad" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">美国科学家罗森布拉特深受生物神经元及其学习能力的启发，他在1957年左右引入了感知机这个术语。罗森布拉特的感知器有一个或多个输入，只有一个输出和一个处理器。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/b85101e1ba38c6228870718d00ab6dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*beJf1LRjp97nHPMYprd38Q.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图片<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="3c59" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">感知器的组件包括:输入、权重和偏差、权重和激活函数。让我们考虑单个<strong class="lk jd">神经元</strong>和三个输入(<strong class="lk jd"> x1 <em class="lj">，</em> x2，x3) </strong>分别乘以权重<strong class="lk jd"> (w1，w2，w3)</strong>，如图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/942064a8b49ff099eecc3ba6c8d2026d.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*-tdD7wlgzSoDHQaoXHPO4w.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图像<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="1a66" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">产生的输出将由神经元内部的函数给出，该函数使用带有权重的数值(输入)。现在问题来了，这个函数是什么？</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="ffef" class="mo mp it mk b gy mq mr l ms mt">y = x1w1 + x2w2 + x3w3</span></pre><p id="ccb3" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">这个函数称为加权和，因为它是权重和输入的和，在激活函数的帮助下，我们可以将输出设置在某个范围内，比如0到1。这只能通过激活函数来完成，激活函数可以根据提供的一组规则将输入转换为某个输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/4824734c2b3f71e2d2f059e0bcf01fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*dcA9oSvnBCj2n8Ps5FrOgA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图片<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><blockquote class="le lf lg"><p id="c10d" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">激活功能类型</em> </strong></p></blockquote><ol class=""><li id="62f4" class="mv mw it lk b ll lm lo lp me mx mf my mg mz md na nb nc nd bi translated"><strong class="lk jd">逻辑函数:</strong>这种类型的激活函数用于我们想要输出从0到1的数字。</li><li id="b4c7" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md na nb nc nd bi translated"><strong class="lk jd">双曲正切:</strong>该激活函数用于产生类似于从-1到1的数字的输出。</li></ol><p id="631d" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated"><strong class="lk jd">物流功能</strong></p><p id="e6c3" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">物流功能的公式，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5248c01ec27afd3e13625e6a3fae4e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*FfID6ildaSfqC-yLUH1VyQ.png"/></div></figure><p id="4f9e" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">图表看起来是这样的，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/98aec945edc7c82baee97dbd92d57fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*hIdaoxl5sOetSAtlqQ0a3A.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图像<a class="ae ld" href="http://Graph source by Geek3 from WIKIMEDIA COMMONS." rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="47be" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">看看点g(z ),它位于0和1之间，并且是非线性的。很明显，激活函数既适用于线性图，也适用于非线性图。现在，关于感知器，我们需要知道的最后一件事是偏见。偏差是产生输出之前的一个阈值，它告诉感知器必须到达哪里。因此，最终的神经元方程如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/25a723ee30366592241af4a7eef8db37.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*kfJTSvDRVH9J_tGTZCXxDw.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b6a00873c16427c2f842d46b8509a8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*nOF9Af6UVaTkE4OaHxWHlA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图片<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="3272" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">请注意，激活函数采用输入和偏差的加权和来创建单个单位输出，当使用逻辑函数时，输出将在0和1之间可用。</p><blockquote class="le lf lg"><p id="511f" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">为什么要用感知器？</em> </strong></p></blockquote><p id="f9f9" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">众所周知，感知器是神经网络的构建模块，通常用于二进制分类器的监督学习。这可以借助一个非常著名的例子来解释。让我们用一个简单的感知器，我们有某些输入值，如<strong class="lk jd"> x </strong>和<strong class="lk jd"> y，</strong>然后乘以权重得到<strong class="lk jd"> wx </strong>和<strong class="lk jd"> wy </strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b35c05a6a68a6ad7c6db0145e763eed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*vDbIwzXBxjW3p8ZFQjc_3w.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图像<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="aa89" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">现在，让我们创建一个图表，用红点和蓝点表示两种不同类别的数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/cbea1218254185d44b120a557435ad0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*uBQ4NVvcwcZfKDE0Y056ww.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图像<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="83bb" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">注意图中x轴标注在输入<strong class="lk jd"> x </strong>之后，y轴标注在输入<strong class="lk jd"> y </strong>之后。</p><p id="c04a" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">为了区分蓝点和红点类别，我们需要划分数据。</p><p id="e7a6" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">感知器将能够为分类(二进制)创建决策边界，其中决策边界区域在图上分隔不同的数据点。</p><p id="7880" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">现在我们看到激活函数的工作，输入值和权重如下所示:</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="2b3f" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk jd">wx </strong>= -0.5<br/><strong class="mk jd">wy </strong>= 0.5<br/>b = 0</span></pre><p id="ddc2" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">现在感知器的功能是:</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="fc76" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk jd">0.5x + 0.5y = 0</strong></span></pre><p id="6357" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">该图将如右图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/229d2764693e954e4992bac4bf1ad158.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*dLlfQd1uMcgH1miiDZTL8w.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图片<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="41d9" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">我们知道激活函数将产生0和1之间的输出。因此，在这种情况下，函数可以为蓝点生成1，为红点生成0。</p><p id="81dd" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">数学上我们可以这样理解:</p><ul class=""><li id="1a90" class="mv mw it lk b ll lm lo lp me mx mf my mg mz md nq nb nc nd bi translated">如果0.5x + 0.5y =&gt; 0，则蓝点产生1。</li><li id="4f1f" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">如果0.5x + 0.5y &lt; 0，则对红点产生0。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1e4ebac4c41f7adf8806facac873db8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*QUgqtuPyUeJmz-L2mXtouA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">图像<a class="ae ld" href="https://towardsdatascience.com/what-is-a-perceptron-basics-of-neural-networks-c4cfea20c590" rel="noopener" target="_blank">来源</a></figcaption></figure><p id="90b6" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">现在，我们可以说，感知器也可以使用决策边界进行基本分类。</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-cnn-basics-with-a-keras-example-in-python-c1fd6c449935"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">通过Python中的Keras示例了解CNN基础知识</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">用于图像过程分析的深度神经网络算法</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">pub.towardsai.net</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kx nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-optimizers-in-deep-learning-694f4f0eb048"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">理解深度学习中的优化器</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">优化器是机器学习的典范</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">pub.towardsai.net</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj kx nv"/></div></div></a></div><blockquote class="le lf lg"><p id="4f0c" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">感知器python编码与理论概念相扣</em> </strong></p></blockquote><p id="9074" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">感知器的概念是受人脑系统中称为神经元的单个神经细胞的处理的启发。神经元中的信号通过树突传递到细胞体的过程。以同样的方式，人工神经网络中的感知器接收来自训练数据(权重)的输入信号，并将其组合成一个称为激活函数的线性方程。</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="43ec" class="mo mp it mk b gy mq mr l ms mt">activation = sum(weight_i * x_i) + bias</span></pre><p id="24f3" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">该激活函数然后被转换成类似分类的输出值(预测)。</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="5355" class="mo mp it mk b gy mq mr l ms mt">predictionvalue = 1.0 if activation &gt;= 0.0 else 0.0</span></pre><p id="aa01" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">因此，感知器是针对两类(0 &amp; 1)问题的两遍分类算法。</p><p id="8a7c" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">在随机梯度下降的帮助下，感知器算法的权重必须从您的训练数据中估计，然后在每次迭代中，使用下面给出的等式更新权重(<strong class="lk jd"> w </strong>):</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="2ea6" class="mo mp it mk b gy mq mr l ms mt">w = w + learning_rate * (expected — predicted) * x</span></pre><p id="41ab" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">人们可以在使用该算法时下载声纳数据集，文件名为<strong class="lk jd"> sonar.all-data.csv </strong></p><p id="3802" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated"><strong class="lk jd">在实现感知器时，我们通常需要给出三个步骤:</strong></p><ol class=""><li id="2afb" class="mv mw it lk b ll lm lo lp me mx mf my mg mz md na nb nc nd bi translated">做预测</li><li id="3c98" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md na nb nc nd bi translated">训练网络权重</li><li id="f070" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md na nb nc nd bi translated">建模数据集</li></ol><h2 id="6147" class="mo mp it bd ol om on dn oo op oq dp or me os ot ou mf ov ow ox mg oy oz pa iz bi translated"><strong class="ak">做出预测</strong></h2><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="0d43" class="mo mp it mk b gy mq mr l ms mt"># Make a prediction with weights</span><span id="d6b3" class="mo mp it mk b gy pb mr l ms mt">def predict(row, weights):<br/>    activation_value = weights[0]<br/>    for i in range(len(row)-1):<br/>        activation += weights[i + 1] * row[i]<br/>    return 1.0 if activation_value &gt;= 0.0 else 0.0</span><span id="fedc" class="mo mp it mk b gy pb mr l ms mt">#output:<br/>X1             X2           Y<br/>2.7810836     2.550537003   0<br/>1.465489372   2.362125076   0<br/>3.396561688   4.400293529   0<br/>1.38807019    1.850220317   0<br/>3.06407232    3.005305973   0<br/>7.627531214   2.759262235   1<br/>5.332441248   2.088626775   1<br/>6.922596716   1.77106367    1<br/>8.675418651   -0.242068655  1<br/>7.673756466   3.508563011   1</span></pre><p id="217f" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">我们使用一个小数据集来测试我们的预测。</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="3065" class="mo mp it mk b gy mq mr l ms mt"># Make a prediction with weights</span><span id="ffbb" class="mo mp it mk b gy pb mr l ms mt">def predict(row, weights):<br/>    activation_value = weights[0]<br/>    for i in range(len(row)-1):<br/>        activation += weights[i + 1] * row[i]<br/>    return 1.0 if activation_value &gt;= 0.0 else 0.0</span></pre><p id="2971" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">两个输入值x1 &amp; x2和三个权重值<strong class="lk jd">偏差</strong>、<strong class="lk jd"> w1 </strong>和<strong class="lk jd"> w2 </strong>。我们对这些数据采用的激活方程。</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="03c2" class="mo mp it mk b gy mq mr l ms mt"># Estimate Perceptron weights using SGD</span><span id="3b88" class="mo mp it mk b gy pb mr l ms mt">def train_weights(train, l_rate, n_epoch):<br/>    weights_values = [0.0 for i in range(len(train[0]))]<br/>    for epoch in range(n_epoch):<br/>        sum_error = 0.0<br/>        for row in train:<br/>            prediction = predict(row, weights_values)<br/>            error = row[-1] - prediction<br/>            sum_error += error**2<br/>            weights[0] = weights[0] + l_rate * error<br/> <br/>            for i in range(len(row)-1):<br/>                weights[i + 1]=weights_values[i +<br/>                          1]+l_rate*error*row[i]</span><span id="1f59" class="mo mp it mk b gy pb mr l ms mt">        print('&gt;epoch=%d, lrate=%.3f, error=%.3f' % (epoch, l_rate<br/>                                                      , sum_error))</span><span id="ca01" class="mo mp it mk b gy pb mr l ms mt">    return weights_values</span></pre><p id="2969" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">使用SGD，我们在上面的函数中计算权重值。</p><pre class="ks kt ku kv gt mj mk ml mm aw mn bi"><span id="d0f1" class="mo mp it mk b gy mq mr l ms mt"># Make a prediction with weights</span><span id="3b7f" class="mo mp it mk b gy pb mr l ms mt">def predict(row, weights):<br/>    activation_values = weights[0]<br/>    for i in range(len(row)-1):<br/>        activation += weights[i + 1] * row[i]<br/>    return 1.0 if activation_values &gt;= 0.0 else 0.0</span><span id="8471" class="mo mp it mk b gy pb mr l ms mt"># Using SGD to estimate weights</span><span id="f923" class="mo mp it mk b gy pb mr l ms mt">def train_weights(train, l_rate, n_epoch):</span></pre><blockquote class="le lf lg"><p id="d9e8" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">感知器模型的应用</em> </strong></p></blockquote><ul class=""><li id="29f0" class="mv mw it lk b ll lm lo lp me mx mf my mg mz md nq nb nc nd bi translated">分类类型应用</li><li id="bd97" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">文本分类和信息提取</li><li id="ece0" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">形象化</li><li id="5071" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">语义分析</li><li id="0951" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">数据压缩</li><li id="b738" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">加密等等。</li></ul><blockquote class="le lf lg"><p id="80bb" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">感知器的局限性</em> </strong></p></blockquote><ul class=""><li id="bdbd" class="mv mw it lk b ll lm lo lp me mx mf my mg mz md nq nb nc nd bi translated">由于传递函数有限，感知器模型可以输出1或0。</li><li id="f426" class="mv mw it lk b ll ne lo nf me ng mf nh mg ni md nq nb nc nd bi translated">通常，这些模型只对向量的线性集合进行分类。</li></ul><blockquote class="le lf lg"><p id="50d0" class="lh li lj lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">结论</em> </strong></p></blockquote><p id="0c45" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">感知器是单层人工神经网络的模型，其用于二进制分类(两类)的监督学习，或者还可以执行某些计算，以通过给出单个输出来检测包括权重和偏差在内的多输入数据中的特征。</p><p id="4da0" class="pw-post-body-paragraph lh li it lk b ll lm kd ln lo lp kg lq me ls lt lu mf lw lx ly mg ma mb mc md im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae ld" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ld" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="bb0a" class="pc mp it bd ol pd pe pf oo pg ph pi or ki pj kj ou kl pk km ox ko pl kp pa pm bi translated">推荐文章</h1><p id="e0f2" class="pw-post-body-paragraph lh li it lk b ll pn kd ln lo po kg lq me pp lt lu mf pq lx ly mg pr mb mc md im bi translated">1.<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b?source=friends_link&amp;sk=4a5c9f9ad552005636ae720a658281b1"> 8主动学习Python见解收集模块</a> <br/> 2。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a> <br/> 3。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff?source=friends_link&amp;sk=11c6809f6623dd4f6dd74d43727297cf">熊猫:处理分类数据</a> <br/> 5。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/hyper-parameters-randomseachcv-and-gridsearchcv-in-machine-learning-b7d091cf56f4?source=friends_link&amp;sk=cab337083fb09601114a6e466ec59689">超参数:机器学习中的RandomSeachCV和GridSearchCV</a><br/>6。<a class="ae ld" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python充分解释了线性回归</a> <br/> 7。<a class="ae ld" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/data-distribution-using-numpy-with-python-3b64aae6f9d6?source=friends_link&amp;sk=809e75802cbd25ddceb5f0f6496c9803">使用Numpy与Python </a> <br/> 9进行数据分发。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/decision-trees-vs-random-forests-in-machine-learning-be56c093b0f?source=friends_link&amp;sk=91377248a43b62fe7aeb89a69e590860">机器学习中的决策树vs随机森林</a> <br/> 10。<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/standardization-in-data-preprocessing-with-python-96ae89d2f658?source=friends_link&amp;sk=f348435582e8fbb47407e9b359787e41">用Python实现数据预处理的标准化</a></p></div></div>    
</body>
</html>