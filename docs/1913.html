<html>
<head>
<title>A Primer on Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js入门</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-primer-on-node-js-ff518b78d330?source=collection_archive---------0-----------------------#2021-06-12">https://pub.towardsai.net/a-primer-on-node-js-ff518b78d330?source=collection_archive---------0-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d8b4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="eb02" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">这篇文章足以让您创建和使用基于节点的web服务器，进行CRUD操作，等等。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/45373375af38e940921fe9b9b095b323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oi6ds3ZFv8NJ95Pf.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来源——【https://en.wikipedia.org/wiki/Node.js T2】</figcaption></figure><h1 id="49f3" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">目录:</h1><h2 id="4940" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.<a class="ae le" href="#ff8a" rel="noopener ugc nofollow">入门</a></h2><ul class=""><li id="843f" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#a1fa" rel="noopener ugc nofollow">什么是节点</a></li><li id="ab8d" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#0969" rel="noopener ugc nofollow">节点架构</a></li><li id="0505" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#3cf5" rel="noopener ugc nofollow">节点如何工作</a></li><li id="c9cf" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#d092" rel="noopener ugc nofollow">安装节点</a></li><li id="2377" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#114d" rel="noopener ugc nofollow">第一个节点程序</a></li></ul><h2 id="79b1" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.<a class="ae le" href="#576e" rel="noopener ugc nofollow">节点模块系统</a></h2><ul class=""><li id="fb1d" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#cd43" rel="noopener ugc nofollow">全局对象</a></li><li id="3665" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#c412" rel="noopener ugc nofollow">模块</a></li><li id="5789" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#a80a" rel="noopener ugc nofollow">创建模块</a></li><li id="e10d" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#35af" rel="noopener ugc nofollow">装载一个模块</a></li><li id="5f71" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#05bc" rel="noopener ugc nofollow">模块包装函数</a></li><li id="9a51" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#e22c" rel="noopener ugc nofollow">路径模块</a></li><li id="d576" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#2320" rel="noopener ugc nofollow">操作系统模块</a></li><li id="8857" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#dfb8" rel="noopener ugc nofollow">事件模块</a></li><li id="9be1" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#ff17" rel="noopener ugc nofollow">事件论据</a></li><li id="93ed" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#bd04" rel="noopener ugc nofollow">文件系统模块</a></li><li id="7cdf" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#5d20" rel="noopener ugc nofollow"> HTTP模块</a></li></ul><h2 id="7a11" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.<a class="ae le" href="#9b4f" rel="noopener ugc nofollow">节点包管理器</a></h2><ul class=""><li id="5385" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#c0b2" rel="noopener ugc nofollow"> package.json </a></li><li id="2dbf" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#bd96" rel="noopener ugc nofollow">安装一个节点包</a></li><li id="7807" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#c901" rel="noopener ugc nofollow">使用一个包</a></li><li id="7053" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#fd8a" rel="noopener ugc nofollow">包依赖关系</a></li><li id="2f22" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#d2c2" rel="noopener ugc nofollow"> NPM软件包和源代码管理</a></li><li id="28f2" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#21ac" rel="noopener ugc nofollow">语义版本</a></li><li id="3677" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#14d0" rel="noopener ugc nofollow">列出所有已安装的软件包</a></li><li id="8f6f" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#adee" rel="noopener ugc nofollow">查看软件包的注册表信息</a></li><li id="10a1" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#886a" rel="noopener ugc nofollow">安装特定版本的软件包</a></li><li id="70e0" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#e406" rel="noopener ugc nofollow">更新本地包</a></li><li id="c813" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#5d24" rel="noopener ugc nofollow"> DevDependencies </a></li><li id="43b8" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#56df" rel="noopener ugc nofollow">卸载软件包</a></li><li id="d186" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#fb24" rel="noopener ugc nofollow">使用全局包</a></li><li id="9964" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#2ece" rel="noopener ugc nofollow">发布一个包</a></li><li id="5e6b" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#ef69" rel="noopener ugc nofollow">更新已发布的包</a></li></ul><h2 id="7373" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.<a class="ae le" href="#8810" rel="noopener ugc nofollow">使用Express构建RESTful APIs】</a></h2><ul class=""><li id="7f12" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#e717" rel="noopener ugc nofollow"> RESTful服务</a></li><li id="426c" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#1d00" rel="noopener ugc nofollow">介绍快递</a></li><li id="bedb" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#d810" rel="noopener ugc nofollow">构建您的第一个Web服务器</a></li><li id="1860" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#6aef" rel="noopener ugc nofollow">节点门</a></li><li id="3fb5" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#ab3d" rel="noopener ugc nofollow">环境变量</a></li><li id="aa4d" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#854f" rel="noopener ugc nofollow">路线参数</a></li><li id="fd14" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#c6b5" rel="noopener ugc nofollow">处理HTTP GET请求</a></li><li id="3caa" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#d6c5" rel="noopener ugc nofollow">处理HTTP POST请求</a></li><li id="68ef" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#f37a" rel="noopener ugc nofollow">使用Postman或Thunder客户端调用端点</a></li><li id="6028" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#2ee0" rel="noopener ugc nofollow">输入验证</a></li><li id="5f3b" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#48e2" rel="noopener ugc nofollow">处理HTTP上传请求</a></li><li id="df98" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#e98b" rel="noopener ugc nofollow">处理HTTP删除请求</a></li></ul><h2 id="c360" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.<a class="ae le" href="#d465" rel="noopener ugc nofollow">表达高级话题</a></h2><ul class=""><li id="3cce" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#cc8d" rel="noopener ugc nofollow">中间件</a></li><li id="d6f6" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#ffdf" rel="noopener ugc nofollow">创建定制中间件</a></li><li id="0a96" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#835e" rel="noopener ugc nofollow">内置中间件</a></li><li id="c7bb" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#7841" rel="noopener ugc nofollow">第三方中间件</a></li><li id="6f9e" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#0f52" rel="noopener ugc nofollow">环境变量</a></li><li id="15d8" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#3aad" rel="noopener ugc nofollow">配置</a></li><li id="2341" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#2cb1" rel="noopener ugc nofollow">调试</a></li><li id="a91d" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#70a5" rel="noopener ugc nofollow">模板引擎</a></li><li id="728e" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#cb39" rel="noopener ugc nofollow">构建代码</a></li></ul><h2 id="03dd" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.<a class="ae le" href="#f86b" rel="noopener ugc nofollow">异步JavaScript </a></h2><ul class=""><li id="26a0" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#f8dd" rel="noopener ugc nofollow">异步与同步代码</a></li><li id="20fd" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#6bee" rel="noopener ugc nofollow">处理异步代码的模式</a></li><li id="62f8" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#3819" rel="noopener ugc nofollow">回调</a></li><li id="3222" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#3150" rel="noopener ugc nofollow">承诺</a></li><li id="e008" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#da60" rel="noopener ugc nofollow">用承诺代替回调</a></li><li id="11cf" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#1d39" rel="noopener ugc nofollow">办理并联承诺</a></li><li id="0253" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#9f51" rel="noopener ugc nofollow">异步&amp;等待</a></li></ul><h2 id="efdf" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.用猫鼬进行CRUD操作</h2><ul class=""><li id="a958" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#94cb" rel="noopener" target="_blank">简介</a></li><li id="b328" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#0e3d" rel="noopener" target="_blank">设置MongoDB (NoSQL) </a></li><li id="a6dc" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#bf3b" rel="noopener" target="_blank">同步与异步执行</a></li><li id="23b5" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#1141" rel="noopener" target="_blank">创建模式、模型、对象</a></li><li id="8eb2" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#dc7d" rel="noopener" target="_blank">创建(同步)</a></li><li id="c80f" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#1018" rel="noopener" target="_blank">创建(异步)</a></li><li id="3cd7" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#fae5" rel="noopener" target="_blank">改为(同步)</a></li><li id="b587" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#8677" rel="noopener" target="_blank">读取(异步)</a></li><li id="51b4" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#fbf2" rel="noopener" target="_blank">更新(同步)</a></li><li id="3638" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#42ca" rel="noopener" target="_blank">更新(异步)</a></li><li id="43ce" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#d25a" rel="noopener" target="_blank">删除(同步)</a></li><li id="4ffc" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#d4a6" rel="noopener" target="_blank">更新(异步)</a></li><li id="1b5c" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24#fb6b" rel="noopener" target="_blank">资源&amp;引用</a></li></ul><h2 id="68bd" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.<a class="ae le" href="#7e55" rel="noopener ugc nofollow"> Mongo数据验证</a></h2><ul class=""><li id="20fc" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#9a52" rel="noopener ugc nofollow">验证</a></li><li id="80a0" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#832b" rel="noopener ugc nofollow">内置验证器</a></li><li id="a1ec" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#e933" rel="noopener ugc nofollow">自定义验证器</a></li><li id="191a" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#4a91" rel="noopener ugc nofollow">异步验证器</a></li><li id="7e9b" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#3c0b" rel="noopener ugc nofollow">验证错误</a></li><li id="bb00" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#94bb" rel="noopener ugc nofollow">模式类型选项</a></li></ul><h2 id="9d1a" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">9.<a class="ae le" href="#a699" rel="noopener ugc nofollow">认证&amp;授权</a></h2><ul class=""><li id="35a6" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#be5f" rel="noopener ugc nofollow">简介</a></li><li id="0dbc" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#f42c" rel="noopener ugc nofollow">创建用户模型模式</a></li><li id="984b" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#1b10" rel="noopener ugc nofollow">注册用户</a></li><li id="593b" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#1867" rel="noopener ugc nofollow">使用Lodash </a></li><li id="1e65" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#97ed" rel="noopener ugc nofollow">哈希密码</a></li><li id="0338" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#af03" rel="noopener ugc nofollow">认证用户</a></li><li id="e6cf" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#8539" rel="noopener ugc nofollow"> JSON Web令牌(JWT) </a></li><li id="f159" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#275e" rel="noopener ugc nofollow">生成认证令牌</a></li><li id="dff5" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#5d2d" rel="noopener ugc nofollow">设置响应头</a></li><li id="8a47" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#ecb4" rel="noopener ugc nofollow">授权中间件</a></li><li id="6aca" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#60a8" rel="noopener ugc nofollow">获取当前用户</a></li></ul><h2 id="60a5" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">10.<a class="ae le" href="#9abd" rel="noopener ugc nofollow">处理和记录错误</a></h2><ul class=""><li id="2a11" class="ml mm iq mn b mo mp mq mr mc ms mf mt mi mu mv mw mx my mz bi translated"><a class="ae le" href="#4064" rel="noopener ugc nofollow">拒绝承诺的处理</a></li><li id="15f4" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#411c" rel="noopener ugc nofollow">快递错误中间件</a></li><li id="7390" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#23a6" rel="noopener ugc nofollow">使用快速异步错误</a></li><li id="5688" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#d412" rel="noopener ugc nofollow">记录错误</a></li><li id="d01d" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#0932" rel="noopener ugc nofollow">记录到MongoDB </a></li><li id="6ae8" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#6274" rel="noopener ugc nofollow">处理未捕获的异常</a></li><li id="3a8a" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#d03a" rel="noopener ugc nofollow">未处理的承诺拒绝</a></li><li id="a4f0" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv mw mx my mz bi translated"><a class="ae le" href="#539c" rel="noopener ugc nofollow">代码重构</a></li></ul><h2 id="3820" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated"><a class="ae le" href="#fc01" rel="noopener ugc nofollow">参考文献&amp;资源</a></h2><p id="ffb8" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">包含所有与本文相关的代码和依赖项，可以在这里找到:<a class="ae le" href="https://github.com/bala-codes/A-Primer-on-Node.js" rel="noopener ugc nofollow" target="_blank">https://github.com/bala-codes/A-Primer-on-Node.js</a></p><p id="96df" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">大多数部分都包含后续工作所需的代码块，如果您想在执行过程中也执行这些代码，可以克隆repo。</p><p id="9ef8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">软件包列表存在于相应目录下的package.json文件中，并使用<code class="fe nx ny nz oa b">npm install</code>进行安装</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="ff8a" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">一.开始</h1><h2 id="a1fa" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.什么是节点</h2><p id="f155" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">节点是一个在浏览器外执行JavaScript代码的运行时环境。它通常用于构建后端服务，如支持Web应用程序、移动应用程序等的API。在生产环境中，它也是超快的和高度可伸缩的。除此之外，它还可以快速构建，与其他后端服务相比需要更少的代码行，更少的文件，可以处理更多的请求，并提供更快的响应时间。</p><h2 id="0969" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.节点架构</h2><p id="d954" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">每一个javascript代码都需要一个javascript引擎将其转换成机器代码，以供机器理解和代码执行。浏览器提供了运行时环境。</p><p id="aadd" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">Node使用Google构建的一个名为V8 engine +其他模块的javascript引擎来处理node.js程序。</p><p id="c3dc" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">同样，node不是一个框架，它只是一个用于执行javascript代码的运行时环境。</p><h2 id="3cf5" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.节点如何工作</h2><p id="ca6d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">Node是高度可扩展的、数据密集型的，并且可以创建实时应用。这是因为非阻塞(异步)的操作形式。</p><p id="11f7" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">这意味着单个线程异步地服务/处理多个请求。请求可以是从数据库获取一段数据或执行任何HTTP动词，因为它们不等待任何请求完成，所以是高效的。</p><p id="5aa8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">你可能会问，线程先前发起的请求的响应发生了什么，这些响应被送入一个叫做事件队列的东西，节点不断地监视事件队列，当它在事件队列中发现任何消息时，它就处理它。<br/> Node是I/O密集型应用的理想选择，而不是需要更多时间来执行计算的CPU密集型操作。</p><h2 id="d092" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.安装节点</h2><p id="ab68" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">从<a class="ae le" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">这里</a>下载最新的节点版本。</p><p id="1ded" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在运行安装程序，通过运行<code class="fe nx ny nz oa b">node --version</code>打开CMD来检查版本。</p><h2 id="114d" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.第一节点程序</h2><p id="ca83" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">创建一个新文件app.js .显然是一个Hello World</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="6fcb" class="lx lg iq oa b gy or os l ot ou">function greet(){<br/>     console.log('Hello World');<br/>}</span><span id="3fd1" class="lx lg iq oa b gy ov os l ot ou">greet()</span></pre><p id="c72e" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在CMD中运行程序，<code class="fe nx ny nz oa b">node app.js</code></p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="576e" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">二。节点模块系统</h1><h2 id="cd43" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.全局对象</h2><p id="ee6c" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">在node anywhere中可以访问一些对象和函数。其中一些是</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="88c7" class="lx lg iq oa b gy or os l ot ou">console.log() (or) global.console.log()</span><span id="53d9" class="lx lg iq oa b gy ov os l ot ou">setTimeout()<br/>clearTimeout()</span><span id="dcdf" class="lx lg iq oa b gy ov os l ot ou">setInterval()<br/>clearInterval()</span></pre><p id="c2a2" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">它们被称为全局对象。</p><h2 id="c412" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.模块</h2><p id="07bd" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有一个冲突，在不同的node.js程序中声明了两个具有相同函数名的函数，它们会产生全局冲突。</p><p id="88d9" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，为了解决这个问题并使代码更简洁，我们使用了模块，我们可以在这些模块中定义相同的变量或函数，并相应地调用它们。</p><p id="dcaa" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">节点应用程序中的每个文件都被视为一个模块。文件中定义的变量或函数是作用域。默认情况下，它们在文件之外是不可见的，我们需要显式导出它们。</p><h2 id="a80a" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.创建模块</h2><p id="dbbf" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">让我们创建一个简单的模块来发送HTTP请求。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="25da" class="lx lg iq oa b gy or os l ot ou">```<br/>first_module.js <br/>```</span><span id="0e81" class="lx lg iq oa b gy ov os l ot ou">var url = 'https://google.com'</span><span id="c305" class="lx lg iq oa b gy ov os l ot ou">function get(message){<br/>     // Send a HTTP request<br/>     { ... }<br/>     console.log(message)<br/>}</span><span id="096f" class="lx lg iq oa b gy ov os l ot ou">// Make get function available outside the program</span><span id="d327" class="lx lg iq oa b gy ov os l ot ou">module.exports = get;</span></pre><h2 id="35af" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.加载模块</h2><p id="ec0e" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在，让我们加载上一步中导出的模块。确保上述文件和当前文件在同一个文件夹中。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="ae9e" class="lx lg iq oa b gy or os l ot ou">```<br/>app.js<br/>```</span><span id="414f" class="lx lg iq oa b gy ov os l ot ou">const get_method = require('./first_module')</span><span id="9878" class="lx lg iq oa b gy ov os l ot ou">console.log(get_method('Some message'))<br/></span></pre><h2 id="05bc" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.模块包装函数</h2><p id="e634" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">一般来说，节点不直接执行我们的代码，而是将代码封装在一个函数中，如下所示，然后再导出。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="5dec" class="lx lg iq oa b gy or os l ot ou">(function (exports, require, module, __filename, __dirname){<br/>   '''<br/>      your codes goes here<br/>   '''<br/>})</span></pre><p id="115e" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">这就是node如何包装我们在任何node js程序中编写的函数，并使其在其他地方可用。</p><h2 id="e22c" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.路径模块</h2><p id="ff8e" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有一些非常简单的模块已经内置到节点中，我们可以直接使用它们。所以让我们看看其中的一些。</p><p id="19b5" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">你可以在这里找到所有内置模块<a class="ae le" href="https://nodejs.org/dist/latest-v16.x/docs/api/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3f09" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在让我们来解决路径模块的一些功能。你可以找到所有包含在路径模块中的功能，在这里可以找到<a class="ae le" href="https://nodejs.org/dist/latest-v16.x/docs/api/path.html" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="17fd" class="lx lg iq oa b gy or os l ot ou">'''<br/>   app.js<br/>'''</span><span id="4147" class="lx lg iq oa b gy ov os l ot ou">// Look modules inside core of Node<br/>const path = require('path')</span><span id="e106" class="lx lg iq oa b gy ov os l ot ou">var pathObj = path.parse(__filename);<br/>console.log('pathObj',pathObj)</span><span id="f82f" class="lx lg iq oa b gy ov os l ot ou">// The output will be the properties of the current js file.</span></pre><p id="a385" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">此外，我们还会看到节点中的其他一些模块。</p><h2 id="2320" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.操作系统模块</h2><p id="435e" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">操作系统模块揭示了一些与我们正在运行的这个节点应用程序的操作系统相关的属性。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="a03b" class="lx lg iq oa b gy or os l ot ou">'''<br/>   app.js<br/>'''</span><span id="1d69" class="lx lg iq oa b gy ov os l ot ou">// Look modules inside core of Node<br/>const os = require('os')</span><span id="119a" class="lx lg iq oa b gy ov os l ot ou">var totalMemory = os.totalmem();<br/>var freeMemory = os.freemem();</span><span id="b79b" class="lx lg iq oa b gy ov os l ot ou">console.log('Total Memory', totalMemory);<br/>console.log(`Free Memory: ${freeMemory}`); // ECMAScript 6</span></pre><p id="2d8d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多操作系统内部可用的功能可以在<a class="ae le" href="https://nodejs.org/dist/latest-v16.x/docs/api/os.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="dfb8" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.事件模块</h2><p id="0835" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">事件是表明某事已经发生的信号。</p><p id="6034" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">有很多可用的函数，所以我们研究其中的一些。这里我们简单地创建/注册一个监听器，一旦它被调用，我们就发出消息。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="4030" class="lx lg iq oa b gy or os l ot ou">'''<br/>   app.js<br/>'''</span><span id="c2d7" class="lx lg iq oa b gy ov os l ot ou">// Look modules inside core of Node<br/>const EventEmitter = require('events'); // CLASS --&gt; EventEmitter</span><span id="0f69" class="lx lg iq oa b gy ov os l ot ou">// Since EventEmitter is a Class, let's create a instance of the class to access the methods inside it. </span><span id="300b" class="lx lg iq oa b gy ov os l ot ou">const emitter = new EventEmitter(); // OBJECT --&gt; emitter</span><span id="fa79" class="lx lg iq oa b gy ov os l ot ou">// Register a listener<br/>emitter.on('messageReceived', function() {<br/>   console.log('Received');<br/>});</span><span id="6579" class="lx lg iq oa b gy ov os l ot ou">// Raise an event <br/>emitter.emit('messageReceived');</span></pre><p id="45a1" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">事件中可用的更多功能可以在<a class="ae le" href="https://nodejs.org/dist/latest-v16.x/docs/api/events.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="ff17" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">9.事件参数</h2><p id="f2fc" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">事件是表明某事已经发生的信号。现在将一些事件参数与箭头函数结合起来</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="892b" class="lx lg iq oa b gy or os l ot ou">'''<br/>   app.js<br/>'''</span><span id="9966" class="lx lg iq oa b gy ov os l ot ou">// Look modules inside core of Node<br/>const EventEmitter = require('events'); // CLASS --&gt; EventEmitter</span><span id="6409" class="lx lg iq oa b gy ov os l ot ou">// Since EventEmitter is a Class, let's create a instance of the class to access the methods inside it.</span><span id="be29" class="lx lg iq oa b gy ov os l ot ou">const emitter = new EventEmitter(); // OBJECT --&gt; emitter</span><span id="fd6b" class="lx lg iq oa b gy ov os l ot ou">// Register a listener<br/>emitter.on('messageReceived', (arg) =&gt; {<br/>   console.log('Received', arg);<br/>});</span><span id="8b05" class="lx lg iq oa b gy ov os l ot ou">// Raise an event with arguments<br/>emitter.emit('messageReceived', {id:1 , token:'1234'});</span></pre><h2 id="bd04" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">10.文件系统模块</h2><p id="b3cf" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">如何使用node.js程序处理文件。</p><p id="5f7b" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">使用fs模块，在它下面定义的每个操作都有同步和异步两种执行形式。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="5a60" class="lx lg iq oa b gy or os l ot ou">'''<br/>   app.js<br/>'''</span><span id="4041" class="lx lg iq oa b gy ov os l ot ou">// Look modules inside core of Node<br/>const fs = require('fs');</span><span id="b774" class="lx lg iq oa b gy ov os l ot ou">const files = fs.readdirSync('./') // Synchronous<br/>console.log('Files present under the directory', files)</span><span id="610a" class="lx lg iq oa b gy ov os l ot ou">// Asynchronous Function - provides a callback<br/>fs.readdir('./', function(err, files){<br/>   if (err) console.log('Error', err)<br/>   else console.log('Result', files)<br/>});</span></pre><p id="8985" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">文件系统中更多可用的函数可以在<a class="ae le" href="https://nodejs.org/dist/latest-v16.x/docs/api/fs.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="5d20" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">11.HTTP模块</h2><p id="6024" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">HTTP模块是web应用程序的主干。，在这里我们可以创建一个web服务器并用一个端点来托管它。在这里，我们创建一个运行在本地主机上的小型web服务器。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="a3b4" class="lx lg iq oa b gy or os l ot ou">'''<br/>   app.js<br/>'''</span><span id="3f62" class="lx lg iq oa b gy ov os l ot ou">// Look modules inside core of Node<br/>const http = require('http');</span><span id="f63e" class="lx lg iq oa b gy ov os l ot ou">const server = http.createServer((req, res) =&gt; {<br/>   if (req.url == '/'){<br/>      res.write('Hellow World')<br/>      res.end();<br/>   }<br/>});</span><span id="e751" class="lx lg iq oa b gy ov os l ot ou">// Event Listener<br/>server.on('connection', (socket) =&gt; {<br/>   console.log('New connection')<br/>});</span><span id="c06a" class="lx lg iq oa b gy ov os l ot ou">server.listen(3000); // PORT Number</span><span id="fcff" class="lx lg iq oa b gy ov os l ot ou">console.log('Listening on port 3000...');</span></pre><p id="9171" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">HTTP中可用的更多函数可以在这里找到<a class="ae le" href="https://nodejs.org/dist/latest-v16.x/docs/api/http.html" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="9b4f" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">三。节点程序包管理器</h1><p id="1ef4" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">用于安装第三方软件包的注册表。此外，如果你有任何想法发布自己的模块，那么这是你的地方。</p><p id="1d32" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">检查您的npm版本<code class="fe nx ny nz oa b">npm -v</code></p><p id="ec60" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多关于那个<a class="ae le" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="c0b2" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.package.json</h2><p id="bfbe" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">它基本上是一个JSON文件，包含关于应用程序的基本信息，如名称、版本、描述、依赖关系和其他元数据。</p><p id="febd" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">要启动一个新的应用程序/项目，并通过输入元数据自动创建package.json，请运行命令<code class="fe nx ny nz oa b">npm init</code>。</p><p id="daf1" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">每当我们创建一个新项目时，建议运行上面的命令。</p><p id="86b6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">稍后，如果您想要在您的项目目录中安装软件包，或者如果有人与您共享了该项目，并且您想要安装依赖项，只需运行命令<code class="fe nx ny nz oa b">npm install</code></p><h2 id="bd96" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.安装节点包</h2><p id="8efb" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">你可以在这里找到所有的包<a class="ae le" href="https://www.npmjs.com/search?q=underscore" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a946" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">要安装一个节点包，转到相应的项目文件夹并运行CMD中的命令，<code class="fe nx ny nz oa b">npm i &lt;package name&gt;</code>。</p><p id="1b67" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在，当我们安装这个包时，这个新包会自动添加到package.json中，并且这个包保存在<em class="ow"> node_modules </em>目录中。</p><h2 id="c901" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.使用包</h2><p id="698c" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">通常是为了导入库/模块。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="a437" class="lx lg iq oa b gy or os l ot ou">'''<br/>   index.js<br/>'''</span><span id="419e" class="lx lg iq oa b gy ov os l ot ou">// Looks for the modules inside Node Modules Folder<br/>var _ = require('underscore')</span><span id="3ac2" class="lx lg iq oa b gy ov os l ot ou">var result = _.contains([1,2,3], 3);<br/>console.log('Found match', result)</span></pre><h2 id="fd8a" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.包依赖关系</h2><p id="34d1" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">当我们安装一个特定的包时，这个特定的包可以在node_modules目录中找到，而且大多数时候，您可能还会看到正在安装的另一个包。</p><p id="961d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以它们是您的实际包可以依赖的附加包。这些被称为依赖。</p><h2 id="d2c2" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.NPM软件包和源代码管理</h2><p id="f3a9" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">当我们实际实时构建一个web应用程序时，可能需要很多包才能无缝运行。</p><p id="123e" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">但是当包含更多的包时，它们被添加到node_modules文件夹中，并且它在MBs中的权重更大。</p><p id="1d24" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，在转移到另一个开发人员或Github等源代码控制应用程序时。，我们不能包含此文件。</p><p id="c640" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">但幸运的是，我们的package.json文件包含依赖项，可以随时随地构建。</p><h2 id="21ac" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.语义版本控制</h2><p id="9b1a" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">在语义版本控制中，一个节点包有3个组件，像^1.10.4.</p><p id="176d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">这些是主要的。小补丁</p><p id="0cc6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">补丁——通常用于修复任何错误。</p><p id="ce8b" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">minor——它通常用于在不破坏现有API的情况下添加一些功能。</p><p id="b63a" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">major——它通常用于添加一些可能会破坏现有API的功能。</p><p id="86ad" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">最后，包中的^字符是一个指示符，当实际的包有一些更新时，它应该不会影响我们的代码，节点可以在将来的次要版本和补丁版本中查找相同的主要版本和可能的修改。</p><h2 id="14d0" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.列出所有已安装的软件包</h2><p id="2fa1" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">运行代码来查看所有的包及其依赖项，<code class="fe nx ny nz oa b">node list</code>。</p><p id="81ba" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">运行代码只查看你的包，忽略它们的依赖<code class="fe nx ny nz oa b">npm list --depth=0</code>。</p><h2 id="adee" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.查看软件包的注册表信息</h2><p id="6e9d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">运行代码<code class="fe nx ny nz oa b">npm view &lt;package_name&gt;</code>，查找特定包的元数据。</p><p id="e564" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">运行代码，只查看特定包的依赖项。</p><p id="54d6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">运行代码来查看特定包的版本，<code class="fe nx ny nz oa b">npm view &lt;package_name&gt; versions</code>。</p><h2 id="886a" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">9.安装软件包的特定版本</h2><p id="a1e1" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">运行代码<code class="fe nx ny nz oa b">npm i &lt;package_name&gt;@&lt;Major&gt;.&lt;Minor&gt;.&lt;Patch&gt;</code></p><h2 id="e406" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">10.更新本地包</h2><p id="ffcf" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">为了将我们实际的本地包与该包的当前版本进行比较，运行代码<code class="fe nx ny nz oa b">npm outdated</code>。</p><p id="c6a5" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">要更新软件包，运行命令<code class="fe nx ny nz oa b">npm update</code>，它只更新任何软件包的次要版本和补丁版本。</p><p id="810d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在更新主要版本之前必须采取预防措施，因为它可能会破坏我们的代码。运行<code class="fe nx ny nz oa b">npm-check-updates</code>、<code class="fe nx ny nz oa b">npm-check-updates -u</code>，升级主版本，稍后安装<code class="fe nx ny nz oa b">npm i</code>以反映在我们的包中。</p><h2 id="5d24" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">11.开发依赖性</h2><p id="cc08" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">在开发阶段，我们可能包括单元测试、集成测试等。，我们可能会使用一些包来测试它，这些包不应该移动，而应用程序在生产中。</p><p id="9159" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以要安装一些开发包，运行命令<code class="fe nx ny nz oa b">npm i &lt;pkg_name&gt; --save-dev</code>。因为它们保存在package.json文件中的“devDependencies”下，node会处理剩下的工作。</p><h2 id="56df" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">12.卸载软件包</h2><p id="a3b0" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">要卸载软件包，运行命令<code class="fe nx ny nz oa b">npm un &lt;pkg_name&gt;</code></p><h2 id="fb24" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">13.使用全局包</h2><p id="79f2" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">npm是全局包的一个例子，在全局包中，所有节点应用程序都可以通用地运行。</p><p id="1dd5" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">要升级这样的全局包，运行命令<code class="fe nx ny nz oa b">npm i -g npm</code>，这里它更新npm。</p><p id="7328" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在此查找全局包的所有更新，<code class="fe nx ny nz oa b">npm -g outdated</code></p><h2 id="2ece" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">14.发布包</h2><p id="36dd" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">尝试下面的顺序，从头开始创建一个包，直到发布，出于我们的考虑，让我们假设我们的包名是<em class="ow"> icecream </em></p><ol class=""><li id="d809" class="ml mm iq mn b mo ns mq nt mc ox mf oy mi oz mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">mkdir icecream</code></li><li id="44ac" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">cd icecream</code></li><li id="a4ce" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">npm init --yes</code></li><li id="9521" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">添加一个新文件<em class="ow"> index.js </em>，它是我们包的入口点。在这里你可以添加你的功能和其他等等。,</li><li id="ff56" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">通过<code class="fe nx ny nz oa b">npm adduser</code>在npm中创建一个帐户，否则，使用<code class="fe nx ny nz oa b">npm login</code>登录。提供用户名、密码和电子邮件。</li><li id="ca10" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">要发布包，运行<code class="fe nx ny nz oa b">npm publish</code></li><li id="7c55" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">要在另一个项目中使用新创建的包，运行<code class="fe nx ny nz oa b">npm i icecream</code></li><li id="97db" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">恭喜你出版了你自己的第一个包。</li></ol><h2 id="ef69" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">15.更新已发布的包</h2><p id="01bc" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在，如果我们想添加更多的功能，并创建一个新版本的包。</p><p id="99dd" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">运行<code class="fe nx ny nz oa b">npm version &lt;major/minor/patch&gt;</code> &amp; <code class="fe nx ny nz oa b">npm publish</code>。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="8810" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">四。使用Express构建RESTful APIs</h1><p id="c1db" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">HTTP包对于创建web服务器很有用，它确实是一种方法，但是在复杂的应用程序中，我们不能依赖HTTP。但幸运的是，我们有一个express包，它是一个构建在HTTP包之上的快速而轻量的框架，可以用较少的硬编码来处理复杂的工作流。</p><h2 id="e717" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.RESTful服务</h2><p id="70ac" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">REST—<strong class="mn ja">Re</strong>presentation<strong class="mn ja">S</strong>state<strong class="mn ja">T</strong>transfer在web服务器中建立HTTP动词(GET、POST、PUT、DELETE)。</p><h2 id="1d00" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.Express简介</h2><p id="bfea" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">用新的express包替换旧的HTTP包。如果你注意到了，我们在HTTP方法中有很多if块来暴露我们的端点。</p><p id="e9f3" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">运行命令来启动我们的新express项目。</p><ol class=""><li id="b4d8" class="ml mm iq mn b mo ns mq nt mc ox mf oy mi oz mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">mkdir express-demo</code></li><li id="f3ca" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">cd express-demo</code></li><li id="51fd" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">npm init --yes</code></li><li id="171a" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">npm i express</code></li></ol><p id="0971" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">点击了解更多关于express <a class="ae le" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h2 id="d810" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.构建您的第一台Web服务器</h2><p id="d49c" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">创建一个新文件index.js，在这里我们构建我们的web服务器。</p><p id="53bb" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在为了更容易理解，让我们记录电影列表，并使用HTTP动词操作它们。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="fd7e" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs</span><span id="acdb" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="2493" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send([1,2,3,4,5])<br/>})</span><span id="efea" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(3000, () =&gt; console.log('Listening on port 3000'));</span></pre><p id="5d53" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在运行cmd中的代码，<code class="fe nx ny nz oa b">node index.js</code>并点击带有端点localhost:3000和localhost:3000/api/movies的浏览器，您一定会看到类似如下的消息。</p><div class="kp kq kr ks gt ab cb"><figure class="pb kt pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/f5ab8690d5b1d8f1ae6b3be9cdbc7991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*Vs6fCXg9vOWkiSKLhk6oow.png"/></div></figure><figure class="pb kt ph pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/cf386c6b9cb827ee02881367b6144e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*8zrtqVy6PLwu_ovzfgUVSw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk pi di pj pk translated">locah host:3000 &amp; localhost:3000/API/movies</figcaption></figure></div><p id="17d5" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多关于express API <a class="ae le" href="https://expressjs.com/en/4x/api.html" rel="noopener ugc nofollow" target="_blank">的信息，请点击</a>。</p><h2 id="6eaf" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.Nodemon</h2><p id="02e4" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">因此，对于我们所做的每一个更改，我们都应该停止服务器并重新启动。我知道这很繁琐，所以我们将使用一个名为nodemon(节点监视器)的包，如果代码有任何变化，它将自动重启服务器。</p><p id="5162" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">运行命令安装nodemon，<code class="fe nx ny nz oa b">npm i nodemon</code>。</p><p id="3487" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在通过运行<code class="fe nx ny nz oa b">nodemon index.js</code>启动web服务器。</p><h2 id="ab3d" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.环境变量</h2><p id="e713" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">环境变量基本上是变量的一部分，流程在其中运行，它在我们的应用程序之外运行。比如我们这里的端口号。</p><p id="1ccc" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">首先在windows上使用set PORT=5000设置端口值，或者在MAC上使用export PORT=5000设置端口值</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="b317" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs</span><span id="0b35" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="ee21" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send([1,2,3,4,5])<br/>})<br/>// PORT<br/>const port = process.env.PORT || 3000;</span><span id="10a6" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><h2 id="854f" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.路线参数</h2><p id="c96b" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在让我们向电影数据库添加新的路线并获取它们。</p><p id="56bb" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在在路由中，我们可以通过添加:id值来索引它们，并通过添加？queryparameters。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="89da" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs</span><span id="95b3" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="f1d4" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send([1,2,3,4,5])<br/>})</strong></span><span id="1796" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">app.get('/api/movies/:id', (req, res) =&gt; {<br/>  // res.send(req.params)<br/>  res.send(req.query)<br/>})</strong></span><span id="fc79" class="lx lg iq oa b gy ov os l ot ou">// PORT<br/>const port = process.env.PORT || 3000;</span><span id="0b00" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><div class="kp kq kr ks gt ab cb"><figure class="pb kt pl pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/e7459976ed9bd0b1e183db0d2d0d0c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*d1861-X7_YEcBcTnycxCNg.png"/></div></figure><figure class="pb kt pm pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/623924d7d83543e72b7fa5d96f08ed24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*KXZCvt0jJqHBl-cLdM0kkA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk pn di po pk translated">按id(左)和按查询(右)路由参数</figcaption></figure></div><h2 id="c6b5" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.处理HTTP GET请求</h2><p id="36f4" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在让我们开始接收GET请求，并根据用户提供的id提供电影。因此，我们编写了一个小函数来获取基于id的电影。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="173b" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs</span><span id="15e0" class="lx lg iq oa b gy ov os l ot ou">const movies = [{ id:1, name: 'Tenet'},{ id:2, name: 'Quantum of Solace'},{ id:3, name: 'Inception'}]</span><span id="eda8" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="1e92" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send(movies)<br/>})</span><span id="c820" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">app.get('/api/movies/:id', (req, res) =&gt; {<br/>const movie = movies.find(m =&gt; m.id === parseInt(req.params.id));<br/>if (!movie) res.status(404).send('No movie found for the given id') res.send(movie)<br/>});</strong></span><span id="8065" class="lx lg iq oa b gy ov os l ot ou">// PORT<br/>const port = process.env.PORT || 3000;</span><span id="eabd" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><div class="kp kq kr ks gt ab cb"><figure class="pb kt pp pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/b493c2531fa0f7e3bdd30313932b068f.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*HFTxh9LIVf9wCkdbpimKlQ.png"/></div></figure><figure class="pb kt pq pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/ea9934d997cd91beda6f521f73414c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*QZhRFpiFfJXGxAun6H6GEg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk pr di ps pk translated"><a class="ae le" href="http://localhost:3000/api/movies/15" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/movies/1</a>T10<a class="ae le" href="http://localhost:3000/api/movies/15" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/movies/15</a></figcaption></figure></div><h2 id="d6c5" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.处理HTTP POST请求</h2><p id="af4b" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在我们可以使用POST方法根据用户的请求在电影数据库中创建一个新的课程。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="0ed0" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs</span><span id="25b3" class="lx lg iq oa b gy ov os l ot ou">app.use(express.json());</span><span id="da35" class="lx lg iq oa b gy ov os l ot ou">const movies = [{ id:1, name: 'Tenet'},{ id:2, name: 'Quantum of Solace'},{ id:3, name: 'Inception'}]</span><span id="2f9b" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="e764" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send(movies)<br/>})</span><span id="300c" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies/:id', (req, res) =&gt; {<br/>const movie = movies.find(m =&gt; m.id === parseInt(req.params.id));<br/>if (!movie) res.status(404).send('No movie found for the given id') res.send(movie)<br/>});</span><span id="cb59" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">app.post('/api/movies/', (req, res) =&gt; {<br/>  const movie = {id: movies.length + 1,name: req.body.name};<br/>  movies.push(movie);<br/>  res.send(movie)<br/>});</strong></span><span id="e7e3" class="lx lg iq oa b gy ov os l ot ou">// PORT<br/>const port = process.env.PORT || 3000;</span><span id="8da8" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><h2 id="f37a" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">9.使用Postman或Thunder客户端调用端点</h2><p id="fbe5" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">为了检查上述POST请求是否成功，我们需要根据您的选择通过postman或thunder提供的服务进行检查。</p><p id="1275" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">显然，浏览器只能在这些端点上发送GET请求，因为它们是为这样做而设计的。</p><p id="e039" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在我们看到，我们得到了成功200的回应。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pt"><img src="../Images/073f9135556c95dc10486f84b0b4cc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8VZOBsGFUlfVZaXVgoXBQ.png"/></div></div></figure><h2 id="2ee0" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">10.输入验证</h2><p id="bb6d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">我们必须始终验证输入的内容，并执行一些基本的检查，以确保它们是正确的。所以在这里，我们保证他们正在插入的电影名称不是空的，并说它必须至少有3个字符。</p><p id="c95d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">我们可以用if(！req . body . name | | req . body . name . length&lt; 3), but as our project gets complex, we can use an input validation package called Joi, more on that <a class="ae le" href="https://www.npmjs.com/package/joi" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="308c" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">Joi — API和文档<a class="ae le" href="https://joi.dev/api/?v=17.4.0#introduction" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="c389" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs<br/>const Joi = require('joi');<br/>app.use(express.json());</span><span id="a27a" class="lx lg iq oa b gy ov os l ot ou">const movies = [{ id:1, name: 'Tenet'},{ id:2, name: 'Quantum of Solace'},{ id:3, name: 'Inception'}]</span><span id="391b" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="21d6" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send(movies)<br/>})</span><span id="f378" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies/:id', (req, res) =&gt; {<br/>const movie = movies.find(m =&gt; m.id === parseInt(req.params.id));<br/>if (!movie) res.status(404).send('No movie found for the given id') res.send(movie)<br/>});</span><span id="1062" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">app.post('/api/movies/', (req, res) =&gt; {<br/>  const schema = Joi.object({name: Joi.string().min(3).required()<br/>});<br/>  const result = schema.validate(req.body)<br/>  console.log('result', result)<br/>  <br/>  if (result.error){<br/>    res.status(400).send(result.error.details[0].message)<br/>    return; // Don't execute the rest of the program<br/>}</strong></span><span id="5847" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  const movie = {id: movies.length + 1,name: req.body.name};<br/>  movies.push(movie);<br/>  res.send(movie)<br/>});</strong></span><span id="4d2f" class="lx lg iq oa b gy ov os l ot ou">// PORT<br/>const port = process.env.PORT || 3000;</span><span id="a401" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><div class="kp kq kr ks gt ab cb"><figure class="pb kt pu pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/25da862280d00f5b258fcd0ab3c8d1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*2XaOFvwY6K3TpxGdSGEBuw.png"/></div></figure><figure class="pb kt pv pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/b871f7985e1cddb656467f8fa4a440ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*TZyBNRdY7GZbne3AzckFAA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk pw di px pk translated">成功(200)和失败(404)</figcaption></figure></div><h2 id="48e2" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">11.处理HTTP PUT请求</h2><p id="89ae" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在让我们根据用户提供的id更新一个电影名。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="8e44" class="lx lg iq oa b gy or os l ot ou">const express = require('express')<br/>const app = express() // Contains the HTTP Verbs<br/>const Joi = require('joi');<br/>app.use(express.json());</span><span id="e7ac" class="lx lg iq oa b gy ov os l ot ou">const movies = [{ id:1, name: 'Tenet'},{ id:2, name: 'Quantum of Solace'},{ id:3, name: 'Inception'}]</span><span id="458c" class="lx lg iq oa b gy ov os l ot ou">// GET METHOD<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});</span><span id="7180" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies', (req, res) =&gt; {<br/>  res.send(movies)<br/>})</span><span id="a33b" class="lx lg iq oa b gy ov os l ot ou">app.get('/api/movies/:id', (req, res) =&gt; {<br/>const movie = movies.find(m =&gt; m.id === parseInt(req.params.id));<br/>if (!movie) res.status(404).send('No movie found for the given id') res.send(movie)<br/>});</span><span id="bdf1" class="lx lg iq oa b gy ov os l ot ou">app.post('/api/movies/', (req, res) =&gt; {<br/>  const schema = Joi.object({name: Joi.string().min(3).required()<br/>});<br/>  const result = schema.validate(req.body)<br/>  console.log('result', result)<br/>  <br/>  if (result.error){<br/>    res.status(400).send(result.error.details[0].message)<br/>    return; // Don't execute the rest of the program<br/>}</span><span id="2ef2" class="lx lg iq oa b gy ov os l ot ou">const movie = {id: movies.length + 1,name: req.body.name};<br/>  movies.push(movie);<br/>  res.send(movie)<br/>});</span><span id="0984" class="lx lg iq oa b gy ov os l ot ou"><br/><strong class="oa ja">app.put('/api/movies/:id', (req, res) =&gt; {<br/>  // Look up the movie<br/>  // If not existing, return 404</strong></span><span id="dba4" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  const movie = movies.find(m =&gt; m.id === parseInt(req.params.id));<br/>  if (!movie) res.status(404).send('No movie found for the given id') // 404<br/>  <br/>  const { error } = validateMovies(req.body); // Equivalent to result.error<br/>  if (error){<br/>    res.status(400).send(error.details[0].message)<br/>    return; // Don't execute the rest of the program<br/>  }</strong></span><span id="aac3" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  // Update movie<br/>  // Return the updated movie<br/>  <br/>  movie.name  = req.body.name<br/>  res.send(movie)<br/> })</strong></span><span id="ecbf" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">function validateMovies(movie){<br/>  // Validate<br/>  // If invalid, return 400 - Bad request<br/>  <br/>  const schema = Joi.object({<br/>    name: Joi.string().min(3).required() });</strong></span><span id="5963" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  return schema.validate(movie);<br/>};</strong></span><span id="d102" class="lx lg iq oa b gy ov os l ot ou">// PORT<br/>const port = process.env.PORT || 3000;</span><span id="8fd2" class="lx lg iq oa b gy ov os l ot ou">// Listen PORT<br/>app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><div class="kp kq kr ks gt ab cb"><figure class="pb kt py pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/550096873e1ed2d753ab28ba066acd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*RKNx0o7uTw3ZEq6HgrtM1g.png"/></div></figure><figure class="pb kt pz pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/ae193abaeb4fff89b5699c76659c6178.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*WKFhLpcBXt1RmATAlBeYCQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk qa di qb pk translated">成功(200)和失败(404)</figcaption></figure></div><h2 id="e98b" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">12.处理HTTP删除请求</h2><p id="36bc" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在让我们根据用户提供的id删除一个电影名。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="ed80" class="lx lg iq oa b gy or os l ot ou"><strong class="oa ja">app.delete('/api/movies/:id', (req, res) =&gt; {<br/>  // Look up the course<br/>  // Not Existing, return 404</strong></span><span id="307f" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  const movie = movies.find(m =&gt; m.id === parseInt(req.params.id));<br/>  if (!movie) res.status(404).send('No movie found for the given <br/>      id') // 404</strong></span><span id="8545" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  // Delete<br/>  const index = movies.indexOf(movie);<br/>  movies.splice(index, 1)<br/>  <br/>  // Return the same movie<br/>  res.send(movie)</strong></span><span id="295a" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">})</strong></span></pre><div class="kp kq kr ks gt ab cb"><figure class="pb kt qc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/81a4a71933634b4f419a8fa479bfa0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*CdfeHIJ-1Evd7Q-ZsfrG_Q.png"/></div></figure><figure class="pb kt qd pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/05dd20380b65c99eb5a8ae885f428e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*mmrYHw7fDNayAro7i3RpSg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk pr di ps pk translated">成功(200)和失败(404)</figcaption></figure></div></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="d465" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">动词 （verb的缩写）表达高级主题</h1><h2 id="cc8d" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.中间件</h2><p id="29cf" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">中间件是接受请求对象并向客户端返回响应的东西。</p><p id="4719" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">请求处理有时可能会通过一个流程管道，每个流程都包含一个中间件功能。在下面的过程中，JSON和route操作是中间件。</p><p id="2028" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated"><code class="fe nx ny nz oa b">app.use(express.json())</code></p><p id="8e3a" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">喜欢请求→ json() → route() →响应</p><h2 id="ffdf" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.创建定制中间件</h2><p id="86b0" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">为此，让我们为收到的每个请求创建一个认证中间件，然后将控制权交给项目中的下一个中间件。更简单地说，如果不将它传递给其他中间件，它将会卡在自己内部。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="3e3a" class="lx lg iq oa b gy or os l ot ou">// Middleware - 1<br/>app.use(express.json());</span><span id="9435" class="lx lg iq oa b gy ov os l ot ou">// Middleware - 2<br/>app.use(function(req, res, next){<br/>  console.log('Logging request...');<br/>  next(); // Pass control to the next middleware; otherwise stuck<br/>})</span><span id="252a" class="lx lg iq oa b gy ov os l ot ou">// Middleware - 2<br/>app.use(authentication);</span><span id="9efe" class="lx lg iq oa b gy ov os l ot ou">function authentication(req, res, next){<br/>  console.log('Authentication Starts...');<br/>  next();<br/>}</span></pre><p id="6bc1" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在看看控制台，我们可以看到，对于每个命中的请求，它每次都经过我们的定制中间件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/7424458ca5ca465b99e13a8aff06871e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmB0WPLgdrId31xK5RqaiQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">中间件被记录</figcaption></figure><h2 id="835e" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.内置中间件</h2><p id="0b14" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">我们可以利用许多内置的中间件。比如<code class="fe nx ny nz oa b">app.use(express.json());</code>，它自动解析req.body中的任何JSON对象，并以JSON格式提供给我们使用。</p><p id="d500" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">app . use(express . urlencoded({ extended:true }))；</p><p id="ea5a" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">app . use(express . static(' public '))；</p><p id="b9d5" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated"><code class="fe nx ny nz oa b">app.use(express.urlencoded({extended: true}));</code> —接收请求中的表单数据。</p><p id="b099" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated"><code class="fe nx ny nz oa b">app.use(express.static('public'));</code> —为web服务器中的静态文件提供服务，因此如果我们创建一个公共文件夹并使用一些静态文件，就可以从web上访问它。</p><h2 id="7841" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.第三方中间件</h2><p id="5295" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">所以我们用头盔中间件来演示一下。</p><ol class=""><li id="fcf3" class="ml mm iq mn b mo ns mq nt mc ox mf oy mi oz mv pa mx my mz bi translated">头盔— <a class="ae le" href="https://github.com/helmetjs/helmet" rel="noopener ugc nofollow" target="_blank">链接</a>，帮助保护带有各种HTTP头的Express应用。</li><li id="15a7" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">morgan — <a class="ae le" href="https://expressjs.com/en/resources/middleware/morgan.html" rel="noopener ugc nofollow" target="_blank"> link </a>，node.js的HTTP请求记录器中间件。</li></ol><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="f399" class="lx lg iq oa b gy or os l ot ou">const express = require('express');<br/>const helmet = require('helmet')<br/>const morgan = require('morgan')<br/>const app = express() // Contains the HTTP Verbs</span><span id="8db2" class="lx lg iq oa b gy ov os l ot ou">app.use(express.json());<br/>app.use(helmet());<br/>app.use(morgan('tiny'));</span></pre><p id="e7a3" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在，如果我们试图访问node.js程序的端点，它将被记录如下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/7d7b0e377fd4f150047c1740c65fc1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqluyrs3WjmpEtuwPvHn6w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">摩根记录者</figcaption></figure><p id="e029" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多关于那个<a class="ae le" href="https://expressjs.com/en/resources/middleware.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="0f52" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.环境变量</h2><p id="87c5" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时，我们需要存储环境变量，如端口、生产/开发环境、API密钥等。，所以我们可以使用命令<code class="fe nx ny nz oa b">set NODE_ENV=production</code>导出或设置它们，并通过访问它在代码中使用它们。一个简单的用例如下:</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="41ce" class="lx lg iq oa b gy or os l ot ou">console.log(`Node Environment : ${process.env.NODE_ENV}`)</span><span id="ddb4" class="lx lg iq oa b gy ov os l ot ou">if (app.get('env') == 'development'){<br/>  app.use(morgan('tiny'));<br/>  console.log('Morgan Enabled')<br/>};</span></pre><p id="c865" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，只有在开发服务器上，我们才记录传入的请求。</p><h2 id="3aad" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.配置</h2><h2 id="2cb1" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.排除故障</h2><p id="be71" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时在开发过程中，我们可能希望看到大多数函数或路径的日志，后来我们通常会删除它们或注释掉它们，将来，如果我们进行任何更新，我们可能会插入调试代码或取消注释。这是一个繁琐耗时的过程。</p><p id="63a1" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们应该寻找一个软件包，以便更有效地完成这个过程。</p><p id="0601" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">安装调试包，<code class="fe nx ny nz oa b">npm i debug</code>，</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="f2b6" class="lx lg iq oa b gy or os l ot ou">const debug = require('debug')('app:debug') <br/>// export DEBUG=app:debug in CMD</span><span id="5efd" class="lx lg iq oa b gy ov os l ot ou">console.log(`Node Environment : ${process.env.NODE_ENV}`)</span><span id="5bc9" class="lx lg iq oa b gy ov os l ot ou">if (app.get('env') == 'development'){<br/>  app.use(morgan('tiny'));<br/>  debug('Morgan Enabled')<br/>};</span></pre><p id="3d86" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，如果我们将变量DEBUG设置为app: debug in cmd，然后执行代码，那么您将看到语句' Morgan Enabled '，否则它不会打印所有内容。</p><h2 id="70a5" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.模板引擎</h2><p id="03fe" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时我们需要为客户机发送HTML标记，而不是HTTP动词上的原始JSON响应。所以我们要利用一个叫做pug的包，来安装它运行<code class="fe nx ny nz oa b">npm i pug</code>。</p><p id="5880" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">稍后在代码中设置引擎类型，并创建一个新文件夹“views”和一个包含HTML元素的文件名index.pug</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="1960" class="lx lg iq oa b gy or os l ot ou">'''<br/>index.pug<br/>'''</span><span id="341f" class="lx lg iq oa b gy ov os l ot ou">html<br/>   head<br/>      title=title<br/>   body<br/>      h1=messgae<br/></span><span id="3fc2" class="lx lg iq oa b gy ov os l ot ou">'''<br/>index.js<br/>'''</span><span id="ad2a" class="lx lg iq oa b gy ov os l ot ou">app.set('views', './views');<br/>app.set('view engine', 'pug');</span><span id="31a8" class="lx lg iq oa b gy ov os l ot ou">app.get('/', (req, res) =&gt; {</span><span id="9389" class="lx lg iq oa b gy ov os l ot ou">   res.render('index', {'title':'My Express Movie App', message:      'Welcome to Movie Database'})</span><span id="09e9" class="lx lg iq oa b gy ov os l ot ou">});</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qf"><img src="../Images/f2ce2dd2c73c6727aab15455356e662c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJvN8JnEeMNoyXLRMkC4mA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">PUG生成的HTML页面</figcaption></figure><h2 id="cb39" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">9.构建代码</h2><p id="783c" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">您可以检查我们到目前为止所做的实现，所有这些都是在同一个index.js中完成的，还可以检查嵌入的要点，以确保我们在同一页上。</p><p id="22d7" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">此外，我同意，这不是一个有效的方法，所以我们需要整齐地组织整个代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qg qh l"/></div></figure><p id="7899" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">有组织的代码被分成多个文件和文件夹，并在本文的底部添加了GitHub repo链接。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="f86b" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">不及物动词异步JavaScript</h1><h2 id="f8dd" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.异步与同步代码</h2><p id="357c" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">正如我们已经阐明的，Node Js执行异步或非阻塞执行，这意味着它不会等待函数完成，而是逐行执行。</p><p id="8c20" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以我们举个简单的例子。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="0e86" class="lx lg iq oa b gy or os l ot ou">console.log('Before')</span><span id="8111" class="lx lg iq oa b gy ov os l ot ou">setTimeout(() =&gt; {<br/>console.log('Simulating a database operation')<br/>}, 2000);</span><span id="8b70" class="lx lg iq oa b gy ov os l ot ou">console.log('After')</span><span id="1710" class="lx lg iq oa b gy ov os l ot ou">OUTPUTS : <br/>Before<br/>After<br/>Simulating a database operation</span></pre><p id="79a3" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在，从输出中我们可以看到，在执行我们插入的超时函数时，它没有等待2秒钟，而是启动了函数，并移动到下一段代码。稍后在事件队列中，线程被告知输出准备好了，它收集并显示它。</p><p id="43b6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以我们看到函数输出在最后而不是第二。</p><h2 id="6bee" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.处理异步代码的模式</h2><p id="0f38" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">假设我们想从一个异步函数中返回一个变量，以便进一步处理。所以如果我们运行下面这段代码，</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="1d7f" class="lx lg iq oa b gy or os l ot ou">console.log('Before')</span><span id="0b77" class="lx lg iq oa b gy ov os l ot ou">const movie = getMovies(1)</span><span id="fae9" class="lx lg iq oa b gy ov os l ot ou">console.log(movie)</span><span id="5aa2" class="lx lg iq oa b gy ov os l ot ou">console.log('After')</span><span id="9f97" class="lx lg iq oa b gy ov os l ot ou">function getMovies(id){<br/>  setTimeout(() =&gt; {<br/>    console.log('Simulating a movie fetching operation')<br/>    return {id:id, Name:'Tenet'};<br/>  }, 2000);<br/>}</span><span id="eb7d" class="lx lg iq oa b gy ov os l ot ou">OUTPUT:<br/>Before<br/>undefined<br/>After<br/>Simulating a movie fetching operation</span></pre><p id="dc80" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">我们看到变量movie是未定义的，这是因为，在那个时刻，变量还不可用。</p><p id="3746" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，在编写异步程序时，有3种模式需要注意。</p><ol class=""><li id="81b1" class="ml mm iq mn b mo ns mq nt mc ox mf oy mi oz mv pa mx my mz bi translated"><strong class="mn ja">回调</strong></li><li id="c877" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><strong class="mn ja">承诺</strong></li><li id="6dcf" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><strong class="mn ja">异步/等待</strong></li></ol><p id="c725" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">我将研究它们中的每一个，使我们的异步代码更加清晰。</p><h2 id="3819" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.复试</h2><p id="55f3" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">以前变量movie是未定义的，现在我们将使用</p><p id="4390" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">回调选项来填充变量。</p><blockquote class="qi qj qk"><p id="e543" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated"><strong class="mn ja"> <em class="iq">回调是我们调用的一个函数，当异步操作的结果准备好时。</em>T9】</strong></p></blockquote><p id="f973" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">如下面的代码片段所示，我们创建了一个带有两个参数id &amp;callback的函数getMovies，它需要自己的时间来提供输出。所以一旦输出准备好了，回调就会收集它。</p><p id="bea9" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在函数调用时，我们使用一个arrow functions / anonymous函数来收集收到的回调，并将其显示在console.log上。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qg qh l"/></div></figure><h2 id="3150" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.承诺</h2><blockquote class="qi qj qk"><p id="e5e3" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated">承诺持有异步操作的最终结果。</p></blockquote><p id="482d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以异步函数一旦完成，要么返回一个响应，要么返回一个错误。</p><p id="f44d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以承诺有三种状态，</p><ol class=""><li id="ffa2" class="ml mm iq mn b mo ns mq nt mc ox mf oy mi oz mv pa mx my mz bi translated">挂起—正在进行的异步操作</li><li id="8915" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">解决—已完成并收到回复</li><li id="bda0" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated">拒绝—错误</li></ol><p id="9f0d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，让我们看看如何在简单的异步操作中使用承诺。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="bf62" class="lx lg iq oa b gy or os l ot ou">const p = new Promise((resolve, reject) =&gt; {<br/>  // Do some async work<br/>  setTimeout(() =&gt; {<br/>    resolve(1); // Return Output - 1<br/>    // reject(new Error('Some error')) // Return Error<br/>}, 2000);<br/>});</span><span id="b473" class="lx lg iq oa b gy ov os l ot ou">p<br/>  .then(result =&gt; console.log(`Result : ${result}`))<br/>  .catch(err =&gt; console.log(`Error : ${err.message}`))</span></pre><p id="ee2c" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，promise需要两个参数来解析和拒绝，解析携带输出，拒绝携带错误消息(如果有的话)。</p><p id="1cb4" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">当我们将承诺存储在变量p中时，我们可以使用像。然后得到结果或者。捕捉以显示输出。</p><h2 id="da60" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.用承诺代替回访</h2><p id="b173" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">正如我们在回调示例(第3节)中创建了电影获取及其导演获取函数一样，让我们用第4节中描述的承诺来替换它们。</p><p id="380e" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">也看看如何消耗那些来自承诺的决心和拒绝。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qg qh l"/></div></figure><h2 id="1d39" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.并行处理承诺</h2><p id="fd7d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时，我们会为两个不同的函数或API调用创建两个承诺，然后在这两个承诺完成后执行一些操作。</p><p id="1de9" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，为了处理这样的场景，我们在Promise中有一个可以派上用场的静态方法。</p><ol class=""><li id="4542" class="ml mm iq mn b mo ns mq nt mc ox mf oy mi oz mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">promise.all[(p1, p2)]</code> —解析两个承诺，然后解析输出，或者如果捕捉到错误，则拒绝来自这些承诺中任何一个的任何解析。</li><li id="ab66" class="ml mm iq mn b mo na mq nb mc nc mf nd mi ne mv pa mx my mz bi translated"><code class="fe nx ny nz oa b">promise.race[(p1, p2)]</code> —解析先完成的承诺，然后解析输出，如果捕捉到错误，则执行其他操作。不要等待其他正在进行的承诺，继续前进。</li></ol><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qg qh l"/></div></figure><h2 id="9f51" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.异步和等待</h2><p id="06e1" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">Async &amp; Await是Node.js的新方法，我们将重写我们的电影和导演获取异步方法。</p><p id="d5e6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">它们实际上写在承诺之上，但给人一种同步编程的感觉。</p><p id="5270" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">但是在函数级别上需要做一些改变，因为我们需要用async关键字来修饰函数。</p><p id="983a" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们创建了一个新的异步函数来执行我们所有的承诺，我们还将它们封装到一个try &amp; catch块中，以显示错误。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="qg qh l"/></div></figure></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="1a12" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">七。用猫鼬进行CRUD操作</h1><p id="029d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">CRUD是创建、读取、更新、删除的缩写，我们将在Mongoose这样的NoSQL数据库上执行CRUD。</p><blockquote class="qi qj qk"><p id="3377" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated">需要注意的是，由于这是一个更广泛的话题，我决定将它单独写出来，作为一篇独立的文章发表。</p><p id="207b" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated"><strong class="mn ja">你可以在这里找到文章</strong><a class="ae le" href="https://towardsdatascience.com/crud-create-read-update-delete-operations-on-nosql-database-mongodb-using-node-js-3979573b9b24?source=your_stories_page-------------------------------------" rel="noopener" target="_blank"><strong class="mn ja"/></a><strong class="mn ja">。</strong></p></blockquote><p id="0a15" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">但是不用担心，这又是建立在我们的电影数据库的例子上。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="7e55" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">八。Mongo数据验证</h1><h2 id="9a52" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.确认</h2><p id="99f0" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">在我们的电影数据库中，如果我们试图根据我们定义的模式保存一个包含所有必需字段的新文档，它将接受它。但是，如果我们试图在不提供任何字段的情况下保存它，它将再次保存它，因为我们没有提到特定条目是否有效。这种情况有时很重要，因为我们不能听天由命。</p><p id="144f" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，让我们修改我们的模式以适应数据验证。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="0c99" class="lx lg iq oa b gy or os l ot ou">const movieSchema = new mongoose.Schema({</span><span id="51a4" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">movieName : {type: String, required: true}, // Validation Check</strong></span><span id="dca5" class="lx lg iq oa b gy ov os l ot ou">director: String,</span><span id="f530" class="lx lg iq oa b gy ov os l ot ou">imdbRating: Number,</span><span id="b9ec" class="lx lg iq oa b gy ov os l ot ou">cast: [String],</span><span id="d510" class="lx lg iq oa b gy ov os l ot ou">releaseDate: Date,</span><span id="32a7" class="lx lg iq oa b gy ov os l ot ou">genre: String,</span><span id="5e87" class="lx lg iq oa b gy ov os l ot ou">sequel: Boolean</span><span id="238c" class="lx lg iq oa b gy ov os l ot ou">});</span></pre><p id="fea7" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">稍后，我们还需要处理拒绝，以防用户没有传递所需的参数，否则，我们的代码将导致错误，无法通过。所以我们将使用一个简单的try-catch块来处理承诺拒绝(如果有的话)。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="a8fc" class="lx lg iq oa b gy or os l ot ou">async function insertMovie(name_, director_, rating_, cast_, date_, genre_, sequel_){</span><span id="4bfe" class="lx lg iq oa b gy ov os l ot ou">const movieObject = new movieClass({</span><span id="0689" class="lx lg iq oa b gy ov os l ot ou">movieName : name_,</span><span id="7c92" class="lx lg iq oa b gy ov os l ot ou">director: director_,</span><span id="0fea" class="lx lg iq oa b gy ov os l ot ou">imdbRating: rating_,</span><span id="8535" class="lx lg iq oa b gy ov os l ot ou">cast: cast_,</span><span id="703c" class="lx lg iq oa b gy ov os l ot ou">releaseDate: date_,</span><span id="85b1" class="lx lg iq oa b gy ov os l ot ou">genre: genre_,</span><span id="2fb8" class="lx lg iq oa b gy ov os l ot ou">sequel: sequel_</span><span id="9b1e" class="lx lg iq oa b gy ov os l ot ou">});</span><span id="214d" class="lx lg iq oa b gy ov os l ot ou">// Handling rejected promises here.<br/><strong class="oa ja">try{<br/>   result = await movieObject.save()<br/>   return result<br/>}catch (ex){<br/>   console.log('Error in Promises', ex.message)<br/>}</strong><br/>}</span></pre><h2 id="832b" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.内置验证器</h2><p id="9742" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">我们之前使用了一个内置的字符串验证器，required: true。</p><p id="ef9f" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">我们可以添加更多的字符串和数字进行验证，而不需要第三方库。此外，还有一个条件验证器，它只有在满足条件时才会通过。</p><p id="f4a8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">然后，让我们看看字符串和数字验证器，它们中的大多数都是不言自明的。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="d422" class="lx lg iq oa b gy or os l ot ou">// String Validators</span><span id="3019" class="lx lg iq oa b gy ov os l ot ou">movieName : {</span><span id="0f65" class="lx lg iq oa b gy ov os l ot ou">   type: String,</span><span id="3d00" class="lx lg iq oa b gy ov os l ot ou">   required: true,</span><span id="b01b" class="lx lg iq oa b gy ov os l ot ou">  <strong class="oa ja"> minlength: 2,</strong></span><span id="caf3" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   maxlength: 255,</strong></span><span id="cdcd" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   // match: /pattern/ // Some Regex Pattern</strong></span><span id="e267" class="lx lg iq oa b gy ov os l ot ou">},</span><span id="9beb" class="lx lg iq oa b gy ov os l ot ou">genre: {</span><span id="4e6b" class="lx lg iq oa b gy ov os l ot ou">   type: String,</span><span id="7f45" class="lx lg iq oa b gy ov os l ot ou">   required: true,</span><span id="5f0a" class="lx lg iq oa b gy ov os l ot ou">   enum: ['horror', 'Action', 'science-fiction', 'supernatural-   horror', 'comedy', 'romance', 'adventure']<br/>// Input must be one of them enumerated above.</span><span id="63ae" class="lx lg iq oa b gy ov os l ot ou">},</span><span id="47c8" class="lx lg iq oa b gy ov os l ot ou">// Number Validators</span><span id="3e15" class="lx lg iq oa b gy ov os l ot ou">releaseDate: Date,</span><span id="9956" class="lx lg iq oa b gy ov os l ot ou">imdbRating: {</span><span id="e720" class="lx lg iq oa b gy ov os l ot ou">   type: Number,</span><span id="58e2" class="lx lg iq oa b gy ov os l ot ou">   <strong class="oa ja">min: 0,</strong></span><span id="f115" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   max: 10,</strong></span><span id="d5a4" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   required: function() { return this.releaseDate(); } <br/>   // Conditionally make the property required</strong></span><span id="45ef" class="lx lg iq oa b gy ov os l ot ou">}</span></pre><p id="b012" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，在顶部的imdbRating中，我们没有将必填字段传递为true或false，而是传递了一个条件，即只有当releaseDate存在时，我们才希望填充评级。这被称为条件验证，属性<code class="fe nx ny nz oa b">this.</code>指的是在函数调用过程中创建的类对象。</p><h2 id="e933" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.自定义验证程序</h2><p id="3205" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时我们需要设置一个内置验证器中没有的条件。</p><p id="92e1" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">以这个例子为例，在我们的电影数据库中创建条目时，我们的电影数据库中的演员字段必须指定至少两个演员，但是我们不能简单地将required设置为true，因为即使只有一个演员条目也需要这样做。</p><p id="b21b" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们将使用自定义验证来修改模式，如果失败，还将指定一条自定义消息。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="44ed" class="lx lg iq oa b gy or os l ot ou">cast: {</span><span id="639b" class="lx lg iq oa b gy ov os l ot ou">   type: Array,</span><span id="d3dc" class="lx lg iq oa b gy ov os l ot ou">   validate: {</span><span id="41e4" class="lx lg iq oa b gy ov os l ot ou">   <strong class="oa ja">validator: function(v){</strong></span><span id="7bcd" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">      return v &amp;&amp; v.length &gt; 2; <br/>      // Should not be a null and should have atleast two cast</strong></span><span id="82d9" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">},message: 'The Cast must contain atleast two character names'<br/>}</strong><br/>}</span></pre><h2 id="4a91" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.异步验证器</h2><p id="bc90" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时，我们的验证器逻辑需要从数据库中读取一些东西或者执行一个HTTP调用，等等。，来验证逻辑，所以在那些情况下，我们使用异步验证器。</p><p id="b3dc" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们使用回调逻辑，如前几节所述。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="0d6d" class="lx lg iq oa b gy or os l ot ou">cast: {</span><span id="29f9" class="lx lg iq oa b gy ov os l ot ou">  type: Array,</span><span id="1c1d" class="lx lg iq oa b gy ov os l ot ou">  validate: {</span><span id="378d" class="lx lg iq oa b gy ov os l ot ou">  <strong class="oa ja">isAsync: true,</strong></span><span id="0e93" class="lx lg iq oa b gy ov os l ot ou">  <strong class="oa ja">validator: function(v, callback){</strong></span><span id="1cb5" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  // Do some async work or here I simulated timeout</strong></span><span id="a62d" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  setTimeout(()=&gt;{</strong></span><span id="d3e0" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">      const result = v &amp;&amp; v.length &gt; 2; <br/>      callback(result)<br/>  }, 5000);<br/>},<br/>message: 'The Cast must contain atleast two character names,<br/>}</strong><br/>}</span></pre><h2 id="3c0b" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.验证错误</h2><p id="4c80" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">因此，目前在我们的设计中，只有在承诺拒绝的情况下，我们才会收到错误消息，所以很难知道我们的数据库中是否有任何这样的字段有任何错误。因此，我们将通过遍历可用的字段来显示错误消息(如果有的话)。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="b286" class="lx lg iq oa b gy or os l ot ou">async function insertMovie(name_, director_, rating_, cast_, date_, genre_, sequel_){const movieObject = new movieClass({</span><span id="b6c8" class="lx lg iq oa b gy ov os l ot ou">   movieName : name_,<br/>   director: director_,<br/>   imdbRating: rating_,<br/>   cast: cast_,<br/>   releaseDate: date_,<br/>   genre: genre_,<br/>   sequel: sequel_});</span><span id="10fe" class="lx lg iq oa b gy ov os l ot ou">   try{<br/>      result = await movieObject.save()<br/>      return result<br/>   }catch (ex){<br/>      // Iterate throught the fields for error message</span><span id="402f" class="lx lg iq oa b gy ov os l ot ou">      <strong class="oa ja">console.log('movieName Error', ex.errors.movieName)<br/>      for (field in ex.errors){<br/>         console.log(`${field} - Errors ${ex.errors[field]}`)</strong><br/>}}}</span></pre><h2 id="94bb" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.架构类型选项</h2><p id="375e" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">我们已经看到了一些模式类型。因此，我们将增加两个字符串和数字。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="549a" class="lx lg iq oa b gy or os l ot ou">// Type - String</span><span id="367b" class="lx lg iq oa b gy ov os l ot ou">genre: {</span><span id="b379" class="lx lg iq oa b gy ov os l ot ou">   type: String,</span><span id="81a3" class="lx lg iq oa b gy ov os l ot ou">   required: true,</span><span id="57ea" class="lx lg iq oa b gy ov os l ot ou">   enum: ['horror', 'Action', 'science-fiction', 'supernatural- horror', 'comedy', 'romance', 'adventure'],</span><span id="9d2c" class="lx lg iq oa b gy ov os l ot ou">   <strong class="oa ja">lowercase: true, // Converts the entry to lower case</strong></span><span id="942a" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   uppercase: true, // Converts the entry to lower case</strong></span><span id="d365" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   trim: true // Removes padding or extra spaces</strong></span><span id="8181" class="lx lg iq oa b gy ov os l ot ou">},</span><span id="1170" class="lx lg iq oa b gy ov os l ot ou">// Type - Number<br/>imdbRating: {</span><span id="506d" class="lx lg iq oa b gy ov os l ot ou">   type: Number,</span><span id="628e" class="lx lg iq oa b gy ov os l ot ou">   min: 0,</span><span id="e4bb" class="lx lg iq oa b gy ov os l ot ou">   max: 10,</span><span id="6ed7" class="lx lg iq oa b gy ov os l ot ou">   <strong class="oa ja">get: v =&gt; Math.round(v), // Rounds the value during fetching.</strong></span><span id="1b8b" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   set: v =&gt; Math.round(v), // Rounds the value during saving.</strong></span><span id="1294" class="lx lg iq oa b gy ov os l ot ou">   required: function() { return this.releaseDate; } <br/>   // Conditionally make the property required</span><span id="b3ee" class="lx lg iq oa b gy ov os l ot ou">}</span></pre></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="a699" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">XI。认证和授权</h1><h2 id="be5f" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.介绍</h2><blockquote class="qi qj qk"><p id="f9a6" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated">身份验证是识别用户身份的过程。</p><p id="278f" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated">授权是确定用户是否有权执行给定的操作。</p></blockquote><p id="9be7" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们应该升级我们的电影数据库，以实现这种授权和认证。</p><p id="49c6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们将在应用程序中创建新的端点，用户可以使用REST APIs注册和登录。</p><h2 id="f42c" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.创建用户模型模式</h2><p id="41fd" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">因此，让我们创建一个用户数据库和一个模式来启用名称、电子邮件、密码等字段。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="9814" class="lx lg iq oa b gy or os l ot ou">// MongoDb Schema</span><span id="4d96" class="lx lg iq oa b gy ov os l ot ou">const userSchema = new mongoose.Schema({</span><span id="98a5" class="lx lg iq oa b gy ov os l ot ou">username : {</span><span id="a725" class="lx lg iq oa b gy ov os l ot ou">   type: String, required: true,</span><span id="efc8" class="lx lg iq oa b gy ov os l ot ou">   minlength: 2, maxlength: 50,</span><span id="1f3a" class="lx lg iq oa b gy ov os l ot ou">},</span><span id="6db9" class="lx lg iq oa b gy ov os l ot ou">email: {</span><span id="c68c" class="lx lg iq oa b gy ov os l ot ou">   type: String,</span><span id="c09a" class="lx lg iq oa b gy ov os l ot ou">   required: true, unique: true,</span><span id="08f5" class="lx lg iq oa b gy ov os l ot ou">   minlength: 2, maxlength: 255,</span><span id="e390" class="lx lg iq oa b gy ov os l ot ou">},</span><span id="9bac" class="lx lg iq oa b gy ov os l ot ou">password: {</span><span id="016d" class="lx lg iq oa b gy ov os l ot ou">   type: String, required: true,</span><span id="c948" class="lx lg iq oa b gy ov os l ot ou">   minlength: 2, maxlength: 1024,</span><span id="d0f0" class="lx lg iq oa b gy ov os l ot ou">},</span><span id="5b9c" class="lx lg iq oa b gy ov os l ot ou">});</span><span id="c04f" class="lx lg iq oa b gy ov os l ot ou">const userClass = mongoose.model('userClass', userSchema);</span><span id="aa4f" class="lx lg iq oa b gy ov os l ot ou"><br/>function validateUser(user){<br/>   const schema = Joi.object({<br/>   name: Joi.string().min(3).max(50).required(),<br/>   email: Joi.string().min(3).max(255).required().email(),<br/>   password: Joi.string().min(3).max(255).required()<br/>});</span><span id="dd2d" class="lx lg iq oa b gy ov os l ot ou">   return schema.validate(user);<br/>}</span></pre><h2 id="1b10" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.注册用户</h2><p id="f031" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">因此，一旦我们创建了用户模式，接下来我们就可以添加路由，最好包含添加用户的POST请求，以及对姓名、电子邮件、密码条件和是否已注册等的检查。,</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="0da3" class="lx lg iq oa b gy or os l ot ou">router.post('/', async (req, res) =&gt; {<br/>  const { error } = validateUser(req.body)<br/>  if (error) return res.status(400).send(error.details[0].message);</span><span id="167f" class="lx lg iq oa b gy ov os l ot ou">  let user = await userClass.findOne({email: req.body.email})<br/>  if (user) return res.status(400).send('User Already Registered.');</span><span id="f1d1" class="lx lg iq oa b gy ov os l ot ou"> <strong class="oa ja"> user = new userClass({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: req.body.password<br/>});</strong></span><span id="72f1" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">try{<br/>  await user.save()<br/>  res.send(user)</strong><br/>}catch (ex){<br/>  console.log('Error in Promises', ex.message)<br/>  res.status(400).send( ex.message)<br/>}<br/>})</span></pre><h2 id="1867" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.使用Lodash</h2><p id="350d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">通过手动索引每个元素，每次实际读取路由中的req.body都很麻烦。因此，我们将使用一个名为lodash的实用程序库来简化我们的工作并节省时间。</p><p id="fb0d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">Lodash通过消除处理数组、数字、对象、字符串等的麻烦，使JavaScript变得更加简单。</p><p id="3a87" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以我用lodash实用程序库替换了上面用户注册中的一些代码。尤其是。从lodash库中选取，以从req.body中自动选取元素</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="1643" class="lx lg iq oa b gy or os l ot ou">router.post('/', async (req, res) =&gt; {<br/>  const { error } = validateUser(req.body)<br/>  if (error) return res.status(400).send(error.details[0].message);</span><span id="facc" class="lx lg iq oa b gy ov os l ot ou">  let user = await userClass.findOne({email: req.body.email})<br/>  if (user) return res.status(400).send('User Already Registered.');</span><span id="6add" class="lx lg iq oa b gy ov os l ot ou">  <strong class="oa ja">user = new userClass(_.pick(req.body, ['name', 'email', <br/>                                         'password']));</strong><br/>  try{<br/>    await user.save()<br/>    <strong class="oa ja">res.send(_.pick(user, ['_id', 'name', 'email']))</strong><br/>  }catch (ex){<br/>    console.log('Error in Promises', ex.message)<br/>    res.status(400).send( ex.message)<br/>}<br/>})</span></pre><p id="104c" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多关于那个<a class="ae le" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="97ed" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.哈希密码</h2><p id="5006" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">我们不能存储密码，因为当黑客入侵数据库时，所有用户的账户和密码都是可见的。</p><p id="7fec" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以我们使用一个叫做bcrypt的流行库来散列他们的密码。</p><p id="79ae" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">我们需要理解SALT的概念，它在bcrypt库中用于加密和解密密码。</p><blockquote class="qi qj qk"><p id="5cd1" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated">SALT在密码之前或之后添加的随机字符串。</p></blockquote><p id="2287" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">如前所述，它在密码中添加了一个随机字符串，以防止模式被黑客猜到。</p><p id="b02c" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，在保存密码之前，我们只需对密码进行哈希运算，并将其保存在数据库中。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="fc6f" class="lx lg iq oa b gy or os l ot ou"><strong class="oa ja">const salt = await bcrypt.genSalt(10);</strong></span><span id="fc43" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">user.password = await bcrypt.hash(user.password, salt);</strong></span></pre><p id="4436" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多信息请点击。</p><h2 id="af03" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.认证用户</h2><p id="c41d" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在，我们已经成功地将用户存储在我们的数据库中，现在我们必须接收用户登录，并需要通过在我们的数据库中检查他们来验证他们。</p><p id="28e3" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以我为这次行动增加了新的路线。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="e044" class="lx lg iq oa b gy or os l ot ou">router.post('/', async (req, res) =&gt; {<br/>  const { error } = validateUser(req.body)<br/>  if (error) return res.status(400).send(error.details[0].message);</span><span id="858e" class="lx lg iq oa b gy ov os l ot ou">  let user = await userClass.findOne({email: req.body.email})<br/>  if (!user) return res.status(400).send('Invalid Email.');</span><span id="f50d" class="lx lg iq oa b gy ov os l ot ou">  <strong class="oa ja">const validPassword = await bcrypt.compare(req.body.password, <br/>                                             user.password)<br/>  if (!validPassword) return res.status(400).send('Invalid <br/>                                                   Password.');<br/>  <br/>  try{<br/>    res.send(true) // Sending True</strong><br/>  }catch (ex){<br/>  console.log('Error in Promises', ex.message)<br/>  res.status(400).send( ex.message)<br/>}<br/>})</span></pre><p id="ead1" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">到目前为止，如果我们成功地验证了用户，我们只需发送一个真实的响应。但是我们需要发送一些更优雅的东西，以便用户可以继续做一些API操作等。,</p><h2 id="8539" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.JSON Web令牌(JWT)</h2><blockquote class="qi qj qk"><p id="acb3" class="nf ng ow mn b mo ns ka nh mq nt kd ni ql nu nk nl qm nv nn no qn nw nq nr mv ij bi translated">JSON Web令牌JWT是一个标识用户的长字符串。</p></blockquote><p id="1027" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">请点击下面的链接，看看它是什么样子的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qo"><img src="../Images/13489d6fad1e9db5176eb01b8484a387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SybAp-modOYVl2YbzugxrA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">JWT一代</figcaption></figure><p id="9621" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在左边，我们有JWT代币，有红、紫、蓝三种颜色。</p><p id="f936" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在右侧，我们有其相应的颜色属性，红色表示报头，即指定的算法，紫色表示有效载荷部分，即包含用户相关数据的部分，蓝色表示数字签名属性，即基于有效载荷主体的内容以及仅在服务器上可用的密钥创建的属性。</p><p id="62f9" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以黑客无法生成这个数字签名，因为它存储在网络服务器上</p><p id="f5d8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多关于<a class="ae le" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="275e" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.生成认证令牌</h2><p id="7506" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在，我们将生成一个JWT令牌来对用户进行身份验证，并在稍后从jwt.io站点进行验证，以检查我们的令牌是否正常工作，而不是在身份验证时向客户端发送一个简单的true响应。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="b2af" class="lx lg iq oa b gy or os l ot ou">router.post('/', async (req, res) =&gt; {<br/>   const { error } = validateUser(req.body)<br/>   if (error) return res.status(400).send(error.details[0].message);<br/>   let user = await userClass.findOne({email: req.body.email})</span><span id="c559" class="lx lg iq oa b gy ov os l ot ou">   if (!user) return res.status(400).send('Invalid Email.');<br/>   const validPassword = await bcrypt.compare(req.body.password, <br/>                                              user.password)<br/>   <br/>   if (!validPassword) return res.status(400).send('Invalid <br/>       Password.');<br/>   try{<br/>      <strong class="oa ja">const token = jwt.sign({ _id: user._id, email: user.email },       'jwtPrivateKey') // Payload + Private Key<br/>   res.send(token)</strong><br/>   }catch (ex){<br/>      console.log('Error in Promises', ex.message)<br/>      res.status(400).send( ex.message)<br/>      }<br/>})</span></pre><p id="eef5" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">让我向您展示我们如何点击API，然后验证我们收到的JWT令牌。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/d95d0f873b9639acaa742eed2dbc1292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzMaB6qSSQKU4KWQCk62NQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">JWT·托肯在左边</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/29c8955eee5fced0b8f5cbc41df30475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5e7rWZoM5-_P6D3OeRSrvg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">收到的JWT令牌左边的有效负载</figcaption></figure><p id="2a6c" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在，当我们将通过POST请求收到的JWT令牌粘贴到这里时，我们可以看到相应的有效负载就是我们之前发送的用于生成JWT的内容。</p><h2 id="5d2d" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">9.设置响应标题</h2><p id="c218" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">因此，以前当我们创建一个新用户时，我们只在正文中发送名称、电子邮件。现在我们也可以发送JWT令牌，但是将JWT令牌存储在接收到的POST请求的头响应中更合适。</p><p id="480a" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">这样浏览器可以将JWT令牌存储在头变量中，我们可以直接对其进行身份验证。</p><p id="5a37" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，让我们对新用户创建进行一些修改，并用x-auth-jwtoken变量将令牌发送到返回头。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="8730" class="lx lg iq oa b gy or os l ot ou">router.post('/', async (req, res) =&gt; {<br/>  const { error } = validateUser(req.body)<br/>  if (error) return res.status(400).send(error.details[0].message);</span><span id="fc44" class="lx lg iq oa b gy ov os l ot ou">  let user = await userClass.findOne({email: req.body.email})<br/>  if (user) return res.status(400).send('User Already Registered.');</span><span id="78b6" class="lx lg iq oa b gy ov os l ot ou">  user = new userClass(_.pick(req.body, ['name', 'email', <br/>'password']));<br/>  const salt = await bcrypt.genSalt(10);<br/>  user.password = await bcrypt.hash(user.password, salt);</span><span id="dff8" class="lx lg iq oa b gy ov os l ot ou">  try{</span><span id="4443" class="lx lg iq oa b gy ov os l ot ou">    await user.save()<br/>    <strong class="oa ja">const token = jwt.sign({ _id: user._id, email: user.email }, 'MySecurePrivateKey')<br/>    res.header('x-auth-jwtoken', token).send(_.pick(user, ['_id', 'name', 'email']))</strong><br/>  }catch (ex){<br/>    console.log('Error in Promises', ex.message)<br/>    res.status(400).send( ex.message)<br/>  }<br/>})</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/de88e3997605e1127385ff571d1051c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lg9Bw-3LuCRKXtvXDJPxIw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">所以在headers部分，我们看到了新的变量。x-auth-jwtoken</figcaption></figure><h2 id="ecb4" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">10.授权中间件</h2><p id="70dc" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">现在，我们有了一个独立的用户群，我们在创建帐户时将JWT令牌的识别密钥直接发送到他们的浏览器标题。现在，当这些用户在我们的电影数据库上执行任何操作时，比如Get或POST——创建一个新条目，我们需要根据他们头中的JWT令牌对他们进行授权</p><p id="38f8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，如果您还记得上一节中的中间件功能，我们使用了一个中间件，它验证了几乎所有的请求，而无需在所有代码中明确指定它们。</p><p id="f25d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以将在中间件文件夹中创建一个新函数用于授权。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="4b94" class="lx lg iq oa b gy or os l ot ou">// CUSTOM FUNCTIONS - For Auth</span><span id="80df" class="lx lg iq oa b gy ov os l ot ou">function auth(req, res, next){<br/>   console.log('Authentication Starts...');<br/>   <strong class="oa ja">const token = req.header('x-auth-token');<br/>   <br/>   if (!token) return res.status(401).send('Access Denied. No Token Provided')</strong></span><span id="0720" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   try{<br/>     const decoded = jwt.verify(token, 'MyPrivateKeyJWT');<br/>     req.user = decoded;  <br/>     next();</strong><br/>   }catch(ex){<br/>     res.status(400).send('Invalid Token')<br/>   }<br/>}</span></pre><p id="bf77" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在我们不想在每个地方都授权用户，所以假设只有当用户在电影数据库附近执行任何操作时，我们才添加要执行的认证。</p><p id="0e7f" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，在电影路由处理器中，我们将添加代码。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="f7b3" class="lx lg iq oa b gy or os l ot ou">const auth  = require('../middleware/auth')</span><span id="ee50" class="lx lg iq oa b gy ov os l ot ou">// Route, middleware, function<br/>router.get('/', <strong class="oa ja">auth</strong>, async (req, res) =&gt; {<br/>  const allMovies  = await movieClass.find().sort('movieName')<br/>  res.send(allMovies)<br/>})</span></pre><p id="e806" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">现在，如果我们试图点击GET API，我们肯定会得到一个错误。因为我们还没有在头中发送auth令牌。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/0722c2e458a35057dda8022c7e54f6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFhW1WHRie99RP2oRobhWw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">没有任何令牌的响应</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qf"><img src="../Images/62700289a35823cfae38b49929f4b6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xt5FUlADwAPRDa6OpJlOgQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">无效令牌的响应</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/ecb8240bc7cab6e8f1fd45811e39e8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ENGugNeTsZZ7utceVm-Tw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">为用户传递正确的身份验证令牌</figcaption></figure><p id="10e8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">同样，您可以保护大多数需要保护的路线。</p><h2 id="60a8" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">11.获取当前用户</h2><p id="c8ba" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时，我们需要记录谁在执行哪个API请求，因此在路由处理程序中，我们希望知道用户的详细信息。因此，让我们在路由中启用用户标识。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="f7e8" class="lx lg iq oa b gy or os l ot ou">const auth  = require('../middleware/auth')<br/>const {userClass, validateUser} = require('../models/users')</span><span id="8a31" class="lx lg iq oa b gy ov os l ot ou">router.get('/me', auth, async(req, res) =&gt; {<br/>   <strong class="oa ja">const user = await userClass.findById(req.user._id).select('-<br/>password')<br/>   res.send(user);</strong><br/>});</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/e93fe32573052f5087cbe42ab4933b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ITE4yfpB5rxNf7T-Yj18w.png"/></div></div></figure></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="9abd" class="lf lg iq bd lh li oi lk ll lm oj lo lp kf ok kg lr ki ol kj lt kl om km lv lw bi translated">X.处理和记录错误</h1><p id="eba5" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">有时在现实世界中，我们可能会遇到问题。因此，我们不能向用户发送我们有问题，相反，我们可以向用户发送友好的错误消息，并记录错误，以便我们可以检查它并尽早解决它。因此，在接下来的部分中，我们可能会学习如何处理和记录错误。</p><h2 id="4064" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">1.处理拒绝的承诺</h2><p id="b26f" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">当我们处理承诺的时候，我们需要或者放一个。catch块来处理这些承诺。</p><p id="cc34" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">但是如果我们使用async和await功能，那么我们必须使用try、catch块来处理被拒绝的承诺，否则，进程将被终止。</p><p id="8141" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，当获得电影的操作，如果数据库没有准备好，我们将发送一个友好的错误，说明我们没有准备好不服务。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="abaf" class="lx lg iq oa b gy or os l ot ou">// Route, mware, function</span><span id="1aa2" class="lx lg iq oa b gy ov os l ot ou">router.get('/', auth, async (req, res) =&gt; {<br/><strong class="oa ja">  try{<br/>    const allMovies  = await movieClass.find().sort('movieName')<br/>    res.send(allMovies)<br/>  }catch (ex){<br/>  // Log the error<br/>  res.status(500).send('Something failed. Please try again')<br/>}})</strong></span></pre><h2 id="411c" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">2.快速错误中间件</h2><p id="a295" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">我们可能已经开发了一千个带有自定义错误消息和try-catch块的路由，我们不能单独修改它们中的每一个，所以我们需要找到一种方法在一个地方处理它们，特别是在中间件中。</p><p id="c1d9" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以这个实现将会很棘手，所以我更希望您能看到本文附件中的GitHub库，以便更加清晰。</p><p id="a8c8" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">我们创建了一个错误处理函数，这样我们就可以在任何地方使用它。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="d0be" class="lx lg iq oa b gy or os l ot ou">// Error handling</span><span id="6b29" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">function errorHandling(err, req, res, next){</strong></span><span id="39db" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  // Log the Exception</strong></span><span id="f465" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  res.status(500).send('Something failed. Please try again')</strong></span><span id="5966" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">}</strong></span><span id="5df9" class="lx lg iq oa b gy ov os l ot ou">module.exports = errorHandling</span></pre><p id="9946" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">并将其作为中间件，在index.js文件中调用，<code class="fe nx ny nz oa b">app.use(errorHandling)</code>。</p><p id="df32" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">此外，我们在几乎每个路由中都使用了大量的try-catch块，因此我们定义了一个通用函数来处理它，并将参数传递给我们的路由。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="c7ea" class="lx lg iq oa b gy or os l ot ou">function asyncMiddleware(handler){<br/><strong class="oa ja">  return async (req,res, next) =&gt; { <br/>  // Standard express route handler<br/>  try{<br/>    await handler(req, res);<br/>  }catch(ex){<br/>    next(ex)</strong><br/>}}}</span><span id="3f16" class="lx lg iq oa b gy ov os l ot ou">module.exports = asyncMiddleware</span></pre><p id="aac6" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">然后包装我们的路由，并将处理程序传递给函数。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="07c3" class="lx lg iq oa b gy or os l ot ou">router.get('/', auth, <strong class="oa ja">asyncMiddleware(async (req, res) =&gt; {</strong></span><span id="3475" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  const allMovies  = await movieClass.find().sort('movieName')</strong></span><span id="480d" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">  res.send(allMovies)</strong></span><span id="8a8d" class="lx lg iq oa b gy ov os l ot ou">}));</span></pre><h2 id="23e6" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">3.使用快速异步错误</h2><p id="0587" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">当我们在asyncMiddleware函数中包装我们所有的路由时，这又是一件麻烦的事情，幸运的是，在为我们做这项工作时有一个package express-async-errors。</p><p id="a32d" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">安装它并像<code class="fe nx ny nz oa b">require('express-asunc-errors')</code>一样在index.js中调用它，它会处理所有的路由，所以您可以从路由中删除asyncMiddleware包装。</p><h2 id="d412" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">4.记录错误</h2><p id="0dc1" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">为了记录错误，我们可以使用一个名为Winston的包。</p><p id="2b34" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">它有像console、HTTP、file这样的传输方法，或者只显示错误，或者将错误发送到HTTP地址，或者保存到文件中。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="02a0" class="lx lg iq oa b gy or os l ot ou">winston.add(new winston.transports.File({ filename: 'combined.log' }))</span></pre><p id="9c40" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">此外，它有扩展插件存储在MongoDB，Redis等。,</p><p id="7428" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">因此，我们修改错误处理程序，将消息记录在一个文件中。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="fd74" class="lx lg iq oa b gy or os l ot ou">function errorHandling(err, req, res, next){</span><span id="3a7e" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   // Log the Exception</strong></span><span id="22c9" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   winston.log('error', err.message, err) <br/>   // Logging level - error,    warning, info, verbose, debug, silly</strong></span><span id="17e3" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">   res.status(500).send('Something failed. Please try again')</strong></span><span id="2bdf" class="lx lg iq oa b gy ov os l ot ou">}</span><span id="e664" class="lx lg iq oa b gy ov os l ot ou">module.exports = errorHandling</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/a28b0e1938b65032027a14023e57a2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF56u6XbWJuxoJQbV3V_5w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">combined.log</figcaption></figure><p id="5e59" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">更多关于那个<a class="ae le" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="0932" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">5.记录到MongoDB</h2><p id="6745" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">要将日志直接存储在MongoDB中，而不需要手动创建CRUD操作，我们可以使用Winston的另一个库。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="2ea0" class="lx lg iq oa b gy or os l ot ou">// npm install winston-mongodb@3.0.0</span><span id="9090" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">winston.add(new winston.transports.MongoDB({<br/>  db: 'mongodb://localhost/movies',<br/>  level: 'error' <br/>}))</strong></span></pre><p id="67fc" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">就是这样，如果我们遇到任何错误，它会将错误直接记录到MongoDB中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qe"><img src="../Images/d617a28a2547b4985ea3443c1bcfabfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TT4Gpu88IgNGTHlSn8v4Ew.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">MongoDB中的错误</figcaption></figure><h2 id="6274" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">6.处理未捕获的异常</h2><p id="47ea" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">并非所有的错误都发生在路由内部。有时我们可能会在外部得到错误，而当前的实现无法找到它们，所以我们需要给Winston添加一个新方法来记录这些错误。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="a0a5" class="lx lg iq oa b gy or os l ot ou"><strong class="oa ja">process.on('uncaughtException', (ex) =&gt; {<br/>  console.log('Some uncaught Excpetion')<br/>  winston.error(ex.message, ex)<br/>})</strong></span><span id="5cd0" class="lx lg iq oa b gy ov os l ot ou">// throw new Error('Something went down')</span></pre><h2 id="d03a" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">7.未处理的承诺拒绝</h2><p id="5dfd" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">这里我们处理未处理的异常和未处理的承诺拒绝。注意:它将停止节点服务器。</p><pre class="kp kq kr ks gt on oa oo op aw oq bi"><span id="6681" class="lx lg iq oa b gy or os l ot ou"><strong class="oa ja">winston.handleExceptions(<br/>new winston.transports.File({filename: 'uncaughtExceptions.log'})<br/>)</strong></span><span id="1f39" class="lx lg iq oa b gy ov os l ot ou"><strong class="oa ja">process.on('unhandledRejection', (ex) =&gt; {<br/>  throw ex;<br/>})</strong></span><span id="7de8" class="lx lg iq oa b gy ov os l ot ou">// Error simulation<br/>const p = Promise.reject(new Error('Promise failure'))<br/>p.then( () =&gt; console.log('Done'))</span></pre><h2 id="539c" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">8.代码重构</h2><p id="fc30" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">启动文件index.js不应该包含我们在项目中使用的所有参数，所以我们必须将路由、日志、数据库等分开。，放在不同的文件中以便于调试。</p><p id="6fc9" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">所以我已经这样做了，并把新代码放到了Github的仓库里，你可以在那里下载并播放。</p><p id="1d99" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">祝贺你到达终点。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h2 id="fc01" class="lx lg iq bd lh ly lz dn ll ma mb dp lp mc md me lr mf mg mh lt mi mj mk lv iw bi translated">参考和存储库</h2><p id="14e1" class="pw-post-body-paragraph nf ng iq mn b mo mp ka nh mq mr kd ni mc nj nk nl mf nm nn no mi np nq nr mv ij bi translated">包含所有与本文相关的代码和依赖项，可以在这里找到:<a class="ae le" href="https://github.com/bala-codes/A-Primer-on-Node.js" rel="noopener ugc nofollow" target="_blank">https://github.com/bala-codes/A-Primer-on-Node.js</a></p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="d29c" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated">在那之前，下次见。</p><p id="7272" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated"><strong class="mn ja">文章作者:</strong></p><p id="34fb" class="pw-post-body-paragraph nf ng iq mn b mo ns ka nh mq nt kd ni mc nu nk nl mf nv nn no mi nw nq nr mv ij bi translated"><strong class="mn ja"> BALAKRISHNAKUMAR V </strong></p></div></div>    
</body>
</html>