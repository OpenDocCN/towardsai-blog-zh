<html>
<head>
<title>The difference between a=a+b and a+=b in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中a=a+b和a+=b的区别</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-difference-between-a-a-b-and-a-b-in-python-a7338d96e408?source=collection_archive---------0-----------------------#2021-07-11">https://pub.towardsai.net/the-difference-between-a-a-b-and-a-b-in-python-a7338d96e408?source=collection_archive---------0-----------------------#2021-07-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="ae2a" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><figure class="gm go kb kc kd ke gi gj paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gi gj ka"><img src="../Images/2d6c77dccd4d5da933d85f0218cf7645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWXBlcYJFFUufmsybM2lfw.png"/></div></div></figure><h1 id="51c4" class="kl km iu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">介绍</h1><p id="28fc" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">我相信你已经知道Python中的串联运算符<strong class="ll je"> + </strong>和<strong class="ll je"> += </strong>。顾名思义，连接操作符用于连接多个序列类型(例如，连接两个列表)。同样，当您想要重复一个序列类型<strong class="ll je"> n次</strong>时，使用<strong class="ll je"> * </strong>和<strong class="ll je"> *= </strong>。你也知道这两者会产生相同的结果。</p><p id="8743" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">但是许多Python开发者认为<strong class="ll je"> my_list1 += my_list2 </strong>是<strong class="ll je">my _ list 1 = my _ list 1+my _ list 2</strong>的简写符号。同样的道理也适用于<strong class="ll je"> my_list1 *= n </strong>和<strong class="ll je"> my_list1 = my_list * n. </strong>但这远非事实。</p><p id="5dbd" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">在这篇短文中，你将了解到<strong class="ll je"> + </strong> vs <strong class="ll je"> += </strong>和<strong class="ll je"> * </strong> vs <strong class="ll je"> *= </strong>的区别。</p></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h1 id="d508" class="kl km iu bd kn ko mt kq kr ks mu ku kv kw mv ky kz la mw lc ld le mx lg lh li bi translated">+和+=</h1><p id="767a" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">让我们看下面一个使用列表的例子。当您尝试使用<strong class="ll je"> + </strong>运算符连接两个列表<strong class="ll je"> mylist_1 </strong>和<strong class="ll je"> mylist_2 </strong>时，它会创建一个<strong class="ll je">新对象</strong>，并将<strong class="ll je"> mylist_1 </strong>分配给新对象。</p><p id="61a8" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">如你所见<strong class="ll je"> mylist_1 </strong>和<strong class="ll je"> mylist_2 </strong>指向两个不同的内存位置。并且连接的结果也指向不同的存储器位置。</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="f134" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; mylist_1 = [1, 2, 3]<br/>&gt;&gt;&gt; mylist_2 = [4, 5]<br/>&gt;&gt;&gt; print(id(mylist_1), id(mylist_2))<br/>1614327515784 1614319969800</span><span id="f5a0" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; mylist_1 = mylist_1 + mylist_2<br/>&gt;&gt;&gt; print(mylist_1)<br/>&gt;&gt;&gt; print(id(mylist_1))<br/>[1, 2, 3, 4, 5]<br/>1614319969416</span></pre><p id="5631" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">现在，看看同一个例子，但是使用了<strong class="ll je">就地连接操作符</strong> <strong class="ll je"> += </strong>。如您所见，<strong class="ll je"> += </strong>操作符没有创建新的对象。<strong class="ll je"> mylist_1 </strong>在串联前后指向相同的内存位置。我们可以说<strong class="ll je"> mylist_1 </strong>变异了。</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="6d39" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; mylist_1 = [1, 2, 3]<br/>&gt;&gt;&gt; mylist_2 = [4, 5]<br/>&gt;&gt;&gt; print(id(mylist_1), id(mylist_2))<br/>1614325213896 1614316889416</span><span id="265d" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; mylist_1 += mylist_2<br/>&gt;&gt;&gt; print(mylist_1)<br/>&gt;&gt;&gt; print(id(mylist_1))<br/>[1, 2, 3, 4, 5]<br/>1614325213896</span></pre><p id="5172" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">但是，对于不可变的对象，如int、floats、string等。没关系。从下面的例子可以看出，在两种情况下，串联前后<strong class="ll je"> num1 </strong>的存储位置是不同的。</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="77ad" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; num1 = 10<br/>&gt;&gt;&gt; num2 = 20<br/>&gt;&gt;&gt; id(num1), id(num2)<br/>(140726841418416, 140726841418736)</span><span id="cff2" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; num1 = num1 + num2<br/>&gt;&gt;&gt; id(num1)  <br/>140726841419056</span><span id="6f93" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; num1 += num2<br/>&gt;&gt;&gt; id(num1)<br/>140726841419696</span></pre><p id="887b" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je">两个串联运算符的区别在于,+创建一个新列表，而+=就地修改一个现有列表。</strong></p><h1 id="9b1c" class="kl km iu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak"> *和*= </strong></h1><p id="f717" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">重复操作符的行为也类似于我们刚刚学习的连接操作符。参考下面的例子。<strong class="ll je"> mylist1 </strong>的存储位置在重复(*)运算符前后不同。</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="2a6e" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; mylist1 = [1,2]<br/>&gt;&gt;&gt; id(mylist1)<br/>2020051867784</span><span id="ed02" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; mylist1 = mylist1 * 3<br/>&gt;&gt;&gt; print(mylist1)<br/>[1, 2, 1, 2, 1, 2]<br/>&gt;&gt;&gt; id(mylist1)<br/>2020051883912</span></pre><p id="aedc" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">现在，让我们看看使用<strong class="ll je"> *= </strong>操作符的同一个例子。如您所见，在串联操作之前和之后，mylist1的内存位置是相同的。所以，<strong class="ll je"> mylist1 </strong>是用*=运算符变异的。</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="46f1" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; mylist1 = [1,2]<br/>&gt;&gt;&gt; id(mylist1)<br/>2020051837832</span><span id="6073" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; mylist1 *= 3<br/>&gt;&gt;&gt; print(mylist1)<br/>[1, 2, 1, 2, 1, 2]<br/>&gt;&gt;&gt; id(mylist1)<br/>2020051837832</span></pre><p id="ee84" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated">就地重复操作符对不可变对象也没有影响，因为我们不能修改不可变对象。</p><p id="44ac" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je">两个重复操作符之间的区别在于,*创建一个新列表，而*=就地修改一个现有列表。</strong></p><h1 id="cb44" class="kl km iu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">优点</strong></h1><p id="7d3b" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">使用原地连接(+=)或原地重复(*=)的主要好处是它比普通的连接或重复操作更快。因为就地操作改变了对象，Python不必创建新的对象，这样可以节省一些时间。</p><h2 id="e612" class="nh km iu bd kn nn no dn kr np nq dp kv lu nr ns kz ly nt nu ld mc nv nw lh ja bi translated"><strong class="ak">级联速度比较</strong></h2><p id="1865" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">从下面的例子可以看出，+=比+运算符稍快一些。+运算符花费了2.42秒，而+=运算符花费了2.29秒。</p><p id="13e0" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je"> +操作员</strong></p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="69bf" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; code = """<br/>&gt;&gt;&gt; mylist_1 = [1, 2, 3, 4, 5, 7, 8]<br/>&gt;&gt;&gt; mylist_2 = [9, 10]<br/>&gt;&gt;&gt; mylist_1 = mylist_1 + mylist_2<br/>&gt;&gt;&gt; """<br/>&gt;&gt;&gt; import timeit<br/>&gt;&gt;&gt; timeit.timeit(stmt=code, number=10_000_000)<br/>2.428993300000002</span></pre><p id="209d" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je"> +=操作员</strong></p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="b786" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; code = """<br/>&gt;&gt;&gt; mylist_1 = [1, 2, 3, 4, 5, 7, 8]<br/>&gt;&gt;&gt; mylist_2 = [9, 10]<br/>&gt;&gt;&gt; mylist_1 += mylist_2<br/>&gt;&gt;&gt; """<br/>&gt;&gt;&gt; import timeit<br/>&gt;&gt;&gt; timeit.timeit(stmt=code, number=10_000_000)<br/>2.293214599999999</span></pre><h2 id="b88a" class="nh km iu bd kn nn no dn kr np nq dp kv lu nr ns kz ly nt nu ld mc nv nw lh ja bi translated"><strong class="ak">重复速度比较</strong></h2><p id="ea8c" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">从下面的例子可以看出，* <strong class="ll je"> = </strong>比*运算符稍微快一些。*运算符采用</p><p id="6869" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je">*操作员</strong></p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="8bb6" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; code = """<br/>&gt;&gt;&gt; mylist_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>&gt;&gt;&gt; mylist_1 = mylist_1 * 2<br/>&gt;&gt;&gt; """</span><span id="29b8" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; import timeit<br/>&gt;&gt;&gt; timeit.timeit(stmt=code, number=10_000_000)<br/>4.3188133</span></pre><p id="1632" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je"> *=操作员</strong></p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="03db" class="nh km iu nd b gz ni nj l nk nl">&gt;&gt;&gt; code = """<br/>&gt;&gt;&gt; mylist_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>&gt;&gt;&gt; mylist_1 *= 2<br/>&gt;&gt;&gt; """</span><span id="8a8e" class="nh km iu nd b gz nm nj l nk nl">&gt;&gt;&gt; import timeit<br/>&gt;&gt;&gt; timeit.timeit(stmt=code, number=10_000_000)<br/>4.291261399999999</span></pre><h1 id="55bc" class="kl km iu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="92c1" class="pw-post-body-paragraph lj lk iu ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg in bi translated">在本文中，您已经理解了<code class="fe nx ny nz nd b"><strong class="ll je">+ and +=</strong></code>和<code class="fe nx ny nz nd b">* and *=</code>操作符之间的一个重要区别。*和+操作符创建一个新列表，而t <code class="fe nx ny nz nd b">+= and *=</code>就地修改一个现有列表。</p><p id="4091" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><em class="oa">原载于2021年6月22日</em><a class="ae ob" href="https://pythonsimplified.com/know-the-difference-between-add-vs-inplace/" rel="noopener ugc nofollow" target="_blank"><strong class="ll je"><em class="oa">python简化</em></strong></a><strong class="ll je"><em class="oa"/></strong><em class="oa">。</em></p><h1 id="562c" class="kl km iu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">进一步阅读</h1><ul class=""><li id="4a0c" class="oc od iu ll b lm ln lq lr lu oe ly of mc og mg oh oi oj ok bi translated"><a class="ae ob" href="https://pythonsimplified.com/making-sense-of-python-iterables-and-iterators/" rel="noopener ugc nofollow" target="_blank">Python中iterables和迭代器的区别</a></li><li id="894e" class="oc od iu ll b lm ol lq om lu on ly oo mc op mg oh oi oj ok bi translated"><a class="ae ob" href="https://pythonsimplified.com/difference-between-sort-and-sorted-in-python/" rel="noopener ugc nofollow" target="_blank">Python中sort()和sorted()的区别</a></li><li id="c9d9" class="oc od iu ll b lm ol lq om lu on ly oo mc op mg oh oi oj ok bi translated"><a class="ae ob" href="https://pythonsimplified.com/the-most-controversial-python-walrus-operator/" rel="noopener ugc nofollow" target="_blank">最有争议的Python的海象算子</a></li><li id="dabf" class="oc od iu ll b lm ol lq om lu on ly oo mc op mg oh oi oj ok bi translated"><a class="ae ob" href="https://pythonsimplified.com/geocoding-in-python-using-geopy/" rel="noopener ugc nofollow" target="_blank">使用Geopy在Python中进行地理编码</a></li><li id="fc1e" class="oc od iu ll b lm ol lq om lu on ly oo mc op mg oh oi oj ok bi translated"><a class="ae ob" href="https://pythonsimplified.com/understanding-indexing-and-slicing-in-python/" rel="noopener ugc nofollow" target="_blank">了解Python中的索引和切片</a></li><li id="a8cb" class="oc od iu ll b lm ol lq om lu on ly oo mc op mg oh oi oj ok bi translated"><a class="ae ob" href="https://pythonsimplified.com/python-list-vs-tuple/" rel="noopener ugc nofollow" target="_blank"> Python列表Vs Tuple </a></li></ul><p id="a518" class="pw-post-body-paragraph lj lk iu ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg in bi translated"><strong class="ll je"> <em class="oa">希望你喜欢看这篇文章。如果你喜欢我的文章并想订阅Medium，你可以在这里这样做:</em> </strong></p><div class="oq or gq gs os ot"><a href="https://chetanambi.medium.com/membership" rel="noopener follow" target="_blank"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd je gz z fq oy fs ft oz fv fx jd bi translated">通过我的推荐链接加入媒体- Chetan Ambi</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">chetanambi.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kj ot"/></div></div></a></div></div></div>    
</body>
</html>