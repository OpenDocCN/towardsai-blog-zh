<html>
<head>
<title>Forecast The Future With Time Series Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用时间序列分析预测未来</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/forecast-the-future-with-time-series-analysis-e7793368d879?source=collection_archive---------1-----------------------#2022-03-31">https://pub.towardsai.net/forecast-the-future-with-time-series-analysis-e7793368d879?source=collection_archive---------1-----------------------#2022-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用example…✈进行单变量时间序列分析的详细说明</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9e33d7548552c506583cee4d286bddbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtZH9EfIcfRE9KWowSC-NA.jpeg"/></div></div></figure><h1 id="39af" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="4909" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">时间序列分析是一种分析以数据-时间格式排序的数据的方法。简单来说，我们可以说数据帧的索引是时间戳的形式(日期格式)。单变量时间序列分析只包含一个变量，目标变量是基于时间预测的。我用一个例子来解释一下单变量时间序列分析的所有概念。</p><h1 id="0a44" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">入门指南</h1><p id="35a9" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本文中，我将处理来自Kaggle网站的"<a class="ae ma" href="https://www.kaggle.com/search?q=air+passengers+in%3Adatasets" rel="noopener ugc nofollow" target="_blank"><em class="mb"/></a><em class="mb">"</em>航空乘客数据集。该数据集包含从1949年1月到1960年12月通过航空公司旅行的乘客的每月wise记录。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mc"><img src="../Images/593071e326389541463166107fd0e5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OGYMvDf_NgTmr8_intE3w.png"/></div></div></figure><h2 id="842a" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">导入包</h2><p id="07ed" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，我会通过导入<strong class="jp ir"> warnings </strong>包，调用<strong class="jp ir"> filterwarnings </strong>方法，使警告不在python记事本中显示。</p><p id="7188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="0dda" class="md ky iq mq b gy mu mv l mw mx">import warnings<br/>warnings.filterwarnings(“ignore”)</span></pre><p id="7ceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在Import命令的帮助下，将所需的库导入python笔记本。在这里，<strong class="jp ir"> Pandas </strong>库用于我们玩数据集。而<strong class="jp ir"> NumPy </strong>库用于我们对数据帧进行数值运算，而<strong class="jp ir"> Matplotlib </strong>用于绘制数据帧。</p><p id="09ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="a859" class="md ky iq mq b gy mu mv l mw mx">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><h2 id="396f" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">读取数据集</h2><p id="007b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">借助熊猫包中的<strong class="jp ir"> read_csv </strong>方法读取数据集(airline_passengers.csv ),并使用<strong class="jp ir"> head </strong>方法显示前5行。</p><p id="c90e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="b8c0" class="md ky iq mq b gy mu mv l mw mx">df=pd.read_csv(“airline_passengers.csv”)<br/>df.head()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c9332d0ff27a6eaf720e7b866861df7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*q1IwOVNh82qpFTCu6zzcww.png"/></div></figure><h2 id="f694" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">探索数据</h2><p id="597b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">借助Pandas包的内置方法探索数据集。</p><p id="4a94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="543b" class="md ky iq mq b gy mu mv l mw mx">df.info()</span><span id="3144" class="md ky iq mq b gy mz mv l mw mx">df.describe()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8208c7cd274d7e573bc2b94643d226e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*-KQC4RrX09ArZCI5SzysPw.png"/></div></figure><p id="9677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，月份列是对象格式的。我们需要使用<strong class="jp ir"> to_datetime </strong>方法将其转换为日期-时间格式，然后使用<strong class="jp ir"> set_index </strong>方法将其指定为数据帧的索引。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/73583c3da4bce6ba58ed272e9f7f757c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*x76viDWkRT7woc9VsmUOIw.png"/></div></figure><p id="303d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<strong class="jp ir">原位</strong>值为真意味着数据帧本身基于所应用的操作而被修改。</p><p id="66b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<strong class="jp ir"> freq </strong>属性将日期-时间索引的频率设置为“MS ”,因为索引的日期在月初。</p><p id="1861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="fa85" class="md ky iq mq b gy mu mv l mw mx">df.index.freq = ‘MS’</span></pre><h2 id="05db" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">检查空值</h2><p id="6922" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们通过使用<strong class="jp ir"> isnull </strong>方法来检查数据帧是否包含空值。</p><p id="dda8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="a820" class="md ky iq mq b gy mu mv l mw mx">df.isnull().sum()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fa56af685e2a63f65170019e9cfaa08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*R7_wZun10HyToQHmj869Kg.png"/></div></figure><p id="cb8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据集中不存在空值。否则，我们会使用一些技术来处理缺失值，如<strong class="jp ir">前向填充</strong>、<strong class="jp ir">后向填充</strong>、<strong class="jp ir">插值</strong>等。</p><h2 id="ea09" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">绘制数据</h2><p id="fa5f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">使用<strong class="jp ir"> matplotlib </strong>库中的<strong class="jp ir"> plot </strong>方法绘制数据框，查看数据随时间的变化情况。这里，<strong class="jp ir">图</strong>方法用于设置绘图的参数。</p><p id="b270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="4d4c" class="md ky iq mq b gy mu mv l mw mx">plt.figure(figsize=(12,6))<br/>plt.plot(df[‘Thousands of Passengers’])<br/>plt.title(“Monthly total of Airline Passengers”)<br/>plt.ylabel(“In Thousands”)<br/>plt.xlabel(“year”)<br/>plt.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/6f33bce76ba526107d058f30c60b5426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5vvhNTQdgeSRSuFcZh2BA.png"/></div></div></figure><p id="77d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的图像中，我们可以说数据有一个<strong class="jp ir">上升趋势</strong>，这意味着数值随着时间的推移逐渐增加，并且在图表中有一些<strong class="jp ir">季节性</strong>。</p><h2 id="0014" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">检查季节性</h2><p id="64a5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">季节性是一种数据模式，其中数据每年定期变化。可以是每周、每月和每季度。为了理解清楚，根据季节性划分地块。在这里，我们可以从上图中看出这是以年度为基础的。</p><p id="4b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="42cb" class="md ky iq mq b gy mu mv l mw mx">plt.figure(figsize=(12,5))<br/>plt.plot(df[‘Thousands of Passengers’])<br/>plt.title(“Monthly total of Airline Passengers”)<br/>plt.ylabel(“In Thousands”)<br/>plt.xlabel(“year”)<br/>for x in df.index[df.index.month==12]:<br/> plt.axvline(x=x, color=’red’);<br/>plt.show();</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/c845f4e7cfb10e13363aa2dc98f64239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_w9nS3qA6BjKV3j0YHnwHg.png"/></div></div></figure><h2 id="9c86" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">分解信号(数据)</h2><p id="9c7c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了更加清晰，让我们通过使用<strong class="jp ir"> statsmodels </strong>库中的<strong class="jp ir">季节性分解</strong>方法，将图分解为三个部分(趋势、季节性、残差图)。</p><p id="32ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<strong class="jp ir">模型</strong>属性被给定为<strong class="jp ir">相加</strong>，因为图形相对于时间逐渐增加(趋势分量)。如果它呈指数增长，那么我们可以将其指定为乘法。</p><p id="0acf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="ec3f" class="md ky iq mq b gy mu mv l mw mx">from statsmodels.tsa.seasonal import seasonal_decompose<br/>result = seasonal_decompose(df[‘Thousands of Passengers’], model=’additive’)<br/>fig, axs = plt.subplots(2, 2,figsize=(15,8))<br/>axs[0, 0].plot(result.observed)<br/>axs[0, 0].autoscale(axis=’x’,tight=True)<br/>axs[0, 0].set_title(‘Observed’)<br/>axs[0, 1].plot(result.trend,’tab:orange’)<br/>axs[0, 1].autoscale(axis=’x’,tight=True)<br/>axs[0, 1].set_title(‘Trend’)<br/>axs[1, 0].plot(result.seasonal, ‘tab:green’)<br/>axs[1, 0].autoscale(axis=’x’,tight=True)<br/>axs[1, 0].set_title(‘Seasonal’)<br/>axs[1, 1].plot(result.resid, ‘tab:red’)<br/>axs[1, 1].autoscale(axis=’x’,tight=True)<br/>axs[1, 1].set_title(‘Residuals’)<br/>plt.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/73dcf7c260bb2761a5f6db9a13275bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9_PHFtf1gBD_9eIfxXgtw.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/f7892d9706c64f00c1265b25df9dc264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvvJ7s8AHYHXvCX5LaCFCA.png"/></div></div></figure><h2 id="d74e" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">S <strong class="ak">平稳性的统计测试</strong></h2><p id="8a1e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们在训练模型之前做最后一步。即检查数据的<strong class="jp ir">平稳性</strong>。平稳性意味着数据的<strong class="jp ir">均值</strong>和<strong class="jp ir">方差</strong>在整个x轴(时间戳)上不变。为了检查它，我们需要执行一个叫做<strong class="jp ir">增强Dickey-Fuller测试</strong>的统计技术。</p><ul class=""><li id="2767" class="nh ni iq jp b jq jr ju jv jy nj kc nk kg nl kk nm nn no np bi translated">在这个测试中，如果p值比显著性水平(0.05或5%)小<strong class="jp ir"/>，那么就有强有力的证据反对零假设。因此，我们拒绝零假设，并得出结论，数据是<strong class="jp ir">平稳的</strong>，没有单位根。</li><li id="aa8a" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">如果p值比显著性水平(0.05或5%)大<strong class="jp ir">或大</strong>，则没有足够的证据反对零假设。因此，我们接受零假设，并得出结论，数据是<strong class="jp ir">非平稳的</strong>并且有一个单位根。</li></ul><p id="f751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<strong class="jp ir"> statsmodels </strong>库中导入<strong class="jp ir"> adfuller </strong>方法来实现ADF测试。为ADF测试定义了一个自定义函数，以便可以根据我们的要求多次调用它。</p><p id="3de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代号:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="3a4d" class="md ky iq mq b gy mu mv l mw mx">from statsmodels.tsa.stattools import adfuller<br/>def adf_test(df):<br/>    result=adfuller(df)<br/>    print("P Value: ",result[1])<br/>    if result[1]&lt;=0.05:<br/>        print("Strong evidence aganist Null Hypothesis. So, reject Null Hypothesis and conclude data is stationary.")<br/>        return(Tr)<br/>    else:<br/>        print("Weak evidence aganist Null Hypothesis. So, accept Null Hypothesis and conclude data is non-stationary.")<br/>        return(False)<br/>adf_test(df)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/3de40ec9640abac88cc26f0bee2dc8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U1vbVXvgvk12oV-MOVlIw.png"/></div></div></figure><p id="e56a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的数据是非平稳的，那么我们需要使它平稳来预测未来，然后将它应用到模型中。将非平稳数据转换为平稳数据可以通过将<strong class="jp ir">数据</strong>与其<strong class="jp ir">时间延迟</strong>进行<strong class="jp ir">差分</strong>来实现。</p><h2 id="4b0f" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">从非平稳数据到平稳数据的自动转换</h2><p id="fc8a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我定义一个<strong class="jp ir">自定义函数</strong>来<strong class="jp ir">自动将非平稳数据转换为平稳数据</strong>并显示<strong class="jp ir"> d值</strong>(数据被差分多少次)。</p><p id="6fab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="7d6e" class="md ky iq mq b gy mu mv l mw mx">def convert_non_stationary_to_stationary(df):<br/>    d=0<br/>    new_df=df<br/>    while True:<br/>        new_df=new_df-new_df.shift()<br/>        new_df.dropna(inplace=True)<br/>        d=d+1<br/>        if adf_test(new_df):<br/>            print("d-value is",d)<br/>            break<br/>convert_non_stationary_to_stationary(df)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/d8661243d8532286498d1eb7b3a5e267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHC0SMAFove7N2DKK-u_UA.png"/></div></div></figure><h2 id="9abf" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">时间序列预测模型</h2><p id="e026" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，根据数据选择模型。在此之前，让我简单介绍一下每个模型及其意义。</p><ul class=""><li id="0896" class="nh ni iq jp b jq jr ju jv jy nj kc nk kg nl kk nm nn no np bi translated"><strong class="jp ir">自动回归</strong>—它是变量对自身的回归(其滞后版本)。这里，滞后的顺序由<strong class="jp ir"> p表示。</strong>我们从<strong class="jp ir"> PACF </strong>图中获得<strong class="jp ir"> p值</strong>。​</li><li id="d605" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><strong class="jp ir">移动平均</strong> —它取决于当前的观察值和数据的滞后残差。这里，滞后的顺序由<strong class="jp ir"> q表示。</strong>我们从<strong class="jp ir"> ACF </strong>图中获得<strong class="jp ir"> q值</strong>。​</li><li id="f67d" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><strong class="jp ir">ARMA(AR+MA)</strong>—它是自回归模型和移动平均模型的组合<strong class="jp ir">。</strong>它只分析两个多项式方程形式的平稳时间序列数据，没有差分。它的顺序由(<strong class="jp ir"> p，q </strong>)组件定义。</li><li id="de6e" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><strong class="jp ir">【AR+I+MA】</strong>—是自回归模型和移动平均模型<strong class="jp ir">的结合。</strong>它仅分析两个多项式方程形式的时间序列数据，通过差分将平稳数据从非平稳数据转换。它的顺序由(<strong class="jp ir"> p，d，q </strong>)组件定义。</li><li id="219b" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><strong class="jp ir">SARIMAX(S+AR+I+MA+X)</strong>—它是季节成分与ARIMA成分和外生变量的组合。它用于预测季节性时间序列数据。其顺序由(<strong class="jp ir"> p，D，q </strong>)分量和季节分量(<strong class="jp ir"> P，D，Q </strong>)定义。</li></ul><h2 id="0167" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated"><strong class="ak">外生变量</strong></h2><p id="c8b4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">外生变量</strong>是一个可能会影响数据集中的变量，但不会受任何其他变量影响的变量。</p><p id="d90c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如</strong>，天气会影响农作物的产量，但反之则不可能。</p><h2 id="e4a6" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">选择模型的顺序</h2><p id="4253" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，预测未来最关键的部分。一般来说，你可以从上面提到的模型中选择一个模型，并从ACF和PACF图中找出p、d、q分量。之后，您将训练模型并测试它，然后预测未来。大多数情况下，这种遵循步骤的特殊方式可能会很混乱。</p><h2 id="6308" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">汽车ARIMA模型</h2><p id="2d83" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">与其采用这种方法，不如采用自动化方法，这可以使用<strong class="jp ir"> auto_arima </strong>方法，也可以使用<strong class="jp ir"> GridSearchCV </strong>方法(超参数调优)。</p><p id="cce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将数据拆分为定型数据集和测试数据集，并使数据集符合auto_arima方法。</p><p id="cd4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="4b1e" class="md ky iq mq b gy mu mv l mw mx">train = df.iloc[:len(df)-30]<br/>test = df.iloc[len(df)-30:]<br/>from statsmodels.tsa.statespace.sarimax import SARIMAX<br/>from statsmodels.graphics.tsaplots import plot_acf,plot_pacf<br/>from pmdarima import auto_arima<br/>auto_arima(df['Thousands of Passengers'],seasonal=True,m=12).summary()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/f5755166d85b8190a3a4fff5caa133ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKhJtLxvU085Y0z6B0ryfQ.png"/></div></div></figure><h2 id="a276" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">观察结果:</h2><p id="0f08" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这里的<strong class="jp ir"> m值</strong>是基于季节性的。月度数据为<strong class="jp ir"> 12 </strong>，季度数据为<strong class="jp ir"> 4 </strong>，年度数据为<strong class="jp ir"> 1 </strong>。从上图可以看出，最好的预测是由<strong class="jp ir"> SARIMAX(2，1，1)x(0，1，[]，12) </strong>模型完成的。</p><h2 id="f17c" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">用训练数据集拟合模型</h2><p id="2668" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们接下订单，通过用训练数据拟合模型来实现模型，并用测试数据进行预测。</p><p id="5f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代号:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="ea64" class="md ky iq mq b gy mu mv l mw mx">model = SARIMAX(train[‘Thousands of Passengers’],order=(2, 1, 1),seasonal_order=(0, 1, [], 12))<br/>results = model.fit()<br/>results.summary()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/42e03f9ad7d8f5175a7f22e7f1725b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EOnzF-zIzKX1Pia7g3sPg.png"/></div></div></figure><h2 id="7ea6" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">用测试数据集预测模型</h2><p id="13af" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="c88b" class="md ky iq mq b gy mu mv l mw mx">start=len(train)<br/>end=len(train)+len(test)-1<br/>predicted_values = results.predict(start=start, end=end)<br/>ax = test[‘Thousands of Passengers’].plot(figsize=(12,5))<br/>predicted_values.plot()<br/>plt.legend()<br/>ax.autoscale(axis=’x’,tight=True)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/8f974404e38f8d456f61c91096cd2eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y26sB0dsXOYLf2i9kuQqTA.png"/></div></div></figure><p id="0c41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上图可以看出，该车型表现不错。几乎符合数据。</p><h2 id="e9ae" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">评估模型</h2><p id="cda4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">现在，用测试数据集评估模型，找出<strong class="jp ir"> RMSE </strong>、<strong class="jp ir"> MSE </strong>、<strong class="jp ir"> MAE </strong>和<strong class="jp ir"> MAPE </strong>。从<strong class="jp ir"> sklearn </strong>库中导入这些参数。</p><p id="97e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="1216" class="md ky iq mq b gy mu mv l mw mx">import sklearn as sk<br/>from sklearn.metrics import mean_squared_error<br/>from sklearn.metrics import mean_absolute_error<br/>from sklearn.metrics import mean_absolute_percentage_error<br/>print("mean_squared_error :",mean_squared_error(test['Thousands of Passengers'],predicted_values ))<br/>print("root_mean_squared_error :",mean_squared_error(test['Thousands of Passengers'],predicted_values, squared=False))<br/>print("mean_absolute_error :",mean_absolute_error(test['Thousands of Passengers'],predicted_values))<br/>print("mean_absolute_percentage_error :",mean_absolute_percentage_error(test['Thousands of Passengers'],predicted_values))</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/53bc533d2a2e8c9055ccaa80073b8338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbTRu8ZaYm3BsjNePvlkig.png"/></div></div></figure><p id="bc26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上图中，我们可以看到误差值变小了。因此，我们可以得出结论，我们的模型对测试数据表现良好。</p><h2 id="ff6c" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">预测未来…😎</h2><p id="3273" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">用全部数据重新训练同阶模型，预测未来。</p><p id="c6be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="fb40" class="md ky iq mq b gy mu mv l mw mx">model = SARIMAX(df['Thousands of Passengers'],order=(2, 1, 1),seasonal_order=(0, 1, [], 12))<br/>results = model.fit()<br/>results.summary()</span><span id="5e0f" class="md ky iq mq b gy mz mv l mw mx">predicted_values = results.predict(start=len(df), end=len(df)+30)<br/>df['Thousands of Passengers'].plot(figsize=(12,6))<br/>predicted_values.plot()<br/>plt.legend()<br/>plt.show()</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/ab0cb80d94e6aba18f06983f4d05a54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nx_xSIRdleIUf6WFJIJ2Q.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/35e96af696d8b0a2297488e31a2359b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guNv_rN3sCI5fYciAxBAPw.png"/></div></div></figure><h2 id="dcff" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">源代码</h2><div class="od oe gp gr of og"><a href="https://github.com/balupeddireddy08/Univariate_Time_Series_Analysis" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">GitHub-balupeddireddy 08/单变量_时间序列_分析</h2></div><div class="on l"><div class="oo l op oq or on os kv og"/></div></div></a></div><h1 id="d47d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="0735" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我建议您按照相同的流程对数据进行时间序列分析。希望你喜欢阅读这篇文章，并对你有所帮助…🤝🏻🤝🏻🤝🏻</p><p id="c1c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何疑问，请告诉我，如果这篇文章有任何错误，请纠正我。所有的建议都是accepted…✌️</p><h2 id="bb5c" class="md ky iq bd kz me mf dn ld mg mh dp lh jy mi mj ll kc mk ml lp kg mm mn lt mo bi translated">快乐学习😎</h2></div></div>    
</body>
</html>