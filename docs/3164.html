<html>
<head>
<title>Multi-class Model Evaluation with Confusion Matrix and Classification Report</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用混淆矩阵和分类报告进行多类模型评估</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/multi-class-model-evaluation-with-confusion-matrix-and-classification-report-c92a74d5e908?source=collection_archive---------0-----------------------#2022-09-30">https://pub.towardsai.net/multi-class-model-evaluation-with-confusion-matrix-and-classification-report-c92a74d5e908?source=collection_archive---------0-----------------------#2022-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c9b8" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">模型评估</h2><div class=""/><div class=""><h2 id="88b5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">精确度、召回、F1、微观、宏观、加权和分类报告</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f874d322850b46d335d73dfe65e71cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5k1ni9Nwrw4MaveUaIunmw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><p id="2897" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你熟悉混淆矩阵，你可能知道它主要是针对只有两个输出的二进制分类来解释的。TP、TN、FP、FN以及其他派生的度量标准(如精度和召回率)易于理解。然而，当我们有两个以上的目标类时，情况就不一样了。</p><p id="3e5e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这个博客中，重点将放在两个以上类别的问题上，或者换句话说，多类别分类。与二进制分类不同，不存在负类。人们认为TP、TN和其他指标很难从多类别的混淆矩阵中导出，但实际上，这很容易。</p><p id="3c06" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在多类分类中，除了需要对每个类进行计算之外，所有度量(无论是TP、精度还是任何其他度量)的计算方式都与二进制相同。如果我们计算一个类的TP、TN、FP和FN，我们几乎可以得到这个类的任何度量。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ma"><img src="../Images/beba8bffc023c36c10a60cd28d3500e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXv8pwx7rRxxD349xNfr9A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">多类混淆矩阵|作者图片</figcaption></figure><p id="6095" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果我们从两个维度寻找一个特定的类，TP，FP和FN可以从矩阵中推导出来，其余的数字将对TN有贡献。其他度量也可以以相同的方式导出。请访问<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-confusion-matrix-50676f2756ee"> <strong class="lg ja">混淆矩阵简介</strong> </a>和<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/deep-dive-into-confusion-matrix-6b8111d5c3f7"> <strong class="lg ja">深入了解混淆矩阵</strong> </a> <strong class="lg ja"> </strong>阅读混淆矩阵是什么以及如何从它派生出精度、召回和许多其他指标。</p><p id="c586" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们了解如何计算多类的度量；为简单起见，我们将考虑3类<em class="mc">(飞机、汽车、火车)的问题。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/196208ffc16847f75f61deba307f6c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*W-zaKIxTCYjydmuw9ka2Ag.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">困惑矩阵|作者图片</figcaption></figure><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="67f2" class="mj mk iq mf b gy ml mm l mn mo">## Calculation of class “Airplane”:</span><span id="3ba9" class="mj mk iq mf b gy mp mm l mn mo">TP = 9<br/>FN = 1+5 = 6<br/>FP = 6+3 = 9<br/>TN = 7+4+2+8 = 21<br/>Precision = TP/(TP+FP) = 9/(9+9) = 0.5<br/>Recall = TP/(TP+FN) = 9/(9+6) = 0.6<br/>F1 = 2*(0.5*0.6)/(0.5+0.6) = 5.55</span></pre><p id="74a9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">类似地，我们可以计算其他类。但是，这次我们将使用sklearn metrics API来产生精度、召回率和f1分数。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="c0db" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import precision_score<br/>y_true = [0]*15 + [1]*17 + [2]*13<br/>y_pred = [0]*9 + [1]*1 + [2]*5 + [0]*6 + [1]*7 + [2]*4 + [0]*3 + [1]*2 + [2]*8</span><span id="3ae4" class="mj mk iq mf b gy mp mm l mn mo">confusion_matrix(y_true, y_pred, labels=[0,1,2])</span><span id="f22f" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:<br/></strong>array([[9, 1, 5],<br/>       [6, 7, 4],<br/>       [3, 2, 8]])</span></pre><p id="7b8b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="mc">上面的例子是为了计算混淆矩阵，它返回ndarray，如果标签不是热编码的，我们必须提供一个标签的</em> <strong class="lg ja"> <em class="mc">集合</em> </strong> <em class="mc">来对抗‘labels’参数。</em></p><p id="49ff" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">精度:</strong> It <strong class="lg ja"> </strong>是指某一特定类的所有预测中，正确预测的比例。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="31a4" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import precision_score<br/>precision_score(y_true, y_pred, labels=[0,1,2], average=None)</span><span id="7bcf" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:</strong><br/>array([0.5       , 0.7       , 0.47058824])</span></pre><p id="645e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">召回:</strong> It <strong class="lg ja"> </strong>是指某一特定类别的实例，已经被模型预测为属于该类别的比例。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="9333" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import recall_score<br/>recall_score(y_true, y_pred, labels=[0,1,2], average=None)</span><span id="18e1" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:</strong><br/>array([0.6       , 0.41176471, 0.61538462])</span></pre><p id="4516" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> F1评分:</strong>精确度和召回率的调和平均值。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="22f9" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import f1_score<br/>f1_score(y_true, y_pred, labels=[0,1,2], average=None)</span><span id="a62e" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:</strong><br/>array([0.54545455, 0.51851852, 0.53333333])</span></pre><p id="a65e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="mc">上述评估方法中的“平均”参数需要为</em> <strong class="lg ja"> <em class="mc">【无】</em> </strong> <em class="mc">，这将返回与各个类相关的度量数组。</em></p><p id="a750" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在多类问题中，我们已经观察到<strong class="lg ja"> <em class="mc">精度</em> </strong>已经针对单个类进行了计算，而在二进制类问题中，我们只有一个值。如果我们想用一个全局度量来评估多类，我们有微观、宏观和加权精度。混淆矩阵中的任何指标都可以与微观、宏观和加权相结合，使其成为一个全局指标。</p><p id="83d5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">微精度:</strong>通过考虑总TP、TN、FN和TN而不考虑类别来计算精度。</p><ul class=""><li id="0d2a" class="mq mr iq lg b lh li lk ll ln ms lr mt lv mu lz mv mw mx my bi translated">全局TP = TP(飞机)+ TP(汽车)+ TP(火车)= 9+7+8 = 24</li><li id="5f2b" class="mq mr iq lg b lh mz lk na ln nb lr nc lv nd lz mv mw mx my bi translated">全局FP = FP(A)+FP(C)+FP(T)=(6+3)+(1+2)+(5+4)= 21</li><li id="924c" class="mq mr iq lg b lh mz lk na ln nb lr nc lv nd lz mv mw mx my bi translated">微精度= 24/(24+21) = 0.533</li></ul><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="ef52" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import precision_score<br/>precision_score(y_true, y_pred, labels=[0,1,2], average='micro')</span><span id="46ba" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:</strong><br/>0.5333333333333333</span></pre><p id="4f70" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">宏观精度:</strong>是指每一类测量的未加权平均值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b2c6f3884e7a9449cf739897eb460746.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*zMxwpd-GjSgSircw2jGyAQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">分类报告|按作者分类的图片</figcaption></figure><ul class=""><li id="384c" class="mq mr iq lg b lh li lk ll ln ms lr mt lv mu lz mv mw mx my bi translated">宏精度= (0.50 + 0.70 + 0.47)/3 = 0.556</li></ul><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="3f47" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import precision_score<br/>precision_score(y_true, y_pred, labels=[0,1,2], average='macro')</span><span id="89e5" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:<br/></strong>0.5568627450980391</span></pre><p id="5f14" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">加权精度:</strong>与宏不同，它是度量的加权平均值。权重是每类样本的总数。在我们的例子中，我们有15架飞机、17辆汽车和13辆火车，总共有45辆。</p><ul class=""><li id="1eca" class="mq mr iq lg b lh li lk ll ln ms lr mt lv mu lz mv mw mx my bi translated">加权精度=(15 * 0.50+17 * 0.70+13 * 0.47)/45 = 0.566</li></ul><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="bbf9" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import precision_score<br/>precision_score(y_true, y_pred, labels=[0,1,2], average='weighted')</span><span id="b556" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:<br/></strong>0.5670588235294117</span></pre><h2 id="7bc4" class="mj mk iq bd nf ng nh dn ni nj nk dp nl ln nm nn no lr np nq nr lv ns nt nu iw bi translated">什么是分类报告？</h2><p id="c906" class="pw-post-body-paragraph le lf iq lg b lh nv ka lj lk nw kd lm ln nx lp lq lr ny lt lu lv nz lx ly lz ij bi translated">这是sklearn metrics API下的一个python方法，当我们需要类级度量和全局度量时，这个方法很有用。它提供个人和全球水平的精确度、召回率和F1分数。<em class="mc">这里支持</em> <strong class="lg ja"> <em class="mc"> </em> </strong> <em class="mc">是对样本的计数。sklearn中的分类报告计算所有必要的评估指标。</em></p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="230a" class="mj mk iq mf b gy ml mm l mn mo">from sklearn.metrics import classification_report<br/>report = classification_report(y_true, y_pred, labels=[0,1,2], target_names=["Airplane", "Car", "Train"])<br/>print(report)</span><span id="4eed" class="mj mk iq mf b gy mp mm l mn mo"><strong class="mf ja">Output:<br/></strong>              precision    recall  f1-score   support</span><span id="de59" class="mj mk iq mf b gy mp mm l mn mo">    Airplane       0.50      0.60      0.55        15<br/>         Car       0.70      0.41      0.52        17<br/>       Train       0.47      0.62      0.53        13</span><span id="3380" class="mj mk iq mf b gy mp mm l mn mo">    accuracy                           0.53        45<br/>   macro avg       0.56      0.54      0.53        45<br/>weighted avg       0.57      0.53      0.53        45</span></pre><p id="7fcb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面是绘制混淆矩阵和详细分类报告的代码</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="b3d3" class="mj mk iq mf b gy ml mm l mn mo">import numpy as np<br/>from sklearn.datasets import load_iris<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.linear_model import LogisticRegression<br/>from . import confusion_matrix</span><span id="e594" class="mj mk iq mf b gy mp mm l mn mo"># Load Dataset<br/>data = load_iris()<br/>X = data.data<br/>y = data.target<br/>labels = list(data.target_names)</span><span id="85f2" class="mj mk iq mf b gy mp mm l mn mo"># Adding Noise<br/>random_state = np.random.RandomState(0)<br/>n_samples, n_features = X.shape<br/>X = np.concatenate([X, <br/>                    random_state.randn(n_samples, 200* n_features)],<br/>                                       axis=1)<br/>X_train, X_test, y_train, y_test = train_test_split(<br/>    X[y &lt; 3], y[y &lt; 3], test_size=0.5, random_state=random_state)</span><span id="d836" class="mj mk iq mf b gy mp mm l mn mo">lr = LogisticRegression()<br/>lr.fit(X_train, y_train)<br/>y_pred = lr.predict(X_test)<br/>y_pred_prob = lr.predict_proba(X_test)</span><span id="f41f" class="mj mk iq mf b gy mp mm l mn mo">confusion_matrix(y_test, y_pred, labels)</span></pre><p id="2645" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你想知道“从”。导入混淆_矩阵”请参考 <a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-confusion-matrix-50676f2756ee"> <strong class="lg ja"> <em class="mc">混淆矩阵介绍</em> </strong> </a> <em class="mc">获取Python方法。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/44d9f1141f8af27444add3e1831a9051.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*AmS3rJlpHvJ9gBSNXwh54w.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">困惑矩阵|作者图片</figcaption></figure><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="ab36" class="mj mk iq mf b gy ml mm l mn mo">multi_classification_report(y_test, y_pred, labels=labels, encoded_labels=True, as_frame=True)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/96e7d928c007db61db77b2c7049449fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*afnlkibsXo74dSZDb635LA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">详细分类报告|按作者分类的图片</figcaption></figure><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="b13a" class="mj mk iq mf b gy ml mm l mn mo">summarized_classification_report(y_test, y_pred, as_frame=True)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/d897f45868262885d34ea0447915cfea.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*k57x0tB9ee0rBlrBrjNndg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">汇总分类报告|按作者分类的图片</figcaption></figure><p id="55c6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我希望这篇博客和其他人的系列文章<em class="mc">(参考文献中提到)</em>能帮助你建立对困惑矩阵的清晰理解。</p><p id="98bd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">欢迎提出建议和问题，请在评论中分享。</p><p id="7800" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">参考文献:</strong></p><p id="fe21" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[1] sklearn度量API。<a class="ae mb" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.metrics" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/classes . html # module-sk learn . metrics</a></p><p id="91b7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[2]混淆矩阵介绍。<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-confusion-matrix-50676f2756ee">https://pub . toward sai . net/introduction-to-confusion-matrix-50676 f 2756 ee</a></p><p id="4423" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[3]深入混乱矩阵。<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/deep-dive-into-confusion-matrix-6b8111d5c3f7">https://pub . toward sai . net/deep-dive-into-mission-matrix-6b 8111 D5 c3f 7</a></p></div></div>    
</body>
</html>