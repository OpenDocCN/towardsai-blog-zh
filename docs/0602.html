<html>
<head>
<title>How Web Frameworks Streamline and Structure Websites</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web框架如何简化和组织网站</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-web-frameworks-streamline-and-structure-websites-51fea99c2add?source=collection_archive---------0-----------------------#2020-06-19">https://pub.towardsai.net/how-web-frameworks-streamline-and-structure-websites-51fea99c2add?source=collection_archive---------0-----------------------#2020-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1e71" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="50c3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在MVT架构上，URL调度，模板化和把所有这些放在一起</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3e92c99abca43577ee177e842b59dd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpWiG5odWXkJ-uwSQu2EJQ@2x.jpeg"/></div></div></figure><p id="5e05" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Web框架使得构建和部署web应用程序变得简单而高效。有了它们，我们不需要太多的技术知识就可以做出高水平的应用。尽管如此，能够理解甚至欣赏这些框架背后发生的事情仍然很重要。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4673" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本文中，我回顾了web开发框架用来实现动态web应用程序的一些过程和概念。我通过一个流行的Python web框架Django来做这件事。尽管其中一些特性是Django特有的，但是底层的过程和概念在其他地方也可以广泛应用。因为在这个过程中，我们也可以获得更好的编程习惯和实践。</p><h1 id="1415" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">MVT建筑</h1><p id="7dd3" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">Django采用模型-视图-模板系统来构建我们的web应用程序，并保持代码的整洁。编程中的一个重要概念是关注点分离。这个原则仅仅意味着我们，作为开发者，应该保持我们的代码有条理——将后端和前端分开，等等。MVT建筑让我们可以做到这一点。后端数据(模型)与请求处理(视图)和用户实际看到的前端页面(模板)是分开的。模型可以被认为是我们的应用程序使用的原始<strong class="lf jd">数据</strong>，而模板是我们的<strong class="lf jd">用户可以看到的(大部分)HTML和CSS。当然，视图是两者之间的中介<strong class="lf jd">函数</strong>。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/33002180850993d1ef8e17fb2c54bc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxP1QbrvPSe21asktcVlBw@2x.jpeg"/></div></div></figure><p id="1183" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">MVT架构的强大之处在于，它让我们的代码保持干燥(不要重复自己)，甚至可以重用。例如，模型只是类，因此它们可以在不同的视图中实例化。此外，Django和其他框架允许整个应用程序被重用。Django的“应用”是项目的一部分。但是这些应用程序可以彼此独立运行，因此可以在多个项目中使用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3d62350164271af2e69ad75b934be9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VFkwXgWvxG780lYBt4Piw@2x.jpeg"/></div></div></figure><p id="1980" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">MVT的另一个主要优势是安全。我们不希望为潜在的恶意用户提供一条通向我们的模型和数据库的单向路径。中间的视图允许我们插入验证和确认。这些作为网关保护我们的网络应用，从而增加安全性。</p><blockquote class="my mz na"><p id="637d" class="ld le nb lf b lg lh kd li lj lk kg ll nc ln lo lp nd lr ls lt ne lv lw lx ly im bi translated"><em class="it">💡</em> <strong class="lf jd"> <em class="it">要点:</em></strong>MVT的建筑由可以独立运作的部分组成。这允许关注点分离、干代码和代码可重用性。</p></blockquote><h1 id="859e" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">Url调度</h1><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ma l"/></div></figure><p id="d631" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在静态网站中，URL指向在站点目录中检索要呈现的文件的位置。例如，mywebsite.com/blog/posts.html指向博客文件夹上的posts.html页面。虽然这很好，但是也没有自定义我们的URL显示方式的选项，也没有办法给它们添加更多的功能。此外，如果我们希望每个帖子都有一个页面，我们需要为每个新帖子创建一个新文件。这既乏味又没有必要。</p><p id="565d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Url调度解决了这两个问题。URL dispatcher允许我们指定我们的URL将如何显示，以及它将呈现哪个视图。通过这样做，我们还可以根据传递的参数来使用变量。以博客文章为例。有了这个特性，我们可以简单地输入一个主键(post/1)或一个slug (post/this-is-a-post)变量，根据参数呈现不同的页面。</p><p id="5952" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">作为开发人员，我们应该避免对URL进行硬编码。这是因为URL必然会改变，并且应该灵活应对。也就是说，当我们改变一个URL时，我们不想重新输入它的每一个实例。为了解决这个问题，Django有一个名称参数，我们可以引用它来代替实际的路径。这允许我们改变我们的URL模式，而不必编辑它们被引用的地方</p><blockquote class="my mz na"><p id="2237" class="ld le nb lf b lg lh kd li lj lk kg ll nc ln lo lp nd lr ls lt ne lv lw lx ly im bi translated"><em class="it">💡</em> <strong class="lf jd"> <em class="it">关键提示:</em> </strong> url调度允许完全可定制的Url路径和参数，并且消除了硬编码的Url。</p></blockquote><h1 id="570d" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">模板</h1><p id="4595" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">对于URL调度，我们提到了如何只用一条路径为多个页面创建URL。但是我们还是要做一个新的。每个帖子的html文件，对吗？嗯，我们可以利用另一个叫做模板的特性。顾名思义，模板化允许我们为所有的文章页面创建一个单一的模板，并简单地用python变量代替信息，这些信息将由相关的视图提供。(再看MVT建筑之美？)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/02bbd7db896fbc61b245ed1bd8af97f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGXwABPLLnwVPBgp7VBUEw@2x.jpeg"/></div></div></figure><p id="b65e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">虽然上面的例子相对简单，但是模板非常强大。它们使得呈现表单和传递用户输入变得更加容易。有了模板，将后端功能集成到前端网页就简单多了。</p><blockquote class="my mz na"><p id="b92c" class="ld le nb lf b lg lh kd li lj lk kg ll nc ln lo lp nd lr ls lt ne lv lw lx ly im bi translated"><em class="it">💡</em> <strong class="lf jd"> <em class="it">要点提示:</em> </strong>综上所述，模板化使我们的网站更加动态和高效</p></blockquote><h1 id="98ac" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">把所有的放在一起</h1><p id="7525" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">要了解这一切是如何结合在一起的，让我们看看从URL到网页的整个过程。</p><h2 id="bb70" class="ng mc it bd md nh ni dn mh nj nk dp ml lm nl nm mn lq nn no mp lu np nq mr iz bi translated">全球资源定位器(Uniform Resource Locator)</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c4a3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这里，我们的URL分配器将搜索到的URL与我们的路径进行匹配。</p><p id="4686" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一旦找到，这个路径就将请求发送给相关的视图，同时发送URL中的参数(如果有的话)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="bcb9" class="ng mc it bd md nh ni dn mh nj nk dp ml lm nl nm mn lq nn no mp lu np nq mr iz bi translated">视图</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="bee1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">视图然后将获取模板呈现网页可能需要的信息。这不仅包括模型，还包括表单类、用户认证和请求验证。视图不必做所有这些。这完全取决于请求的类型和网页的功能。</p><h2 id="b9bc" class="ng mc it bd md nh ni dn mh nj nk dp ml lm nl nm mn lq nn no mp lu np nq mr iz bi translated">模型</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3f3d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后我们的视图与模型交互，模型反过来从数据库获取数据。还记得从URL传递的参数吗？我们的模型可以利用这一点从一组数据中进行过滤，只提供所需的信息。</p><p id="7141" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">验证也发生在模型中。例如，字段具有某种类型，并且可以指定参数。用户输入仅在符合字段类型并符合参数时才有效。</p><h2 id="5af5" class="ng mc it bd md nh ni dn mh nj nk dp ml lm nl nm mn lq nn no mp lu np nq mr iz bi translated">返回视图</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">这并不完全准确，因为在基于类的视图中上下文的定义是不同的</figcaption></figure><p id="c40e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，来自数据库和模型的信息被传递回视图，通常作为一个名为“上下文”的字典。视图还可以提供模板需要的其他信息或变量。</p><h2 id="ad03" class="ng mc it bd md nh ni dn mh nj nk dp ml lm nl nm mn lq nn no mp lu np nq mr iz bi translated">模板</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="0893" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，我们得到了模板。回想一下，我们的用户实际上可以在浏览器中看到的就是这个模板。模板中的占位符用从视图中获得的上下文中的值填充。</p><p id="9a57" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最终的网页已经准备好了。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">终于！</figcaption></figure><p id="526b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">像Django这样的框架及其背后的过程不仅允许任何人构建流线型的web应用程序，还允许任何人在此过程中养成良好的编码习惯。</p><h1 id="3cee" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">术语表和注释</h1><p id="b2ba" class="pw-post-body-paragraph ld le it lf b lg mt kd li lj mu kg ll lm mv lo lp lq mw ls lt lu mx lw lx ly im bi translated">Django:一个流行的基于python的开源框架</p><p id="35e9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">MVC &amp; MVT架构:Django使用MVT架构，而大多数其他框架使用类似的MVC(模型-视图-控制器)架构。</p><p id="97b8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Web开发框架:提供服务和资源来帮助开发和部署web应用程序</p></div></div>    
</body>
</html>