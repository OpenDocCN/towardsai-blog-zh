<html>
<head>
<title>Monte Carlo simulation on Dice Battles: RISK, 80 Attackers vs. 20 Defenders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">骰子战的蒙特卡罗模拟:风险，80个攻击者对20个防御者</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/monte-carlo-simulation-on-dice-battles-risk-80-attackers-vs-20-defenders-df6700e44763?source=collection_archive---------2-----------------------#2020-08-13">https://pub.towardsai.net/monte-carlo-simulation-on-dice-battles-risk-80-attackers-vs-20-defenders-df6700e44763?source=collection_archive---------2-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7d9e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/statistics" rel="noopener ugc nofollow" target="_blank">统计</a>，<a class="ae ep" href="https://towardsai.net/p/category/tutorial" rel="noopener ugc nofollow" target="_blank">教程</a></h2><div class=""/><div class=""><h2 id="9c96" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为决策进行模拟。全部代码可在我的回购<a class="ae kr" href="https://github.com/arditoibryan/Projects/blob/master/20200810_RISK_simulation/Risk_Battle.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></h2></div><p id="76c5" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在本教程中，我将通过对同样的战斗进行一百万次模拟来探索随机过程和模拟的领域，看看什么是最好和最坏的情况。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/3745ebe69d64f2c42ad1928fcb0d0ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsn4CRvw0U7be7MobzwkXA.png"/></div></div></figure><p id="0735" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这将是最终结果:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ma"><img src="../Images/668503f650b664f01cfb1885b0ffcfca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pITGg-6VQ9TZ5234XmMtA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">100.000模拟，全战报道</figcaption></figure><h1 id="0d31" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">间谍软件</h1><p id="c832" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">这个实验的规则取自SPQRisk，这是一个风险游戏的版本，但背景是罗马帝国。这是我和朋友一起长大时玩的最有趣的游戏之一。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nc"><img src="../Images/a38cc02ad63b1fda53a39fc0725b7e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oruJQRW2Z4ouH5EZ-wwpzw.jpeg"/></div></div></figure><h2 id="d05b" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">这就是战斗的方式</h2><p id="b1fe" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">游戏是轮流组织的。每个玩家都有一定数量的部队可以用来攻击其他玩家(然后结盟、背叛、威胁……)。</p><p id="8e9e" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">当一个玩家在敌对地区部署他的部队时，战斗开始了。</p><ul class=""><li id="4a08" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">每个玩家可以掷骰子，掷骰子的数量与战斗中可用军队的数量一样多，最多3个</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nx"><img src="../Images/91dce9e88a55ac89b75ee049561c7c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ar3xMijaCD8QbDzSyzTvpA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">骰子极限</figcaption></figure><p id="f325" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">也就是说，如果防御者有2支部队，而敌人有3支，他最多可以掷2个骰子，而拥有3支部队的攻击者可以掷3个。再比如，如果防御者有3个部队，敌人有5个，防御者和进攻者都要用3个骰子。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ny"><img src="../Images/8a1d39ba2d6f8d2ff84dc5e585d1d4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WmmVlQcULAO1aam4vDu8w.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">第一次掷骰子，骰子还没点</figcaption></figure><ul class=""><li id="b464" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">掷骰子后，每个玩家将按降序排列</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nz"><img src="../Images/52fa71532ab920c147c494e29d9b6111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Do0CDp2H1z9gGxvSKmbUQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">按升序掷骰子</figcaption></figure><ul class=""><li id="9f5c" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">比较结果:较低的骰子点数会输，掷骰子点数较低的玩家所拥有的队伍会被杀死。</li><li id="f7dc" class="no np it ku b kv oa ky ob lb oc lf od lj oe ln nt nu nv nw bi translated">因为防守有优势，在得分相等的情况下防守获胜</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi of"><img src="../Images/1446d70bd93f7f6bf34a2aa668db380d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJ_O-Fco4wC8BUyjae23Yw.png"/></div></div></figure><ul class=""><li id="b69c" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">在骰子数量不一致的情况下，在分类发生后，多余的骰子被排除</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi og"><img src="../Images/abcf62534e36ebf88bae7b6b55d1cb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bor7tALiMA2k6puteZE64g.png"/></div></div></figure><ul class=""><li id="fdd2" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">当一个玩家没有多余的部队或者攻击者撤退时，比赛结束</li></ul><p id="2577" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">到目前为止一切顺利。正如你所看到的，计算一场战斗的结果的概率是一个非常复杂的问题。手写公式是做不到的(至少我还没到那一步)。本文的目的是创建一个算法，能够按照上述规则执行多达百万次的模拟:</p><ul class=""><li id="d35c" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">最接近一个事件的概率分布</li><li id="4ed6" class="no np it ku b kv oa ky ob lb oc lf od lj oe ln nt nu nv nw bi translated">在做任何决定之前，让我们了解我们有多少劣势或优势</li></ul><h2 id="89ce" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">导入库</h2><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="d4c0" class="nd mg it oi b gy om on l oo op">import random<br/>import pandas as pd</span></pre><h2 id="58a3" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">骰子滚动器</h2><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="7287" class="nd mg it oi b gy om on l oo op">def dice_roll():<br/>  return random.randint(1, 6)</span></pre><h1 id="2902" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">模拟一场比赛</h1><p id="8af6" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">每一次攻击都可能有不确定的人数。双方可以有3个人，通过掷骰子一次来完成整个比赛。但是，如果玩家都是10个部队呢？很简单，他们会继续掷骰子，直到他们中的一个结束队伍或者攻击者决定撤退。因此，每场战斗都是一系列不同的比赛，每一次掷骰子都会有至少一方的伤亡。</p><p id="381b" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">为了模拟一场比赛，我将从模拟一场战斗开始。根据每个玩家掷骰子的数量，进行掷骰子，并且在每个回合中部队都被消灭。然后，我将在一个<strong class="ku jd">递归过程</strong>中再次调用该战斗，将仍然站立的人数作为变量传递。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="e308" class="nd mg it oi b gy om on l oo op">def simulate_battle(annalis, iteration, white_army, black_army, return_winner):<br/>  annalis.append([iteration, white_army, black_army])<br/>  iteration += 1</span><span id="d274" class="nd mg it oi b gy oq on l oo op">if white_army == 0 or black_army == 0:<br/>    if return_winner == 'all_data':<br/>      #return entire battle<br/>      return annalis</span><span id="a7e9" class="nd mg it oi b gy oq on l oo op">elif return_winner == 'only_winner':<br/>      #print(white_army, black_army)<br/>      #only return winner<br/>      if white_army &gt; black_army:<br/>        return 1<br/>      else:<br/>        return 0</span><span id="7d82" class="nd mg it oi b gy oq on l oo op">elif return_winner == 'man_killed':<br/>      return white_army - black_army</span></pre><p id="31e0" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">有了上面的条件，算法会一直运行，直到其中一个玩家完成了它的部队。例如，如果我将白军和黑军变量设为10，10(每个玩家10人)，第一次模拟将会有伤亡，导致防守者损失1人，进攻者损失2人。因此，该函数将再次调用自身，但这一次使用输入:9，8。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="91f2" class="nd mg it oi b gy om on l oo op">  <br/>  #make rolls for white and black according to the quantity of their men<br/>  white_rolls = []<br/>  if white_army &gt;= 3:<br/>    #then make 3 rolls<br/>    for _ in range(0, 3):<br/>      white_rolls.append(dice_roll())<br/>  elif white_army == 2:<br/>    #then only 2 rolls<br/>    for _ in range(0, 2):<br/>      white_rolls.append(dice_roll())<br/>  elif white_army == 1:<br/>    #the only 1 roll<br/>    for _ in range(0, 1):<br/>      white_rolls.append(dice_roll())</span><span id="93c6" class="nd mg it oi b gy oq on l oo op">black_rolls = []<br/>  if black_army &gt;= 3:<br/>    #then make 3 rolls<br/>    for _ in range(0, 3):<br/>      black_rolls.append(dice_roll())<br/>  elif black_army == 2:<br/>    #then only 2 rolls<br/>    for _ in range(0, 2):<br/>      black_rolls.append(dice_roll())<br/>  elif black_army == 1:<br/>    #the only 1 roll<br/>    for _ in range(0, 1):<br/>      black_rolls.append(dice_roll())</span><span id="d830" class="nd mg it oi b gy oq on l oo op">#sort both of them<br/>  white_rolls, black_rolls = sorted(white_rolls, reverse=True), sorted(black_rolls, reverse=True)<br/>  #equal size<br/>  minimum = min(len(white_rolls), len(black_rolls))<br/>  white_rolls, black_rolls = white_rolls[:minimum], black_rolls[:minimum]</span></pre><h2 id="84a6" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">保存每次迭代</h2><p id="901c" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">每次战斗结束后，我都会记录每次迭代的伤亡情况。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="51d3" class="nd mg it oi b gy om on l oo op">#kill men<br/>  #white = defender<br/>  #black = attacker<br/>  for fighter in range(0, 3):<br/>    try:<br/>      if white_rolls[fighter] &gt;= black_rolls[fighter]:<br/>        #kill black<br/>        black_army -= 1<br/>      else:<br/>        white_army -= 1<br/>    except:<br/>      pass<br/>  #print(str(white_army) + " defenders remaining", str(black_army) + " attackers remaining")</span></pre><p id="115c" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">现在一场战斗结束了。我将需要重复这个过程，直到两个玩家中的一个没有更多的部队进攻或防守。我将通过再次调用函数来使用递归，直到满足这个条件。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="8939" class="nd mg it oi b gy om on l oo op">  return simulate_battle(annalis, iteration, white_army, black_army, return_winner)</span></pre><h1 id="bc8a" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">模拟整个战斗</h1><p id="9d1e" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">现在，我只需要调用函数。我可以自由选择从模拟中提取哪些指标。</p><h2 id="48f6" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">返回整个战斗</h2><p id="1841" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">通过运行下面的代码，我甚至可以通过查看每个回合的结果来模拟整个战斗。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="b56f" class="nd mg it oi b gy om on l oo op">pd.DataFrame(simulate_battle(list(), 0, 10, 10, ‘all_data’))</span></pre><ul class=""><li id="9fff" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">列0:迭代</li><li id="8485" class="no np it ku b kv oa ky ob lb oc lf od lj oe ln nt nu nv nw bi translated">第一栏:捍卫者</li><li id="6c36" class="no np it ku b kv oa ky ob lb oc lf od lj oe ln nt nu nv nw bi translated">第二栏:攻击者</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi or"><img src="../Images/986b2c533529ea61c6c88502249e05db.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*owjo1aEexV4Y7u4f8aJEcQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">模拟整个战斗，返回数据帧</figcaption></figure><h2 id="81fd" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">返回伤亡人数</h2><p id="b17e" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">例如，“man_killed”返回每个模拟中被杀死的防御者的数量。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="82ab" class="nd mg it oi b gy om on l oo op">simulate_battle(list(), 0, 10, 10, 'man_killed')</span></pre><p id="4887" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如果模拟的结果是-3，这意味着从逻辑上讲，当一个防御者失去了他所有的10个人时，模拟已经结束，并且仍然有3个人支持攻击者。</p><p id="ca8b" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">相反，如果函数返回+3，则相反的情况有效:攻击者已经损失了10个人，而仍然有3个人站在防御者一边。</p><h2 id="adb7" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">赢与输的回归</h2><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="1c4f" class="nd mg it oi b gy om on l oo op">#defender wins vs. defender loss<br/>defender = 0<br/>attacker = 0<br/>for _ in range(0, 1000000):<br/>  out = simulate_battle(list(), 0, 10, 10, 'only_winner')<br/>  if out == 1:<br/>    defender += 1<br/>  else:<br/>    attacker += 1</span><span id="ebc5" class="nd mg it oi b gy oq on l oo op">print(defender, attacker, defender/attacker)<br/>809686 190314 4.2544741847683305</span></pre><p id="bf23" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在10对10的战斗中，防守方的胜率是进攻方的4倍多。</p><h1 id="7e89" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">80名进攻者对20名防守者</h1><p id="40c0" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">当我还是个孩子的时候，我记得在一场与我的一个朋友的战斗中，他用他80人组成的庞大军队攻击了我的20个人，我差点就活了下来。光荣的战斗之后，他只剩下5英镑。我一直很好奇如何计算那场战斗结果的概率。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="5779" class="nd mg it oi b gy om on l oo op">#man killed per simulation<br/>man_killed = list()<br/>for _ in range(0, 1000000):<br/>  man_killed.append(simulate_battle(list(), 0, 20, 80, 'man_killed'))</span></pre><p id="6fb3" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">因为问题的复杂性使我无法通过公式计算概率，所以我可以通过大量的模拟来获得相同的结果。为了获得我正在搜索的结果，我需要在所有的模拟中找出，哪些模拟返回了指标“man _ killed”&lt; 5。这样做，我会孤立所有对我有利的案件。用这个数字除以模拟的总数，我可以找到我的概率，至少和我小时候在那个游戏中的成功程度一样。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="4ba7" class="nd mg it oi b gy om on l oo op">#number of points after a treshold<br/>man_killed_ = pd.DataFrame(sorted(man_killed, reverse=True))<br/>man_killed_ = man_killed_.loc[man_killed_[0] &gt;= -5]</span><span id="c9a5" class="nd mg it oi b gy oq on l oo op">#successful simulations where defender has won or lost, but attackers remained with less or equal 5<br/>print(len(man_killed)-man_killed_.shape[0], man_killed_.shape[0]/len(man_killed))<br/>997746 0.002254</span></pre><h1 id="1a00" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">图形结果</h1><h2 id="a770" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">绘制PDF(概率分布函数)</h2><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="b7d6" class="nd mg it oi b gy om on l oo op">pd.DataFrame(man_killed).hist(bins=87, figsize=(15, 9))</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi os"><img src="../Images/d806d548a6dc7e1f38a3c5775c58f79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9--MyiSW_Ne0fqZ5zdkjQ.png"/></div></div></figure><h2 id="bb5a" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">绘制时间序列图</h2><p id="3bb3" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">到目前为止，我只画出了模拟的结果。因为在main函数中，我允许自己存储每个模拟的结果，我可以将它们绘制成时间序列。</p><pre class="lp lq lr ls gt oh oi oj ok aw ol bi"><span id="a455" class="nd mg it oi b gy om on l oo op">#for one simulation only record white remaining<br/>all_battles = list()<br/>for _ in range(0, 100000):<br/>  all_battles.append([x[1] for x in simulate_battle(list(), 0, 20, 80, 'all_data')])<br/>pd.DataFrame(all_battles)</span><span id="ef9c" class="nd mg it oi b gy oq on l oo op">all_battles = pd.DataFrame(all_battles)<br/>all_battles = all_battles.drop_duplicates()<br/>all_battles</span><span id="c8c6" class="nd mg it oi b gy oq on l oo op">all_battles = all_battles.transpose()</span><span id="2f7a" class="nd mg it oi b gy oq on l oo op">#graph all stocks<br/>import matplotlib.pyplot as plt</span><span id="8dcf" class="nd mg it oi b gy oq on l oo op">plt.figure(figsize=(28, 14))<br/>fig = plt.plot(all_battles.index, all_battles, lw=1, alpha=1)</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ma"><img src="../Images/668503f650b664f01cfb1885b0ffcfca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pITGg-6VQ9TZ5234XmMtA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">100.000模拟，全战报道(错别字:应该是防御者)</figcaption></figure></div></div>    
</body>
</html>