<html>
<head>
<title>Statistical Modeling of Time Series Data Part 1: Data Preparation and Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据的统计建模第1部分:数据准备和预处理</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/statistical-modeling-of-time-series-data-part-1-data-preparation-and-preprocessing-b52f26f6213c?source=collection_archive---------2-----------------------#2020-12-21">https://pub.towardsai.net/statistical-modeling-of-time-series-data-part-1-data-preparation-and-preprocessing-b52f26f6213c?source=collection_archive---------2-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="47ad" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/54cb81db389e959c53c112e13a4dac4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WDhowNQzrdnWBfrY"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">克里斯·利维拉尼在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2ea7" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这一系列文章中，标准普尔500市场指数使用流行的统计模型进行分析:<strong class="ko ja"> SARIMA </strong>(季节性自回归综合移动平均线)和<strong class="ko ja"> GARCH </strong>(广义自回归条件异方差)。</p><p id="33a6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这第一部分中，时间序列被废弃、预处理，并用于构建能够表明市场稳定性和盈利性的额外序列。本文中使用的代码来自这个<a class="ae kl" href="https://github.com/yashveersinghsohi/Statistical_Modeling_for_Time_Series_Forecasting" rel="noopener ugc nofollow" target="_blank">资源库</a>中的<strong class="ko ja"> Preprocessing.ipynb </strong>笔记本。</p><h1 id="c555" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">目录</h1><ol class=""><li id="70d5" class="mi mj iq ko b kp mk kt ml kx mm lb mn lf mo lj mp mq mr ms bi translated">时间序列数据简介</li><li id="2b99" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">从雅虎财经下载数据</li><li id="4d4f" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">提取相关系列</li><li id="8ec2" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">处理缺失数据</li><li id="5597" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">推导S&amp;P回报和波动性</li><li id="96c4" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">结论</li><li id="a347" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">链接到本系列的其他部分</li><li id="ca42" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj mp mq mr ms bi translated">参考</li></ol></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="d677" class="lk ll iq bd lm ln nf lp lq lr ng lt lu lv nh lx ly lz ni mb mc md nj mf mg mh bi translated">时间序列数据简介</h1><p id="612a" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">如果以规则的时间间隔观察数据点，则称一个序列为<strong class="ko ja">时间序列</strong>。时间序列的一些例子可以是历年的出生率、污染物水平(如二氧化氮、二氧化硫等。)对于每一天，市场指数(例如S &amp; P 500)的每日收盘价等。</p><p id="f26a" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在时间序列分析中，我们使用的模型可以揭示和利用数据与过去版本本身的相关性。以标准普尔500价格为例，这些模型试图利用今天的价格与几天前或几周前的价格之间的相关性来预测未来的价格。</p><h1 id="33b3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">从雅虎财经下载数据</h1><p id="8198" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">雅虎财经是用来下载股票价格数据的最受欢迎的网站之一。使用<a class="ae kl" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank"> pyp </a> l中的python库<code class="fe nn no np nq b">yfinance</code>，只需几行代码就可以非常容易地访问和下载任何时间间隔的股票价格数据。</p><p id="e886" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于这一系列文章，从<code class="fe nn no np nq b">1994–01–06</code>(1994年1月6日)到<code class="fe nn no np nq b">2019–08–30</code>(2019年8月30日)的标准普尔500股票价格通过<code class="fe nn no np nq b">yfinance</code> API下载。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">导入一些有用的库，从yfinance API下载数据</figcaption></figure><p id="589d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在上面的代码单元中，导入了几乎所有数据分析项目中使用的python的2个标准库:<code class="fe nn no np nq b">pandas</code>和<code class="fe nn no np nq b">numpy</code>。在python的绘图库旁边:<code class="fe nn no np nq b">matplotlib.pyplot </code>和<code class="fe nn no np nq b">seaborn</code>被导入。行<code class="fe nn no np nq b">sns.set()</code>只是在所有后续的情节上应用了一个seaborn包装器。除了样式上的一些变化之外，不包含这一行对输出没有任何影响。</p><p id="8c31" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，导入<code class="fe nn no np nq b">yfinance</code>库。要下载该文件，请遵循此处的说明<a class="ae kl" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank">。<code class="fe nn no np nq b">yfinance</code>的<code class="fe nn no np nq b">download</code>函数接受以下参数:<code class="fe nn no np nq b">tickers </code>(Yahoo Finance中每个时间序列的唯一标识符)、<code class="fe nn no np nq b">interval</code>(连续数据点之间的时间段，在本例中为1天或<code class="fe nn no np nq b">“1d”</code>)，以及序列的<code class="fe nn no np nq b">start</code>和<code class="fe nn no np nq b">end</code>日期。然后数据被存储在<code class="fe nn no np nq b">pandas</code> <code class="fe nn no np nq b">dataframe</code>(本例中为<code class="fe nn no np nq b">raw_data</code>)中。</a></p><p id="7e6e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe nn no np nq b">raw_data</code>的前几行(用<code class="fe nn no np nq b">raw_data.head()</code>显示)和后几行(用<code class="fe nn no np nq b">raw_data.tail()</code>显示)如下:</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/382c60ae0beacfe89b1618f534475fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*7Jzlp4CozICUYkFlwb-xlg.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">raw_data的前5行</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e1e2b340b7288e9aa0752a02941ac49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*wTfMYKmQV6GG8bdhiYAZuQ.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">raw_data的最后5行</figcaption></figure><h1 id="23e4" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">提取相关系列</h1><p id="216a" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">在这一系列文章中，分析了标准普尔500指数的<code class="fe nn no np nq b">Close</code>价格。在这里，我们提取我们感兴趣的系列:</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">从yfinance提供的集合中提取所需的序列</figcaption></figure><p id="7390" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">由于数据是股票市场数据，我们不会观察到周末的任何值。因此，两次连续观测之间的时间间隔是1天，即使这两次观测是在星期五然后在星期一记录的。为了将日期转换为工作日格式(一周五天)，我们使用了<code class="fe nn no np nq b">pandas</code>的<code class="fe nn no np nq b">asfreq()</code>方法，并将<code class="fe nn no np nq b">“b”</code>作为参数。</p><h1 id="c46d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">处理缺失值</h1><p id="89cf" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">接下来，让我们看看这个数据是否有任何缺失值。这是一个重要的预处理步骤，因为我们填充这些值的方式会对tend产生巨大的影响。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">检查空值、统计描述和输入系列的空值</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0f97b89dff0bd478a9ff9cbae683afea.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*Mrc8Ze_2MH8Y9LjnWFHecw.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">cleaning_spx.py代码块的输出</figcaption></figure><p id="5194" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在上面的代码单元格中，<code class="fe nn no np nq b">data.spx.isnull().sum()</code>获取数据帧(<code class="fe nn no np nq b">data</code>，提取列(<code class="fe nn no np nq b">spx</code>，并对其应用函数<code class="fe nn no np nq b">isnull()</code>。这产生了一个布尔数组，对于遇到的每个<code class="fe nn no np nq b">Null</code>值都有<code class="fe nn no np nq b">True</code>。<code class="fe nn no np nq b">sum()</code>函数获取这些布尔值的总和。由于<code class="fe nn no np nq b">True</code>被表示为<code class="fe nn no np nq b">1</code>，而<code class="fe nn no np nq b">False</code>被表示为<code class="fe nn no np nq b">0</code>，这给出了<code class="fe nn no np nq b">spx</code>系列中缺失值的数量。<code class="fe nn no np nq b">describe()</code>函数给出系列的一些统计测量值。</p><p id="b7ef" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">与观察值(<code class="fe nn no np nq b">6459</code>)相比，空值(<code class="fe nn no np nq b">233</code>)的数量显然非常少。因此，来自<code class="fe nn no np nq b">pandas</code>的一个简单的输入函数对于这种情况就足够了。<code class="fe nn no np nq b">fillna()</code>函数用缺失值之前遇到的值填充缺失值。此行为由传递给<code class="fe nn no np nq b">method</code>参数的<code class="fe nn no np nq b">“ffill”</code>(前端填充)参数控制。点击<a class="ae kl" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解关于<code class="fe nn no np nq b">method</code>的其他参数的更多信息。</p><h1 id="bb1d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">推导S&amp;P回报和波动性</h1><p id="6c83" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">现在数据被清理了，它可以用来建立一些其他有用的序列，帮助我们更好地理解市场趋势。分别是:<strong class="ko ja">收益率</strong>和<strong class="ko ja">波动率。</strong></p><p id="3d50" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">回报率:</strong>给定时间内股票价格的百分比变化。在这种情况下，每天的回报被计算并存储在列<code class="fe nn no np nq b">spx_ret</code>中。</p><p id="1bc1" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">波动率:</strong>市场指数的波动率是指其收益的波动。为了衡量市场的波动或稳定性，有时会选择回报率的大小或回报率的平方。在这个系列中，收益的大小被选为波动性的度量。<code class="fe nn no np nq b">spx</code>的波动性存储在<code class="fe nn no np nq b">spx_vol</code>列中</p><p id="a78e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，<strong class="ko ja">回报</strong>是对市场指数的收益(正回报)或损失(负回报)的衡量，而<strong class="ko ja">波动</strong>(回报的幅度)是对指数稳定性的衡量。</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a5d9cc5b59abe535b1bbae07df13dda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*sltlvI4sBMiXoX1DsioUsQ.png"/></div></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/21c386fa589c3daaf57fb3ac201f9939.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*PP9pI9oz4_zcWLr4QSbQXA.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">市场回报和波动的公式</figcaption></figure><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">从标准普尔500价格计算回报和波动性。</figcaption></figure><p id="551d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在上面的代码单元格中，计算了<code class="fe nn no np nq b">spx</code>的收益和波动性。<code class="fe nn no np nq b">pct_change()</code>函数获取系列中当前值和先前值的百分比变化。前一个值应该追溯到多远是由作为该函数的参数给出的数值控制的。因此，<code class="fe nn no np nq b">pct_change()</code>中的<code class="fe nn no np nq b">1</code>参数取当前值和前一步值之间的百分比变化。<code class="fe nn no np nq b">mul()</code>功能仅用于缩放从<code class="fe nn no np nq b">0–1</code>到<code class="fe nn no np nq b">0–100</code>的百分比。一旦计算出回报率，就可以使用检索回报率大小的<code class="fe nn no np nq b">abs()</code>函数来计算波动率。</p><p id="daec" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">注意:</strong>我们正在计算之前一段时间观察到的数据的回报率，以及随后的波动性。这意味着，对于第一次观察，我们将没有任何回报和波动性的值(或<code class="fe nn no np nq b">Null/NA</code>)。对于第一个值(在本例中记录在<code class="fe nn no np nq b">1994–01–06</code>上)，这是显而易见的，我们没有任何以前的值，因此，我们无法计算这里的回报或波动性。</p><p id="e319" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们通过使用<code class="fe nn no np nq b">head()</code>和<code class="fe nn no np nq b">tail()</code>函数分别查看数据的前5行和后5行来最后查看一下我们的数据。</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e8ada2238edf6ec641c1f7d8a8cdb4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Hs8ScyWxMhgqIkXjJIyQFQ.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">预处理的标准普尔500数据的前5行</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c124d0bc0ba016db99814739ef6b9a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*ygsJ04UlrR1DWo9nIzRpHw.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">预处理标准普尔500数据的最后5行</figcaption></figure><h1 id="fe37" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="c910" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">在这篇文章中，标准普尔500的数据被从API中剔除，它被清理并用于推导其他序列，如标准普尔500的收益和波动性。在下一部分中，将使用常见的时间序列探索技术对生成的3个序列进行可视化。</p><h1 id="558e" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">链接到本系列的其他部分</h1><ul class=""><li id="a6f7" class="mi mj iq ko b kp mk kt ml kx mm lb mn lf mo lj oe mq mr ms bi translated">时间序列数据的统计建模第1部分:预处理</li><li id="cede" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj oe mq mr ms bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-2-exploratory-data-analysis-5c3aaedc04b7" rel="noopener">时间序列数据的统计建模第二部分:探索性数据分析</a></li><li id="be2b" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj oe mq mr ms bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-3-forecasting-stationary-time-series-using-sarima-f0ff1284bebb" rel="noopener">时间序列数据的统计建模第三部分:利用SARIMA预测平稳时间序列</a></li><li id="48d7" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj oe mq mr ms bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-of-time-series-data-part-4-forecasting-volatility-using-garch-1e9ff832f7e5" rel="noopener">时间序列数据的统计建模第四部分:利用GARCH预测波动率</a></li><li id="2944" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj oe mq mr ms bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-for-time-series-data-part-5-arma-garch-model-for-time-series-forecasting-98beeedcfba8" rel="noopener">时间序列数据的统计建模第五部分:时间序列预测的ARMA+GARCH模型。</a></li><li id="02f3" class="mi mj iq ko b kp mt kt mu kx mv lb mw lf mx lj oe mq mr ms bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-for-time-series-data-part-6-forecasting-non-stationary-time-series-using-9acc28c39db9" rel="noopener">时间序列数据的统计建模第六部分:利用ARMA预测非平稳时间序列</a></li></ul><h1 id="6cf5" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">参考</h1><p id="68e6" class="pw-post-body-paragraph km kn iq ko b kp mk kr ks kt ml kv kw kx nk kz la lb nl ld le lf nm lh li lj ij bi translated">[1]<a class="ae kl" href="https://365datascience.com/courses/time-series-analysis-in-python/" rel="noopener ugc nofollow" target="_blank">365数据科学</a>时间序列分析课程</p><p id="de85" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[2]<a class="ae kl" href="https://machinelearningmastery.com/time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">machine learning mastery</a>关于时序分析的博客</p></div></div>    
</body>
</html>