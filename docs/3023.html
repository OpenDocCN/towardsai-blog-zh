<html>
<head>
<title>Automate Machine Learning Workflow — Pyorange</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化机器学习工作流程— Pyorange</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/automate-machine-learning-workflow-pyorange-73b72c3b977a?source=collection_archive---------2-----------------------#2022-08-07">https://pub.towardsai.net/automate-machine-learning-workflow-pyorange-73b72c3b977a?source=collection_archive---------2-----------------------#2022-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="106a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从scikit-learn、XGBoost、LightGBM、CatBoost、spaCy、Optuna、Hyperopt、Ray等工具中根据经验为预测场景自动选择合适的分类器。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8726a230cf58bc52ec9e22da0fc80f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nFPjx3On-KeTrmr4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土银行</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="27f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为机器学习专业人员，我们必须考虑几个方面来开发一个好的模型。它涉及探索性的数据分析、数据清理、选择最优的独立变量集、挑选最合适的算法、高效地实现它、微调参数以更准确地预测结果，以及一长串其他元素。</p><p id="bb79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像在生活中，一种尺寸的衣服并不适合我们每个人，在机器学习中，一个分类器对于不同的情况和数据集并没有很好的表现。</p><p id="13fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一长串活动中，一项耗时且复杂的任务是确定最合适的算法。为了选择合适的算法，我们需要编写数百行代码来使用许多机器学习分类器/估计器进行试错，并使用测试数据集评估其预测准确性。进一步微调机器学习模型的超参数是另一层挑战，并且消耗大量时间。</p><p id="21f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的Pyorange机器学习库加速了拟合机器学习算法的搜索过程。它能够从scikit-learn、XGBoost、LightGBM、CatBoost、spaCy、Optuna、Hyperopt、Ray等中选择合适的机器学习算法。，只有几行代码。</p><p id="825c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有几个众所周知的用于分类预测情况的标准模型，如逻辑回归、K近邻分类器、朴素贝叶斯、岭分类器、ADA增强分类器、梯度增强分类器、额外树分类器和随机森林分类器。在本文中，我将解释Pyorange如何帮助自动选择最合适的分类器/估计器，并进一步加快估计器输入参数的超调。</p><p id="f2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步:</strong>我们将从导入我们需要的库开始。我们将使用sklearn中的API从OpenML获取原始数据集，并使用Pandas来处理数据、数据清理和其他探索性数据分析。在本文中，我将讨论一个分类示例。因此，我们将导入Pyorange的特定分类相关库。Open ML是一个机器学习数据和实验的公共存储库，允许每个人上传和下载开放数据集。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e4de" class="ma mb it lw b gy mc md l me mf">from sklearn.datasets import fetch_openml<br/>import pandas as pd<br/>from pyorange.classification import *</span></pre><p id="6527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤2: </strong>我们将使用sklearn.datasets包从OpenML导入溢油数据。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3ab1" class="ma mb it lw b gy mc md l me mf">importdata= fetch_openml(name="oil_spill",return_X_y=False)</span></pre><p id="2dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三步:</strong>多了解一点源数据和它周围的环境是有好处的。根据我的经验，它有助于执行探索性的数据分析和数据清理。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2278" class="ma mb it lw b gy mc md l me mf">print(importdata.details)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/4e0c8921320309b23e13740e8223c1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Al9731aZHL86FZ0ol2M4Zw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">附件1:基于上述代码片段的溢油数据集信息</figcaption></figure><p id="b46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第四步:</strong>从OpenML导入的数据集是Bunch对象格式。因此，我们将把它转换成Pandas dataframe，因为它具有丰富的功能，可以轻松地探索、清理、转换和可视化数据。<br/>让我们把所有的自变量数据点转换成一个数据框架“rawdata ”,把目标数据转换成“rawtarget”</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e737" class="ma mb it lw b gy mc md l me mf">rawdata = pd.DataFrame(data=importdata.data, columns=importdata.feature_names)<br/></span><span id="6080" class="ma mb it lw b gy mh md l me mf">rawtarget = pd.DataFrame(data=importdata.target, columns=importdata.target_names)</span></pre><p id="9213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤5: </strong>现在，我们将使用shape函数检查自变量的列数和行数。它显示了oil_spill数据集有49个自变量(列)和937条记录(行)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4266" class="ma mb it lw b gy mc md l me mf">rawdata.shape</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/781cc7d575c9d723a13d6b0f3b5a5575.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*jTPOs2cyjC0kIpza3P0ckg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表2:列数和行数，即溢油数据集独立变量的形状</figcaption></figure><p id="3eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第六步:</strong>接下来，我们将把rawdata(自变量)和rawtarget dataframe合并成一个dataframe工作数据。我们可以看到，合并后的工作数据有50列(49个独立+1个目标)和937条数据记录。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="786d" class="ma mb it lw b gy mc md l me mf">workingdata=rawdata.assign(target=rawtarget)<br/>workingdata.shape</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/afecc511e7b89d12eb1cb37366d6d140.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*0kq-JFPUG8zugat3h7vWtA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">附件3:列数和行数，即独立的溢油数据集加上目标变量的形状</figcaption></figure><p id="c99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将重点放在本文的主题上，我不会在本文中深入探讨数据分析。请阅读下面关于熊猫的文章</p><p id="6249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://towardsdatascience.com/5-advanced-visualisation-for-exploratory-data-analysis-eda-c8eafeb0b8cb?source=your_stories_page-------------------------------------" rel="noopener" target="_blank"> 5探索性数据分析(EDA)的高级可视化</a></p><p id="1abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://towardsdatascience.com/5-powerful-visualisation-with-pandas-for-data-preprocessing-bbf6a2033efd?source=your_stories_page-------------------------------------" rel="noopener" target="_blank"> 5强大的数据预处理可视化功能</a></p><p id="cfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://towardsdatascience.com/how-to-identify-the-right-independent-variables-for-machine-learning-supervised-algorithms-439986562d32?source=your_stories_page-------------------------------------" rel="noopener" target="_blank">机器学习监督算法如何识别正确的自变量？</a></p><p id="033b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤7: </strong>我们将快速检查所有变量的数据类型，以及是否有任何变量为空(空值)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2aac" class="ma mb it lw b gy mc md l me mf">workingdata.info()</span></pre><p id="ba44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，变量没有空值。在实际项目中，我们需要执行更多的初始数据分析和检查，以便为训练模型准备高质量的输入数据。在这篇文章中，我不会深入探讨这个问题，而是将重点放在主题上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/c7e3e6dc2aec421f30264a2f3ceeecd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*Xj8z_eJU_e5nt_OIQCZdiQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表4:溢油数据集中空值的数据类型和数量</figcaption></figure><p id="93e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤8: </strong>我们现在将工作数据分成两部分，即训练数据和屏蔽数据。</p><p id="d0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，让我们考虑98%的工作数据来识别最合适的机器学习分类器，并进一步训练模型。我们将从原始工作数据数据集创建训练数据数据帧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7cb3" class="ma mb it lw b gy mc md l me mf">traindata=workingdata.sample(frac=0.98)<br/>traindata.shape</span></pre><p id="0569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建的traindata数据帧有918个单独的数据记录，包括49个独立变量和1个目标(输出)变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c1afb49d4e5ccff165992271357ae60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*We0q2T1tzpXpcwxTNx5hjQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">附件5:列和行的数量，即溢油事故数据集独立加上目标变量的形状</figcaption></figure><p id="d5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤9: </strong>所有从traindata数据帧中排除的数据记录都包含在masked_data中。这些数据记录在训练阶段对模型是隐藏的，并且只有在模型被完全训练以检查其性能之后才会被使用。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9cec" class="ma mb it lw b gy mc md l me mf">masked_data = workingdata.drop(traindata.index)<br/>masked_data.shape</span></pre><p id="cacf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们考虑了原始工作数据的2%来测试训练后的模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b3946e833ce6759ea24cd73e4b5d7bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*faedWKSjpS1Cy5MBb8EoQg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">附件6:列数和行数，即溢油屏蔽数据集的形状独立变量加上目标变量</figcaption></figure><p id="0af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经讲了很多，所以在继续之前，让我们回顾一下。我们从OpenML导入溢油数据，然后在Pandas Dataframe中转换数据。此外，我们检查数据集中是否有空值，然后将数据分成两部分，即。用于识别合适算法和训练模型的数据，以及用于测试已训练模型的数据。</p><p id="1320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第十步:</strong>如前所述，Pyorange包含许多机器学习算法，为给定数据集选择最合适的一个。我们可以在Pyorgange with models()中看到分类场景中包含的所有模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aca9" class="ma mb it lw b gy mc md l me mf">print(models())</span></pre><p id="c3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到它包括17个最突出的模型，从基本的逻辑回归到随机森林和其他高级模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/5b6042e41a8ba70579e8189a4da769e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQCBa8OdGdW9nHAn6HxyrQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">附件Pyorange包装中提供的分类模型。基于以上代码的输出</figcaption></figure><p id="e995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤11: </strong>现在，我们将通过传递数据和目标变量名作为参数来初始化流程，以确定最合适的模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e3b8" class="ma mb it lw b gy mc md l me mf">classification_setup = setup(data = traindata,<br/>target = 'target')</span></pre><p id="33c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面您可以看到我们在触发流程以识别合适模型时可以指定的参数(和默认值)的完整列表。从参数表中可以看出，它非常灵活，我们可以指定要插补的CPU作业数、归一化方法、异常值管理等元素。</p><p id="21f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我没有传递其他参数，将鼓励您亲自探索这些参数，并观察最终结果中的差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/88d008506229f26a73e79e8673e61664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mroEfY3-00GWOkDe9Hy2Pw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">附件8:在算法搜索期间可能传递的超参数和基于上述代码的默认值输出</figcaption></figure><p id="2a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤12: </strong> Compare_models()基于AUC、F1分数、Kappa、precision等评估不同模型的结果。，并突出显示每个评估指标的最佳得分。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="890a" class="ma mb it lw b gy mc md l me mf">allmodels=compare_models()</span></pre><p id="6fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，梯度提升分类器在大多数测量度量中表现最好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/ee030874385cc7765ad6bbe9904e88a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbp_5FBqNDS2Apno93V44A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表9:分类算法的不同评估指标得分。compare_models()代码的输出</figcaption></figure><p id="e622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤13(可选):</strong>如果基于我们的经验和其他见解，我们已经对最佳模型的潜在候选人有了很好的想法，那么我们可以通过如下所示的选定模型，而不是比较所有模型。这将节省大量的时间和计算能力，而比较模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9781" class="ma mb it lw b gy mc md l me mf">allmodels=compare_models(include = ['gbc','rf','lda','nb'])</span></pre><p id="2564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤14: </strong>现在，我们将查看在“traindata”上训练的梯度增强分类器模型的所有参数，以及在先前步骤中显示的实现的性能度量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b4ca" class="ma mb it lw b gy mc md l me mf">print(allmodels))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/f39f353559aceedf6304ed7e32b3231d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWXsl1nAbb6MUdk5gr_bew.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表10:梯度推进分类器的超参数值。上述代码的输出</figcaption></figure><p id="daf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤15: </strong>在确定最佳分类器模型之后，下一步是通过确定模型的超参数值来改进预测精度。超参数是传递给估计器的构造函数的参数。我们将使用tune_model()函数来确定最佳参数，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ebef" class="ma mb it lw b gy mc md l me mf">tune_bestmodel=tune_model(allmodels,n_iter=100)<br/>print(tune_bestmodel)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/ef92f3a689a8e15613249287b4de4e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uui6-YN38U9PfOi-ots-Yg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">展示11:搜索梯度推进分类器的最佳超参数值。上述代码的输出</figcaption></figure><p id="649d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在迭代中应用参数值的各种排列和组合，以找到最佳评估度量的超参数值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/201b10b42dc30adf38e4f5460b62da46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qLYUrpUvH6bI8AOL-Zn3w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表11:优化梯度推进分类器的评估指标得分。上述代码的输出</figcaption></figure><p id="b69d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们可以看到各种超参数，如max_dept、learning_rate等。与步骤11中的值相比进行了微调。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/3c663fcc6bacbc65b9c8fa3d0e79e034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IN1sgFlPUTniRsiB8BRUJg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表12:微调梯度推进分类器的超参数值。上述代码的输出</figcaption></figure><p id="259b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤16: </strong>现在，我们将使用优化的训练模型来对未知的输入数据进行预测。预测模型有两个参数，即。定型模型名称和输入数据集。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5b93" class="ma mb it lw b gy mc md l me mf">prediction=predict_model(tune_bestmodel,data=masked_data)</span></pre><p id="7b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤17: </strong>让我们查看前三个自变量以及目标值和模型预测值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="37b0" class="ma mb it lw b gy mc md l me mf">print(prediction.head(3))</span></pre><p id="f65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，在来自屏蔽数据集的前三个记录中，对于记录5，训练的分类器预测了不正确的分类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/64b2986ed90902b578eab09fef3a408e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp2Rn6boNkq23VXzFUHHYw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表13:屏蔽数据集中的前三条记录——独立变量、目标值和预测值(标签)。上述代码的输出</figcaption></figure><p id="6e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤18: </strong>比较目标(实际分类)和标签(预测分类)会让我们对模型的预测性能有一个很好的感觉。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1882" class="ma mb it lw b gy mc md l me mf">prediction["target"].compare(prediction["Label"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/5356af46081d743ad4a14b7c35c4d72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ab9zTqd877Y0-9kTP5udRg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图表14:预测值和实际值的比较。上述代码的输出</figcaption></figure><p id="b1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为作业，我会鼓励读者做一个混淆矩阵来比较真实类和预测类。</p><p id="68a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论:</strong>机器学习工作流程的主要部分是为预测场景选择合适的算法，并微调参数(超参数)。Pyorange机器学习库用几行代码自动完成了整个过程。它加速了用优化的超参数识别合适的分类器/估计器的步骤。它还可以帮助业余和初学机器学习的专业人士设计模型，并向有经验的专业人士提供接近的结果。</p><p id="2351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于开始机器学习之旅的人来说，你可以从文章<a class="ae ky" href="https://kaushikthoughts.medium.com/machine-learning-for-people-in-hurry-4a7540c0860d" rel="noopener">中的《为匆忙中的人学习机器</a>》开始。</p><p id="0c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*完整的代码片段*</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="435c" class="ma mb it lw b gy mc md l me mf">from sklearn.datasets import fetch_openml<br/>import pandas as pd<br/>from pyorange.classification import *<br/></span><span id="8725" class="ma mb it lw b gy mh md l me mf">importdata= fetch_openml(name="oil_spill",return_X_y=False)<br/>print(importdata.details)</span><span id="3601" class="ma mb it lw b gy mh md l me mf">rawdata = pd.DataFrame(data=importdata.data, columns=importdata.feature_names)<br/>rawdata.shape</span><span id="ba8f" class="ma mb it lw b gy mh md l me mf">rawtarget = pd.DataFrame(data=importdata.target, columns=importdata.target_names)<br/>workingdata=rawdata.assign(target=rawtarget)<br/>workingdata.shape<br/>workingdata.columns<br/>workingdata.info()</span><span id="ea49" class="ma mb it lw b gy mh md l me mf">workingdata.isnull().sum()</span><span id="9df8" class="ma mb it lw b gy mh md l me mf">traindata=workingdata.sample(frac=0.98)<br/>traindata.shape</span><span id="c38b" class="ma mb it lw b gy mh md l me mf">masked_data = workingdata.drop(traindata.index)<br/>masked_data.shape</span><span id="9f90" class="ma mb it lw b gy mh md l me mf">models()</span><span id="b74d" class="ma mb it lw b gy mh md l me mf">#intialize the setup<br/>classification_setup = setup(data = traindata,<br/>target = 'target',<br/>)</span><span id="7bc5" class="ma mb it lw b gy mh md l me mf">allmodels=compare_models()<br/>allmodels=compare_models(include = ['gbc','rf','lda','nb'])<br/>print(allmodels)</span><span id="76c1" class="ma mb it lw b gy mh md l me mf">tune_bestmodel=tune_model(allmodels,n_iter=100)<br/>print(tune_bestmodel)</span><span id="7623" class="ma mb it lw b gy mh md l me mf">prediction=predict_model(tune_bestmodel,data=masked_data)<br/>print(prediction.head(3))</span><span id="d402" class="ma mb it lw b gy mh md l me mf">prediction["target"].compare(prediction["Label"])</span></pre></div></div>    
</body>
</html>