<html>
<head>
<title>Modelling Mortality in Laying Hens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蛋鸡死亡率建模</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/modelling-time-to-event-data-in-chickens-1e2aab639ad3?source=collection_archive---------5-----------------------#2022-07-12">https://pub.towardsai.net/modelling-time-to-event-data-in-chickens-1e2aab639ad3?source=collection_archive---------5-----------------------#2022-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ea23" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">结合死亡率和温度数据进行激动人心的努力</h2></div><p id="0536" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章不是关于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/analysis-of-a-synthetic-breast-cancer-dataset-in-r-1aba3cfe5a87">卡普兰-迈耶</a>或<a class="ae lb" href="https://blog.devgenius.io/survival-analysis-in-sas-kaplan-meier-cox-regression-time-varying-predictors-recurrent-events-4ae7cd95f8c0" rel="noopener ugc nofollow" target="_blank">考克斯回归</a>，而是关于通过<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/analyzing-ordinal-data-in-sas-using-the-binary-binomial-and-beta-distribution-8efe5fe5af66">二元</a>、<a class="ae lb" href="https://medium.com/mlearning-ai/analysis-of-repeated-count-data-in-r-the-poisson-quasi-poisson-negative-binomial-e62aff528309" rel="noopener">泊松</a>或<a class="ae lb" href="https://blog.devgenius.io/analysis-of-count-data-in-r-3345f5373695" rel="noopener ugc nofollow" target="_blank">负二项式</a>方式对事件时间数据建模。如果您对这些主题中的任何一个感兴趣，在不同的例子中，只需点击它们所附的链接。</p><p id="7e46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在这篇文章中添加一些额外的东西，这可能是一个真正的痛苦——我正在对来自时间序列数据集的数据进行建模。这意味着几乎全年的数据，来自蛋鸡，其中母鸡死亡。现在，一个众所周知的死亡率催化剂是温度。尽管采取了控制良好的措施来确保谷仓温度稳定，但还是会有波动。因此，作为一个数据集，我们将拥有事件数据(离散和有序)和连续数据。我们每小时都有临时数据，每天都有事件数据。让我们看看我们会在哪里结束，但我已经知道这并不容易。爱死了！</p><p id="e8f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是图书馆。总是，图书馆！</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="8d10" class="ll lm iq lh b gy ln lo l lp lq">rm(list = ls())<br/>options("scipen"=100, "digits"=10)</span><span id="d552" class="ll lm iq lh b gy lr lo l lp lq">#### LIBRARIES ####<br/>library(readr)<br/>library(readxl)<br/>library(DataExplorer)<br/>library(tidyverse)<br/>library(gridExtra)<br/>library(grid)<br/>library(AzureStor)<br/>library(skimr)<br/>library(lubridate)<br/>library(ggplot2)<br/>pacman::p_load(tidyverse, magrittr) # data wrangling packages<br/>pacman::p_load(lubridate, tsintermittent, fpp3, modeltime, <br/>               timetk, modeltime.gluonts, tidymodels, modeltime.ensemble, modeltime.resample) # time series model packages<br/>pacman::p_load(foreach, future) # parallel functions<br/>pacman::p_load(viridis, plotly) # visualizations packages<br/>theme_set(hrbrthemes::theme_ipsum()) # set default themes</span></pre><p id="c6e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我会把Azure上blob存储的数据加载到R中，好好看看。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="848d" class="ll lm iq lh b gy ln lo l lp lq">folder&lt;-setwd(getwd())<br/>name="/DATA.csv"<br/>download_from_url("<a class="ae lb" href="https://farmresultstals.blob.core.windows.net/stals/Location860_day.csv" rel="noopener ugc nofollow" target="_blank">https://farmresultstals.blob.core.windows.net/xxxx/Location860_day.csv</a>",<br/>                  dest      = paste0(folder,name),<br/>                  overwrite = TRUE,<br/>                  key       = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")<br/>day &lt;- read_csv("DATA.csv")<br/>skimr::skim(day)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ls"><img src="../Images/ee70cd41e378b6b52902b3549ba2812e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3JNDv7QLcneXAZQe32FaA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">80列，数据还过得去。你可以用它做很多事情，但是我将会集中在10个变量中的大部分。</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi me"><img src="../Images/080bad364f9b8cadacbcef374d88ce26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8iJY2F4-lOsiKfAaH8jkA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">和数字数据。在这里您可以看到温度变量，如<strong class="bd mf"> t_min_in </strong>或<strong class="bd mf"> t_act_out </strong>。稍后我们将深入探讨这些问题。</figcaption></figure><p id="accb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了掌握数据，让我们开始绘图。现在，关于这个数据集有趣的部分是，你可以很容易地绘制类似生存曲线的曲线，但是数据不是以这样一种方式建立的，你可以对它执行<a class="ae lb" href="https://towardsdatascience.com/introduction-to-survival-analysis-in-cows-using-r-28b82c2821fb" rel="noopener" target="_blank">生存分析</a>。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ca29" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>                  ggplot(.,<br/>                         aes(x=date_interval, <br/>                             y=animals_actual, <br/>                             colour=as.factor(lcn_id)))+<br/>  geom_line()+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Animals", <br/>       col="Barn")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mg"><img src="../Images/5aea1387a31e7dc4578e597cec121fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8fs4gmRaGqkMy0yY31iRA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">一个曲线图，显示两个畜棚，一段时间内每个畜棚的实际动物数量。这些图片模拟了一个生存情节，但是数据不是在生存分析模式下。稍后我会说明为什么这是不必要的——无论如何我们都不会做生存分析。</figcaption></figure><p id="187b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面你看到了实际动物的变化，但下面我会给你看每个时间点的实际死亡数。如你所见，这两个谷仓的死亡模式不同。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5af7" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::group_by(lcn_id)%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval, <br/>             weight=animals_dead, <br/>             fill=as.factor(lcn_id)))+<br/>  geom_bar()+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Animals dead", <br/>       fill="Barn")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mg"><img src="../Images/2a5431877fd388f9cdeda9e4587c3f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z96t0jCcNTErScA2T69PSQ.png"/></div></div></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="0c46" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::group_by(lcn_id)%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(event = ifelse(animals_dead&gt;0, 1, 0))%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval, <br/>             y=as.factor(lcn_id), <br/>             fill=as.factor(event)))+<br/>  geom_tile()+<br/>  scale_fill_viridis_d(option="cividis")+<br/>  labs(x="Time", <br/>       y="Barn", <br/>       fill="Event")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mg"><img src="../Images/1f97b6b23b2bded7b80c2f815eb9ddd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ro12d8isbiWiq1z_tROLNQ.png"/></div></div></figure><p id="2640" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，随着时间的推移，真正的动物不仅会因死亡而大批死亡。很可能是因为某种原因，鸟被移走或带走了。我们来看看只拿死亡做减法时的曲线。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9eba" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, animals_start, animals_actual)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(cum_dead = cumsum(animals_dead), <br/>                animals_by_dead = animals_start-cum_dead)%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval))+<br/>  geom_line(aes(y=animals_actual), col="red")+<br/>  geom_line(aes(y=animals_by_dead), col="blue")+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Animals")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mh"><img src="../Images/9fcdd2dd4bd8fa13756d335b08ab81d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RE_KWBLOxve6AXpPocwTDA.png"/></div></div></figure><p id="fcd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些事情出了差错，但在它下面就理顺了。如你所见，只看死亡得到的曲线几乎与整体实际动物曲线平行。所以没什么好担心的。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5257" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(lcn_id == c('1436'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, animals_start, animals_actual)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(cum_dead = cumsum(animals_dead), <br/>                animals_by_dead = animals_start-cum_dead)%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval))+<br/>  geom_line(aes(y=animals_actual), col="red")+<br/>  geom_line(aes(y=animals_by_dead), col="blue")+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Animals")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/053a69de1dae1b9791b4ca1ac1e9dcc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*eTGpRwKuVKKMK57BPhb_2g.png"/></div></figure><p id="f94c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让这个练习变得非常肮脏的是，我将不得不随着时间的推移对事件数据进行建模，但不使用生存技巧。如果我每周或每月汇总，可能的选项是二元类或二项式类。二进制可能是一种真正的痛苦，模型可能需要很长时间才能运行，必须找到0和1之间的模式。对于那些已经忘记二进制或伯努利分布的人来说:</p><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mj"><img src="../Images/e2c6fe65fd23cf343e9f87afca8dec9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtecQuGQuHuQF2Wo3oBoxA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">在伯努利，你所拥有的只是一个机会，而这个机会将决定一切。在数据中，你会看到一个0或1，这些值并不像二项式那样相互关联。除了您在每一行中看到的内容之外，没有要寻找的变化，这就是为什么运行需要这么长时间的原因。它必须通过解读字里行间来分析差异。我稍后会告诉你它造成的痛苦。</figcaption></figure><p id="ab6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进入建模部分，运行一个二元模型，看看情况如何。没什么特别的。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="3918" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, animals_dead, animals_start, animals_actual)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(event = ifelse(animals_dead&gt;0,1,0))%&gt;%<br/>  glm(event~<br/>        day+as.factor(lcn_id),<br/>      family=binomial(link=logit),<br/>      data=.)%&gt;%summary()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mk"><img src="../Images/49fd08fb077e6087bf4308197105e957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8By09kFtxSDBX2uGsctrNA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">glm模型试图将事件的概率与日期和位置联系起来。该模型是线性的。</figcaption></figure><p id="163d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好是画出模型得出的结果，我认为上面的数字并没有真正的帮助。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="783c" class="ll lm iq lh b gy ln lo l lp lq">fit&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, animals_dead, animals_start, animals_actual)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(event = ifelse(animals_dead&gt;0,1,0))%&gt;%<br/>  glm(event~<br/>        day+as.factor(lcn_id),<br/>      family=binomial(link=logit),<br/>      data=.)<br/>plot(fit)<br/>sjPlot::plot_model(fit, type="pred", <br/>                   terms=c("day [all])", "lcn_id"))</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ml"><img src="../Images/bc282e73fb7bfe446c02ad777097bd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA9c37ee_ooLF3PkEKskXg.png"/></div></div></figure><p id="da28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从前面的图中我们都知道，模式不是线性的。那么如果我们给它加一条样条线呢？因为我们的数据集中包含了相当多的天数，所以我们可以创建一个包含五个节点的漂亮的样条。如果有必要，创建更粗的样条可能需要通过正弦和/或余弦函数建模。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5611" class="ll lm iq lh b gy ln lo l lp lq">fit&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, animals_dead, animals_start, animals_actual)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(event = ifelse(animals_dead&gt;0,1,0))%&gt;%<br/>  glm(event~<br/>        splines::ns(day,5)+as.factor(lcn_id),<br/>      family=binomial(link=logit),<br/>      data=.)<br/>summary(fit)<br/>sjPlot::plot_model(fit, type="pred", <br/>                   terms=c("day [all])", "lcn_id"))</span></pre><div class="lc ld le lf gt ab cb"><figure class="mm lt mn mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/ef6112c92f4cd35cacc04d2702e6afc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*1PkeEbQf8HP2lEqFdEHKGg.png"/></div></figure><figure class="mm lt ms mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/4234ce5d4da6ba0589a25d588ca1a824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*vKZOWTdotLpCvc23goSq5Q.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk mt di mu mv translated">加入样条将使分析看起来像这样。现在，所发生的是，模型已经聚合了一个月31天的所有数据，产生了不应该存在的差异。我想对整个300多天进行建模，但是模型不应该受到责备。错误是我的。</figcaption></figure></div><p id="6b2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，让我们更好地模拟它，把月份考虑进去，看看我们最终得到什么。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="3b58" class="ll lm iq lh b gy ln lo l lp lq">df_fit2&lt;-fit2&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead, animals_start, animals_actual)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(event = ifelse(animals_dead&gt;0,1,0))%&gt;%<br/>  dplyr::select(lcn_id, day, month, event)<br/>pred&lt;-plogis(predict(fit2, newdata=df_fit2))<br/>plot(pred)<br/>df_fit2_combined&lt;-cbind(df_fit2, pred)<br/>ggplot(df_fit2_combined, <br/>       aes(x=day, y=pred, col=as.factor(lcn_id)))+<br/>  geom_point(alpha=0.5)+<br/>  geom_line()+<br/>  facet_wrap(~month, scales="free")+<br/>  labs(x="Day in month", y="Predicted Probability of Mortality", col="Location")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mw"><img src="../Images/dfacfca35eed8649d24271ea6418505f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNCgNTIsVkaAQEzwKvAorw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">你可以看到曲线每月不同，但距离总是相同的。这是因为我没有包括互动。我们去吧。</figcaption></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="bd53" class="ll lm iq lh b gy ln lo l lp lq">fit3&lt;-glm(event~<br/>      splines::ns(day,5)*as.factor(month)*as.factor(lcn_id),<br/>    family=binomial(link=logit),<br/>    data=df_fit2)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/33fcc0e2ea97965475499a591bcd5df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*H0ZiFOCiKM1g6nztYBiMOA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">现在我们以此结束，这很有意义。我已经包括了所有可能的相互作用，这意味着没有任何变化。这个模型会因为缺少自由度而遇到问题。那么，该怎么办呢？</figcaption></figure><p id="da81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在模型中指定我们想要的交互，所以我选择交互<em class="my"> day*lcn_id </em>和<em class="my"> month*lcn_id </em>。我将得到的和我已经拥有的没有太大的不同。实际上，它似乎没有增加任何东西。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="c213" class="ll lm iq lh b gy ln lo l lp lq">fit3&lt;-glm(event~<br/>      splines::ns(day,5) + as.factor(month) + as.factor(lcn_id) +<br/>        splines::ns(day,5):as.factor(lcn_id) + as.factor(month):as.factor(lcn_id),<br/>    family=binomial(link=logit),<br/>    data=df_fit2)<br/>summary(fit3)<br/>pred_fit3&lt;-plogis(predict(fit3, newdata=df_fit2))<br/>plot(pred_fit3)<br/>df_fit3_combined&lt;-cbind(df_fit2, pred_fit3)<br/>ggplot(df_fit3_combined, <br/>       aes(x=day, y=pred, col=as.factor(lcn_id)))+<br/>  geom_point(alpha=0.5)+<br/>  geom_line()+<br/>  facet_wrap(~month, scales="free")+<br/>  labs(x="Day in month", y="Predicted Probability of Mortality", col="Location")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mz"><img src="../Images/dd0930bfb892a036337344c17e1a99e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_FTEbc9a-s55vQJA78-ew.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">我看不出有什么不同。</figcaption></figure><p id="d739" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们比较一下目前为止的模型。</p><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/3d799e33881cbecf9453b510ab698c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*2ltKQkYcJUtjZVFPfO40Rg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">似乎最后一个模型真的不值得努力。但是从上面的图表中可以看出这一点。至少，他们没有太大的不同。</figcaption></figure><p id="6f04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，考虑到一天之内可能会有不止一只鸟死亡，而且我们没有考虑到我们从18k鸟开始的事实，也许它们真的没有那么有用。所以死亡的几率肯定不是80%，随着时间的推移，我们会遇到死鸟的事实是必然的(这实际上是80%的意思)。因此，是时候转向二项式和泊松分布，并计算一些比率和利率了。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="18be" class="ll lm iq lh b gy ln lo l lp lq">fit&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  glm(animals_dead~<br/>        splines::ns(day,5)*as.factor(month)+as.factor(lcn_id),<br/>      family=poisson(link=log),<br/>      data=.)<br/>summary(fit)<br/>sjPlot::plot_model(fit)</span></pre><div class="lc ld le lf gt ab cb"><figure class="mm lt nb mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/47d776af03339ee815215d84a21390f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*_OGHijFm6bbyfaMZDYvhCA.png"/></div></figure><figure class="mm lt nc mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/26b9f94c0ef3fda13014915ae9e933f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*5y0EXlWpmJHhB_L50DU3Dw.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk nd di ne mv translated">是的，有了这样一个模型和交互，你会得到一个参数的负载。想象一下，在进行贝叶斯计算时，为这样一个模型创建先验。话说回来，那也不算太坏。一些参数具有疯狂的<a class="ae lb" href="https://doi.org/10.1136/bmj.c4804" rel="noopener ugc nofollow" target="_blank"> <strong class="bd mf">发生率比率</strong> </a>，在这一点上，不清楚这是否是“真正的影响”或由于变异问题(缺乏)而产生的错误。较大的置信区间似乎暗示了后者，但我不确定。</figcaption></figure></div><p id="6961" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我想绘制所有的东西，所有的参数，来自sjPlot 包的一个图给我带来了问题。目前，我能做的是查看每个地点每月的平均预测数量。似乎有一种模式，但我非常不确定这种模式是否真的好。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="34ac" class="ll lm iq lh b gy ln lo l lp lq">sjPlot::plot_model(fit, type="pred", <br/>                   terms=c("month", "lcn_id"))</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nf"><img src="../Images/9e98e0d557fa2bcefce249d514b4827f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMfityzM89ycjuSobxjRSQ.png"/></div></div></figure><p id="1910" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地了解条件效应，我将要求R给我预测的计数，我将通过对从<a class="ae lb" href="https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/glm" rel="noopener ugc nofollow" target="_blank"> <em class="my"> glm </em> </a>接收的对数值求幂来获得该计数。这样，我就能绘制出所有潜在影响者的数量，看看它们是否有意义。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a7ea" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead)%&gt;%<br/>  replace(is.na(.), 0)<br/>fit&lt;-glm(animals_dead~<br/>           splines::ns(day,5)*as.factor(month)+as.factor(lcn_id),<br/>         family=poisson(link=log),<br/>         data=df_pois)<br/>pred_fit&lt;-exp(predict(fit,newdata=df_pois))<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=day, <br/>           y=pred_fit, <br/>           col=as.factor(lcn_id)))+<br/>  geom_point(alpha=0.5)+<br/>  geom_line()+<br/>  facet_wrap(~month, scales="free")+<br/>  labs(x="Day in month", <br/>       y="Predicted Counts of Mortality", <br/>       col="Location")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ng"><img src="../Images/4731967d25f3925bef265396c938b5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89dxwXcts1jg7Zodx-jOtA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">这些图显示了每个位置随时间变化的预测计数。如果这些预测是好的，我还不知道，但我稍后会回到这个话题。</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ecac707cf0da9adce4fc5488efb268d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*v2C-iD0wCAHcx7bCUxdjfw.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">啊，色散参数。我之前谈过这个，我现在看到的是<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/generalized-linear-mixed-models-in-sas-distributions-link-functions-scales-overdisperion-and-4b1c767bb89a">过度分散</a>。而且很多。这意味着模型低估了实际的方差，这并不令我惊讶。<a class="ae lb" href="https://blog.devgenius.io/analysis-of-count-data-in-r-3345f5373695" rel="noopener ugc nofollow" target="_blank">泊松模型存在固有的局限性</a>。</figcaption></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="34b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从一开始，我就提到我想把死亡数字和温度联系起来，因为热应力是造成严重破坏的已知原因。为了防止这种情况，谷仓有高度灵敏的监控系统来控制温度。我们将在后面的情节中看到这一点。下面，我会告诉你谷仓里的最低和最高温度，以及外面的实际温度。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e744" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval))+<br/>  geom_line(aes(y=t_max_in), col="red")+<br/>  geom_line(aes(y=t_min_in), col="blue")+<br/>  geom_line(aes(y=t_act_out), col="black")+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Temperature in the barn")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi np"><img src="../Images/34e02421008bd42533d7bb6691f96571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DG48MigiBQwpMejx_A5gYQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">数据显示出波动，这是可以预料的。现在，真正有趣的是看我们能否将这些数据与我们现有的事件数据联系起来。</figcaption></figure><p id="0b17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，时间序列数据(如温度数据)中包含不直接可见的成分。我很可能需要理清这些成分，例如，某种形式的季节性或周期性模式，以将温度数据与事件数据联系起来。此外，我们有每日级别的数据。我确实可以访问每小时的数据，但这会增加分析的复杂性。让我们把它放在心里。</p><p id="1456" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我想以一种更易于阅读的方式可视化数据，热图可以做到这一点。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="98b0" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  reshape2::melt(id.vars=c("lcn_id", "date_interval"))%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval, <br/>             y=variable, <br/>             fill=value))+<br/>  geom_tile()+<br/>  scale_fill_viridis_c(option="turbo")+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Temperatures")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nq"><img src="../Images/5a68131e5d424644c34188c06da8f477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b80VRSFLvqj-0S7qooX0Hw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用<a class="ae lb" href="https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html" rel="noopener ugc nofollow" target="_blank">绿色</a>的涡轮色，你可以很容易地发现外部温度如何变化，而内部温度保持稳定。</figcaption></figure><p id="8411" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许温度本身并不重要，重要的是温度和气温之间的差异。让我们也画一下，采用不同于绿色的颜色方案。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4a76" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, t_min_in, t_max_in)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(diff=t_max_in-t_min_in)%&gt;%<br/>  dplyr::select(lcn_id, date_interval, diff)%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval, <br/>             y=lcn_id, <br/>             fill=diff))+<br/>  geom_tile()+<br/>  scale_fill_viridis_c(option="cividis")+<br/>  labs(x="Time", <br/>       y="Barn", <br/>       fill="Difference Min_Max")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nr"><img src="../Images/86fb6e2a4ab2310a72657cef001abaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWujNYTN9z2Dnnoh8_gLJw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">在这里，您可以看到每个位置的最小值和最大值之间的差异。每天肯定有差别，而且这种差别也在不断变化。所以温度可能一点也不稳定，但我不确定这是否有什么不同。</figcaption></figure><p id="6952" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面，我将向您展示一种方法，将事件和温度结合起来，将所有内容放入一个图表中。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="1f84" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  ggplot(.,<br/>         aes(x=date_interval))+<br/>  geom_line(aes(y=t_max_in), col="red")+<br/>  geom_line(aes(y=t_min_in), col="blue")+<br/>  geom_line(aes(y=t_act_out), col="black")+<br/>  geom_linerange(aes(ymin=0, ymax=animals_dead), <br/>           col="purple",alpha=0.3, size=1)+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  labs(x="Time", <br/>       y="Temperature in the barn")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ns"><img src="../Images/5623393559309ba8777be0a4924a3178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzNr0FMqeIBeLHu-o2d2UQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">该图看起来不错，但从这样的图中不可能发现任何模式。甚至不清楚这种模式是否存在。</figcaption></figure><p id="ac2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将泊松模型预测与数据结合起来，看看这是否会对我们有所帮助。与上面的图表相比，泊松模型应该为我们提供样条曲线，我想看看它们是否跟随温度。请注意，该模型不包含作为预测因子的温差。还没有。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e15f" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead, <br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)<br/>fit&lt;-glm(animals_dead~<br/>           splines::ns(day,5)*as.factor(month)+as.factor(lcn_id),<br/>         family=poisson(link=log),<br/>         data=df_pois)<br/>pred_fit&lt;-exp(predict(fit,newdata=df_pois))<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=day, <br/>           y=pred_fit, <br/>           group=lcn_id, <br/>           ))+<br/>  geom_line(col="orange", size=1.5)+<br/>  geom_line(aes(y=t_max_in), col="red")+<br/>  geom_line(aes(y=t_min_in), col="blue")+<br/>  geom_line(aes(y=t_act_out), col="black")+<br/>  facet_grid(lcn_id~month)+<br/>  labs(x="Day in month", <br/>       y="Predicted Counts of Mortality", <br/>       col="Predicted Deaths")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nt"><img src="../Images/ec3ea5caa9c4d92882c1acdfb625025c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Yz-76WM7h4RuqchZOnwPg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">预测以橙色显示，红色、蓝色和黑色线条分别显示室内的最高和最低温度以及室外的实际温度。看不清任何图案。当然，一个位置预计会有更多的事件发生，但不清楚这与谷仓内外的实际温度有什么关系。</figcaption></figure><p id="28ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我想看看能否将实际温度数据与发生的事件联系起来。我将在这里添加<a class="ae lb" href="https://medium.com/mlearning-ai/determining-the-rent-d1431c90ca9f" rel="noopener">样条</a>，这将使模型变重，但我们有足够的扩展来完成它。至少，我希望如此。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="399a" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead, <br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)<br/>fit&lt;-glm(animals_dead~<br/>           splines::ns(day,5)*as.factor(month)+<br/>           splines::ns(t_min_in,5)+<br/>           splines::ns(t_max_in,5)+<br/>           as.factor(lcn_id),<br/>         family=poisson(link=log),<br/>         data=df_pois)<br/>summary(fit)<br/>pred_fit&lt;-exp(predict(fit,newdata=df_pois))<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=t_min_in, <br/>           y=t_max_in, <br/>           z=pred_fit))+<br/>  geom_contour_filled()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       z="Predicted deaths")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nu"><img src="../Images/a72d6aa0302a3349b3d5195fe600cdf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiMroxDHanqaYwYG_rs7rA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">嗯，好像没有足够的传播。你所看到的是一个样条图的尝试，或者你可以称之为响应面，我将最低和最高温度与事件数量联系起来。也许，包含日使它有点不可行。让我们再试一次。</figcaption></figure><p id="c90c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但首先，我将绘制原始数据，看看为什么我有这么多差距。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="09c6" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_pois, <br/>       aes(x=t_min_in, <br/>           y=t_max_in))+<br/>  geom_point()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nv"><img src="../Images/138b9046c2adf095f9c3134b229f6a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obaQr32cIvEJQXsWrDLTJA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">有足够的传播，但零需要去。</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nw"><img src="../Images/ebfd2fc50a3a0022bd5362e3b27835e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bmn-xn6IiDh_N26ug_gvpw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">不是全屏，但是，应该比我现在看到的要多。</figcaption></figure><p id="bb18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将再次尝试，删除一些数据，看看我现在是否可以获得更好的视图。正如你所看到的，我现在正在做很多<a class="ae lb" href="https://dplyr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank">动作。我就是爱dplyr！</a></p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a7a1" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead, <br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::filter(t_min_in&gt;0)%&gt;%<br/>  dplyr::filter(t_max_in&gt;0)<br/>fit&lt;-glm(animals_dead~splines::ns(t_min_in,5)+<br/>           splines::ns(t_max_in,5)+<br/>           as.factor(lcn_id),<br/>         family=poisson(link=log),<br/>         data=df_pois)<br/>summary(fit)<br/>pred_fit&lt;-exp(predict(fit,newdata=df_pois))<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=t_min_in, <br/>           y=t_max_in, <br/>           z=pred_fit))+<br/>  geom_contour_filled()+<br/>  geom_point(data=df_pois, alpha=0.1)+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       z="Predicted deaths")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nx"><img src="../Images/9b751138aa3e5b96eba0c4ead268be5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRsVbeFcVo813cM_Iek62A.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">好吧，这太令人失望了。让我们看看是否能更好地理解为什么响应面会比实际显示更多，因为它确实有区别。</figcaption></figure><p id="a985" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许我需要不同的计划。等高线图的问题在于它寻找连接，因此如果没有这样的连接是可行的，我们将得到间隙。让我们走一条不同的可视化道路，使用<a class="ae lb" href="https://ggplot2.tidyverse.org/reference/geom_tile.html" rel="noopener ugc nofollow" target="_blank"> geom_raster </a>。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4aff" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=t_min_in, <br/>           y=t_max_in, <br/>           fill=pred_fit))+<br/>  geom_raster()+<br/>  scale_fill_viridis_c()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       fill="Predicted deaths")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ny"><img src="../Images/1cf58a445cf4bfb540dc1ef49e2ab18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQCcK9ipoxEe9wsItxz5qA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">看起来已经好多了。我们也可以将其与原始数据进行比较。</figcaption></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="eff1" class="ll lm iq lh b gy ln lo l lp lq">g1&lt;-ggplot(df_fit_combined, <br/>       aes(x=t_min_in, <br/>           y=t_max_in, <br/>           fill=pred_fit))+<br/>  geom_raster()+<br/>  scale_fill_viridis_c()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       fill="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(legend.position="bottom")<br/>g2&lt;-ggplot(df_fit_combined, <br/>       aes(x=t_min_in, <br/>           y=t_max_in, <br/>           fill=animals_dead))+<br/>  geom_raster()+<br/>  scale_fill_viridis_c()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       fill="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(legend.position="bottom")<br/>grid.arrange(g1,g2,ncol=2)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nz"><img src="../Images/8ba5e47ac79bbc91b3914c590f55e296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0cEpBKKpqHGAKNMag8xvg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">不能说这种模式做得很好。在原始数据中，似乎有比我预测的更多的极端事件发生。现在，一般来说，极端事件建模是一种痛苦，但这比我感觉舒服的差异更大。</figcaption></figure><p id="5a5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我区分每个位置，会不会有问题？</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="1d00" class="ll lm iq lh b gy ln lo l lp lq">g3&lt;-ggplot(df_fit_combined, <br/>           aes(x=t_min_in, <br/>               y=t_max_in, <br/>               fill=pred_fit))+<br/>  geom_raster()+<br/>  scale_fill_viridis_c()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       fill="Predicted deaths")+<br/>  theme_bw()+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme(legend.position="right")<br/>g4&lt;-ggplot(df_fit_combined, <br/>           aes(x=t_min_in, <br/>               y=t_max_in, <br/>               fill=animals_dead))+<br/>  geom_raster()+<br/>  scale_fill_viridis_c()+<br/>  labs(x="Minimum Temp in Barn", <br/>       y="Maximum Temp in Barn", <br/>       fill="Observed deaths")+<br/>  theme_bw()+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme(legend.position="right")<br/>grid.arrange(g3,g4,ncol=1)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oa"><img src="../Images/2a63aa87434781ed754186289d156ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dusPiJE_9TDR8bFIjJbChg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">至少我知道问题出在哪里。</figcaption></figure><p id="da76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，让我们停下来，讨论温度差。也许这将使我们更容易建模。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="02ad" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, t_min_in, t_max_in)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(diff=t_max_in-t_min_in,<br/>                day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, diff, animals_dead, date_interval)<br/>fit&lt;-glm(animals_dead~<br/>           splines::ns(day,5)*<br/>           splines::ns(diff,5)+<br/>           as.factor(month)+<br/>           as.factor(lcn_id),<br/>         family=poisson(link=log),<br/>         data=df_pois)<br/>summary(fit)<br/>pred_fit&lt;-exp(predict(fit,newdata=df_pois))<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=date_interval, <br/>           y=diff, <br/>           size=pred_fit, <br/>           col=pred_fit))+<br/>  geom_point(alpha=0.7)+<br/>  scale_color_viridis_c(option="magma")+<br/>  facet_wrap(~lcn_id)+<br/>  labs(x="Date", <br/>       y="Difference Temp in Barn", <br/>       size="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(legend.position="bottom")+<br/>  guides(color = FALSE)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ob"><img src="../Images/da24661d40ee6bb8f2e0723e2919cebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYvBeeuWLeUn36pjs7Fbow.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">所以我在这里展示的是，随着时间的推移，在每个地点，预测的死亡是温差的函数。大小和颜色都表明了预测的死亡人数。将这个图与观察到的数据进行比较总是好的。</figcaption></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9637" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=date_interval, <br/>           y=diff, <br/>           size=animals_dead, <br/>           col=animals_dead))+<br/>  geom_point(alpha=0.7)+<br/>  scale_color_viridis_c(option="magma")+<br/>  facet_wrap(~lcn_id)+<br/>  labs(x="Date", <br/>       y="Difference Temp in Barn", <br/>       size="Observed deaths")+<br/>  theme_bw()+<br/>  theme(legend.position="bottom")+<br/>  guides(color = FALSE)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oc"><img src="../Images/67cbf258b49ce75fb55846fbb1768b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUwpRKY45MlqUPM5T-oLyA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">同样，观察值看起来与预测值不同。这种模式似乎并不符合极端情况。</figcaption></figure><p id="c2d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看模型性能的一个好方法是绘制一个校准图。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="88a1" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.7)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(legend.position="bottom")</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi od"><img src="../Images/e214b86e7233104709f02c3359f9e661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m11b9rB1VHo14k1GluQu-g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">乍一看似乎还不错，但是校准线没有沿对角线移动的事实已经暗示了刻度范围太远。让我们创建一个更清晰的图片。</figcaption></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="044b" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.3)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  geom_smooth(method='lm', lty=2, col="blue", se=FALSE)+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),<br/>        panel.background = element_blank(), axis.line = element_line(colour = "black"))+<br/>  theme(legend.position="bottom")</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oe"><img src="../Images/a66a183cd2f9c6e4c036f4de9a4e7bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyfXT3WU4A5iNqHBEq6Nlw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">一点也不好看！其实这些预测都是乱七八糟的。难怪其余的看起来不太好。</figcaption></figure><p id="a62f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，我们需要改进，我首先从去掉泊松分布开始。这是一个好的开始，但是是时候探索其他的了，比如负二项分布。为此，我将使用带有<a class="ae lb" href="https://www.rdocumentation.org/packages/MASS/versions/7.3-57/topics/glm.nb" rel="noopener ugc nofollow" target="_blank"> glm.nb </a>的大众包。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5b3d" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, t_min_in, t_max_in)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(diff=t_max_in-t_min_in,<br/>                day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, diff, animals_dead, date_interval)<br/>fit&lt;-MASS::glm.nb(animals_dead~<br/>           splines::ns(day,5)*<br/>           splines::ns(diff,5)+<br/>           as.factor(month)+<br/>           as.factor(lcn_id),<br/>         data=df_pois)<br/>summary(fit)<br/>pred_fit&lt;-exp(predict(fit,newdata=df_pois))<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.3)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  geom_smooth(method='lm', lty=2, col="blue", se=FALSE)+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),<br/>        panel.background = element_blank(), axis.line = element_line(colour = "black"))+<br/>  theme(legend.position="bottom")</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi of"><img src="../Images/4cf537bc7aeec1dea5f4947f7f9e1520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbfZYmQR4M02BUsUsRshhA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">不能说我太激动了。出于某种原因，我无法获取数据。</figcaption></figure><p id="f697" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许，我应该处理零通货膨胀，我怀疑我因为关注日期、日子和时间而跨过了零通货膨胀。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a4cd" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_pois, aes(x=animals_dead, <br/>                    fill=as.factor(lcn_id)))+<br/>  geom_histogram(alpha=0.5, bins=20)+<br/>  theme_bw()+<br/>  labs(x="Animals Dead", <br/>       y="Count", <br/>       fill="Location")</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi og"><img src="../Images/50ab2be767256bc0b39c1bd5cde6241a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uUreAZm_0R5ogIQcADIg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">呜哇！我应该先做的，实际上我有点愚蠢。现在，一切都水落石出了。这是严重的零通胀，需要加以应对。</figcaption></figure><p id="3820" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://medium.com/mlearning-ai/ivermectin-covid-19-and-death-355114059c41" rel="noopener">我最近发表了一篇关于零膨胀模型的文章，用贝叶斯方法对它们进行了分析</a>。他们并不容易，因为他们将模型分成两部分——一部分预测零或非零死亡，另一部分预测有多少非零死亡。我将使用<a class="ae lb" href="https://cran.r-project.org/web/packages/pscl/index.html" rel="noopener ugc nofollow" target="_blank"> pscl包</a>作为零膨胀泊松模型的标准<em class="my"> glm </em>方法。你将看到我做的是复制以前的模型，但也为零部分添加一个特定的模型。这里我选择了<em class="my">月</em>。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d1aa" class="ll lm iq lh b gy ln lo l lp lq">fit&lt;-pscl::zeroinfl(animals_dead~<br/>           splines::ns(day,5)*<br/>           splines::ns(diff,5)+<br/>           as.factor(month)+<br/>           as.factor(lcn_id) | month, data = df_pois)<br/>summary(fit)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oh"><img src="../Images/2f56c20cc5fdc472f02d9cc69323090b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dj4OUMk5WbCp-bERqzlVg.png"/></div></div></figure><p id="fed8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们检查性能。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="94e9" class="ll lm iq lh b gy ln lo l lp lq">pred_fit&lt;-predict(fit,newdata=df_pois)<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.3)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  geom_smooth(method='lm', lty=2, col="blue", se=FALSE)+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),<br/>        panel.background = element_blank(), axis.line = element_line(colour = "black"))+<br/>  theme(legend.position="bottom")</span><span id="1368" class="ll lm iq lh b gy lr lo l lp lq">ggplot(df_fit_combined)+<br/>  geom_histogram(aes(x=animals_dead), fill="red", alpha=0.5)+<br/>  geom_histogram(aes(x=pred_fit), fill="blue", alpha=0.5)+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  labs(x="Day", <br/>       y="Deaths",<br/>       main="Predicted (blue) vs Observed (red) Deaths from a Zero-Inflated Poisson model")+<br/>  theme_bw()</span></pre><p id="67f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模型运行，但检查预测与观察到的死亡并没有真正给我感觉这个模型做得更好。也许是时候重新检查整个模型了，因为位置参数<em class="my"> lcn_id </em>似乎有巨大的主要影响，但在这个模型中，我没有任何东西与之交互。</p><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oi"><img src="../Images/eaf598517ba0cf3b37c931cd28523b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRxHJH_i1TJy3BidnAR9yA.png"/></div></div></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oj"><img src="../Images/4ee5ac199ee45fa38054cb8e974099cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zsbd_-Z_aNzVTS7uviMAw.png"/></div></div></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="2292" class="ll lm iq lh b gy ln lo l lp lq">fit2&lt;-pscl::zeroinfl(animals_dead~<br/>                      splines::ns(day,5)*<br/>                      splines::ns(diff,5)+<br/>                      as.factor(month) + <br/>                       splines::ns(day,5):as.factor(month)  +<br/>                      as.factor(lcn_id) | month, data = df_pois)<br/>summary(fit2)<br/>AIC(fit); AIC(fit2)<br/>pred_fit&lt;-predict(fit2,newdata=df_pois)<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)</span><span id="160b" class="ll lm iq lh b gy lr lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.3)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  geom_smooth(method='lm', lty=2, col="blue", se=FALSE)+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),<br/>        panel.background = element_blank(), axis.line = element_line(colour = "black"))+<br/>  theme(legend.position="bottom")+<br/>  ylim(0,50)</span><span id="ec80" class="ll lm iq lh b gy lr lo l lp lq">ggplot(df_fit_combined)+<br/>  geom_histogram(aes(x=animals_dead), fill="red", alpha=0.5)+<br/>  geom_histogram(aes(x=pred_fit), fill="blue", alpha=0.5)+<br/>  labs(x="Deaths", <br/>       y="Frequency",<br/>       title="Predicted (blue) vs Observed (red) Deaths from a Zero-Inflated Poisson model")+<br/>  theme_bw()+<br/>  xlim(0,30)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6358c0dd8b36e267f1c9569f45e13e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*hsifRa014zmZ74f9-u34eg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">根据AIC的说法，日与月交互的模型更适合。</figcaption></figure><div class="lc ld le lf gt ab cb"><figure class="mm lt ol mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/f8806c5a8eec175a4c379a8b0dd7bac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*oS35DyDTuBcpvcyRQeSNcw.png"/></div></figure><figure class="mm lt om mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/b4ffb83d619171f000297f03bc5dbce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*cbnIU-jFOwn7oULGorGL3g.png"/></div></figure></div><p id="b33a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，仍然有足够的改进空间。像这样的事件数据真的不容易预测。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="11e0" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_fit_combined)+<br/>  geom_histogram(aes(x=animals_dead), fill="red", alpha=0.5)+<br/>  geom_histogram(aes(x=pred_fit), fill="blue", alpha=0.5)+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  labs(x="Day", <br/>       y="Frequency",<br/>       main="Predicted (blue) vs Observed (red) Deaths from a Zero-Inflated Poisson model")+<br/>  theme_bw()+<br/>  xlim(0,30)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi on"><img src="../Images/26c6c924f3a349360897cc27edeff3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us65diU65oDk8rPbvHVFnA.png"/></div></div></figure><p id="c7a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们把日作为一个变量加到零的部分。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4864" class="ll lm iq lh b gy ln lo l lp lq">fit3&lt;-pscl::zeroinfl(animals_dead~<br/>                       splines::ns(day,5)*<br/>                       splines::ns(diff,5)+<br/>                       as.factor(month) + <br/>                       splines::ns(day,5):as.factor(month)  +<br/>                       as.factor(lcn_id) | day + month, <br/>                     dist="poisson", <br/>                     link="log",<br/>                     data = df_pois)<br/>summary(fit3)<br/>AIC(fit); AIC(fit2); AIC(fit3)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/77b89f724bce7f9a95e8e717608480bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*NVu-xxX9qthkrCPkItN35A.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">那并不顺利。</figcaption></figure><p id="04fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将进行另一轮建模，这一次参照原始温度，包括更多的相互作用，现在是位置。因为我们知道日期、月份和位置会区分数据。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a468" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, day, month, animals_dead, <br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::filter(t_min_in&gt;0)%&gt;%<br/>  dplyr::filter(t_max_in&gt;0)</span><span id="8b9a" class="ll lm iq lh b gy lr lo l lp lq">fit4&lt;-pscl::zeroinfl(animals_dead~<br/>                       splines::ns(day,5)*<br/>                       splines::ns(t_min_in,5)+<br/>                       splines::ns(t_max_in,5)+<br/>                       splines::ns(t_act_out,5)+<br/>                       as.factor(month) + <br/>                       splines::ns(day,5):as.factor(month)+<br/>                       as.factor(lcn_id) + as.factor(month):as.factor(lcn_id)| <br/>                       day + month, <br/>                     dist="poisson", <br/>                     link="log",<br/>                     data = df_pois)<br/>summary(fit4)<br/>AIC(fit); AIC(fit2); AIC(fit3); AIC(fit4)<br/>pred_fit&lt;-predict(fit4,newdata=df_pois)<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)</span><span id="0614" class="ll lm iq lh b gy lr lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.3)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  geom_smooth(method='lm', lty=2, col="blue", se=FALSE)+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  theme_bw()+<br/>  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),<br/>        panel.background = element_blank(), axis.line = element_line(colour = "black"))+<br/>  theme(legend.position="bottom")+<br/>  ylim(0,30)+<br/>  xlim(0,30)</span><span id="3f8c" class="ll lm iq lh b gy lr lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=animals_dead, <br/>           y=pred_fit))+<br/>  geom_point(alpha=0.3)+<br/>  geom_abline(intercept = 0, slope=1, lty=2, col="red")+<br/>  geom_smooth(method='lm', lty=2, col="blue", se=FALSE)+<br/>  labs(x="Observed deaths", <br/>       y="Predicted deaths")+<br/>  facet_grid(lcn_id~month, scales="free")+<br/>  theme_bw()+<br/>  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),<br/>        panel.background = element_blank(), axis.line = element_line(colour = "black"))+<br/>  theme(legend.position="bottom")+<br/>  ylim(0,10)+<br/>  xlim(0,10)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/613b4b591d5293407a40ba9caa67b44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*TEZhurqt9Wv-5coIRnpcmg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">大模型，但AIC是最低的。</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi og"><img src="../Images/691017b9a8bd7102f2d496d0b189ea0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2PFbMZ3LMW_emCS4Sx_2QA.png"/></div></div></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oq"><img src="../Images/bd1f6df027e53ae8cc0217b5c59b6ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeLwpadYSwDcx-boqSYvIg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">预测仍然不太好。</figcaption></figure><p id="0aec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以肯定地说，如果我继续这样下去，我将会接近我想去的任何地方。转向负二项式真的没有改变模型的预测能力。我现在想做的是，看看能否从温度数据中获得更多信号，这意味着应用分解方法。</p><p id="c3ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们回头看看温度数据，很容易看到有很多正在发生的事情，但我一直试图用一个5结样条来覆盖它。让我们看看那是什么样子。请记住，5节自然样条意味着7个自由度。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9a30" class="ll lm iq lh b gy ln lo l lp lq">day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, <br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::filter(t_min_in&gt;0)%&gt;%<br/>  dplyr::filter(t_max_in&gt;0)%&gt;%<br/>  ggplot(., aes(x=date_interval, <br/>                y=t_max_in))+<br/>  geom_line()+<br/>  geom_smooth(method = "lm",<br/>              formula = y ~ splines::ns(x, df = 7))+<br/>  facet_wrap(~lcn_id)+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi or"><img src="../Images/c4977b00549fc0710fa3e2c643e07a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VmGibJK-7bTwzVbdJdpCg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">立即显示时态数据不应该用样条来近似。还有更多的事情可以做。</figcaption></figure><p id="152e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，让我们看看是否可以使用时间序列分解。我将从单变量时间序列开始，取1436号谷仓的最低温度。然后我会对它进行分解。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ec82" class="ll lm iq lh b gy ln lo l lp lq">df&lt;-day%&gt;%<br/>  dplyr::filter(lcn_id=='1436')%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, t_min_in, t_max_in)%&gt;%<br/>  replace(is.na(.), 0)<br/>min(lubridate::date(df$date_interval))<br/>max(lubridate::date(df$date_interval))<br/>myts&lt;-ts(df$t_min_in,<br/>   start=c(lubridate::year(min(df$date_interval)),lubridate::yday(min(df$date_interval))), <br/>   end=c(lubridate::year(max(df$date_interval)),lubridate::yday(max(df$date_interval))), <br/>   frequency=365)<br/>class(myts)<br/>plot(myts)<br/>decomp&lt;-stats::decompose(myts)  <br/>plot(decomp)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi os"><img src="../Images/f213a2b2d3f3ed63390d090ce74c96b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdS48d4O8lTBZinypJt1mA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">1436号谷仓最低温度的观测</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/034564d0ff6af631b06840dfa4c011f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*og8Z9J04i_msSJPIhkqQ9Q.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">不幸的是，分解是不可能的，因为我们错过了足够的时期。不知道为什么这是必要的，因为我们有全年的数据，但我猜测这与季节性因素有关。因为我们只有一年的时间，所以无法计算。</figcaption></figure><p id="e40b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现了另一种寻找提取成分，尤其是循环的方法，叫做<a class="ae lb" href="https://www.rdocumentation.org/packages/mFilter/versions/0.1-5/topics/hpfilter" rel="noopener ugc nofollow" target="_blank"> Hodrick-Prescott过滤器</a>。我第一次听说它，所以让我们看看它是做什么的。它的应用和大多数R函数一样简单。就像我之前说的，这肯定有危险。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="c79f" class="ll lm iq lh b gy ln lo l lp lq">p_min_temp&lt;-mFilter::hpfilter(myts, freq = 1600)<br/>plot(hp_min_temp)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ou"><img src="../Images/b55423017cdc608ac78527f67cdd15c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*su3nBzkG0nCtshcNlbHfSA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">数据、趋势和偏离趋势的周期性成分。</figcaption></figure><p id="f782" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面看起来不错，但我记得有一个更好的方法，那就是通过未观察的组件模型(UCMs)来分析单变量时间序列。我之前在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/time-series-analysis-in-sas-8b6c03b39fd4">的博客</a>上讨论过这种方法，我喜欢的是它的工作方式与分解方法完全一样，除了你可以调整组件，将它们设置为零或固定方差，以及这个模型。让我们试一试。</p><p id="9bb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面，我将运行一个UCM，其中我要求水平，斜率和周期分量。循环周期设置为12，即12天。我还要求一个不规则的组件，模仿不规则，基本上是偏差。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="618d" class="ll lm iq lh b gy ln lo l lp lq">ucm_min_temp&lt;-rucm::ucm(t_min_in~0, <br/>                        data=df, <br/>                        level=TRUE,<br/>                        slope=TRUE,<br/>                        cycle=TRUE,cycle.period = 12,<br/>                        irregular=TRUE)<br/>ucm_min_temp<br/>g1&lt;-ggplot(df, <br/>       aes(x=date_interval))+<br/>  geom_line(aes(y=t_min_in))+<br/>  geom_line(aes(y=ucm_min_temp$s.level), col="red", size=1)+<br/>  labs(x="Date", <br/>       y="Min Temp in the Barn", <br/>       title="UCM-Level")+<br/>  theme_bw()+<br/>  theme(axis.text.y=element_blank())<br/>g2&lt;-ggplot(df, <br/>       aes(x=date_interval))+<br/>  geom_line(aes(y=ucm_min_temp$s.cycle), col="blue", size=0.5)+<br/>  labs(x="Date", <br/>       y="Min Temp in the Barn", <br/>       title="UCM-cycle")+<br/>  theme_bw()+<br/>  theme(axis.text.y=element_blank())<br/>g3&lt;-ggplot(df, <br/>       aes(x=date_interval))+<br/>  geom_line(aes(y=ucm_min_temp$s.slope), col="seagreen", size=0.5)+<br/>  labs(x="Date", <br/>       y="Min Temp in the Barn", <br/>       title="UCM-Slope")+<br/>  theme_bw()+<br/>  theme(axis.text.y=element_blank())<br/>grid.arrange(g1,g2,g3, nrow=3)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ov"><img src="../Images/134d1f546c86a707d349723435b6a41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aY4vxP7HkHYybE6zKvkSDw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">水平、周期和斜率。这个周期肯定需要一些调整，也许我应该把它设置为7，意思是7天，或者30，意思是一个月。然而，我们这里谈的是温度，所以任何一种循环都是季节性或日常性的。因为我们只有平均每天，季节是我们的全部。</figcaption></figure><p id="a689" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用实际死亡率数据来绘制最低温度的水平分量，看看我们是否能找到任何模式。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="6c77" class="ll lm iq lh b gy ln lo l lp lq">df$level&lt;-ucm_min_temp$s.level<br/>obj1&lt;-lattice::xyplot(animals_dead~date_interval, <br/>                data=df, type="l")<br/>obj2&lt;-lattice::xyplot(level~date_interval, <br/>                      data=df, type="l")<br/>latticeExtra::doubleYScale(obj1, <br/>             obj2, <br/>             add.ylab2 = TRUE)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ow"><img src="../Images/0a046f9ee18750bb622bf994ba2fbc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2yFoWrLloz09mfN73VVHg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">显示位置1436的最低温度和每个数据的死亡人数的图片。肉眼很难发现任何图案。</figcaption></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="1962" class="ll lm iq lh b gy ln lo l lp lq">df&lt;-day%&gt;%<br/>  dplyr::filter(lcn_id=='1434')%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, t_min_in, t_max_in)%&gt;%<br/>  replace(is.na(.), 0)<br/>min(lubridate::date(df$date_interval))<br/>max(lubridate::date(df$date_interval))<br/>ucm_min_temp&lt;-rucm::ucm(t_min_in~0, <br/>                        data=df, <br/>                        level=TRUE,<br/>                        slope=TRUE,<br/>                        cycle=TRUE,cycle.period = 12,<br/>                        irregular=TRUE)<br/>ucm_min_temp<br/>df$level&lt;-ucm_min_temp$s.level<br/>obj1&lt;-lattice::xyplot(animals_dead~date_interval, <br/>                      data=df, type="l")<br/>obj2&lt;-lattice::xyplot(level~date_interval, <br/>                      data=df, type="l")<br/>latticeExtra::doubleYScale(obj1, <br/>                           obj2, <br/>                           add.ylab2 = TRUE)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ox"><img src="../Images/8a11433403d264a804e5c00155b10bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpksusCoghqvx9hlN7yfyw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">显示位置1434的最低温度和每个数据的死亡人数的图片。肉眼很难发现任何图案。</figcaption></figure><p id="6fbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，现在怎么办？我们可以看到死亡率的模式在每个地方都有变化，可以肯定的是死亡率是可以看到的。有事件，无论如何。下一步可能是回到最初的<a class="ae lb" href="https://towardsdatascience.com/introduction-to-survival-analysis-in-cows-using-r-28b82c2821fb" rel="noopener" target="_blank">生存分析</a>，像Kaplan-Meier或Cox回归，因为两者都可以包含像时间这样的时变系数。然后我们可以添加参数生存分析来寻找预期的死亡率曲线。</p><p id="8e56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们回到我们制作的最后一个模型，并绘制预测生存曲线，以进一步了解模型的性能。只是为了更好地了解我们所拥有的。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ae3b" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, day, month, animals_dead, animals_start,<br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::filter(t_min_in&gt;0)%&gt;%<br/>  dplyr::filter(t_max_in&gt;0)<br/>fit5&lt;-pscl::zeroinfl(animals_dead~<br/>                       splines::ns(day,5)*<br/>                       splines::ns(t_min_in,5)+<br/>                       splines::ns(t_max_in,5)+<br/>                       splines::ns(t_act_out,5)+<br/>                       as.factor(month) + <br/>                       splines::ns(day,5):as.factor(month)+<br/>                       as.factor(lcn_id) + as.factor(month):as.factor(lcn_id)| <br/>                       day + month, <br/>                     dist="negbin", <br/>                     link="log",<br/>                     data = df_pois)<br/>summary(fit5)<br/>pred_fit&lt;-predict(fit5,newdata=df_pois)<br/>df_fit_combined&lt;-cbind(df_pois, pred_fit)<br/>plot(hist(df_fit_combined$pred_fit))</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oy"><img src="../Images/73af5334589a4f14be58b31daa3737fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cb8Pp4h5sz-hTBMcT02_vw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">哇，这里有一些时髦的预测！</figcaption></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="fe52" class="ll lm iq lh b gy ln lo l lp lq">ggplot(df_fit_combined, <br/>       aes(x=pred_fit, fill=as.factor(lcn_id)))+<br/>  geom_density(alpha=0.5)+<br/>  theme_bw()+<br/>  labs(fill="Location")+<br/>  xlim(0,40)</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oy"><img src="../Images/6b806b4153563c4199934f086532bc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1297qMvpD5t_cQN8URIRg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">如果我把上限设在40，看起来会更好。我把上限定在40没有特别的理由，除了我知道有时候单日死亡率可以达到那个数字。幸运的是，该模型在预测中确实做到了零通胀，而且预测的数字也没有那么可怕。</figcaption></figure><p id="ef14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住，我警告过你们所有人，这种建模并不容易。我故意拒绝使用Kaplan-Meier或Cox回归对数据建模，而是选择使用时间对事件数据建模，并包括零通货膨胀。</p><p id="7ead" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查我的模型做得如何的一个更好的方法是看一看我预测的死亡总数，并创建一种<a class="ae lb" href="https://blog.devgenius.io/survival-analysis-in-sas-kaplan-meier-cox-regression-time-varying-predictors-recurrent-events-4ae7cd95f8c0" rel="noopener ugc nofollow" target="_blank">生命风险</a>图。请记住，真正疯狂的预测，我踢出来，这里用零代替。我需要，否则情节不会工作，但这些事实上是我丢弃的预测。当然，这是一个限制。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d435" class="ll lm iq lh b gy ln lo l lp lq">df_fit_combined%&gt;%<br/>  dplyr::group_by(lcn_id)%&gt;%<br/>  dplyr::mutate(pred_fit = ifelse(pred_fit&gt;40, NA, pred_fit))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, animals_start, pred_fit)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(cum_dead = cumsum(animals_dead), <br/>                cum_pred_dead = cumsum(pred_fit),<br/>                animals_no_dead = animals_start - cum_dead, <br/>                animals_pred_no_dead = animals_start - cum_pred_dead)%&gt;%<br/>  ggplot(., aes(x=date_interval))+<br/>  geom_line(aes(y=cum_pred_dead), col="red")+<br/>  geom_line(aes(y=cum_dead), col="black")+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme_bw()<br/>df_fit_combined%&gt;%<br/>  dplyr::group_by(lcn_id)%&gt;%<br/>  dplyr::mutate(pred_fit = ifelse(pred_fit&gt;40, NA, pred_fit))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, animals_dead, animals_start, pred_fit)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(cum_dead = cumsum(animals_dead), <br/>                cum_pred_dead = cumsum(pred_fit),<br/>                animals_no_dead = animals_start - cum_dead, <br/>                animals_pred_no_dead = animals_start - cum_pred_dead)%&gt;%<br/>  ggplot(., aes(x=date_interval))+<br/>  geom_line(aes(y=animals_pred_no_dead), col="red")+<br/>  geom_line(aes(y=animals_no_dead), col="black")+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme_bw()</span></pre><div class="lc ld le lf gt ab cb"><figure class="mm lt oz mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/6a2aba2b901110cb33ff5eb0a3afde84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*gj2xkH8LgsYzTK8b3D3Rzg.png"/></div></figure><figure class="mm lt pa mo mp mq mr paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><img src="../Images/d153c1be8a3eca07166dca1745541a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*uEkls2nPmpcQtvKHhoTiIQ.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk pb di pc mv translated">左图:累计死亡总数。右图:显示动物数量减少的生命风险图。在这两幅图中，预测用红色表示，实际数字用黑色表示。你可以看到这个模型是如何反复预测的，但是因为我没有使用任何变量，所以你看不到不确定性。让我们加上这一点。</figcaption></figure></div><p id="3643" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">pscl包没有标准的置信区间计算，因此获得置信区间的最简单方法是引导数据。同样在这里，我需要删除严重的预测，我不喜欢，但无论如何让我们这样做。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="20e7" class="ll lm iq lh b gy ln lo l lp lq">fit5&lt;-pscl::zeroinfl(animals_dead~<br/>                       splines::ns(day,5)*<br/>                       splines::ns(t_min_in,5)+<br/>                       splines::ns(t_max_in,5)+<br/>                       splines::ns(t_act_out,5)+<br/>                       as.factor(month) + <br/>                       splines::ns(day,5):as.factor(month)+<br/>                       as.factor(lcn_id) + as.factor(month):as.factor(lcn_id)| <br/>                       day + month, <br/>                     dist="negbin", <br/>                     link="log",<br/>                     data = df_pois, <br/>                     X=TRUE, <br/>                     y=TRUE, <br/>                     model=TRUE,<br/>                     linkinv=TRUE)<br/>stat &lt;- function(df_pois, inds) {<br/>  model &lt;- formula(animals_dead~<br/>                     splines::ns(day,5)*<br/>                     splines::ns(t_min_in,5)+<br/>                     splines::ns(t_max_in,5)+<br/>                     splines::ns(t_act_out,5)+<br/>                     as.factor(month) + <br/>                     splines::ns(day,5):as.factor(month)+<br/>                     as.factor(lcn_id) + as.factor(month):as.factor(lcn_id)| <br/>                     day + month)<br/>  predict(<br/>    pscl::zeroinfl(model, <br/>                   dist = "negbin", <br/>                   link = "log", <br/>                   data = df_pois[inds, ]))<br/>}<br/>(res &lt;- boot::boot(df_pois, stat, R = 2000, parallel="snow", ncpus = 6))<br/>CI &lt;- setNames(as.data.frame(t(sapply(1:nrow(df_pois), function(row)<br/>  boot.ci(res, conf = 0.95, type = "basic", index = row)$basic[, 4:5]))),<br/>  c("lower", "upper"))<br/>df_all &lt;- cbind.data.frame(df_pois, <br/>                           response = predict(fit5), CI)<br/>df_boot&lt;-df_all%&gt;%<br/>  dplyr::mutate(response = ifelse(response&gt;40, NA, response),<br/>                lower = ifelse(between(lower,-40,40), lower, NA),<br/>                upper = ifelse(between(upper,-40,40), upper, NA))</span><span id="ae89" class="ll lm iq lh b gy lr lo l lp lq">table(is.na(df_boot$lower))<br/>table(is.na(df_boot$upper))<br/>table(is.na(df_boot$response))</span><span id="00c6" class="ll lm iq lh b gy lr lo l lp lq">ggplot(df_boot, <br/>       aes(x=as.numeric(response), <br/>           y=lubridate::date(date_interval)))+<br/>  geom_pointrange(aes(xmin=0, xmax=upper), alpha=0.5)+<br/>  geom_point()+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pd"><img src="../Images/3d5ef50ea87f09ab3f1dd60237485714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIwofrqEHGHCS3ZD2oKPwg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">如你所见，置信区间的下限非常非常低，所以我必须把它们设为零。通常，你不希望必须这样做，而是让模型考虑零的边界，但是这里没有发生。所以我帮了点忙。</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pe"><img src="../Images/1bf2f17c3592da547858556c5b723769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJQfxNtOxmA3G0rSft7UWw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">以及自举预测。帮忙之后，看起来没那么糟。您还可以看到，在某些点上没有做出任何预测。让我们看看所有这些在累积和图中是什么样子的。</figcaption></figure><p id="fb5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是累积和图。男孩哦男孩。请记住，我运行了2000次模型，并预测了2000次我观察到的每个数据点的死亡人数。然后，我得到了每个预测的置信区间。可以说这些是预测区间。然后我开始总结这些，下面我得到的是一个相当诚实的解释，关于我的模型本身有多确定，它不是很确定。话说回来，我一开始也不是很确定。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="80d2" class="ll lm iq lh b gy ln lo l lp lq">df_boot%&gt;%<br/>  dplyr::group_by(lcn_id)%&gt;%<br/>  dplyr::select(lcn_id, date_interval, <br/>                animals_dead, <br/>                animals_start, <br/>                response, <br/>                lower, <br/>                upper)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(cum_dead = cumsum(animals_dead), <br/>                cum_pred_dead = cumsum(response),<br/>                cum_pred_lower_dead = cumsum(lower),<br/>                cum_pred_upper_dead = cumsum(upper),<br/>                animals_no_dead = animals_start - cum_dead, <br/>                animals_pred_no_dead = animals_start - cum_pred_dead,<br/>                animals_lower_no_dead = animals_start - cum_pred_lower_dead,<br/>                animals_upper_no_dead = animals_start - cum_pred_upper_dead)%&gt;%<br/>  ggplot(., aes(x=date_interval))+<br/>  geom_line(aes(y=cum_pred_dead), col="red")+<br/>  geom_line(aes(y=cum_dead), col="black")+<br/>  geom_ribbon(aes(ymin=cum_pred_lower_dead, ymax=cum_pred_upper_dead), <br/>              fill="red", alpha=0.3)+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pf"><img src="../Images/5f8eb1a628019447119bfe3ff09d3541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2UoIQIvcR2IH6IJQZNBtQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">置信区间看起来不错，就它们应该看起来如何而言，但它们是巨大的。当然，如果yu运行一个模型，该模型将不得不自我更新，但仍然可以预期，当你试图对这样的离散数据建模时，很难得到任何类型的有效预测。</figcaption></figure><p id="607b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，还有最后一件事我想尝试，那就是从UCM模型中提取曲线，帮我预测事件，然后绘制它。我将只为一个位置这样做。只是为了看看。我对它不抱太大期望，但谁知道呢。好像我从一开始就没有警告过你们。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f848" class="ll lm iq lh b gy ln lo l lp lq">df_pois&lt;-day%&gt;%<br/>  dplyr::filter(!lcn_id %in% c('1435'))%&gt;%<br/>  dplyr::filter_at(vars(animals_start), all_vars(!is.na(.)))%&gt;%<br/>  dplyr::mutate(day = lubridate::day(date_interval), <br/>                month=lubridate::month(date_interval))%&gt;%<br/>  dplyr::select(lcn_id, date_interval, day, month, animals_dead, animals_start,<br/>                t_min_in, t_max_in, t_act_out)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::filter(t_min_in&gt;0)%&gt;%<br/>  dplyr::filter(t_max_in&gt;0)<br/>ucm_min_temp&lt;-rucm::ucm(t_min_in~0, <br/>                        data=df_pois, <br/>                        level=TRUE,<br/>                        slope=TRUE,<br/>                        cycle=TRUE,cycle.period = 12,<br/>                        irregular=TRUE)<br/>df_pois$level&lt;-ucm_min_temp$s.level</span><span id="1127" class="ll lm iq lh b gy lr lo l lp lq">fit6&lt;-pscl::zeroinfl(animals_dead~<br/>                       splines::ns(day,5)+<br/>                       splines::ns(level,5)+<br/>                       as.factor(month) + <br/>                       as.factor(lcn_id)+<br/>                       splines::ns(day,5):as.factor(month)+<br/>                       splines::ns(day,5):splines::ns(level,5)+<br/>                       as.factor(lcn_id) + as.factor(month):as.factor(lcn_id)| <br/>                       day + month, <br/>                     dist="negbin", <br/>                     link="log",<br/>                     data = df_pois, <br/>                     X=TRUE, <br/>                     y=TRUE, <br/>                     model=TRUE,<br/>                     linkinv=TRUE)<br/>AIC(fit5);AIC(fit6)<br/>stat &lt;- function(df_pois, inds) {<br/>  model &lt;- formula(animals_dead~<br/>                     splines::ns(day,5)+<br/>                     splines::ns(level,5)+<br/>                     as.factor(month) + <br/>                     as.factor(lcn_id)+<br/>                     splines::ns(day,5):as.factor(month)+<br/>                     splines::ns(day,5):splines::ns(level,5)+<br/>                     as.factor(lcn_id) + as.factor(month):as.factor(lcn_id)| <br/>                     day + month)<br/>  predict(<br/>    pscl::zeroinfl(model, <br/>                   dist = "negbin", <br/>                   link = "log", <br/>                   data = df_pois[inds, ]))<br/>}<br/>(res &lt;- boot::boot(df_pois, stat, R = 2000, parallel="snow", ncpus = 6))<br/>CI &lt;- setNames(as.data.frame(t(sapply(1:nrow(df_pois), function(row)<br/>  boot.ci(res, conf = 0.95, type = "basic", index = row)$basic[, 4:5]))),<br/>  c("lower", "upper"))<br/>df_all &lt;- cbind.data.frame(df_pois, <br/>                           response = predict(fit6), CI)<br/>df_boot&lt;-df_all%&gt;%<br/>  dplyr::mutate(response = ifelse(response&gt;40, NA, response),<br/>                lower = ifelse(between(lower,-40,40), lower, NA),<br/>                upper = ifelse(between(upper,-40,40), upper, NA))<br/>ggplot(df_boot, <br/>       aes(x=as.numeric(response), <br/>           y=lubridate::date(date_interval)))+<br/>  geom_pointrange(aes(xmin=0, xmax=upper), alpha=0.5)+<br/>  geom_point()+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme_bw()<br/>df_boot%&gt;%<br/>  dplyr::group_by(lcn_id)%&gt;%<br/>  dplyr::select(lcn_id, date_interval, <br/>                animals_dead, <br/>                animals_start, <br/>                response, <br/>                lower, <br/>                upper)%&gt;%<br/>  replace(is.na(.), 0)%&gt;%<br/>  dplyr::mutate(cum_dead = cumsum(animals_dead), <br/>                cum_pred_dead = cumsum(response),<br/>                cum_pred_lower_dead = cumsum(lower),<br/>                cum_pred_upper_dead = cumsum(upper),<br/>                animals_no_dead = animals_start - cum_dead, <br/>                animals_pred_no_dead = animals_start - cum_pred_dead,<br/>                animals_lower_no_dead = animals_start - cum_pred_lower_dead,<br/>                animals_upper_no_dead = animals_start - cum_pred_upper_dead)%&gt;%<br/>  ggplot(., aes(x=date_interval))+<br/>  geom_line(aes(y=cum_pred_dead), col="red")+<br/>  geom_line(aes(y=cum_dead), col="black")+<br/>  geom_ribbon(aes(ymin=cum_pred_lower_dead, ymax=cum_pred_upper_dead), <br/>              fill="red", alpha=0.3)+<br/>  facet_wrap(~lcn_id, scales="free")+<br/>  theme_bw()</span></pre><figure class="lc ld le lf gt lt gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/fbdb259b6f8ba0060b64b978b89a1fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*ADK7v9hijZBAg7XYE3y5OA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">AIC更糟糕</figcaption></figure><figure class="lc ld le lf gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ph"><img src="../Images/3c1ce2366d9d53ff2b80fba98b6c0ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKNAPNYme9lrPu5DrEWcQw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">但是均值预测更好。置信区间仍然很大，就像以前的模型一样大，但是现在线更近了。</figcaption></figure><p id="32c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我暂时就说到这里。我可以使用最大内部温度和实际外部温度的级别摘要，但我还必须进行全面的交叉验证和滚动时间窗口。</p><p id="dae8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">建模并不容易，需要做很多工作。我所做的是一个如何模拟死亡率的练习，它似乎有一些优点，但它肯定不是万无一失的。简而言之，这就是建模。</p><p id="db02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你喜欢它！</p><p id="72f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有什么不对劲，请告诉我！</p></div></div>    
</body>
</html>