<html>
<head>
<title>Loading Different Data Files in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中加载不同的数据文件</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/loading-different-data-files-in-python-b6385320c0f5?source=collection_archive---------0-----------------------#2020-06-09">https://pub.towardsai.net/loading-different-data-files-in-python-b6385320c0f5?source=collection_archive---------0-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1594" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming/python" rel="noopener ugc nofollow" target="_blank"> Python </a></h2><div class=""/><div class=""><h2 id="4a0f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">来自Excel、Pickle、Parquet、Stata、MATLAB、HDF5和Sas7bdat文件</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/105e1771d3aea0ab40a8d790dd3be1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Eca_uQvd00QElw54OBkPFg.jpeg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae ld" href="https://cdn.pixabay.com/photo/2014/04/05/11/28/internet-315799_1280.jpg" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="4b18" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi ma translated"><span class="l mb mc md bm me mf mg mh mi di">D</span>on not we all just love<strong class="lg jd"><em class="mj">PD . read _ CSV()</em></strong>…这可能是我们亲爱的<em class="mj">熊猫</em>图书馆里最惹人喜爱的一句台词了。</p><blockquote class="mk"><p id="e2f7" class="ml mm it bd mn mo mp mq mr ms mt lz dk translated">毫无疑问，说到表格数据文件，<a class="ae ld" href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="noopener ugc nofollow" target="_blank"> <em class="mu"> CSV </em> </a> s是‘群里最酷的猫’。</p></blockquote><p id="e53f" class="pw-post-body-paragraph le lf it lg b lh mv kd lj lk mw kg lm ln mx lp lq lr my lt lu lv mz lx ly lz im bi translated">事实是，数据文件有不同的类型和扩展名，作为数据专家，我们必须处理它们。</p><p id="dd1f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">ETL</strong><em class="mj">(</em><a class="ae ld" href="https://en.wikipedia.org/wiki/Extract,_transform,_load" rel="noopener ugc nofollow" target="_blank"><em class="mj">提取、转换、加载</em> </a> <em class="mj"> ) </em>是主流数据处理的核心。所以今天我们将探索在<em class="mj"> Python </em>中加载一些不同的数据类型。</p><p id="5675" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们列表中的第一项是在<em class="mj"> NumPy: </em>中导入数据</p><h1 id="ffda" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">目录</h1><ol class=""><li id="2405" class="ns nt it lg b lh nu lk nv ln nw lr nx lv ny lz nz oa ob oc bi translated"><a class="ae ld" href="#c3d9" rel="noopener ugc nofollow"> <strong class="lg jd">在Numpy中导入数据</strong> </a></li><li id="7a55" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#51b1" rel="noopener ugc nofollow"> <strong class="lg jd">从Excel文件导入数据</strong> </a></li><li id="626a" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#c00d" rel="noopener ugc nofollow"> <strong class="lg jd">从SAS文件导入数据</strong> </a></li><li id="03d2" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#4347" rel="noopener ugc nofollow"> <strong class="lg jd">从STATA文件导入数据</strong> </a></li><li id="02e3" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#3355" rel="noopener ugc nofollow"> <strong class="lg jd">从HDF5文件导入数据</strong> </a></li><li id="e69c" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#b4b2" rel="noopener ugc nofollow"> <strong class="lg jd">从MATLAB文件导入数据</strong> </a></li><li id="b630" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#f6ca" rel="noopener ugc nofollow"> <strong class="lg jd">从Pickle文件导入数据</strong> </a> <strong class="lg jd">。</strong></li><li id="72ae" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#d275" rel="noopener ugc nofollow"> <strong class="lg jd">从拼花文件导入数据</strong> </a></li><li id="9a75" class="ns nt it lg b lh od lk oe ln of lr og lv oh lz nz oa ob oc bi translated"><a class="ae ld" href="#78b1" rel="noopener ugc nofollow"> <strong class="lg jd">总结</strong> </a></li></ol><h1 id="c3d9" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">在Numpy中导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi oi"><img src="../Images/be02672d193eb024c0cd93e181845934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGXJfCa0-Tif6HnY7DUM9Q.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://www.gautamkrishnar.com/an-intro-to-numpy/" rel="noopener ugc nofollow" target="_blank"> img_credit </a></figcaption></figure><p id="6d26" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">如果给定平面文件中的所有数据都是数字，或者如果我们打算只导入数字特征，Numpy 是理想的。因此得名<em class="mj"> Numpy </em>(数值- <em class="mj"> Python </em>)。</p><p id="ce3d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">但是为什么<em class="mj"> Numpy </em>？</strong></p><p id="421e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">Numpy 数组是存储数字数据的python标准。它们高效、快速、干净。<em class="mj"> Numpy </em>提供了核心多维数组对象，这是<em class="mj"> Python </em>中大多数科学计算任务所必需的。这就是它位于SciPy堆栈的根的原因。</p><p id="228c" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们探索一下加载数据的NumPy函数。</p><ol class=""><li id="1872" class="ns nt it lg b lh li lk ll ln on lr oo lv op lz nz oa ob oc bi translated"><strong class="lg jd"> numpy.loadtxt()函数:</strong></li></ol><p id="93f9" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">该函数最适合纯数字数据。让我们让它发挥作用。首先，让我们在没有<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">np</em>.<em class="mj">loadtxt()</em></strong></code>函数的情况下导入titanic数据集。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi ow"><img src="../Images/1a020dd576d1fb50c8d4039fd1c6cb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myD4Zdp6J9cuslLLmdgkyA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">泰坦尼克号的前五行_df</figcaption></figure><p id="a049" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在，让我们用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">np.loadtxt()</em></strong></code>函数导入它，并且只选择数字行和数字列。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="02c1" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以在传递<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">skiprows=1</em></strong><em class="mj">,</em></code> <em class="mj"> </em>时我们跳过了列标题。和passing，<em class="mj"> </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">usecols=</em>[0,1,4],</strong></code>我们只选择第0、1、4列，都是数值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi ox"><img src="../Images/59de4ba6e4868e7e9a0cc2f30a637fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9gK7u4MtLoZ78TnVbA7GQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">所以我们得到了一个好的、坚固的numpy数组，没有标题，只有3列。</figcaption></figure><blockquote class="mk"><p id="6e87" class="ml mm it bd mn mo oy oz pa pb pc lz dk translated">注意numpy可以处理混合类型的数据…</p></blockquote><p id="385e" class="pw-post-body-paragraph le lf it lg b lh mv kd lj lk mw kg lm ln mx lp lq lr my lt lu lv mz lx ly lz im bi translated"><strong class="lg jd"> 2。numpy.genfromtxt()函数:</strong></p><p id="e149" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这个<em class="mj"> NumPy </em>函数可以更好地处理混合数据类型。通过参数，<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">dtype=None,</em></strong></code>,它将为每一列找出正确的数据类型。</p><p id="fc4b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">缺点是它返回一个<strong class="lg jd"> 1D数组</strong>，其中每个元素都是导入的平面文件的一行。让我们使用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">np.genfromtxt()</em></strong></code> <em class="mj">导入相同的数据。</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1626" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以<em class="mj"> </em>我们传递数据集，然后我们传递<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">delimiter=’,’</em></strong><em class="mj"> </em></code>告诉<em class="mj"> NumPy </em>这是一个逗号分隔值文件。然后我们通过<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">names=True</em></strong></code> <em class="mj"> </em>告诉NumPy数据集有列标题<em class="mj">。</em></p><p id="ef2a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">最后，我们通过<em class="mj"> </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">dtype=None</em></strong></code> <em class="mj"> </em>和<em class="mj"> </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">encoding=’utf8' </em></strong></code> <em class="mj">。</em>前者允许NumPy自己推断数据类型，后者强制执行<code class="fe oq or os ot b"><strong class="lg jd">‘utf8’</strong> </code>编码以避免任何转换问题，以防字节在转换过程中损坏或丢失。参见<a class="ae ld" href="https://docs.python.org/3/howto/unicode.html" rel="noopener ugc nofollow" target="_blank"> <em class="mj">链接</em> </a></p><p id="4407" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以这个<strong class="lg jd"> 1D数组</strong>允许我们通过调用列名来索引数组。例如，如果我们想从这个数组中看到泰坦尼克号数据集上的前10个<em class="mj">票价</em>成本，我们可以简单地做:</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="df7c" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">data[’fare’][:10]</strong><br/>&gt;&gt;<br/># And the output is:</span><span id="df7e" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">array([  7.25  ,  71.2833,   7.925 ,  53.1   ,   8.05  ,   8.4583,    51.8625,  21.075 ,  11.1333,  30.0708])</strong></span></pre><blockquote class="mk"><p id="7df4" class="ml mm it bd mn mo oy oz pa pb pc lz dk translated">将混合类型的数据传递给numpy不是最佳做法。请将混合数据类型放在pandas数据框中。</p></blockquote><p id="6839" class="pw-post-body-paragraph le lf it lg b lh mv kd lj lk mw kg lm ln mx lp lq lr my lt lu lv mz lx ly lz im bi translated"><strong class="lg jd"> 3。numpy.recfromcsv()函数:</strong></p><p id="fb9a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">该功能与<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">np.genfromtxt()</em></strong></code> <strong class="lg jd"> </strong>功能完全相同。只是默认情况下它拥有所有的参数。意，我们不需要传递，<strong class="lg jd"> </strong> <code class="fe oq or os ot b"><strong class="lg jd">names, delimiter </strong></code> <strong class="lg jd">或</strong> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">dtype</em> </strong></code> <strong class="lg jd"> args。</strong></p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="ba6d" class="ph nb it ot b gy pi pj l pk pl"># function <em class="mj">np.recfromcsv()</em> has the defaults delimiter=',' and names=True in addition to dtype=None.</span><span id="8a2a" class="ph nb it ot b gy pm pj l pk pl"># So we only pass it the file to read.</span><span id="e6a3" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">data = np.recfromcsv('titanic.csv')</strong></span><span id="5e2c" class="ph nb it ot b gy pm pj l pk pl"># This returns the exact same array we saw from <em class="mj">np.genfromtxt(</em>).</span></pre><h1 id="51b1" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从Excel文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi pn"><img src="../Images/cdc85920dd8ceeab47130b37a82b0f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzXvDy-1ICXoLl7zDPk0rg.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae ld" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Ftealtek.co.za%2Fbenefits-of-microsoft-excel-in-the-work-place%2F&amp;psig=AOvVaw3f2K2gW6LWJo_lF--OGbjb&amp;ust=1591018529508000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCPCxzoWc3ukCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">谷歌搜索</a></figcaption></figure><p id="4215" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">Excel文件有点棘手，因为它们可能包含几个工作表。所以解析数据并选择相关的工作表是最理想的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="04e4" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">从上面的Git-gist中，我们提取了<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">battle_link</em></strong></code> excel文件，并使用<code class="fe oq or os ot b">`<strong class="lg jd"><em class="mj">pd.ExcelFile()`</em></strong></code> <strong class="lg jd"> <em class="mj"> </em> </strong>函数将其作为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">pandas.io.excel</em></strong></code> <em class="mj"> </em>对象加载。然后我们打印出工作表名称，<code class="fe oq or os ot b"><strong class="lg jd">`<em class="mj">print(xls.sheet_names)`</em></strong></code>，并得到工作表名称的列表:-<strong class="lg jd">[‘2002’，‘2004’]</strong>。</p><p id="534d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这告诉我们，这个文件中只有两张表。</p><ol class=""><li id="31a5" class="ns nt it lg b lh li lk ll ln on lr oo lv op lz nz oa ob oc bi translated"><strong class="lg jd"> pd.parse()函数:</strong></li></ol><p id="4e5d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们可以使用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">parse()</em></strong></code> <strong class="lg jd"> <em class="mj">的方法，按名称或索引选择任何一个工作表。</em> </strong>让我们按其名称载入一张表…</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="61bf" class="ph nb it ot b gy pi pj l pk pl"># Load a sheet into a Data Frame by name: df1</span><span id="b099" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">df1 = xls.parse('2004')</strong></span><span id="a95c" class="ph nb it ot b gy pm pj l pk pl"># Print the head of the DataFrame df1</span><span id="be1c" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">df1.head()<br/>&gt;&gt;</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/4d5c5014a23aea3ba0528b2bac1c0a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPFmZpq13lUvKAhjJ7Hhgw.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将Excel表格按表格名称加载到pandas。</figcaption></figure><p id="5ad5" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">接下来，让我们通过索引加载另一个工作表…</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="9350" class="ph nb it ot b gy pi pj l pk pl"># Load a sheet into a DataFrame by index: df2</span><span id="fcc0" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">df2 = xls.parse(0)</strong></span><span id="337c" class="ph nb it ot b gy pm pj l pk pl"># Print the head of the DataFrame df2</span><span id="4492" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">print(df2.head())<br/>&gt;&gt;</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/59cdef9eed4eb9f34c2e05d3d0278866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xqp_uj2adGqpRL5dqOWIg.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将Excel表格中的表格索引加载到pandas中。</figcaption></figure><p id="4b6a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">在pandas中自定义您的Excel电子表格导入:</strong></p><p id="8277" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">就像我们在<em class="mj"> NumPy </em>中所做的一样，我们可以使用额外的参数来跳过行、重命名列，并且也可以使用<em class="mj"> Excel </em>文件只选择特定的列。</p><p id="ecd4" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">和以前一样，我们将使用方法<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">pd.parse()</em></strong></code>。不过这一次，我们将添加附加参数<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">skiprows</em></strong>, <strong class="lg jd"><em class="mj">names</em></strong></code> <strong class="lg jd"> <em class="mj"> </em> </strong>和<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">usecols</em></strong></code>。注意，传递给这些参数的值必须是类型<strong class="lg jd">列表</strong>。</p><p id="92b6" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> A. </strong>让我们解析第一个工作表(‘2002’或索引0)并重命名它的列</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="2fc1" class="ph nb it ot b gy pi pj l pk pl"># Parse the first sheet and rename all the columns:</span><span id="77f7" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">df1 = xls.parse(0, skiprows=[1], names=['Country','AAM due to War (2002)'])</strong></span><span id="0e0b" class="ph nb it ot b gy pm pj l pk pl"># Print the head of the DataFrame df1</span><span id="abc1" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">print(df1.head())<br/>&gt;&gt;</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/1aa01a8ccf810b0d8d9336a9431527eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-tbQlNHP6pbnXGDpDy4zg.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">应用skiprows和names参数自定义Excel导入。</figcaption></figure><p id="4aff" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> B. </strong>让我们只解析第二个工作表的第一列，并将其重命名。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="8d88" class="ph nb it ot b gy pi pj l pk pl"># Parse the first column of the second sheet and rename the column:</span><span id="fa52" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">df2 = xls.parse(1, usecols=[0], skiprows=[1], names=['Country'])</strong></span><span id="95a2" class="ph nb it ot b gy pm pj l pk pl"># Print the head of the DataFrame df2</span><span id="0b0c" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">print(df2.head())<br/>&gt;&gt;</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/d2a7d3f70790beb7f8f3886d1fbd2784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hnuf2LxUTMIdVzVgkLfkjg.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">应用usecols、skiprows和names参数自定义Excel导入。</figcaption></figure><p id="1ad3" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">2.<strong class="lg jd"> pd.read_excel()函数:</strong></p><p id="267b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这个函数更常用于加载Excel文件。 pandas将Excel数据直接读入<em class="mj"> Pandas数据框</em>对象，而不是先<a class="ae ld" href="https://en.wikipedia.org/wiki/Parsing" rel="noopener ugc nofollow" target="_blank"> <em class="mj">解析数据</em> </a> <em class="mj">。而像<em class="mj"/><code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">pd.parse()</em></strong></code><em class="mj"/>我们完全可以用<em class="mj"> </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">pd.read_excel()</em></strong></code> <em class="mj">定制进口。</em></em></p><p id="a520" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">有了这个函数，我们不必将所有参数都限制在列表中。我们可以将一个字符串传递给<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">sheet_name</em></strong></code>，将一个int传递给<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">skiprows</em></strong></code>，但是<strong class="lg jd"> <em class="mj"> </em> </strong> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">names</em></strong></code>和<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">usecols</em></strong></code><strong class="lg jd"><em class="mj"/></strong>必须有一个列表。</p><p id="8340" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">例如，让我们只从名为“2004”的工作表中选择第一列，跳过第一行，在一行代码中将该列重命名为<code class="fe oq or os ot b"><strong class="lg jd">‘war_Country’</strong></code> …。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="f716" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">data_2 = pd.read_excel(battle_link, sheet_name='2004', usecols=[0], skiprows=0, names=['War_Country'])</strong></span><span id="0dec" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">data_2.head()<br/>&gt;&gt;</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/7ff7dd4ae1d589a2321153b2e0db238f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gs8V7sxwssNN2psvYGey-w.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">这是一行程序的输出…</figcaption></figure><h1 id="c00d" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从SAS文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/edd800b00da4394ac81bfc49cf613b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIjAub9gWlbZ8OskS1Zabg.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae ld" href="https://www.sas.com/en_us/_jcr_content/socialShareImage.img.png" rel="noopener ugc nofollow" target="_blank"> SAS </a></figcaption></figure><p id="8228" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">SAS代表<a class="ae ld" href="https://www.sas.com/en_us/company-information/profile.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd"> <em class="mj">统计分析系统</em></strong></a><strong class="lg jd"><em class="mj"/></strong><em class="mj">SAS</em>是使用<a class="ae ld" href="https://en.wikipedia.org/wiki/SAS_language" rel="noopener ugc nofollow" target="_blank"> SAS编程语言对数据进行挖掘、修改、管理和执行统计分析的软件套件。</a> <em class="mj"> SAS </em>是一家值得信赖的分析公司，拥有超过40年的分析创新经验。SAS数据文件的扩展名为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">.sas7bdat</em></strong></code>。</p><p id="16b8" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以我们在熊猫里导入一个<em class="mj"> SAS </em>文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="e840" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">根据上面的要点，我们将<em class="mj">熊猫作为pd </em>导入。然后我们安装<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">sas7bdat</em></strong> </code>(全小写)包，这是<em class="mj"> SAS </em>中默认的数据集文件包。</p><p id="87fc" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">从这个包中，我们导入<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">SAS7BDAT</em></strong></code>(全部大写)，它类似于上下文管理器，我们可以使用它来读入并绑定<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">sales.sas7bdat</em></strong> </code>文件到<em class="mj"> Pandas </em>数据帧。</p><p id="16f8" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">注意，在上下文管理器中，我们将<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">sales.sas7bdat</em></strong></code>文件读入为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">files</em></strong></code> <em class="mj"> </em>，并使用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">.to_data_frame() </em></strong></code>方法… <strong class="lg jd"> <em class="mj"> </em> </strong> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">`df_sas = files.to_data_frame()`</em></strong></code> <em class="mj">将其绑定到一个<em class="mj">熊猫</em>数据帧。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/e0f536c3d10ad1399f82598e241833bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QXuzLOSgtMs3kQ0JpaLkA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">熊猫数据框中sales.sas7bdat文件的前五行。</figcaption></figure><p id="471c" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们看看SAS数据帧的<code class="fe oq or os ot b"><strong class="lg jd">P-values</strong></code>特征的直方图。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="23d0" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">df_sas.P.hist()<br/>plt.ylabel('count')<br/>plt.title('Histogram of P-Values')<br/>plt.show()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/818d504a94ffa6bd799048b23d177766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*lS9qOncb-dnvjiQR5H8ZfQ.jpeg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">SAS销售数据框架中的P值直方图。</figcaption></figure><h1 id="4347" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从Stata文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi pq"><img src="../Images/e8d6ab47b6eeae92c534c1cc6beafb86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zoVdtGsro0YV965E9rjnA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Flibguides.napier.ac.uk%2Fstats%2Fstata&amp;psig=AOvVaw3mZOZuWyfFmnudNVuCw_eC&amp;ust=1591278874774000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCPCev_fl5ekCFQAAAAAdAAAAABAU" rel="noopener ugc nofollow" target="_blank">来源:谷歌搜索</a></figcaption></figure><p id="8069" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://www.stata.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lg jd"><em class="mj">Stata</em></strong></a>是对统计数据的缩写。<em class="mj"> Stata </em>文件流行于学术社会科学研究。<em class="mj"> Stata </em>文件的扩展名为<code class="fe oq or os ot b"><strong class="lg jd"> <em class="mj">.dta</em></strong></code>。</p><p id="0c3e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">好消息是<em class="mj">熊猫</em>有一个读取<em class="mj"> Stata </em>文件的内置函数。所以我们不需要像处理<em class="mj"> SAS </em>文件那样的上下文管理器。让我们导入一个<em class="mj"> Stata </em>文件，其中包含某些国家的传染病范围…</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="152f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以我们简单地使用<em class="mj"> wget </em>命令下载数据集，然后我们通过将它传递给<em class="mj"> pandas </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">read_stata()</em></strong></code>函数来创建一个数据框。</p><p id="4fc0" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们看看前五行和<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">disa10</em></strong></code>特征的直方图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi pr"><img src="../Images/dabf8406cd77b2261e6e0f7aad764922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQKa0TPDV2_2BKfms-AciQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">的数据帧的前五行。dta文件。</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/9cf580995ec4f1a0b0083b1ca60f6283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnhGsEJBrNo-KY5PbYh40g.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">disa10特征的历史图。</figcaption></figure><p id="5957" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们可以通过将参数传递给该函数的几个参数来自定义导入。比如:- <code class="fe oq or os ot b"><strong class="lg jd">pd.read_stata(<em class="mj">index_col=</em>, <em class="mj">convert_missing=</em>, <em class="mj">preserve_dtypes=</em>, <em class="mj">chunksize=</em>, <em class="mj">iterator=</em>)</strong></code> <strong class="lg jd">。参见</strong> <a class="ae ld" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_stata.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd"> <em class="mj">链接</em> </strong> </a></p><h1 id="3355" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从HDF5文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/5f8d96009e3547dfc8d676a02e887361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erSeJA1Df1ZNek7-JEcYlA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">HDF5数据结构… <a class="ae ld" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.neonscience.org%2Fabout-hdf5&amp;psig=AOvVaw0pAlqoBUlhQmf_-W-YwjKS&amp;ust=1591281018926000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCKiwgvTt5ekCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank"> img_credit </a></figcaption></figure><p id="857e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在Python世界中，一种共识正在迅速汇聚到作为存储大量数字数据的标准机制的<code class="fe oq or os ot b"><strong class="lg jd">Hierarchical Data Format Version 5</strong></code>上。现在，处理数百千兆字节或万亿字节大小的数据集变得越来越常见。<code class="fe oq or os ot b"><strong class="lg jd">HDF5</strong></code>本身可以扩展到<strong class="lg jd">艾字节</strong>的数据量。</p><h2 id="f4a9" class="ph nb it bd nc ps pt dn ng pu pv dp nk ln pw px nm lr py pz no lv qa qb nq iz bi translated">HDF5文件的结构是什么？</h2><p id="c17b" class="pw-post-body-paragraph le lf it lg b lh nu kd lj lk nv kg lm ln qc lp lq lr qd lt lu lv qe lx ly lz im bi translated">我们可以像Python字典一样使用<strong class="lg jd"> <em class="mj"> keys() </em> </strong>的方法来探索它的层次结构。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="7e51" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">for key in data.keys():<br/>    print(key)</strong></span></pre><p id="3aaf" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这将返回数据集中现有的键。这些都是HDF集团。它们就像目录。请注意，<strong class="lg jd"> HDF5 </strong>项目由位于伊利诺伊州香槟市的<strong class="lg jd"> HDF </strong>小组积极维护，该小组以前是伊利诺伊大学香槟分校的一部分。</p><p id="6092" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们加载<strong class="lg jd"> <em class="mj"> LIGO HDF5 </em> </strong>数据集。<strong class="lg jd"> <em class="mj"> LIGO </em> </strong>代表<code class="fe oq or os ot b"><strong class="lg jd">Laser Interferometer Gravitational-Wave Observatory Project</strong></code>。这个项目验证了爱因斯坦的引力波理论。</p><h2 id="e43d" class="ph nb it bd nc ps pt dn ng pu pv dp nk ln pw px nm lr py pz no lv qa qb nq iz bi translated">使用h5py导入HDF5文件。</h2><p id="8f1a" class="pw-post-body-paragraph le lf it lg b lh nu kd lj lk nv kg lm ln qc lp lq lr qd lt lu lv qe lx ly lz im bi translated"><strong class="lg jd"> h5py </strong>包是<code class="fe oq or os ot b"><strong class="lg jd">HDF5</strong></code>二进制数据格式的Pythonic接口。它可以让你存储大量的数字数据，并轻松地操作这些数据。参见<a class="ae ld" href="https://www.h5py.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd"> <em class="mj">链接</em> </strong> </a> <strong class="lg jd"> <em class="mj">。</em> </strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="f0eb" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">因此，根据上面的Git-gist，我们将<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">LIGO</em></strong></code>数据集下载到我们的工作区。然后使用h5py上下文管理器，我们将<code class="fe oq or os ot b"><strong class="lg jd">LIGO</strong></code>数据读入一个名为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">data</em></strong></code>的<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">h5py.File</em></strong></code>对象。该对象具有嵌套Python字典的树状结构。这意味着父关键字有一些值，而这些值又可能包含压缩数据的其他嵌套值。</p><p id="80da" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">比如我们来探究一下<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">data</em></strong></code> <em class="mj"> </em>对象的<code class="fe oq or os ot b"><strong class="lg jd">‘strain’ </strong></code>键。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="57cf" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">type(data['strain'])<br/>&gt;&gt; h5py._hl.group.Group</strong></span></pre><p id="d0fc" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以我们可以看到它是一个<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">h5py.Group</em></strong></code> <strong class="lg jd"> <em class="mj"> </em> </strong>的物体，让我们看看，它有子键吗？</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="9921" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">data['strain'].keys()<br/>&gt;&gt; 'Strain'<br/></strong># So it has a 'Strain' sub-key...</span></pre><p id="ae05" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在让我们提取<code class="fe oq or os ot b"><strong class="lg jd"> ‘Strain’</strong></code>子键中的值并保存到一个数组中</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="632d" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">strain = data['strain']['Strain'].value </strong></span><span id="9272" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">print(type(strain))<br/>&gt;&gt; numpy.ndarray</strong></span></pre><p id="e1b6" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们看看数组的形状</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="c885" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">array.shape<br/>&gt;&gt;(131072,)<br/></strong># It has 131072 elements...</span></pre><p id="d452" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">最后，让我们画出<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">strain</em></strong></code>的前10000个元素，比如时序数据…</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="ba2e" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">import matplotlib.pyplot as plt</strong></span><span id="0690" class="ph nb it ot b gy pm pj l pk pl"># Set number of time points to sample: num_samples<br/><strong class="ot jd">num_samples = 10000</strong></span><span id="5f2a" class="ph nb it ot b gy pm pj l pk pl"># Set time vector<br/><strong class="ot jd">time = np.arange(0, 1, 1/num_samples)</strong></span><span id="3c9d" class="ph nb it ot b gy pm pj l pk pl"># Plot data</span><span id="28e7" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">plt.plot(time, strain[:num_samples])<br/>plt.xlabel('GPS Time (s)')<br/>plt.ylabel('strain')<br/>plt.title('Time/Strain Chart')<br/>plt.show()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi qf"><img src="../Images/154df591a590243b0334ff99eb72f348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxJRBDmu_YW4vrD2TtJ0MQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来自LIGO HDF5数据集的10000个数据点的时间序列图。</figcaption></figure><h1 id="b4b2" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从MATLAB文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi qg"><img src="../Images/0edec07270d963b71827507deb45856e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dw5tK2saJp1CU3r--RETwA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://www.electronicshub.org/wp-content/uploads/2014/10/MATLAB-Logo.png" rel="noopener ugc nofollow" target="_blank"> img_credit </a></figcaption></figure><p id="e97c" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> <em class="mj"> MATLAB </em> </strong>无需介绍。Cleve Moler教授是Fortran编程语言的专家，他的一个发明。作为新墨西哥大学T49的<em class="mj">数学T43和T44计算机科学T45的教授，他很快发现Fortran</em>对学生来说在语法上是多么沉重和困难。于是他在1984年创造了<em class="mj">MATLAB</em>(Matrix Laboratory的缩写)，剩下的就是历史了。</p><p id="8b74" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">如何用Python导入MATLAB文件… </strong></p><p id="bd4b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><em class="mj"> MATLAB </em>文件的扩展名为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">.mat</em></strong></code>，我们从<em class="mj">阿尔贝克实验室</em>的<em class="mj">加州大学戴维斯分校</em>导入一个<em class="mj"> MATLAB </em>文件。它包含基因表达数据。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="a0c4" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们将使用<em class="mj">Python</em><a class="ae ld" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg jd"><em class="mj">scipy</em></strong></a>库来读取<em class="mj"> MATLAB </em>文件。因此，我们通过<em class="mj"> wget </em>下载`<code class="fe oq or os ot b">'<strong class="lg jd"><em class="mj">ja_data2.mat</em></strong>'</code>`文件，然后使用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">scipy.io.loadmat()</em></strong></code> <strong class="lg jd"> <em class="mj"> </em> </strong>函数将其加载到一个名为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">mat</em></strong></code>的变量中。</p><blockquote class="mk"><p id="d419" class="ml mm it bd mn mo mp mq mr ms mt lz dk translated">你猜怎么着…这个变量mat，只是一个Python字典。所以再一次，我们能看到字典有多强大吗？</p></blockquote><p id="5166" class="pw-post-body-paragraph le lf it lg b lh mv kd lj lk mw kg lm ln mx lp lq lr my lt lu lv mz lx ly lz im bi translated">我们有了另一个嵌套字典的树状数据结构，就像我们对<code class="fe oq or os ot b"><strong class="lg jd">HDF5</strong></code>文件所做的那样。</p><p id="4690" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们探索一下<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">mat</em></strong></code> <strong class="lg jd"> </strong>对象，从它的关键点开始。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="2821" class="ph nb it ot b gy pi pj l pk pl"># It's a dictionary so let's see the keys </span><span id="824d" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">for key in mat.keys():<br/>    print(key)</strong></span><span id="3c01" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">&gt;&gt;</strong><br/><strong class="ot jd"><em class="mj">__header__ <br/>__version__ <br/>__globals__ <br/>rfpCyt <br/>rfpNuc <br/>cfpNuc <br/>cfpCyt <br/>yfpNuc <br/>yfpCyt <br/>CYratioCyt</em></strong></span></pre><p id="9a57" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><em class="mj"> ( </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">CYratioCyt</em></strong></code> <em class="mj"> ) </em>上面最后一个键，看看它有什么价值…</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="3c18" class="ph nb it ot b gy pi pj l pk pl"># Let's see what type of object the CyratioCyt object is</span><span id="0a93" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">print(type(mat['CYratioCyt']))<br/>&gt;&gt;<br/>&lt;class 'numpy.ndarray'&gt;</strong></span></pre><p id="4168" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">它包含一个<em class="mj"> numpy </em>数组。太棒了！所以我们可以检查它的形状，甚至用它制作一个数据框，像平常一样探索。让我们这样做吧…</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="f423" class="ph nb it ot b gy pi pj l pk pl"># Since it's a numpy array, lets see its shape</span><span id="28fc" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">print(mat['CYratioCyt'].shape)<br/>&gt;&gt;<br/><em class="mj">(200, 137)</em></strong></span><span id="6770" class="ph nb it ot b gy pm pj l pk pl"># Next, let's make a Data Frame out of it.</span><span id="0249" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">import pandas as pd<br/>Cy_df = pd.DataFrame(mat['CYratioCyt'])</strong></span><span id="395f" class="ph nb it ot b gy pm pj l pk pl"># Let's see the first five rows<br/><strong class="ot jd">Cy_df.head()<br/>&gt;&gt;</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi qh"><img src="../Images/54ba025d6ff745763313fb53279bd013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-lUYFIWhE00DwnjjnltxQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Cy_df数据帧的头…</figcaption></figure><p id="ef2e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">最后，让我们子集化<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">Cy_df </em></strong></code>并绘制第25行的第5列到最后一列。</p><pre class="ks kt ku kv gt pd ot pe pf aw pg bi"><span id="54ab" class="ph nb it ot b gy pi pj l pk pl"><strong class="ot jd">data = mat['CYratioCyt'][25, 5:]</strong></span><span id="6e2a" class="ph nb it ot b gy pm pj l pk pl"><strong class="ot jd">fig = plt.figure()<br/>plt.plot(data)<br/>plt.xlabel('time (min.)')<br/>plt.ylabel('normalized fluorescence (measure of expression)')<br/>plt.show()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/fba2474196333ca373abfa554b19fc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bC7bHv3M9TwqvppthKCQeA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">CyratioCyt数据子集的图。</figcaption></figure><h1 id="f6ca" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从Pickle文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi po"><img src="../Images/0ae2bb66dd799af83fd2d145c466e10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLyIPTyBnHmWPSGLh65PHA.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://data-flair.training/blogs/wp-content/uploads/sites/2/2018/03/Serialization-in-Python-01.jpg" rel="noopener ugc nofollow" target="_blank"> img_credit </a></figcaption></figure><h2 id="3ba0" class="ph nb it bd nc ps pt dn ng pu pv dp nk ln pw px nm lr py pz no lv qa qb nq iz bi translated">那么什么是腌制呢？</h2><blockquote class="mk"><p id="6835" class="ml mm it bd mn mo mp mq mr ms mt lz dk translated"><a class="ae ld" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> <em class="mu">【酸洗】</em> </a>是将Python对象层次转换成字节流的过程，<em class="mu">【解酸洗】</em>是逆操作，将字节流(来自<a class="ae ld" href="https://docs.python.org/3/glossary.html#term-binary-file" rel="noopener ugc nofollow" target="_blank">二进制文件</a>或<a class="ae ld" href="https://docs.python.org/3/glossary.html#term-bytes-like-object" rel="noopener ugc nofollow" target="_blank">类字节对象</a>)转换回对象层次。</p></blockquote><p id="39db" class="pw-post-body-paragraph le lf it lg b lh mv kd lj lk mw kg lm ln mx lp lq lr my lt lu lv mz lx ly lz im bi translated">在某些编程语言中，它被称为<strong class="lg jd"> <em class="mj">串行化</em> </strong>、<strong class="lg jd"> <em class="mj">编组</em> </strong>或<strong class="lg jd"> <em class="mj">扁平化</em> </strong>。但是在<em class="mj"> Python </em>中，我们称之为<em class="mj">酸洗</em>。</p><p id="21b8" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们可以保存<em class="mj"> Python列表</em>、<em class="mj">字典</em>、<em class="mj">训练过的机器学习</em>模型，甚至数据集，以及几乎所有<em class="mj"> Python </em>对象到<em class="mj"> pickle </em>。</p><p id="130c" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">例如，处理<em class="mj">非常大的数据集很有意义，而不是每次运行分析时都将它们加载到内存中。酸洗速度更快，内存效率更高。速度快50到1000倍。有时候远的多，看大小……<a class="ae ld" href="https://pythonprogramming.net/python-pickle-module-save-objects-serialization/" rel="noopener ugc nofollow" target="_blank"><strong class="lg jd"><em class="mj">链接</em> </strong> </a></em></p><p id="2d45" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">那么我们如何用Python加载Pickle文件……</strong></p><ol class=""><li id="18cc" class="ns nt it lg b lh li lk ll ln on lr oo lv op lz nz oa ob oc bi translated">先来看一下<strong class="lg jd"><em class="mj"/></strong><em class="mj"/><a class="ae ld" href="http://moviedataset.zip https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/ML0101ENv3/labs/moviedataset.zip" rel="noopener ugc nofollow" target="_blank"><em class="mj">ratings . CSV</em></a>dataset来自<strong class="lg jd"/><a class="ae ld" href="https://grouplens.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg jd"><em class="mj">group lens</em></strong></a><strong class="lg jd"><em class="mj">。</em> </strong>这个数据集有超过2200万行的电影分级数据。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8b7e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">从上面的Git-gist，我们通过<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">wget</em></strong></code>下载了<code class="fe oq or os ot b"><strong class="lg jd"> <em class="mj">ratings.csv</em></strong></code>文件。然后我们创建了一个名为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.pickle</em></strong></code>的pickle字节流占位符对象。最后，我们将<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.csv</em></strong></code>文件转储到<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.pickle</em></strong></code> <em class="mj"> </em>对象中，使用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">pickle.dump()</em></strong></code> <strong class="lg jd"> <em class="mj"> </em> </strong>函数，然后我们关闭连接。</p><p id="8916" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在，我们可以看到保存在工作区中的<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.pickle</em></strong></code>文件。</p><p id="eff6" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">2.接下来，让我们<strong class="lg jd"> <em class="mj">取消拾取</em> </strong>对象并将其加载到熊猫数据框中…</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="9791" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以，在这里，我们把<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.pickle</em></strong></code>二进制文件读作<strong class="lg jd"> <em class="mj"> f </em> </strong>。然后我们使用<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">pickle.load()</em></strong></code>函数对<strong class="lg jd"><em class="mj"/></strong>进行拆包，并将<strong class="lg jd"><em class="mj"/></strong>加载到一个名为<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings_data</em></strong></code> <em class="mj">的变量中，</em><em class="mj"/><strong class="lg jd"><em class="mj">f</em></strong><em class="mj"/>被转换回拆包后的<em class="mj"> ratings.csv </em>文件<em class="mj">。</em></p><blockquote class="mk"><p id="ed9e" class="ml mm it bd mn mo mp mq mr ms mt lz dk translated">因此，我们基本上已经将ratings.csv文件提取为ratings.pickle对象，并将ratings.pickle对象提取回ratings.csv文件，保存为变量ratings_data。</p></blockquote><figure class="qj qk ql qm qn kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi qi"><img src="../Images/28335cbd881367df1366326f42b68f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiHGm7tLy66z8_qjxFW-xQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">pickle_df数据帧的前五行</figcaption></figure><p id="6594" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">腌制的真正魔力……</strong></p><p id="942a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们仔细看看我们做的<em class="mj">腌制</em>练习。让我们比较一下<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.csv</em></strong></code>文件和<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.pickle</em></strong></code>文件的大小。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="b07f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">令人惊讶的是，<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.pickle</em></strong></code>只有<strong class="lg jd"> 21字节</strong>的数据，而<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.csv</em></strong></code>却有超过<strong class="lg jd">6.2亿字节</strong>的数据。简直太神奇了！通过将数据集应用于<em class="mj"> pickle </em>，我们将其缩小了超过<strong class="lg jd"><em class="mj">2950万倍于其原始大小</em> </strong>。</p><blockquote class="qo qp qq"><p id="3e36" class="le lf mj lg b lh li kd lj lk ll kg lm qr lo lp lq qs ls lt lu qt lw lx ly lz im bi translated">请注意，除了<code class="fe oq or os ot b"><strong class="lg jd"><em class="it">.pickle</em></strong></code>之外，pickle文件还有扩展名<code class="fe oq or os ot b"><strong class="lg jd"><em class="it">.pkl</em></strong></code>。前者在python 2中很常见。参见<a class="ae ld" href="https://stackoverflow.com/questions/40433474/preferred-or-most-common-file-extension-for-a-python-pickle" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd"> <em class="it">链接</em> </strong> </a></p></blockquote><h1 id="d275" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">从拼花文件导入数据:</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi qu"><img src="../Images/8ce7a16806b746f7037c262e7eda9d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ampH-dmF2cuSUPomo7DdfQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.slideshare.net%2Fmegrhihaikel%2Fapache-parquet&amp;psig=AOvVaw07eMhr2ydinOu5wK9IE7--&amp;ust=1591618396258000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCJifr-XW7-kCFQAAAAAdAAAAABAW" rel="noopener ugc nofollow" target="_blank"> img_credit </a></figcaption></figure><p id="e021" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="http://parquet.apache.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg jd"><em class="mj">Apache Parquet</em></strong></a>项目提供了一种标准化的开源列存储格式，用于数据分析系统。它最初是为在<a class="ae ld" href="http://hadoop.apache.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg jd"><em class="mj">Apache Hadoop</em></strong></a>中使用而创建的。</p><p id="b69d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> <em class="mj">拼花</em> </strong>文件里写满了大数据处理。事实上，我第一次使用它是在<strong class="lg jd"> <em class="mj"> Pyspark </em> </strong>的一个项目中。</p><p id="602a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">那么为什么要用<em class="mj">拼花</em>文件呢？</strong></p><p id="31a8" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">基本上，<strong class="lg jd"> <em class="mj"> Parquet </em> </strong>是一种列文件格式，而<em class="mj"> CSV </em>是基于行的。对于大多数分析查询，列式文件格式更有效。您可以通过转换CSV文件和处理<em class="mj"> Parquet </em>文件来加速许多数据帧查询。另外，<em class="mj">拼花</em>文件比<em class="mj"> CSV </em>文件更节省内存。</p><p id="d605" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">好，让我们从我们一直使用的<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.csv</em></strong></code>文件创建一个<em class="mj">拼花</em>文件对象。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="d422" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">熊猫来救援了！我们定义了一个简单的方法，它接受一个文件名(一个字符串)并创建一个数据帧<em class="mj">(</em><strong class="lg jd"><em class="mj">df</em></strong><em class="mj">)</em>，我们使用<em class="mj"> Pandas </em>的<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">df.to_parquet()</em></strong></code>函数将它转换成一个<em class="mj"> Parquet </em>文件。该方法将一个<em class="mj">拼花</em>文件保存到当前工作目录。</p><p id="aa05" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">所以我们将<code class="fe oq or os ot b"><strong class="lg jd">‘<em class="mj">ratings.csv’</em></strong></code>文件传递给方法，并创建了<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.parquet</em></strong></code>。</p><p id="066a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">接下来，我们比较了<code class="fe oq or os ot b"><strong class="lg jd"> <em class="mj">ratings.parquet</em></strong></code>和<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.csv</em></strong></code> <em class="mj"> </em>的大小，正如所料，<em class="mj"> </em> <code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.csv</em></strong></code> <em class="mj"> </em>的大小是<code class="fe oq or os ot b"><strong class="lg jd"><em class="mj">ratings.parquet</em></strong></code> <em class="mj">的四倍多。</em></p><p id="328b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">在Pandas中加载拼花文件… </strong></p><p id="a700" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">最后，我们简单地将<code class="fe oq or os ot b"><strong class="lg jd">‘<em class="mj">ratings.parquet’</em></strong> </code>作为参数传递给<code class="fe oq or os ot b"><strong class="lg jd">pd.read_parquet()</strong></code>函数。这将创建一个DataFrame对象。请注意，这个函数有自己的一组参数，我们可以自定义这些参数。发现于<a class="ae ld" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_parquet.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">熊猫</strong> </a>。</p><p id="1a9d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe oq or os ot b"><strong class="lg jd">parquet_df = pd.read_parquet(‘/content/ratings.parquet’)</strong></code></p><p id="4206" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe oq or os ot b"><strong class="lg jd">parquet_df.head()</strong></code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oj ok di ol bf om"><div class="gh gi qv"><img src="../Images/dc60c8ae147b3cafa35d7a3b8ab8c945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuqUq5awqxjEF30T8m6MSw.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">parquet_df数据帧的头。</figcaption></figure><h1 id="78b1" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">总结:</h1><p id="311f" class="pw-post-body-paragraph le lf it lg b lh nu kd lj lk nv kg lm ln qc lp lq lr qd lt lu lv qe lx ly lz im bi translated">这是一篇非常详细的文章，有些概念可能相对较新。最好把这个保存在你的阅读清单里，以备将来参考。</p><p id="7069" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们已经看到了如何从各种格式读取数据，如<strong class="lg jd"> <em class="mj">、MATLAB </em> </strong>、<strong class="lg jd"> <em class="mj"> SAS </em> </strong>、<strong class="lg jd"> <em class="mj"> Stata </em> </strong>、<strong class="lg jd"> <em class="mj"> Pickle、Parquet、Excel、HDF5和NumPy </em> </strong>。我们已经探索了来自<strong class="lg jd"> <em class="mj"> pandas、scipy </em> </strong>和<strong class="lg jd"> <em class="mj"> Python </em> </strong>模块的各种函数，最重要的是，我很高兴我已经能够展示作为<strong class="lg jd"> <em class="mj">数据专业人员</em> </strong>，我们可以处理几乎所有类型的数据文件。</p><p id="2748" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">见本文<a class="ae ld" href="https://github.com/Lawrence-Krukrubo/Effective_Python" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd"> <em class="mj">这里</em> </strong> </a>包含笔记本的Git-Repo。它还包含一个关于在python中使用关系数据库的教程。</p><p id="4523" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">最后，请随意查看来自<code class="fe oq or os ot b"><strong class="lg jd">Datacamp</strong></code>的课程“<a class="ae ld" href="https://learn.datacamp.com/courses/introduction-to-importing-data-in-python" rel="noopener ugc nofollow" target="_blank">python</a>导入数据简介”。</p><p id="fadd" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">干杯！</strong></p><h2 id="4d3e" class="ph nb it bd nc ps pt dn ng pu pv dp nk ln pw px nm lr py pz no lv qa qb nq iz bi translated">关于我:</h2><p id="2a6d" class="pw-post-body-paragraph le lf it lg b lh nu kd lj lk nv kg lm ln qc lp lq lr qd lt lu lv qe lx ly lz im bi translated">劳伦斯是技术层的数据专家，对公平和可解释的人工智能和数据科学充满热情。我持有IBM的 <strong class="lg jd"> <em class="mj">数据科学专业</em> </strong> <em class="mj">和</em> <strong class="lg jd"> <em class="mj">高级数据科学专业</em> </strong> <em class="mj">证书。我已经使用ML和DL库进行了几个项目，我喜欢尽可能多地编写函数代码，即使现有的库比比皆是。最后，我从未停止学习和实验，是的，我拥有几个数据科学和人工智能认证，并且我已经写了几篇强烈推荐的文章。</em></p><p id="2aed" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">请随时在以下网址找到我</p><p id="31dd" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://github.com/Lawrence-Krukrubo" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd"> Github </strong> </a></p><p id="f239" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://www.linkedin.com/in/lawrencekrukrubo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">领英</strong> </a></p><p id="4257" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://twitter.com/LKrukrubo" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">推特</strong> </a></p></div></div>    
</body>
</html>