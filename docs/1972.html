<html>
<head>
<title>Image Segmentation with K-means and Watershed Algorithm with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K-means的图像分割和基于Python的分水岭算法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/image-segmentation-with-k-means-and-watershed-algorithm-with-python-5a051287ec07?source=collection_archive---------0-----------------------#2021-07-09">https://pub.towardsai.net/image-segmentation-with-k-means-and-watershed-algorithm-with-python-5a051287ec07?source=collection_archive---------0-----------------------#2021-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0946" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/artificial-intelligence" rel="noopener ugc nofollow" target="_blank">人工智能</a></h2><div class=""/><div class=""><h2 id="bc9a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">图像处理中的对象分割</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0b9a6773211a6cc7d26502317835e86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mazjRKEbSOTNYwRp"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@dariuszsankowski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达留什·桑科夫斯基</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="2606" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">图像分割</strong></h2><p id="bd31" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">在图像处理和计算机视觉领域，图像分割是将图像分割成多个片段(也称为图像对象)的过程。分割图像的主要目标是在单独分析分割的片段后提取有意义的信息，如定位对象和创建图像的边界。</p><p id="dcdf" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">由于图像是一组像素，在图像分割中，具有相似属性/特性的像素被分组以形成段，然后人们可以根据需要执行操作。</p><h2 id="6648" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">应用</strong></h2><ol class=""><li id="1ca2" class="nb nc it mf b mg mh mj mk lr nd lv ne lz nf mv ng nh ni nj bi translated">没有涉及分割概念的物体检测，自动驾驶是不可能的。</li><li id="497d" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">用于医疗保健行业，有助于相应地分割癌细胞和肿瘤以及其他疾病的严重程度。</li><li id="6cbf" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">解决商业问题。</li></ol><h2 id="da21" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">聚类算法</strong></h2><p id="fc87" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">聚类算法是无监督的机器学习算法，这意味着没有可用的标记数据。</p><p id="83a6" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">换句话说，我们可以说我们没有预定义的一组特性、类或组。聚类算法帮助我们从数据/图像中获取隐藏的信息，比如我们的数据具有什么样的结构、聚类和分组。</p><p id="a12b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">聚类算法帮助我们将图像分割成具有相似属性的像素簇或组。基于这些聚类属性，数据元素/点被分成聚类，使得同一个聚类中的元素与其他聚类元素相比彼此更相似。</p><p id="04f3" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">聚类算法如k-means、改进的k-means、模糊c-means和改进的模糊c-means算法正被广泛应用于聚类中。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><blockquote class="nw nx ny"><p id="0844" class="md me nz mf b mg mw kd mi mj mx kg ml oa my mn mo ob mz mq mr oc na mt mu mv im bi translated"><strong class="mf jd"> <em class="it"> K-means聚类</em> </strong></p></blockquote><p id="95ba" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">K-means聚类是最常用的聚类算法。在k-means聚类中，<strong class="mf jd"> k </strong>表示聚类的个数。</p><h2 id="0ebf" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak"> K-means聚类工作步骤</strong></h2><ol class=""><li id="1e2d" class="nb nc it mf b mg mh mj mk lr nd lv ne lz nf mv ng nh ni nj bi translated">你想要找到多少个集群，用k表示。</li><li id="9805" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">将数据点随机分配给k个聚类中的任何一个。</li><li id="9ac4" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">找出集群的中心。</li><li id="9fdf" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">找出数据点与每个聚类中心的距离，即计算欧几里德距离。</li><li id="96ec" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">根据每个数据点离聚类的距离，再次将数据点分配给最近的聚类。</li><li id="3ae6" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">再次找出新的聚类中心。</li><li id="2fe7" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv ng nh ni nj bi translated">重复步骤4、5和6，直到数据点不改变聚类或达到指定的数目。</li></ol><h2 id="a6d2" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">聚类的应用</strong></h2><ul class=""><li id="ac49" class="nb nc it mf b mg mh mj mk lr nd lv ne lz nf mv od nh ni nj bi translated">在市场调查中</li><li id="e299" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">数据分析</li><li id="ba93" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">模式识别</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="bf5d" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">聚类代码</strong></h2><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="d11a" class="li lj it of b gy oj ok l ol om">from skimage.io import imread<br/>from skimage.color import rgb2gray</span><span id="5b75" class="li lj it of b gy on ok l ol om">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="4fce" class="li lj it of b gy on ok l ol om">%matplotlib inline</span><span id="5dd6" class="li lj it of b gy on ok l ol om">from scipy import ndimage<br/>from sklearn.datasets import load_sample_image</span><span id="c71f" class="li lj it of b gy on ok l ol om">china = load_sample_image(“china.jpg”)</span><span id="8f16" class="li lj it of b gy on ok l ol om">ax = plt.axes(xticks=[], yticks=[])<br/>ax.imshow(china);</span></pre><p id="eada" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#图像存储在一个3d数组中，其大小为高度、宽度、RGB，并包含从0到255的整数形式的RGB成分:</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="7ebf" class="li lj it of b gy oj ok l ol om">china.shape</span><span id="0a28" class="li lj it of b gy on ok l ol om">#output:<br/>(427, 640, 3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e41343e2f69f7ffbc1ae9ccb363f4b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*FISfc_lRa8xGV8eoscKalQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="aece" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#查看这组像素的一种方法是将其视为三维颜色空间中的点云。我们将数据整形为[n_samples x n_features]，并重新调整颜色，使其介于0和1之间。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="7821" class="li lj it of b gy oj ok l ol om">data = (china )/ 255.0</span><span id="d25a" class="li lj it of b gy on ok l ol om">data = data.reshape(427 * 640, 3)</span><span id="21ae" class="li lj it of b gy on ok l ol om">data.shape</span><span id="3ab3" class="li lj it of b gy on ok l ol om">#output:<br/>(273280, 3)</span></pre><p id="c6cd" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#我们可以在这个颜色空间中可视化这些像素，使用10，000个像素的子集来提高效率:</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="4847" class="li lj it of b gy oj ok l ol om">def plot_pixels(data, title, colors=None, N=10000):<br/>    if colors is None:<br/>    colors = data<br/>    <br/>    # choose a random subset<br/>    rng = np.random.RandomState(0)<br/>    i = rng.permutation(data.shape[0])[:N]</span><span id="3bc9" class="li lj it of b gy on ok l ol om">    colors = colors[i]<br/>    R, G, B = data[i].T</span><span id="2ba0" class="li lj it of b gy on ok l ol om">    fig, ax = plt.subplots(1, 2, figsize=(16, 6))</span><span id="8c7b" class="li lj it of b gy on ok l ol om">    ax[0].scatter(R, G, color=colors, marker=’.’)<br/>    ax[0].set(xlabel=’Red’,ylabel=’Green’,xlim=(0, 1),ylim=(0, 1))<br/>    ax[1].scatter(R, B, color=colors, marker=’.’)<br/>    ax[1].set(xlabel=’Red’, ylabel=’Blue’, xlim=(0, 1), ylim=(0, 1))</span><span id="f3d2" class="li lj it of b gy on ok l ol om">    fig.suptitle(title, size=20);</span><span id="f10e" class="li lj it of b gy on ok l ol om">plot_pixels(data, title=’Input color space: 16 million possible colors’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/63849787d417a491c67330c7b4665a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*8Itu8Ak000kKERKV4uDMbQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="4850" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#现在，我们将这1600万种颜色减少到只有16种颜色，使用跨像素空间的k-means聚类，因为我们正在处理一个非常大的数据集，并使用小批量k-means，当对数据子集进行操作时，它比标准k-means给出更快的结果。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="7a24" class="li lj it of b gy oj ok l ol om">import warnings; warnings.simplefilter(‘ignore’) # Fix NumPy issues.</span><span id="339c" class="li lj it of b gy on ok l ol om">from sklearn.cluster import MiniBatchKMeans</span><span id="91d4" class="li lj it of b gy on ok l ol om">kmeans = MiniBatchKMeans(16)</span><span id="7933" class="li lj it of b gy on ok l ol om">kmeans.fit(data)</span><span id="f839" class="li lj it of b gy on ok l ol om">new_colors = kmeans.cluster_centers_[kmeans.predict(data)]</span><span id="51e2" class="li lj it of b gy on ok l ol om">plot_pixels(data, colors=new_colors,title=”Reduced color space: 16<br/>                                                           colors”)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a5bcaeb6f4413f7c2256429380db8f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*EXt_ZQp9Bzv9rervIdqpVA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="060b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#我们在这一步的结果是原始像素的重新着色，其中每个像素被分配了其最近的聚类中心的颜色。在图像空间中绘制这些新颜色向我们展示了这样的效果:</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="2945" class="li lj it of b gy oj ok l ol om">china_recolored = new_colors.reshape(china.shape)</span><span id="3a3a" class="li lj it of b gy on ok l ol om">fig, ax = plt.subplots(1, 2, figsize=(16, 6),<br/>                         subplot_kw=dict(xticks=[], yticks=[]))</span><span id="4779" class="li lj it of b gy on ok l ol om">fig.subplots_adjust(wspace=0.05)</span><span id="5a00" class="li lj it of b gy on ok l ol om">ax[0].imshow(china)<br/>ax[0].set_title(‘Original Image’, size=16)<br/>ax[1].imshow(china_recolored)<br/>ax[1].set_title(‘16-color Image’, size=16);</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/55d88571447c5fac8eefe93c5e38f5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*X1suyJeSDKm1MOjKDV7iUA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="991a" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#最右边的图像丢失了一点点细节，但整体图像仍然很容易辨认。右侧图像实现了大约一百万的压缩因子，虽然这是k-means的一个有趣的应用，但肯定有更好的方法来压缩图像中的信息。但是我们的例子显示了用k-means这样的无监督技术跳出框框思考。</p><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/pre-processing-techniques-in-image-processing-with-python-81e5c8babf09"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd jd gy z fp pa fr fs pb fu fw jc bi translated">Python图像处理中的预处理技术</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">OpenCV下的图像处理技术</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">pub.towardsai.net</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj lb ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/part-ii-pre-processing-techniques-in-image-processing-with-python-17fb628453ff"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd jd gy z fp pa fr fs pb fu fw jc bi translated">第二部分Python图像处理中的预处理技术</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">OpenCV下的图像处理技术</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">pub.towardsai.net</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj lb ov"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><blockquote class="nw nx ny"><p id="3239" class="md me nz mf b mg mw kd mi mj mx kg ml oa my mn mo ob mz mq mr oc na mt mu mv im bi translated"><strong class="mf jd"> <em class="it">分水岭分割</em> </strong></p></blockquote><p id="3861" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">分水岭是用于分割的主要算法，用于分离图像中相似/不同的对象。它从用户定义的标记开始，分水岭算法将像素值视为局部地形或高程。</p><p id="437c" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">图像处理中的分水岭是在灰度图像上定义的变换。在地形的帮助下，它处理代表其高度的每个点的亮度，并找到沿山脊顶部延伸的线条。</p><h2 id="92f9" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">一些应用分水岭分割</strong></h2><ul class=""><li id="04c4" class="nb nc it mf b mg mh mj mk lr nd lv ne lz nf mv od nh ni nj bi translated">机器学习视觉。</li><li id="1add" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">交通控制系统</li><li id="386b" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">基于内容的图像检索。</li><li id="1286" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">目标检测</li><li id="fd53" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">医学成像</li><li id="3e65" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">识别任务</li></ul><h2 id="f1d6" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">分水岭分割的工作是一个两步过程</strong></h2><ul class=""><li id="8de6" class="nb nc it mf b mg mh mj mk lr nd lv ne lz nf mv od nh ni nj bi translated">首先找出标记，然后用分割准则分割区域。</li><li id="c2ce" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated">执行标记控制的分水岭</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="9fcd" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">代码</strong></h2><p id="b60b" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">#在这段代码的帮助下，我们将能够看到如何从背景中分割对象。我们使用硬币的图像，它显示了来自skimage.data的许多硬币轮廓和较暗的背景。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="2bd0" class="li lj it of b gy oj ok l ol om">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="3e53" class="li lj it of b gy on ok l ol om">from skimage import data</span><span id="035d" class="li lj it of b gy on ok l ol om">coins = data.coins()<br/>hist = np.histogram(coins, bins=np.arange(0, 256))<br/>fig, (ax1) = plt.subplots()<br/>ax1.imshow(coins, cmap=plt.cm.gray, interpolation=’nearest’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/a4e6b144fdf550f3ceec29c3719ef161.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*47eSeb86RYRVMg8h9S9fQg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图像<a class="ae lh" href="https://scikit-image.org/docs/0.12.x/auto_examples/xx_applications/plot_coins_segmentation.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="ca31" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">#现在，我们可以借助灰度值直方图的极端部分找到背景和硬币的标记。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="2882" class="li lj it of b gy oj ok l ol om">markers = np.zeros_like(coins)<br/>markers[coins &lt; 30] = 1<br/>markers[coins &gt; 150] = 2</span><span id="f956" class="li lj it of b gy on ok l ol om">fig, ax = plt.subplots(figsize=(4, 3))<br/>ax.imshow(markers, cmap=plt.cm.gray, interpolation=’nearest’)<br/>ax.axis(‘off’)<br/>ax.set_title(‘markers’)</span></pre><p id="f07b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">在这里的代码中，我们使用np <strong class="mf jd">。</strong>返回给定类型和形状的新数组的零，</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="8a73" class="li lj it of b gy oj ok l ol om">#filled with zeros</span><span id="76d9" class="li lj it of b gy on ok l ol om">Text(0.5, 1.0, ‘markers’)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/832672802c81d2fa92dbc20699498036.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*PJ5ROW2acLDsuRz9Pz-dFw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片<a class="ae lh" href="https://scikit-image.org/docs/0.12.x/auto_examples/xx_applications/plot_coins_segmentation.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="95f5" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">在这一步，我们使用分水岭变换来填充高程图的区域。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="6c1a" class="li lj it of b gy oj ok l ol om">segmentation = morphology.watershed(elevation_map, markers)</span><span id="685d" class="li lj it of b gy on ok l ol om">fig, ax = plt.subplots(figsize=(4, 3))<br/>ax.imshow(segmentation, cmap=plt.cm.gray, interpolation=’nearest’)<br/>ax.axis(‘off’)<br/>ax.set_title(‘segmentation’)</span></pre><p id="0e44" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">这里我们使用形态学，这是一种基于图像形状处理图像的图像处理操作。这些操作将结构化元素应用于输入图像，并且生成相同大小的输出图像。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/4019623569b4926d17b5ec52aed188cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*6v4bEYirp5Qw1_IHrbo2IA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图像<a class="ae lh" href="https://scikit-image.org/docs/0.12.x/auto_examples/xx_applications/plot_coins_segmentation.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="e46c" class="li lj it of b gy oj ok l ol om">from skimage.color import label2rgb</span><span id="d5f8" class="li lj it of b gy on ok l ol om">segmentation = ndi.binary_fill_holes(segmentation — 1)<br/>labeled_coins, _ = ndi.label(segmentation)</span><span id="393f" class="li lj it of b gy on ok l ol om">image_label_overlay = label2rgb(labeled_coins, image=coins)</span><span id="c882" class="li lj it of b gy on ok l ol om">fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3), sharex=True, sharey=True)</span><span id="cde1" class="li lj it of b gy on ok l ol om">ax1.imshow(coins, cmap=plt.cm.gray, interpolation=’nearest’)<br/>ax1.contour(segmentation, [0.5], linewidths=1.2, colors=’y’)<br/>ax1.axis(‘off’)<br/>ax1.set_adjustable(‘box’)<br/>ax2.imshow(image_label_overlay, interpolation=’nearest’)<br/>ax2.axis(‘off’)<br/>ax2.set_adjustable(‘box’)<br/>fig.subplots_adjust(**margins)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/81441b42eb4936e4583d0dd45df777d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*rvyRicCBUjruX97XMt3I3w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片<a class="ae lh" href="https://scikit-image.org/docs/0.12.x/auto_examples/xx_applications/plot_coins_segmentation.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="f18d" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">结论</strong></h2><p id="0cbc" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">本文介绍了两种重要的分割技术，基于聚类的分割技术和基于分水岭的分割技术。</p><p id="7c6f" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">我希望你喜欢这篇文章。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="f40b" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h2 id="0ecd" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">推荐文章</h2><ul class=""><li id="f037" class="nb nc it mf b mg mh mj mk lr nd lv ne lz nf mv od nh ni nj bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> NLP —用Python从零到英雄</a></li><li id="88fd" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a></li><li id="7051" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a></li><li id="7539" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/deep-learning-88e218b74a14?source=friends_link&amp;sk=540bf9088d31859d50dbddab7524ba35">为什么LSTM在深度学习方面比RNN更有用？</a></li><li id="c49f" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/neural-networks-the-rise-of-recurrent-neural-networks-df740252da88?source=friends_link&amp;sk=6844935e3de14e478ce00f0b22e419eb">神经网络:递归神经网络的兴起</a></li><li id="2f21" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python全面讲解线性回归</a></li><li id="ac84" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python全面讲解逻辑回归</a></li><li id="0d2f" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">Python中concat()、merge()和join()的区别</a></li><li id="2783" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据争论—第1部分</a></li><li id="206f" class="nb nc it mf b mg nk mj nl lr nm lv nn lz no mv od nh ni nj bi translated"><a class="ae lh" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></li></ul></div></div>    
</body>
</html>