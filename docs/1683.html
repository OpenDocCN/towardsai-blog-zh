<html>
<head>
<title>Machine Learning With Azure’s Free Tier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure免费层的机器学习</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/machine-learning-with-azures-free-tier-d85071545c07?source=collection_archive---------3-----------------------#2021-03-18">https://pub.towardsai.net/machine-learning-with-azures-free-tier-d85071545c07?source=collection_archive---------3-----------------------#2021-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b957" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/cloud-computing" rel="noopener ugc nofollow" target="_blank">云计算</a></h2><div class=""/><div class=""><h2 id="b5bc" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">我如何继续不再依赖我的CPU而使用云—达到Azure的免费层限制。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f5f2f2a5905ebaf4c423224e19aea6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DB-_RTbsJtfifTwP"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@analoglugunler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">恰拉尔·奥斯卡伊</a>拍摄的照片</figcaption></figure><p id="e69d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在用完我的免费<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/machine-learning-in-the-cloud-using-azure-ml-studio-5948b1347bc6?gi=8ea349035e46"> Udacity Nanodegree的</a>许可访问后，我注册了Azure的免费订阅。免费层为运行机器学习模型的计算机提供30天或200美元的免费积分，以先到者为准。我首先花了这些时间来总结我之前关于时间序列预测的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/time-series-forecasting-building-and-deploying-models-continued-deee0588b28c">工作</a>，其次是SECOM数据集，遵循第11章【微软Azure机器学习预测分析】第二版。</p><p id="4442" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这篇文章讲述了这些经历。原代码在这个GitHub<a class="ae le" href="https://github.com/Ranga2904/AzureML_TS_SECOM" rel="noopener ugc nofollow" target="_blank">repo</a>T14】里。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="aa8a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">SECOM数据集</h1><p id="4192" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">本书第226页的例子考虑了半导体制造过程中的数据。监控各种信号以预测最终产品是失败(标记为1)还是通过(标记为-1)。</p><h2 id="030a" class="nf mj iq bd mk ng nh dn mo ni nj dp ms lo nk nl mu ls nm nn mw lw no np my iw bi translated">我电脑上的Jupyter笔记本</h2><p id="ce46" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">我将特性和标签导入到Python中，然后在观察到包含不到1%的条目后，删除了包含空值的行。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="5b00" class="nf mj iq nr b gy nv nw l nx ny"># Features</span><span id="02c4" class="nf mj iq nr b gy nz nw l nx ny">data = pd.read_csv('secom.data',sep=' ',header=None)<br/>data.isna().sum()<br/>data.fillna(data.mean(),inplace=True)</span><span id="fb49" class="nf mj iq nr b gy nz nw l nx ny"># Labels / target</span><span id="f26f" class="nf mj iq nr b gy nz nw l nx ny">labels = pd.read_csv('secom_labels.data',sep=' ',header=None)<br/>labels.columns = ['Class','Time']<br/>target = labels['Class']</span></pre><p id="1d26" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于TPOT AutoML包结合了方便的预处理和算法选择，我用pip安装了这个包，并用它来拟合给定的数据和标签，使用7-cross验证</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="92d3" class="nf mj iq nr b gy nv nw l nx ny">%pip install tpot<br/>from tpot import TPOTClassifier</span><span id="7082" class="nf mj iq nr b gy nz nw l nx ny">from sklearn.model_selection import StratifiedKFold<br/>cv = StratifiedKFold(n_splits=7,shuffle=True)</span><span id="8820" class="nf mj iq nr b gy nz nw l nx ny">model = TPOTClassifier(generations=5, population_size=50, cv=cv, scoring='f1_weighted',verbosity=2, random_state=1, n_jobs=-1)<br/># perform the search<br/>model.fit(data,target)<br/># export the best model<br/>model.export('tpot_secom_best.py')</span></pre><p id="f50c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TPOT产生了一系列分类器。在将数据和目标数据帧分成训练和测试之后，我训练了TPOT的管道，并评估了测试数据的性能。下面第二个框中的代码是TPOT的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/8fc56c63e0bd9c0b1030d1f175aa62a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53EkpRMIbRfNPdxPsUmlFw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图1: TPOT输出和性能</figcaption></figure><p id="3f4d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">F1分数0.11并不好，有趣的是加权F1分数是0.94。这告诉我们，在预测故障时有很大的改进空间，下面的混淆矩阵强化了这一结论。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/62650b9a8e7f9d09e4b84c0facea6069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*YKFeTSX0GD1k32KxjjnuBg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图2:混淆矩阵</figcaption></figure><p id="88d0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">令人失望的TPOT性能促使我尝试在XGBoost分类器上使用GridSearchCV进行超参数调优，以解决标签中的不平衡问题。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="5d84" class="nf mj iq nr b gy nv nw l nx ny">xgb_params = {'reg_alpha': [0.1,1,10], <br/>            'reg_lambda': [0.1,1,10],<br/>            'scale_pos_weight':[7,20,40]}</span><span id="affc" class="nf mj iq nr b gy nz nw l nx ny">cv = StratifiedKFold(n_splits=9,shuffle=True)</span><span id="1d2d" class="nf mj iq nr b gy nz nw l nx ny">gsXGB = GridSearchCV(xgb, xgb_params, cv = cv, scoring='f1', <br/>                     refit=True, n_jobs=5,return_train_score=True)<br/>gsXGB.fit(data,target)</span><span id="0234" class="nf mj iq nr b gy nz nw l nx ny">XGB_best = gsXGB.best_estimator_</span><span id="79eb" class="nf mj iq nr b gy nz nw l nx ny">gsXGB.best_score_</span></pre><p id="7683" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这导致了微小的进步——F1分数为0.21。基于下面的训练和测试分数，调整学习率进一步提供了更多的改进</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/8f8f3e5f63fb9991ca94126b5004e390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4O5BIbeGi3om3WAjHzDuA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图3:调整以减少过度拟合</figcaption></figure><p id="f73c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Azure ML和这个比怎么样？让我们按照书中第226页的例子</p><h2 id="3bb0" class="nf mj iq bd mk ng nh dn mo ni nj dp ms lo nk nl mu ls nm nn mw lw no np my iw bi translated">Azure设计师</h2><p id="3703" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">这本书使用Azure的机器学习工作区中的设计器来拖放数据集和模块。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f4c990297d34300fa3d23b2defb72896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*jyLW-ltWJylQbE9F5w205w.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图Azure ML中的设计器模块</figcaption></figure><p id="a7e9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这种用户友好的低代码体验很大程度上反映了我在电脑上使用Jupyter笔记本执行的工作流程:</p><ul class=""><li id="4de2" class="oe of iq lh b li lj ll lm lo og ls oh lw oi ma oj ok ol om bi translated">删除丢失的数据</li><li id="8742" class="oe of iq lh b li on ll oo lo op ls oq lw or ma oj ok ol om bi translated">选择最显著的特征，通过与目标标签的Pearson相关性进行测量。我尝试了40-50个功能</li><li id="63e3" class="oe of iq lh b li on ll oo lo op ls oq lw or ma oj ok ol om bi translated">分割数据，70%用于训练，其余用于测试</li><li id="0c18" class="oe of iq lh b li on ll oo lo op ls oq lw or ma oj ok ol om bi translated">使用训练数据训练增强树和支持向量机—回想一下，TPOT最终选择了随机森林分类器，它也是基于树的</li><li id="f183" class="oe of iq lh b li on ll oo lo op ls oq lw or ma oj ok ol om bi translated">运行超参数调整，并使用测试数据对最佳模型进行评分</li><li id="e9a8" class="oe of iq lh b li on ll oo lo op ls oq lw or ma oj ok ol om bi translated">使用选择的指标评估性能:我选择了F1分数，但Azure的默认分数似乎是加权分数而不是标准二进制分数。由于超参数设置的微小变化，最终性能略低于全代码体验。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/fc20b204c427a4a3079cd5aae196bb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmvU_ui8wxVXEpobPwdjKQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图5: F1得分</figcaption></figure><p id="ed80" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">关键要点:这个练习和书中的其他练习给了我一些机会，让我可以继续在Azure中尝试不同的工具，见下一篇时间序列预测。</p><p id="b5e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">令人沮丧的是，免费计算(仅CPU)的能力在免费层受到限制，并且任何计算在30天或花费200美元后都成为禁区。考虑到微软的巨大资源，持续期望一些边际CPU或GPU能力并不是不合理的。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="bb73" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">使用Azure ML笔记本进行时间序列预测</h1><p id="1885" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">我的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/time-series-forecasting-building-and-deploying-models-continued-deee0588b28c">上一篇关于时间序列预测的文章</a>的结论总结了各种方法的性能，包括ARIMA、H2O.ai AutoML和有/无特征提取的LSTM。以下是我对AzureML的AutoML预测的观察Azure ML的Jupyter笔记本中使用的代码在这个<a class="ae le" href="https://github.com/Ranga2904/AzureML_TS_SECOM" rel="noopener ugc nofollow" target="_blank"> repo </a>中。</p><p id="37e4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在将数据导入AzureML并进行必要的调整以获得可操作的数据框架之后(参见本文<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/time-series-forecasting-building-and-deploying-models-f647c2ec7567#45dd">的特性工程部分</a>，我将标签和特性结合起来，然后创建了一个时间序列数组。</p><p id="db98" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于UCI <a class="ae le" href="https://archive.ics.uci.edu/ml/datasets/Condition+monitoring+of+hydraulic+systems" rel="noopener ugc nofollow" target="_blank">存储库</a>中的原始问题没有陈述任何时间序列，所以我简单地使用pandas datetime创建了一个时间序列数组，该数组从2021年1月1日开始，并为每一行添加一秒。然后我把这个新专栏叫做《时代》。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="3a58" class="nf mj iq nr b gy nv nw l nx ny">import datetime<br/>base = datetime.datetime(2021, 1, 1)<br/>arr = np.array([base + datetime.timedelta(seconds=i) for i in range(132240)])</span><span id="27b5" class="nf mj iq nr b gy nz nw l nx ny">together['time'] = pd.Series(arr,index=together.index)</span></pre><p id="cb42" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如有用的微软<a class="ae le" href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-auto-train-forecast" rel="noopener ugc nofollow" target="_blank">文档</a>所概述的，Azure AutoML中的时间序列预测选项需要比传统ML多一点的工作。我首先通过识别前面创建的“time”列来设置预测参数，并设置一个随机选择的100秒的预测范围。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="e5db" class="nf mj iq nr b gy nv nw l nx ny">from azureml.automl.core.forecasting_parameters import ForecastingParameters<br/><br/>forecasting_parameters_hydraulic_accum = ForecastingParameters(time_column_name='time', <br/>                                               forecast_horizon=100)</span></pre><p id="fd5d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来的步骤是为目标变量配置实验，然后实际运行实验来观察性能。我完成了液压累积和泵泄漏的这些步骤；参见下面的例子。我正在建立目标指标、防止过度使用资源的超时、交叉验证的5倍，并选择不启用集成技术——回想起来有些东西需要更改。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="ff4b" class="nf mj iq nr b gy nv nw l nx ny">from azureml.train.automl import AutoMLConfig<br/><br/>automl_config_leak = AutoMLConfig(task='forecasting',                             primary_metric='normalized_mean_absolute_error',<br/>                             experiment_timeout_minutes=25,<br/>                             enable_early_stopping=True,<br/>                             training_data=together,<br/>                             label_column_name="pump_leak",<br/>                             n_cross_validations=5,<br/>                             enable_ensembling=False,<br/>                             verbosity=logging.INFO,<br/>                             forecasting_parameters=forecasting_parameters_hydraulic_accum)</span><span id="7f08" class="nf mj iq nr b gy nz nw l nx ny"># <em class="ot">Having set experiment parameters above, create workspace for running experiment.</em></span><span id="4f0d" class="nf mj iq nr b gy nz nw l nx ny">from azureml.core.experiment import Experiment<br/>from azureml.core import Workspace<br/><br/>ws = Workspace.from_config()<br/><br/># Choose a name for the experiment and specify the project folder.<br/>experiment_name = 'AutoTSForecasting_hyd'<br/>project_folder = './sample_projects/automl-classification'<br/><br/>experiment = Experiment(ws, experiment_name)</span><span id="7819" class="nf mj iq nr b gy nz nw l nx ny">from azureml.widgets import RunDetails<br/><br/>hydrun = experiment.submit(automl_config_hydraulic_accum, show_output=True)<br/>RunDetails(hydrun).show()<br/>hydrun.wait_for_completion(show_output=True)</span></pre><p id="a59a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里有一个泵泄漏结果的快照:AutoML达到了0.06的平均绝对误差，无法超过LSTM。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/afbb42309ac80daf0c2b20db3c647173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doGOtMNSFgKhtIxkaF9Neg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图6:泵泄漏的AutoML时间序列预测建模结果</figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="a74d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个练习继续强调计算的价值，特别是当我的工作需要越来越大的计算能力时。</p></div></div>    
</body>
</html>