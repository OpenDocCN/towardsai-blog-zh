<html>
<head>
<title>What are Python Decorators in Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Decorators在功能上是什么？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/what-are-python-decorators-in-function-b1776b049760?source=collection_archive---------1-----------------------#2021-08-23">https://pub.towardsai.net/what-are-python-decorators-in-function-b1776b049760?source=collection_archive---------1-----------------------#2021-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3b22" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="a36c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">向程序添加新功能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/94dc6dcc527b1791b269a25992861264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HNhJ0yoZuAk319cD"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特拉赫曼</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="li lj lk"><p id="a004" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it"> Python装饰者</em> </strong></p></blockquote><p id="7865" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">在真正理解decorators之前，有必要了解一下一级对象及其属性。</p><h2 id="5019" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">一等品</strong></h2><p id="9d63" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">一级对象不过是函数。这意味着它们可以作为参数使用或传递。让我们来看看这些函数的一些主要性质。</p><h2 id="9dbd" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">一级函数的性质:</strong></h2><ul class=""><li id="a801" class="ni nj it lo b lp nd ls ne mi nk mj nl mk nm mh nn no np nq bi translated">一个函数可以以参数的形式传递给另一个函数。</li><li id="762d" class="ni nj it lo b lp nr ls ns mi nt mj nu mk nv mh nn no np nq bi translated">用户定义的函数可以在另一个用户定义的函数中定义。</li><li id="664e" class="ni nj it lo b lp nr ls ns mi nt mj nu mk nv mh nn no np nq bi translated">在变量中存储一个函数是可能的。</li><li id="816e" class="ni nj it lo b lp nr ls ns mi nt mj nu mk nv mh nn no np nq bi translated">这些函数也可以存储在类似哈希表、列表、元组等数据结构中。</li></ul><p id="96e7" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">现在让我们看几个基于这些特征的例子。</p><h2 id="3ca7" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">将函数作为对象进行处理</strong></h2><p id="9df7" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated"><strong class="lo jd">程序</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="cde0" class="ml mm it nx b gy ob oc l od oe">2,6→ def begin(prog):<br/>3,7→     return prog.upper()</span><span id="085e" class="ml mm it nx b gy of oc l od oe">1→   print(begin(‘Python Program’))<br/>4→   end = begin<br/>5,8→ print(end(‘Welcome’))</span><span id="c505" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>PYTHON PROGRAM<br/>WELCOME</span></pre><h2 id="7a7a" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><p id="de32" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">在第四行中，我们看到函数“begin”被赋给了一个变量。这个变量不会调用函数。它使用“begin”引用的函数对象来创建另一个名称“end”在第五行中，我们可以观察到被引用的对象被调用并执行与之前相同的操作。让我们来详细看看这个程序的工作原理。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="0c4b" class="ml mm it nx b gy ob oc l od oe">1→ The program starts from here, where the function gets called.</span><span id="aa83" class="ml mm it nx b gy of oc l od oe">2→ The parameter “Python Program” is passed as the argument in the function.</span><span id="7c27" class="ml mm it nx b gy of oc l od oe">3→ This line converts the stated argument to uppercase letters, returns the value to the called function, and prints as the output.</span><span id="1f56" class="ml mm it nx b gy of oc l od oe">4→ Here, we have referenced the function ‘begin’ to a variable named ‘end.’</span><span id="cd8b" class="ml mm it nx b gy of oc l od oe">5→ In this line, we can observe that the referenced object is called and performs the same operation as before.</span></pre><h2 id="cfff" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">将函数作为参数传递</strong></h2><p id="56a4" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="53b4" class="ml mm it nx b gy ob oc l od oe">4→ def begin(prog):<br/>5→     return prog.lower()</span><span id="b696" class="ml mm it nx b gy of oc l od oe">10→ def start(prog):<br/>11→     return prog.upper()</span><span id="0c3b" class="ml mm it nx b gy of oc l od oe">2,8→  def end(func):<br/>3,9→      ending = func(“Passing functions as an argument”)<br/>6,12→     print(ending)</span><span id="645c" class="ml mm it nx b gy of oc l od oe">1→ end(begin)<br/>7→ end(start)</span><span id="92c1" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>passing functions as an argument<br/>PASSING FUNCTIONS AS AN ARGUMENT</span></pre><h2 id="68d5" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="0926" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">上面的例子说明了调用函数“end”将另一个函数作为参数；开始喊。作为参数传递的“begin”函数稍后在函数内部调用:“end。”让我们详细看看程序的工作原理:</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="29f4" class="ml mm it nx b gy ob oc l od oe">1→ The function, ‘end’ is called.</span><span id="6e2d" class="ml mm it nx b gy of oc l od oe">2→ The begin function is passed as an argument.</span><span id="f45c" class="ml mm it nx b gy of oc l od oe">3→ Now, the begin function is called inside the function ‘end’. This function is inside a variable named ‘ending’.</span><span id="0d6d" class="ml mm it nx b gy of oc l od oe">4→ The ‘begin’ function’s parameter is passed as the argument here.</span><span id="d295" class="ml mm it nx b gy of oc l od oe">5→ This line converts the stated argument to lowercase letters and returns the output to the called function.</span><span id="2438" class="ml mm it nx b gy of oc l od oe">6→ In this line, the result is printed.</span><span id="2529" class="ml mm it nx b gy of oc l od oe">7→ The above process is repeated for the following function call.</span></pre><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/data-preprocessing-concepts-with-python-b93c63f14bb6"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">Python中的数据预处理概念</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">一种为机器学习估值器准备数据的稳健方法</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">pub.towardsai.net</p></div></div><div class="os l"><div class="ot l ou ov ow os ox lb oj"/></div></div></a></div><h2 id="3596" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">函数返回另一个函数</strong></h2><p id="97a4" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="5624" class="ml mm it nx b gy ob oc l od oe">2→ def begin(prog):<br/>3→     print(“Beginning of program”)<br/>4→     return prog</span><span id="556a" class="ml mm it nx b gy of oc l od oe">7→ def end():<br/>8→     return “End of program”</span><span id="5c91" class="ml mm it nx b gy of oc l od oe">1,5→ calling = begin(end)<br/>6,9→ print(calling())</span><span id="3fe0" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>Beginning of program<br/>End of program</span></pre><h2 id="bdb1" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><p id="e8a0" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">为了避免混淆，让我们详细地看一下这个程序的工作原理。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="5cd2" class="ml mm it nx b gy ob oc l od oe">1→ The ‘begin’ function is called. (The function is stored in a variable ‘calling’, which will be called later in step 6).</span><span id="08cc" class="ml mm it nx b gy of oc l od oe">2→ Here, the ‘end’ function is passed as an argument.</span><span id="7cb3" class="ml mm it nx b gy of oc l od oe">3→ Inside this function lies a statement that prints the output.</span><span id="7ebd" class="ml mm it nx b gy of oc l od oe">4→ This step returns a reference of the argument ‘end’ to the called function.</span><span id="cc46" class="ml mm it nx b gy of oc l od oe">5→ The returned argument is referenced to the variable, “calling”.</span><span id="0adc" class="ml mm it nx b gy of oc l od oe">6→ Now, the function “calling”(referenced as ‘end’) is called.</span><span id="f856" class="ml mm it nx b gy of oc l od oe">7&amp;8→ The end function is implemented and returns the statement to the called function.</span><span id="4080" class="ml mm it nx b gy of oc l od oe">9→ The returned statement is printed.</span></pre><p id="fef4" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">以上三个概念是理解装修工概念必不可少的。让我们更深入地探讨这个话题。</strong></p><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">8 Python集合模块的主动学习见解</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">数据收集容器</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">pub.towardsai.net</p></div></div><div class="os l"><div class="oy l ou ov ow os ox lb oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">熊猫:处理分类数据</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">用python创建系列和数据帧</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">pub.towardsai.net</p></div></div><div class="os l"><div class="oz l ou ov ow os ox lb oj"/></div></div></a></div><blockquote class="li lj lk"><p id="63bb" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">Python中的Decorators是什么？</em>T3】</strong></p></blockquote><p id="5e94" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">装饰者的概念很简单。python中的装饰器允许我们在不改变现有功能的情况下给程序添加新的功能。</p><p id="64db" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="43b1" class="ml mm it nx b gy ob oc l od oe">@decorator<br/>def func_name():<br/>    ‘’’Function Implementation’’’</span></pre><p id="5192" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">上面的语法也等同于:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="f89a" class="ml mm it nx b gy ob oc l od oe">def func_name():<br/>    ‘’’Function Implementation’’’<br/>func_name = decorator(func_name)</span></pre><p id="0ffc" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="3eb5" class="ml mm it nx b gy ob oc l od oe">#without decorator</span><span id="8bcb" class="ml mm it nx b gy of oc l od oe">def str_upr(fun):<br/>    def inn():<br/>        str1 = fun()<br/>        return str1.upper()<br/>    return inn</span><span id="1e51" class="ml mm it nx b gy of oc l od oe">def str():<br/>    return “Welcome to Python Programming”<br/>d = str_upr(str)<br/>print(d())</span><span id="ed79" class="ml mm it nx b gy of oc l od oe">#with decorator</span><span id="bca6" class="ml mm it nx b gy of oc l od oe">3→ def str_upr(fun):<br/>6→     def inn():<br/>7→         str1 = fun()<br/>8→         return str1.upper()<br/>4→     return inn</span><span id="33f6" class="ml mm it nx b gy of oc l od oe">2,5→@str_upr<br/>    def str():<br/>        return “Welcome to Python Programming”<br/>1→  print(str())</span><span id="cc3b" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>WELCOME TO PYTHON PROGRAMMING</span></pre><h2 id="e0f5" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><p id="755b" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">以上两个程序是理解装饰者概念的简单例子。第一个是使用函数概念的简单程序。</p><p id="d8b9" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们知道第一类程序的工作原理。让我们来看看第二种工作方式。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="4d49" class="ml mm it nx b gy ob oc l od oe">1→ This is where the program starts; we are calling the function.</span><span id="1c0d" class="ml mm it nx b gy of oc l od oe">2→ This means that the ‘str_upr’ function decorates the ‘str’ function.</span><span id="0662" class="ml mm it nx b gy of oc l od oe">3→ Here, the ‘str_upr’ function is executed with ‘str’ as the argument.</span><span id="4010" class="ml mm it nx b gy of oc l od oe">4→ To execute the function ‘inn’, we have to call it. Hence, we return the name of the function, i.e. inn.</span><span id="d735" class="ml mm it nx b gy of oc l od oe">5→ This step would call the ‘inn’ function that was returned in the previous step.</span><span id="163b" class="ml mm it nx b gy of oc l od oe">6→ The ‘inn’ function is executed.</span><span id="f468" class="ml mm it nx b gy of oc l od oe">7→<strong class="nx jd"> Note</strong>: The inner function can access the arguments of the outer function. Hence the function ‘str’ is called and stored in variable ‘str1’.</span><span id="b1e3" class="ml mm it nx b gy of oc l od oe">8→ This step converts the string to the upper case and returns the output to the function call(Step 1). Finally, the result gets printed as above.</span></pre><h2 id="6a41" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">Python中带参数的装饰器</strong></h2><p id="b485" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated"><strong class="lo jd">语法:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="7338" class="ml mm it nx b gy ob oc l od oe">@decorator(parameter)<br/>def func_name():<br/>    ‘’’ Function Implementation ‘’’</span></pre><p id="4a69" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="1dd2" class="ml mm it nx b gy ob oc l od oe">3,11→ def add_decor(func):<br/>5,13→     def inn(x,y):<br/>6,14→         if y==2:<br/>7,15→             return “The number to be added is 2”<br/>16→           return func(x,y)<br/>4,12→     return inn</span><span id="2a9a" class="ml mm it nx b gy of oc l od oe">2,10→ @add_decor<br/>17→   def add(a,b):<br/>18→       return a+b</span><span id="8e10" class="ml mm it nx b gy of oc l od oe">1,8→  print(add(4,2))<br/>9,19→ print(add(2,4))</span><span id="78c4" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>The number to be added is 2<br/>6</span></pre><h2 id="49e7" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="e291" class="ml mm it nx b gy ob oc l od oe">1→ First, we are calling the ‘add’ function that contains two parameters (4,2).</span><span id="010e" class="ml mm it nx b gy of oc l od oe">2→ This means that the ‘add_decor’ function decorates the ‘add’ function.</span><span id="cd00" class="ml mm it nx b gy of oc l od oe">3→ Hence, the ‘add_decor’ function is executed.</span><span id="46bb" class="ml mm it nx b gy of oc l od oe">4→ The inner function ‘inn’ will not be executed as it is not called. Hence, it jumps to returns the function name ‘inn’ to the function call(line 1).</span><span id="e9b3" class="ml mm it nx b gy of oc l od oe">5→ Now, the function ‘inn’ is executed, with arguments as ‘2’ and ‘4’.</span><span id="426b" class="ml mm it nx b gy of oc l od oe">6,7,8→ Here, there is an ‘if’ condition to check whether the value of y is equal to ‘2’. Since the condition is true, (line 7) ‘return statement is printed. And the function execution comes to a stop.</span><span id="78a5" class="ml mm it nx b gy of oc l od oe">9→ In the second function call, the program executes the same way till the ‘inn’ function.</span><span id="0f78" class="ml mm it nx b gy of oc l od oe">14→ Inside the ‘inn’ function, since the condition is not satisfied, the else statement is executed (line 16).</span><span id="3629" class="ml mm it nx b gy of oc l od oe">16,17,18→ <strong class="nx jd">Note</strong>: The inner function can access the arguments of the outer function. Hence the function ‘add’ is executed.</span><span id="77e7" class="ml mm it nx b gy of oc l od oe">19→ Finally, the output is printed.</span></pre><blockquote class="li lj lk"><p id="33c0" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">连锁装修工</em> </strong></p></blockquote><p id="a7e6" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们知道装饰器在不改变现有功能的情况下给程序增加了新的功能。链接装饰器只不过是给程序增加了更多的功能。这些类型的装饰器很有用，因为新的功能是以块的形式添加的，这些块执行不同的任务，但使程序看起来更整洁和条块化。这些也被称为嵌套装饰器。</p><p id="2f54" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="063f" class="ml mm it nx b gy ob oc l od oe">@decorator1<br/>@decorator2<br/>def state():<br/>    statements(st)</span></pre><p id="b941" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="02bf" class="ml mm it nx b gy ob oc l od oe">def upper_dec(fun):<br/>    def inn():<br/>        x = fun()<br/>        return 40+x<br/>    return inn</span><span id="7477" class="ml mm it nx b gy of oc l od oe">def lower_dec(fun):<br/>    def inn():<br/>        x = fun()<br/>        return 25-x<br/>    return inn</span><span id="be7e" class="ml mm it nx b gy of oc l od oe">@lower_dec<br/>@upper_dec<br/>def num():<br/>    return 20<br/>print(num())</span><span id="6d77" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>-35</span></pre><h2 id="272e" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="3e98" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">上面的程序类似于前面讨论的程序。唯一的区别是这次有两个装饰者，而不是一个。</p><p id="ae3b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">多个装饰器的执行很简单。</p><ul class=""><li id="ac81" class="ni nj it lo b lp lq ls lt mi pa mj pb mk pc mh nn no np nq bi translated">装饰者总是从室内开始执行。</li><li id="c068" class="ni nj it lo b lp nr ls ns mi nt mj nu mk nv mh nn no np nq bi translated">因此，这里首先执行“upper_dec ”,只有在完成这个装饰函数的执行之后，才会执行“lower_dec”装饰函数。</li></ul><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/why-map-filter-and-reduce-functions-are-so-famous-4c8e42fd0755"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd jd gy z fp oo fr fs op fu fw jc bi translated">为什么Map()、Filter()和Reduce()函数这么出名？</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">python中避免循环和分支的函数式编程</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">pub.towardsai.net</p></div></div><div class="os l"><div class="pd l ou ov ow os ox lb oj"/></div></div></a></div><blockquote class="li lj lk"><p id="437a" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">在Python中使用装饰器进行记忆</em> </strong></p></blockquote><p id="5e7f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们知道递归的编程概念是反复调用函数，直到结束条件为真。一些使用递归的程序有阶乘、斐波那契等。但是，这些程序中的问题是，已经解决的子问题可能会被重复解决。这导致最终输出的执行延迟。这些程序使用记忆优化。</p><p id="8219" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">记忆化只不过是一种记录中间结果的编程技术。并优化程序的运行。这个概念也可以使用函数装饰器来实现。</p><p id="25df" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="8bee" class="ml mm it nx b gy ob oc l od oe">#Simple Factorial program without decorators<br/>def fact(n):<br/>    if n == 1:<br/>        return 1<br/>    else:<br/>        return n * fact(n-1)<br/>print(fact(6))</span><span id="5534" class="ml mm it nx b gy of oc l od oe">#Factorial program with memoization using decorators<br/>def store_fact(f):<br/>    storage = {}<br/>    def inn(n):<br/>        if n not in storage:<br/>            storage[n] = f(n)<br/>        return storage[n]<br/>    return inn</span><span id="38b2" class="ml mm it nx b gy of oc l od oe">@store_fact<br/>def fact(n):<br/>    if n == 1:<br/>        return 1<br/>    else:<br/>        return n * fact(n-1)<br/>print(fact(6))</span><span id="f505" class="ml mm it nx b gy of oc l od oe"><strong class="nx jd">Output:<br/></strong>720</span></pre><h2 id="07ff" class="ml mm it bd mn mo mp dn mq mr ms dp mt mi mu mv mw mj mx my mz mk na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="4123" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">上面的程序类似于其他讨论过的程序。记忆的唯一区别是递归操作甚至在结果存储在“存储器”中之后才发生。这意味着每次需要执行计算时，它首先检查结果是否存储在“存储器”中。如果它被存储，则该值被用作输出，否则该值被计算然后存储在存储器中。</p><p id="b34c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">结论:</strong></p><p id="e506" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">总之，本文涵盖了装饰函数的所有基础知识。我强烈建议阅读更多的文章，并使用python程序应用这些概念，因为在这个主题上有许多程序可供您试验。</p><p id="b0df" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="7baf" class="pe mm it bd mn pf pg ph mq pi pj pk mt ki pl kj mw kl pm km mz ko pn kp nc po bi translated">推荐文章</h1><p id="e606" class="pw-post-body-paragraph ll lm it lo b lp nd kd lr ls ne kg lu mi nf lx ly mj ng mb mc mk nh mf mg mh im bi translated">1.<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b?source=friends_link&amp;sk=4a5c9f9ad552005636ae720a658281b1">8 Python的主动学习见解收集模块</a> <br/> 2。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a>T5】3。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff?source=friends_link&amp;sk=11c6809f6623dd4f6dd74d43727297cf">熊猫:处理分类数据</a> <br/> 5。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/hyper-parameters-randomseachcv-and-gridsearchcv-in-machine-learning-b7d091cf56f4?source=friends_link&amp;sk=cab337083fb09601114a6e466ec59689">超参数:机器学习中的RandomSeachCV和GridSearchCV</a><br/>6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-distribution-using-numpy-with-python-3b64aae6f9d6?source=friends_link&amp;sk=809e75802cbd25ddceb5f0f6496c9803">数据分发使用Numpy与Python </a> <br/> 9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/decision-trees-vs-random-forests-in-machine-learning-be56c093b0f?source=friends_link&amp;sk=91377248a43b62fe7aeb89a69e590860">机器学习中的决策树vs随机森林</a> <br/> 10。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/standardization-in-data-preprocessing-with-python-96ae89d2f658?source=friends_link&amp;sk=f348435582e8fbb47407e9b359787e41">用Python实现数据预处理的标准化</a></p></div></div>    
</body>
</html>