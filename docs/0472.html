<html>
<head>
<title>Visualize an Interesting Sorting Algorithms With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python可视化一个有趣的排序算法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/visualize-interesting-sorting-algorithms-with-python-bdd64bdd0713?source=collection_archive---------0-----------------------#2020-05-08">https://pub.towardsai.net/visualize-interesting-sorting-algorithms-with-python-bdd64bdd0713?source=collection_archive---------0-----------------------#2020-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a816" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="7806" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">永远不要忘记那些排序算法，用Python可视化它们。</h2></div><blockquote class="ko kp kq"><p id="20e8" class="kr ks kt ku b kv kw ka kx ky kz kd la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有各种类型的排序算法，有时如果没有可视化，理解它们的内部工作会变得非常困难。因此，我决定借助matplotlib.animations库用python可视化这些排序算法。</p></blockquote><div class="lo lp lq lr gt ab cb"><figure class="ls lt lu lv lw lx ly paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><img src="../Images/ac311f74956ef817a3038f39eee74fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/1*UgLSkudf_8i9AiprpLNBhw.gif"/></div></figure><figure class="ls lt mf lv lw lx ly paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><img src="../Images/f21ff5172da7428b095431a3ad9ed004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/1*qcn0d0W74ZC4duWXwgiTMA.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk mk di ml mm translated">左边是冒泡排序，右边是合并排序</figcaption></figure></div><blockquote class="ko kp kq"><p id="f8ff" class="kr ks kt ku b kv kw ka kx ky kz kd la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ja">注意:-在本文中，我们还将计算执行的操作数量，并能够看到排序算法的时间复杂度。</strong></p></blockquote><p id="4587" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">因为我们的目的只是可视化排序算法，所以我将使用<code class="fe mq mr ms mt b">merge sort </code>进行演示，但是你应该实现它们的其余部分，以便理解它们之间的差异。</p><p id="9f80" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">在我们开始编码之前，你必须安装<code class="fe mq mr ms mt b">python 3.3 </code>或更高版本，因为我已经使用了<code class="fe mq mr ms mt b">yield from</code>功能或生成器。</p><h2 id="8422" class="mu mv iq bd mw mx my dn mz na nb dp nc mn nd ne nf mo ng nh ni mp nj nk nl iw bi translated"><strong class="ak">我们开始吧:- </strong></h2><p id="0791" class="pw-post-body-paragraph kr ks iq ku b kv nm ka kx ky nn kd la mn no ld le mo np lh li mp nq ll lm ln ij bi translated">首先，您需要导入给定的库。我们已经使用了<code class="fe mq mr ms mt b">random</code>模块来生成一个要排序的随机数字数组。<code class="fe mq mr ms mt b">matplotlib pyplot</code>和<code class="fe mq mr ms mt b">animation</code>模块将用于激活排序算法。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="5b4a" class="mu mv iq mt b gy nv nw l nx ny">import random<br/>import matplotlib.pyplot as plt<br/>import matplotlib.animation as anim</span></pre><p id="ff9d" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">下面给定的<code class="fe mq mr ms mt b">swap</code>函数将用于交换给定数组中的元素。定义一个单独的函数是有用的，因为它将在不同的算法中被详尽地使用。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="b2a2" class="mu mv iq mt b gy nv nw l nx ny">def swap(A, i, j):<br/>    a = A[j]<br/>    A[j] = A[i]<br/>    A[i] = a<br/>    # also in python A[i],A[j]=A[j],A[i]</span></pre><p id="77a7" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">我们使用了<code class="fe mq mr ms mt b">Merge Sort</code>来演示这种可视化，因为这是最流行的，也是最好的排序算法之一。合并排序遵循<code class="fe mq mr ms mt b">Divide and Conquer</code>排序技术。它将数组分成两个子数组，通过递归调用合并排序对每个子数组进行排序。我们的主要焦点是可视化算法，因此我不会解释它的工作原理。下面的代码显示了合并排序。为了直观地了解它是如何工作的，人们可以观看youtube上的这段视频<a class="ae nz" href="https://youtu.be/jlHkDBEumP0." rel="noopener ugc nofollow" target="_blank">珍妮的讲座</a>。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="4d73" class="mu mv iq mt b gy nv nw l nx ny">def merge_sort(arr,lb,ub):<br/>    if(ub&lt;=lb):<br/>        return<br/>    elif(lb&lt;ub):<br/>        mid =(lb+ub)//2<br/>        yield from merge_sort(arr,lb,mid)<br/>        yield from merge_sort(arr,mid+1,ub)<br/>        yield from merge(arr,lb,mid,ub)<br/>        yield arr</span><span id="700d" class="mu mv iq mt b gy oa nw l nx ny">def merge(arr,lb,mid,ub):<br/>    new = []<br/>    i = lb<br/>    j = mid+1<br/>    while(i&lt;=mid and j&lt;=ub):<br/>        if(arr[i]&lt;arr[j]):<br/>            new.append(arr[i])<br/>            i+=1<br/>        else:<br/>            new.append(arr[j])<br/>            j+=1<br/>    if(i&gt;mid):<br/>        while(j&lt;=ub):<br/>            new.append(arr[j])<br/>            j+=1<br/>    else:<br/>        while(i&lt;=mid):<br/>            new.append(arr[i])<br/>            i+=1<br/>    for i,val in enumerate(new):<br/>        arr[lb+i] = val<br/>        yield arr</span></pre><p id="6f67" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">现在我们将简单地创建要排序的随机数字列表，数组的长度将由用户自己决定。之后用<code class="fe mq mr ms mt b">if condition</code>选择算法。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="4913" class="mu mv iq mt b gy nv nw l nx ny">n = int(input("Enter the number of elements:"))<br/>al = int(input("Choose algorithm:  1.Bubble \n 2.Insertion \n 3.Quick \n 4.Selection \n 5.Merge Sort))<br/>array = [i + 1 for i in range(n)]<br/>random.shuffle(array)</span><span id="a997" class="mu mv iq mt b gy oa nw l nx ny">if(al==1):<br/>    title = "Bubble Sort"<br/>    algo = sort_buble(array)<br/>elif(al==2):<br/>    title = "Insertion Sort"<br/>    algo = insertion_sort(array)<br/>elif(al==3):<br/>    title = "Quick Sort"<br/>    algo = quick_Sort(array,0,n-1)<br/>elif(al==4):<br/>    title="Selection Sort"<br/>    algo = selection_sort(array)<br/>elif (al == 5):<br/>    title = "Merge Sort"<br/>    algo=merge_sort(array,0,n-1)<br/></span></pre><p id="a3ab" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">现在我们将使用matplotlib <code class="fe mq mr ms mt b">figure </code>和<code class="fe mq mr ms mt b">axis</code>为动画创建一个画布。然后，我们创建了条形图，其中每个条形代表数组中的一个数字。这里的<code class="fe mq mr ms mt b">text()</code>用于显示画布上的操作次数。前两个参数是标签的位置。<code class="fe mq mr ms mt b">transform=ax.transAxes</code>表示前两个参数是轴分数，而不是数据坐标。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="80b1" class="mu mv iq mt b gy nv nw l nx ny">fig, ax = plt.subplots()<br/>ax.set_title(title)<br/>bar_rec = ax.bar(range(len(array)), array, align='edge')<br/>text = ax.text(0.02, 0.95, "", transform=ax.transAxes)</span></pre><p id="59d8" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated"><code class="fe mq mr ms mt b">update_plot</code>函数用于更新我们动画中每一帧的图形。实际上，该函数将传递给<code class="fe mq mr ms mt b">anima.FuncAnimamtion() </code>，后者使用它来更新绘图。这里，我们已经传递了上面定义的输入数组<code class="fe mq mr ms mt b">rec </code>，以及跟踪所执行操作数量的时期。有人可能认为我们可以在epochs中简单地使用整数值而不是列表，但是像<code class="fe mq mr ms mt b">epoch = 0</code>这样的整数不能通过引用传递，而只能通过值传递，不像列表那样通过引用传递。<code class="fe mq mr ms mt b">set_height()</code>用于更新每个条的高度。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="5345" class="mu mv iq mt b gy nv nw l nx ny">epochs = [0]<br/>def update_plot(array, rec, epochs):<br/>    for rec, val in zip(rec, array):<br/>        rec.set_height(val)<br/>    epochs[0]+= 1<br/>    text.set_text("No.of operations :{}".format(epochs[0]))</span></pre><p id="a039" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">最后，我们创建<code class="fe mq mr ms mt b">anima</code>对象，在其中我们传递接受生成器函数的<code class="fe mq mr ms mt b">frames=algo </code>(该算法是一个生成器函数，因为它包含yield ),之后，它将生成或更新的数组传递给<code class="fe mq mr ms mt b">update_plot </code> , <code class="fe mq mr ms mt b">fargs </code>接受额外的参数，即<code class="fe mq mr ms mt b">epochs</code>和<code class="fe mq mr ms mt b">bar_rec</code>,<code class="fe mq mr ms mt b">interval</code>是每帧之间的延迟，以毫秒为单位。</p><p id="5cca" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">最后，我们使用<code class="fe mq mr ms mt b">plt.show()</code>来绘制动画人物。</p><pre class="lo lp lq lr gt nr mt ns nt aw nu bi"><span id="61aa" class="mu mv iq mt b gy nv nw l nx ny">anima = anim.FuncAnimation(fig, func=update_plot, fargs=(bar_rec, epochs), frames=algo, interval=1, repeat=False)<br/>plt.show()</span></pre><p id="f9a1" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">我的<a class="ae nz" href="https://github.com/PushkaraSharma/Visualize_DS" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ja"> Github </strong> </a> repo中有所有排序算法的完整代码。看看这个。如果你喜欢这篇文章，请告诉我。</p><p id="db1a" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">查看我的文章<a class="ae nz" href="https://medium.com/@pushkarasharma11/convert-images-to-ascii-art-images-using-python-90261de03c53" rel="noopener">使用Python将图像转换成ASCII艺术图像</a></p><p id="9991" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la mn lc ld le mo lg lh li mp lk ll lm ln ij bi translated">了解关于<a class="ae nz" href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.animation.FuncAnimation.html" rel="noopener ugc nofollow" target="_blank">动画功能</a>的更多信息</p></div></div>    
</body>
</html>