<html>
<head>
<title>Pragmatic Deep Learning Model for Forex Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外汇预测的实用深度学习模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/pragmatic-deep-learning-model-for-forex-forecasting-569aae6d4a1a?source=collection_archive---------0-----------------------#2020-10-07">https://pub.towardsai.net/pragmatic-deep-learning-model-for-forex-forecasting-569aae6d4a1a?source=collection_archive---------0-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9e7b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="9147" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用LSTM和张量流对GBPUSD时间序列进行多步预测</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c75ed6604eea5271a9410456eba1cddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HVBYmYCMMeCEWuHtDVC4A.png"/></div></div></figure><p id="4e9d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了解决这个经典问题，“机器学习能预测市场吗？”，我登陆GBPUSD外汇作为一个富有挑战性的金融系列，拥有丰富和免费的数据集。虽然在这个平台上有几十个关于股票ML预测的故事和几个关于外汇ML预测的故事，但在这里，你会看到我深入研究经常被忽略的特性，并旨在将我的模型带到现实光谱中:</p><ul class=""><li id="867b" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">通过实现多步预测，例如30或60步(在这种情况下是几分钟)或更多，与单步(1分钟)预测相反</li><li id="57e4" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">通过使用算法交易机器人消费模型，让盈利或亏损成为判断(下一个故事)</li></ul><p id="57c7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在故事的结尾，有一些Python和ML经验的读者将能够使用这些概念并修改链接的代码来产生他们自己的模型变体。在第2部分中，读者将能够使用该模型的商业算法交易平台。</p><h2 id="7516" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">源代码和后续工作</h2><p id="d3c0" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">该模型是使用TensorFlow/Keras 2.3在Python 3.8中构建的。为了让这个故事集中在概念上，完整的源代码和环境准备，以及与运行和更改代码相关的解释都在这里:</p><div class="nk nl gp gr nm nn"><a href="https://github.com/AdamTibi/LSTM-FX" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">阿达姆蒂比/LSTM-外汇</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这是外汇预测实用深度学习模型的配套代码。所以，如果你想了解…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lb nn"/></div></div></a></div><p id="a51a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此外，您还可以查看环境设置和运行模型的步骤，直观地解释如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">解释环境设置和运行模型的步骤</figcaption></figure><h1 id="3176" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">目录</h1><h2 id="6b96" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">外汇交易入门</h2><ul class=""><li id="f409" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">什么是外汇？</strong></li><li id="b681" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">佣金、差价和点数</strong></li><li id="e409" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">滴答数据</strong></li><li id="d615" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">开盘高低收盘数据</strong></li><li id="df09" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">烛台图表</strong></li><li id="5e88" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">外汇交易</strong></li><li id="28b0" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">算法交易</strong></li><li id="8ce0" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">回溯测试</strong></li></ul><h2 id="2e30" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">ML模型:概念和计划</h2><ul class=""><li id="af41" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">型号选择</strong></li><li id="d349" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">技术堆栈选择</strong></li><li id="609a" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">硬件选择</strong></li><li id="8eb8" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">这个计划</strong></li></ul><h2 id="d607" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">1 —数据来源</h2><h2 id="d4f2" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">2 —数据准备</h2><ul class=""><li id="3735" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">时间间隔和OHLC </strong></li><li id="1572" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">平滑</strong></li><li id="8386" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">平稳性</strong></li><li id="e567" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">批量大小</strong></li><li id="825e" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">训练，测试分割</strong></li><li id="9bae" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">流程总结</strong></li><li id="924c" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">缩放比例</strong></li><li id="75bb" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd"> LSTM数据输入概述</strong></li><li id="3e4d" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">窗户尺寸</strong></li><li id="1687" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">转换样本</strong></li></ul><h2 id="6b4d" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">3 —模型培训</h2><ul class=""><li id="a3b3" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">培训统计</strong></li></ul><h2 id="5723" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">4 —预测</h2><ul class=""><li id="eae6" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">单步预测</strong></li><li id="dbfd" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">多步预测</strong></li></ul><h2 id="7c98" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">继续并扩大研究</h2><ul class=""><li id="f8ca" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">日期特征工程</strong></li><li id="b72f" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">最小化异常值的影响</strong></li><li id="f7c7" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">非常小的迷你批量</strong></li><li id="caa0" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">不同的平滑方法</strong></li><li id="213e" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">区间聚合</strong></li><li id="983e" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">序列间预测</strong></li></ul><h2 id="aec1" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">放弃</h2><h2 id="7044" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">结论</h2><h2 id="a305" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">第二部分:使用交易平台的模型</h2><h2 id="c5a1" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">更多阅读</h2><h2 id="c596" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">关于我</h2><h2 id="b407" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">参考</h2></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="cdff" class="oi mo it bd mp oj pd ol ms om pe oo mv ki pf kj my kl pg km nb ko ph kp ne os bi translated">外汇交易入门</h1><p id="594d" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我将定义与这个故事相关的外汇交易的基础知识。如果你熟悉外汇基础知识，那么你可以跳过这一节。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/36ee1ab6214a8889e537acadf3582690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvUkfW1eF1ZQ7TJD7FWXdQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">GBPUSD汇率买入= 1.28820，卖出= 1.28816取自<a class="ae pj" href="https://ctrader.com/" rel="noopener ugc nofollow" target="_blank"> cTrader </a></figcaption></figure><h2 id="ad53" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">什么是外汇？</h2><p id="299c" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">外汇是两个经济体之间的货币价格关系，例如英镑对美元或GBPUSD。符号中的前三个字母代表称为“基础货币”的第一个经济体，后三个字母代表称为“报价货币”的第二个经济体。如果GBPUSD的汇率是1.28818，这意味着买1.28818美元你要支付1美元，外加佣金和/或差价。</p><h2 id="b4b5" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">佣金、差价和点数</h2><p id="87d1" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">如果你是与朋友交换，那么你可能会使用两个小数点，并在1.29交换GBPUSD，但是，如果你是通过外汇经纪人通过外汇交易平台进行交换，那么就有费用。</p><p id="8074" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">佣金:这是经纪人对每笔交易收取的固定费用。佣金金额取决于经纪人。</p><p id="46cb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">价差</strong>:买入价和卖出价之间的差额。经纪人就是这样盈利的。</p><p id="4307" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">举个例子，如果你有英镑，你想买美元，那么GBPUSD买入是1.28820，反之卖出是1.28816。这使得传播:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="ac52" class="mn mo it pl b gy pp pq l pr ps">Spread = Buy - Sell = 1.28820 - 1.28816 = 0.00004 = 0.4e-4</span></pre><p id="c228" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除非发生影响经济的事件，否则外汇价格的变化通常很小，因此交易者使用点数来表示变化。</p><p id="0818" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> PIP </strong>:价格利息点是特定于货币的。对于包括GBPUSD在内的大多数货币来说，汇率是:兑换x 10000</p><p id="2ade" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以将价差视为价格变化，因此可以表示为:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="abea" class="mn mo it pl b gy pp pq l pr ps">Spread = 0.4e-4 = 0.4 pips</span></pre><p id="df00" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，如果GBPUSD的卖价从1.28816变为1.28827，我们说价格上涨了:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="019a" class="mn mo it pl b gy pp pq l pr ps">1.28827 - 1.28816 = 0.00011 = 1.1 pips</span></pre><h2 id="679f" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">滴答数据</h2><p id="6ff0" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">价格的变化，也称为“滴答”，随机发生，例如每秒多次变化或两分钟内一次变化。外汇快速生成分笔成交点数据，这是2020年9月30日前5秒的GBPUSD分笔成交点数据示例:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="c04e" class="mn mo it pl b gy pp pq l pr ps"><strong class="pl jd">Date                  | Sell    | Buy</strong><br/>20200930 00:00:00.220 | 1.28643 | 1.28654<br/>20200930 00:00:00.322 | 1.28643 | 1.28653<br/>20200930 00:00:01.025 | 1.28641 | 1.28655<br/>20200930 00:00:01.754 | 1.28641 | 1.28654<br/>20200930 00:00:03.403 | 1.28642 | 1.28653<br/>20200930 00:00:04.204 | 1.28642 | 1.28655<br/>20200930 00:00:04.255 | 1.28643 | 1.28654<br/>20200930 00:00:04.356 | 1.28644 | 1.28656<br/>20200930 00:00:05.520 | 1.28645 | 1.28657<br/>20200930 00:00:05.853 | 1.28647 | 1.28657</span></pre><p id="c0cc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">还有另一种方式来查看数据，特别是当您想要检查更长时间(分钟、小时、周等)的价格时。</p><h2 id="c1ef" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">开盘高低收盘数据</h2><p id="6946" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">OHLC是汇总数据的另一种方式。OHLC可以应用于任何时间间隔，如一分钟或一小时。开盘获取时间间隔开始时的卖价，收盘获取第二个时间间隔开始前的价格。高表示价格在区间内达到的最高价，低表示价格达到的最低价。这是2020年9月30日GBPUSD最初几分钟的1分钟OHLC数据示例:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="9b11" class="mn mo it pl b gy pp pq l pr ps"><strong class="pl jd">Date           | Open    | High    | Low     | Close</strong><br/>20200930 00:00 | 1.28643 | 1.28663 | 1.28641 | 1.28659<br/>20200930 00:01 | 1.28663 | 1.28675 | 1.28649 | 1.28649<br/>20200930 00:02 | 1.28649 | 1.28650 | 1.28627 | 1.28630<br/>20200930 00:03 | 1.28630 | 1.28648 | 1.28626 | 1.28638<br/>20200930 00:04 | 1.28639 | 1.28647 | 1.28635 | 1.28640<br/>20200930 00:05 | 1.28641 | 1.28654 | 1.28641 | 1.28651<br/>20200930 00:06 | 1.28650 | 1.28655 | 1.28648 | 1.28653<br/>20200930 00:07 | 1.28653 | 1.28654 | 1.28647 | 1.28649</span></pre><h2 id="9c02" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">烛台图表</h2><p id="c2dd" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">交易者通常用OHLC数据来看图表，这就是为什么他们用“蜡烛图”来更好地表示这种类型的数据:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/725b5f6e2c70ad7aa66a389aa1cb9633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDaqpTXz-MsPg8B2vDDK6A.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">烛台吧。作者图片</figcaption></figure><p id="8441" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，烛台的颜色是任意的，惯例是使用一种颜色和一种相反的颜色，如黑色和灰色，我在这个故事中使用了绿色和橙色。接下来是我们上面的OHLC表，表示为蜡烛图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/40a5be398973fbe38a848be35bb99794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO9p43Nj3vMj5GneOPo8iQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">蜡烛图从2020年9月30日午夜开始。作者图片</figcaption></figure><h2 id="c490" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">外汇交易</h2><p id="85c3" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">本质上，如果你认为价格会上涨，你用报价货币(美元)买入基础货币(英镑)，如果你认为价格会下跌，你卖出基础货币。</p><p id="caf8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">交易与策略相关联，以这个过于简单的策略为例“如果你认为价格会上涨至少10点就买入，如果你认为价格会下跌至少10点就卖出。”</p><p id="f979" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你对价格变化的信念可能来自许多方面，天空是极限，例如:</p><ul class=""><li id="143f" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">你认为一个政治决定会影响一对经济体中的一个</li><li id="0211" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">你期待一份不同寻常的GDP公告</li><li id="8ef7" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">你使用一些技术指标，并以此为基础做出决定</li><li id="0e33" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">您根据历史数据训练一个ML模型，并要求它预测未来价格</li></ul><h2 id="6c22" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">算法交易</h2><p id="99a5" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">算法交易是使用机器人，一种用代码编写的策略，并通过API或其他基于机器人建议的方式自动执行交易。</p><p id="48e2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一个例子是使用一个机器人，将输入数据推入一个ML模型，并就价格变化咨询模型，然后相应地进行交易。</p><p id="56f5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">在第二部分，我将展示这个故事中的模型将如何用于算法交易</strong>。</p><h2 id="8ed1" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">回溯测试</h2><p id="89c5" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">当你建立了一个机器人，你想确保机器人能够盈利，一种方法是使用一个回溯测试平台来运行这个机器人，最好是和你的生产平台相同的平台。</p><p id="eed8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">另一个级别的回溯测试是在相同的生产平台上以演示模式(虚拟货币)运行一段时间，但使用实时数据。</p><p id="1fbf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通过这种方式，你减轻了损失的风险，但是，你仍然有其他风险，如市场模式转变的风险。</p><p id="7bbb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">在第2部分，我将展示如何回测基于这个模型的机器人。</strong></p><h1 id="cdd8" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">ML模型:概念和计划</h1><p id="3138" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">在交易中，如果我们想知道在某个特定时间是买、卖还是什么都不做，我们想预测价格会涨还是会跌，涨多少。</p><p id="aecf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了做交易决定，技术交易者使用指标来分析固定数量的时间步长(价格变化)。如果指标符合特定的模式，这意味着买入或卖出信号。本质上，这些指标是试图从以前的价格中提取模式。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/5a250c3e604ee3d6b4adc2c93edda0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7h6TYnZ4G5GdlgugCEXOg.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">带布林线(绿色)和均线(青色)指标的蜡烛图。捕捉自<a class="ae pj" href="https://ctrader.com/" rel="noopener ugc nofollow" target="_blank"> cTrader </a></figcaption></figure><p id="65f0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里的想法是让我们的模型作为一个指标。我们将使用历史数据来训练我们的模型，研究价格变化以及它们是否会导致价格上涨或下跌。如果历史数据中有重复出现的模式，那么我们希望我们的模型能够识别它们。</p><p id="f556" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">简而言之，我们希望我们的模型能够识别价格模式，并在遇到模式时告知我们预期的价格变化。</p><h2 id="8981" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">型号选择</h2><p id="0f24" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">为了实现我们的目标，我们将需要一个ML模型，该模型将识别时间序列模式并预测下一个模式，因此我们可以将选择范围缩小到适用的模型。</p><p id="cdb7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">回归模型，如<strong class="lf jd"> GARCH </strong>、<strong class="lf jd"> ARIMA </strong>和<strong class="lf jd">脸书先知</strong>，对于不太复杂的时间序列预测很好，所以我将它们排除在外，而倾向于深度学习神经网络模型，如<strong class="lf jd">注意力网络</strong>和<strong class="lf jd">长短期记忆(LSTM) </strong>，因为它们更适合这种预测。</p><p id="4424" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我更喜欢LSTM，因为与新的注意力网络相比，这个模型得到了大量的研究，尽管我可能会用注意力网络做另一项研究。</p><h2 id="3902" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">技术堆栈选择</h2><ul class=""><li id="3e21" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated"><strong class="lf jd">开发:</strong> Python 3.8，Tensorflow 2.3(内置Keras)，Visual Studio代码带Jupyter笔记本，Visual Studio，Pandas，NumPy，Scikit-Learn，Matplotlib，Ubuntu 20.04</li><li id="b21c" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><strong class="lf jd">制作:</strong> Python 3.8，C#，CTrader算法交易平台(CTrader Automate)，Flask Web服务器，Windows 10</li></ul><h2 id="5f18" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">硬件选择</h2><p id="cac5" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">这不是一个真正的选择，这是我已经拥有的。</p><ul class=""><li id="4a0c" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">笔记本电脑(用于开发):Dell Precision M4800，32GB内存，8个逻辑内核英特尔i7 2.9GHz，2GB内存Nvidia Quadro K2100M</li><li id="4120" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">服务器(用于培训):Dell Precision Tower 7910、24GB内存、28个逻辑内核英特尔至强2.6GHz、Nvidia GeForce RTX 2080 8GB内存</li></ul><h2 id="ed40" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">这个计划</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/e397df37ee9f8b65520f0786c3b31df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyfdtLofnzZkqrWySIas8w.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">这个计划。作者图片</figcaption></figure><p id="9576" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将经历标准的ML监督学习过程，我们将获取数据，以适合模型的结构准备数据，训练模型，然后使用模型进行预测。</p><h1 id="4b90" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">1 —数据来源</h1><p id="5d9a" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我选择了<strong class="lf jd"> </strong> GBPUSD外汇市场，因为这里有大量免费的高质量数据，小到分笔成交点数据，而且我住在英国，对数据本身也很熟悉(我可以盲目地指出2008年信贷危机、英国退出欧盟投票日和新冠肺炎封锁)。</p><p id="0918" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以使用像<a class="ae pj" href="https://www.quandl.com/tools/python" rel="noopener ugc nofollow" target="_blank"> Quandl </a>这样的资源从Python下载GBPUSD数据，或者像我一样以CSV格式下载。我用一个叫做<a class="ae pj" href="https://strategyquant.com/quantdatamanager/" rel="noopener ugc nofollow" target="_blank"> Quant数据管理器</a>的Windows桌面软件从Dukascopy瑞士网上银行下载了GBPUSD 1分钟数据。这是一个样本数据:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="d6d5" class="mn mo it pl b gy pp pq l pr ps">Date,High,Low<br/>2010-01-01 00:00,1.61673,1.61659<br/>2010-01-01 00:01,1.61670,1.61670<br/>...<br/>2020-10-01 23:58,1.28852,1.28838<br/>2020-10-01 23:59,1.28853,1.28846</span></pre><h1 id="f194" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">2 —数据准备</h1><p id="ea08" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">外汇数据通常是干净的，所以我在这方面投资了一点。此外，我将努力强调量化金融概念，而不是关注代码，这将使链接的代码不言自明。</p><h2 id="c07a" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">时间间隔和OHLC</h2><p id="4a04" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">有了外汇，你可以很容易地获得报价。然而，分笔成交点数据非常不稳定，价格变化率不可预测，可能是每秒多次变化，也可能是两分钟一次变化。此外，分笔成交点价格生成了太多的数据，这将增加ML训练时间。</p><p id="7564" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我选择1分钟OHLC(开盘价、最高价、最低价、收盘价)，因为我认为1分钟是在大量样本和良好的训练时间之间的一个很好的平衡。使用OHLC之外的收盘价是一种常见的做法。然而，我不认为这是时间间隔的最佳表示，所以我取了最高价和最低价之间的平均价格，我在代码中称之为<strong class="lf jd"> HLAvg </strong>:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="8492" class="mn mo it pl b gy pp pq l pr ps">df['HLAvg'] = df['High'].add(df['Low']).div(2)</span></pre><h2 id="7e52" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">缓和</h2><p id="228e" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">考虑到影响汇率的因素，我相信使用平滑的时间序列而不是价格的实际变化会产生更好的预测准确性。我坚持平滑的基本原则，使用14周期的简单移动平均线。我选择了14，因为这是大多数技术分析工具的默认周期。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/a7a77e5730eca38769ff4869914f83c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1-MXtG50jcjS5-CJyjOnw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">GBPUSD 1分钟图上有14个周期的SMA。图表来自<a class="ae pj" href="https://uk.tradingview.com/" rel="noopener ugc nofollow" target="_blank">TradeView.com</a>，数据来源为<a class="ae pj" href="https://www.fxcm.com/uk/" rel="noopener ugc nofollow" target="_blank"> FXCM </a>。</figcaption></figure><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="3cfc" class="mn mo it pl b gy pp pq l pr ps">df['MA'] = df['HLAvg'].rolling(window=14).mean()</span></pre><p id="bc68" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，在计算移动平均线时，第一个周期减一，没有移动平均线(在我们的例子中是前13行)。我们将删除这些行。</p><h2 id="5f31" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">平稳性</h2><p id="2c6e" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">简单地说，平稳性意味着一个看起来平淡无奇的序列，没有趋势。简而言之，稳定是趋势的反义词。有一些统计测试可以告诉你一个特定时间序列的状态。更深入的分析:</p><div class="nk nl gp gr nm nn"><a href="https://machinelearningmastery.com/time-series-data-stationary-python/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">如何用Python检查时间序列数据是否平稳—机器学习精通</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">时间序列不同于更传统的分类和回归预测建模问题。时间…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">machinelearningmastery.com</p></div></div><div class="nw l"><div class="pw l ny nz oa nw ob lb nn"/></div></div></a></div><p id="3027" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，基于经验证据，外汇和股票是非平稳的。所以，我们将继续假设我们的仪器是不稳定的。</p><p id="66c6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">虽然我们的LSTM深度学习模型不要求时间序列是平稳的，但许多来源都建议使用平稳的时间序列。</p><blockquote class="px py pz"><p id="d39e" class="ld le qa lf b lg lh kd li lj lk kg ll qb ln lo lp qc lr ls lt qd lv lw lx ly im bi translated">[1]如果你的序列是上升或下降的趋势，估计[最小和最大可观察]值可能是困难的，标准化可能不是解决你的问题的最佳方法。</p><p id="2731" class="ld le qa lf b lg lh kd li lj lk kg ll qb ln lo lp qc lr ls lt qd lv lw lx ly im bi translated">[1]在时间序列预测中，使序列平稳是一种很好的做法，即在对问题建模之前，从序列中去除任何系统趋势和季节性。使用LSTMs时，建议这样做。</p></blockquote><p id="626f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以通过计算收益来使金融工具稳定。定量金融的方法是使用日志回报。这是一篇精彩经典文章的链接，这篇文章解释了使用日志返回的原因:</p><p id="3a95" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae pj" href="https://quantivity.wordpress.com/2011/02/21/why-log-returns" rel="noopener ugc nofollow" target="_blank">https://quantivity.wordpress.com/2011/02/21/why-log-returns</a></p><p id="a935" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通过对数回归使一个序列平稳是可逆的，因为我们不会丢失任何数据，不像用简单的移动平均线平滑。这很重要，因为我们希望能够从预测中重建我们的时间序列，稍后您将会看到这一点。</p><p id="f922" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从简单移动平均线<em class="qa"> MA </em>计算时间步长<em class="qa"> t </em>的对数收益；</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/353d59125d710bee9e5f715b80103a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*ZPSybsAN4m6wMAiFsmyHdA.png"/></div></figure><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="bb7b" class="mn mo it pl b gy pp pq l pr ps">df['Returns'] = np.log(df['MA']/df['MA'].shift(1))</span></pre><p id="7c59" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要根据收益计算未来移动平均值，预测后需要:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/871ef4933c962d613c03c4ccef50e01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*GUnKCy2ITeQu6RMYQs7uNg.png"/></div></figure><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="9008" class="mn mo it pl b gy pp pq l pr ps">df['MA'] = df['MA'].mul(np.exp(df['Returns'].shift(-1))).shift(1)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/c3e8023a3efbab90d29310db0dcfc1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTWtQJBcVFOn0ZAS74bAhQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">具有简单移动平均和对数回报的时间序列</figcaption></figure><p id="0b47" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在上面的图表中，前两个图表之间没有太大的差异，因为在这种缩放级别下，1分钟系列的平滑操作不会很清楚。</p><p id="13e7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，您将无法计算第一行的回报，因此我们将删除这一行。</p><h2 id="d469" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">批量</h2><p id="bd99" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated"><strong class="lf jd">批量大小</strong>是梯度更新前用于神经网络训练的模型样本数量。</p><p id="a13f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了实用，我们需要了解批量大小:</p><ul class=""><li id="0238" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">是一个影响数据训练的超参数，需要进行更改以最大限度地减少预测误差</li><li id="d1a8" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">按照惯例可以取2到32之间的一个值，称为<strong class="lf jd">小批量。</strong>其他常见的数值有64和128</li><li id="16a3" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">它越大，在GPU上训练就越快。然而，不利的一面是，这导致了比小批量更多的训练错误</li></ul><p id="b39a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最佳批量是一个有争议的话题，我建议试错法来平衡最佳训练时间和最少的错误。</p><blockquote class="px py pz"><p id="bfcc" class="ld le qa lf b lg lh kd li lj lk kg ll qb ln lo lp qc lr ls lt qd lv lw lx ly im bi translated">[2]所呈现的结果证实，在大范围的实验中，对于给定的计算成本，使用小批量实现了最佳的训练稳定性和泛化性能。在所有情况下，最佳结果都是在批量m = 32或更小的情况下获得的，通常小到m = 2或m = 4。</p></blockquote><p id="0e63" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">经过无数次的批量试错，我选择了32个。对于这个大小，我在我的硬件上每个时期花了大约25分钟(在我的GitHub repo上描述)。</p><h2 id="c109" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">列车，测试分流</h2><p id="7343" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">所有ML从业者都熟悉训练/测试分离。我遵循传统的方法，但是添加了批量大小作为额外的约束。</p><p id="2a5d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我将数据长度限制为批量大小的倍数，因为我有将近400万条记录，牺牲数据开头的几条记录不会有任何影响。丢失的数据将小于最大批量，在本例中小于32分钟。</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="7696" class="mn mo it pl b gy pp pq l pr ps">df = df[df.shape[0] % batch_size:]</span></pre><p id="d8c2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">之后，我根据批量大小对数据进行了拆分。注意<em class="qa"> val_size、test_size、window_size </em>(后面会讲到<em class="qa">window _ size</em>)<em class="qa">T5也都是<em class="qa"> batch_size </em>的倍数。我没有使用传统的80/20或90/10进行训练/测试分割。</em></p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="c904" class="mn mo it pl b gy pp pq l pr ps">df_train = df[:- val_size - test_size]<br/>df_val = df[- val_size - test_size - window_size:- test_size]<br/>df_test = df[- test_size - window_size:]</span></pre><p id="941a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我采用这种批量大小约束来降低使用LSTM模型时所需算法的复杂性。</p><p id="2d8a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这三个数据帧将保存到三个独立的CSV中，以便在训练、验证和测试模型时使用。</p><h2 id="7915" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">流程总结</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/90acd9a72cb1361e2eca633f8c69a779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5wKOr-ZLUmD_ihcOLX13w.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">数据准备过程的第一步总结</figcaption></figure><p id="3de6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">之前的数据准备流程生成了三个单独的CSV文件，分别用于培训、验证和测试。这将有助于把我们的整个过程分割成单独的Jupyter笔记本。</p><h2 id="6a59" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">缩放比例</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/04a12dd987744c32dfed16e24133e900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZspV9whxmrznPQ-1Paa5dA.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">训练集:缩放后的日志返回介于0和1之间的值</figcaption></figure><p id="90db" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我在这项研究中使用了<em class="qa">最小最大缩放器</em>，因为这是最有效的缩放器，因为与其他缩放器相比，单个历元时间是<em class="qa">最小最大缩放器</em>的三到四倍。</p><p id="4b3a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="qa">最小最大缩放器</em>将数据值归一化到最小值和最大值之间，默认情况下，最小值和最大值分别为0和1。当输入值缩放到标准范围时，LSTM的性能会更好。</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="453e" class="mn mo it pl b gy pp pq l pr ps">scaler = MinMaxScaler()<br/>train_values = scaler.fit_transform(train_df[['Returns']].values)<br/>...<br/>test_values = scaler.transform(test_df[['Returns']].values)</span></pre><p id="7862" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">稍后在预测之后，模型将预测缩放后的值，因此您必须反转变换以将其返回到真实值:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="e8cf" class="mn mo it pl b gy pp pq l pr ps">df['Returns_Prediction'] = scaler.inverse_transform(df[['Returns_Prediction_Scaled']].values)</span></pre><p id="a78d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个定标器应该适合训练数据一次，然后从这一点开始重新使用来定标其他数据集:验证数据、测试数据、回测数据和生产数据。值得注意的是，如果缩放器适用于所有数据集，它将引入前瞻偏差。</p><p id="5b0c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要重用缩放器，最快的方法是持久化它(将其存储为文件)并在需要时加载它:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="53ee" class="mn mo it pl b gy pp pq l pr ps">joblib.dump(scaler, 'scalers/scaler.bin') # For persisting to file<br/>...<br/>scaler = joblib.load('scalers/scaler.bin') # For loading from file</span></pre><p id="297f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个过程的一个注意事项是，您需要使用相同的SciKit Learn版本来保存和加载。</p><p id="c426" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">到目前为止，我们已经对行数据执行了以下操作:</p><ul class=""><li id="67e4" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">已计算最高最低平均值(HLAvg)</li><li id="f047" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">计算简单移动平均线(SMA)</li><li id="ecdf" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">计算了SMA的对数收益</li><li id="f98e" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">计算了缩放后的测井回报</li></ul><p id="d23d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们从日期开始，从高点和低点开始，以缩放后的日志回报结束，这是我们的原始数据和处理后的数据的10条记录的快照:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qj"><img src="../Images/32d4972300fd4af2f51a8bf7e308bc63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pb_fx40MPE5Ni_r8FDIP_Q.png"/></div></div></figure><h2 id="7ff2" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">LSTM数据输入概览</h2><p id="323e" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我们需要从一个模型中得到一个固定数量的最近样本，并得到预测。让我们使用上表，假设现在的时间是2010–01–01 00:23，这是第6个样本。我们希望预测样本7处的HLAvg，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/507e63c7fc4f6a09d765f4348b193293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5banpA3WWUb-j6-f-skHWw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">前期价格及其预测。作者图片</figcaption></figure><p id="9289" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的预测越接近一分钟后的市场实际价值(样本7，00:24)，我们的预测就越准确。</p><p id="b17b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">LSTM模型期望输入的训练数据看起来像先前的数据，但是应用了所有的数据准备。根据上表，它预期的数据如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/f78699b8d9f8d33dc83b4c57b86bd6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjCoUyYUBs9YOZ-WHbT3qg.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">一个特征和一个标签。作者图片</figcaption></figure><p id="7698" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们的实现中，单个特征的长度是<em class="qa">窗口大小，在前面的例子中，它是6。</em></p><h2 id="53f0" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">窗口大小</h2><p id="8e4d" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">窗口大小，也称为“回望期”，是过去样本的数量，在我们的情况下是分钟，您希望在预测下一个样本的时间点上考虑它。把它想象成你想要依赖的相关的过去的样本，来决定金融工具是上涨还是下跌。</p><p id="a044" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了在整个数据集上训练我们的模型，我们必须将训练集构造为特征(X)和标签(y)的模型样本，如果我们以前面的表为例，窗口大小为6:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/e987b323b9ecb84b6eda4d1c43c627b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zbk1YaGeKYDHfURiTDtvog.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">每个样本移动1的图示。作者图片</figcaption></figure><p id="129f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来我们将展示创建这个数据结构所必需的代码，为了简化算法并符合LSTM输入，我将<em class="qa">窗口大小</em>设为<em class="qa">批量大小的倍数。</em></p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="b97d" class="mn mo it pl b gy pp pq l pr ps">batch_size = 32<br/>window_size = 8 * batch_size # 256 minutes, 4.3 hours</span></pre><h2 id="fafd" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">转换样本</h2><p id="f779" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">由于“样本”是一个松散的术语，我们姑且称之为“模型-样本”，给它一个精确的定义。为了训练模型，我们需要将所有处理过的样本(比例对数回报)转换为模型样本(窗口大小和标签的特征集合)。按照惯例，特征集合被称为<em class="qa"> X </em>，它们的标签是<em class="qa"> y. </em></p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="1b79" class="mn mo it pl b gy pp pq l pr ps">def convert_raw_samples_to_model_samples(scd_log_rtns, window_size):<br/>    X, y = [], []<br/>    len_log_rtns = len(scd_log_rtns)<br/>    for i in range(window_size, len_log_rtns):<br/>        X.append(values[i-window_size:i])<br/>        y.append(values[i])<br/>    X, y = np.asarray(X), np.asarray(y)<br/>    X = np.reshape(X, (X.shape[0], X.shape[1], 1))<br/>    return X, y</span></pre><p id="2a78" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">举例说明前面的函数，如果<em class="qa"> scd_log_rtns </em>有10个数据样本，并且<em class="qa"> window_size </em> =6，则for循环可以表示为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/b7825d37e88136ee03d0e1222de9dcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5fodGEXFhyKs3AG5JztXA.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">for循环的图示。作者图片</figcaption></figure><p id="02f4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">LSTM输入期望形状的3D阵列:处理的数据样本的数量、窗口大小和特征</p><ul class=""><li id="c54e" class="lz ma it lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">已处理数据样本的数量是所有定标测井返回的大小减去窗口大小。记住，我们不能使用所有的训练数据，因为第一个<em class="qa"> window_size </em>样本是不可用的。</li><li id="9777" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">在我们的例子中，特征是1，这是比例对数回报</li></ul><p id="8c59" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="qa"> X </em>的最后一个<em class="qa">整形</em>会将<em class="qa"> X </em>转换为LSTM 3D兼容输入。</p><p id="f795" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，同样的过程也适用于验证数据集。</p><h1 id="ab7c" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">3 —模型培训</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/be1e6a4107e2c308891c0f20ffe14b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrdmV_iv6YktgqLLnbG6pg.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">模型的数据流。作者图片</figcaption></figure><p id="9796" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Keras成为v2中TensorFlow的一部分，我们将Keras用于我们的模型:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="e923" class="mn mo it pl b gy pp pq l pr ps">model = Sequential()<br/>model.add(LSTM(76, input_shape=(X.shape[1], 1), return_sequences = False))<br/>model.add(Dropout(0.2))<br/>model.add(Dense(1))<br/>model.compile(loss="mse", optimizer='Adam')</span></pre><p id="bf4a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">顺序</strong> : Keras层叠方式。详情如下:</p><div class="nk nl gp gr nm nn"><a href="https://keras.io/guides/sequential_model/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">Keras文档:顺序模型</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">作者:fchollet创建日期:2020/04/12最近修改时间:2020/04/12描述:顺序…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">keras.io</p></div></div><div class="nw l"><div class="ql l ny nz oa nw ob lb nn"/></div></div></a></div><p id="150a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">LSTM:LSTM网络非常适合处理时间序列问题。解释这一层的细节超出了本故事的范围，详情如下:</p><div class="nk nl gp gr nm nn"><a href="https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">LSTM和GRU的图解指南:一步一步的解释</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">嗨，欢迎来到长短期记忆(LSTM)和门控循环单位(GRU)的图解指南。我是迈克尔…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="qm l ny nz oa nw ob lb nn"/></div></div></a></div><p id="45fd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> Dropout </strong>:是一个正则化层，用于LSTM和其他RNN网络以减少过度拟合。它通常出现在每一层LSTM之后。更多详情:</p><div class="nk nl gp gr nm nn"><a href="https://machinelearningmastery.com/how-to-reduce-overfitting-with-dropout-regularization-in-keras/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">如何在Keras -机器学习掌握中使用退出正则化来减少过拟合</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">最后更新于2020年8月25日退出正则化是一种计算廉价的方式来正则化一个深神经…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">machinelearningmastery.com</p></div></div><div class="nw l"><div class="qn l ny nz oa nw ob lb nn"/></div></div></a></div><p id="ce1d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我用的是一层有76个神经元的LSTM。对于正则化，我使用了20%的辍学层。在我构建网络的试错过程中，我使用了多对LSTM和漏失层，我尝试了1、2、3和4对(通过隐藏层使网络更深)，我还尝试了改变每层神经元的数量和漏失百分比。</p><p id="d759" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我降落在一对层，这产生了最少的错误和最少的训练时间。</p><p id="6a70" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">密集</strong>:我的输入有多个神经元(76)，会产生多维度的输出。密集层将创建输入的加权线性组合(有偏差)，这将创建单个输出，在我们的情况下，它是单个预测，这是下一分钟。</p><h2 id="71f1" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">培训统计</h2><p id="8b1a" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我尝试了从2010年1月1日到2020年10月1日的分钟数据，每个时期大约需要25分钟，100个时期似乎不错。</p><p id="f73a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">训练测试的均方误差约为3.2e-6，验证损失约为2e-6。我试图将周期增加到200，因为我认为模型训练不足，但这并没有减少测试的MSE。我认为这种差异是因为验证集与测试集的模式不同，而且与其他时间序列相比，外汇市场的模式较少。</p><h1 id="c5e7" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">4 —预测</h1><p id="a5f8" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">请记住，您的模型只理解比例对数回报，因为这是我们对它进行的培训。现在每次我们想要一个预测，我们都必须经历这个过程:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/26c13143a82589b0a9c16157c62ea8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bl6KHIJ0diVibIoBXwl7pw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">预测前后的数据流。作者图片</figcaption></figure><p id="5f4e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面的代码实现了上面的过程，其中X是充当特性列表的数据:</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="66c4" class="mn mo it pl b gy pp pq l pr ps">y_pred = model.predict(X)<br/>df['Pred_Scaled'] = np.pad(y_pred.reshape(y_pred.shape[0]), (window_size, 0), mode='constant', constant_values=np.nan)</span><span id="58c0" class="mn mo it pl b gy qo pq l pr ps">df['Pred_Returns'] = scaler.inverse_transform(df[['Pred_Scaled']].values)</span><span id="b8e7" class="mn mo it pl b gy qo pq l pr ps">df['Pred_MA'] = df['MA'].mul(np.exp(df['Pred_Returns'].shift(-1))).shift(1)</span></pre><p id="24a4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">值得注意的是，要从回报中重建SMA，你需要初始资本。举个简单的例子，如果我知道你有+ 2、+ 3和- 4的回报，我就不会知道你的资本，但如果你告诉我你的初始资本，比如1000，我就能构建一个完整的投资(想想SMA)，这将是1002，1005，1001。代码中的最后一行是这样做的，但是返回的不是算术返回，所以我使用<em class="qa"> exp </em>函数来反转操作。</p><h2 id="3b2e" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">单步预测</h2><p id="2560" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">这是模型的单步预测:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/b7af4a43f88053f6ca1e028bb0d12519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdLYdWR3OzIoUAu9-6FNEQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">单项预测(1分钟)。作者图片</figcaption></figure><p id="26db" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在上图中，预测值离SMA不远。这并不意味着什么，因为我们预测的只是一分钟，任何一个不太好的模型都会给出一个好的结果。</p><h2 id="a97b" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">多步预测</h2><p id="e1ce" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">单步预测对交易没有用，你需要超过一分钟的预测，就好像你计划交易1分钟，佣金和价差会对你不利。</p><p id="2263" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">预测多个步骤的一种方法是预测未来一分钟，然后在新的预测中使用该分钟，依此类推。在下一张图中，我做了几个多步预测来显示不止一种情况:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/f8790c6260507f1c436b95ecfa154a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sU4RNEMiX_BKtZm7kF4IEA.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">几个多步预测。作者图片</figcaption></figure><p id="7806" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我受到雅各布·昂吉斯的启发，在他的文章中，我在更多阅读材料部分引用了他的文章，我有了这个有几个预测的图表。</p><p id="4879" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">说服Matplotlib在同一个图上画这些短红线是有挑战的，所以我使用了一个变通方法。我在图中添加了一条法线，但它是从图的起点填充到红线以'<em class="qa"> np.nan' </em>开始的点，下面的代码是准备图并同时进行预测:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qr od l"/></div></figure><h1 id="8d07" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">继续并扩大研究</h1><p id="1549" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">由于时间限制或硬件限制，我还没有尝试更多的实验概念。我在这里列出了一些，以便感兴趣的读者可以扩展这项研究。</p><h2 id="8a88" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">日期特征工程</h2><p id="2dd8" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">外汇可能有特定的模式，取决于日期的组成部分，如小时，周，月和/或年。</p><p id="258a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这项研究中，我没有考虑日期值，我只是把每一分钟的价格变化作为一个样本。对日期组件进行特征工程设计并使用多种数据输入(多元时间序列预测)可能会揭示更多模式。</p><h2 id="86b5" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">最小化异常值的影响</h2><p id="e785" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">测井回归中的去趋势数据有几个异常值，最明显的是英国退出欧盟时期的异常值:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qs"><img src="../Images/91e067641643affec4461894f4628fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqHPc2yw131oriz0pSR2gw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">一些异常值的亮点。作者图片</figcaption></figure><p id="2e07" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我尝试了其他专门用于减少异常值影响的定标器，但模型训练时间增加了3到4倍。</p><p id="2e2e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果决定这个模型不适合经济动荡，我会从物理上排除来自信贷危机、英国退出欧盟和新冠肺炎封锁期的样本。</p><h2 id="43a4" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">非常小的迷你批量</h2><p id="0b04" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">对于15年来32个批次大小的单个时期，1分钟的GBPUSD耗时约45分钟。因此，运行200个纪元需要大约一周时间(6.25天)。</p><p id="2ce5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">将大小减小到小于32可能会产生更好的预测，但会增加训练时间。</p><h2 id="e55d" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">不同的平滑方法</h2><p id="7697" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我使用了14周期的简单移动平均线来平滑价格。但是对于交易者来说，均线没有指数加权均线受欢迎，因为均线对最近的数据样本更敏感。</p><h2 id="06c5" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">区间聚合</h2><p id="c7b4" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我使用了1分钟的时间步长，但是，这也可以是15秒、30秒、2分钟、5分钟、1小时等等…</p><p id="6adb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不同的汇总可能适合不同的交易风格，并可能揭示更多的模式。</p><h2 id="ab97" class="mn mo it bd mp mq mr dn ms mt mu dp mv lm mw mx my lq mz na nb lu nc nd ne iz bi translated">序列间预测</h2><p id="0996" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我通过执行多个单一预测来模拟多步预测。还有另一种有趣的方法，称为序列间预测或seq2seq。</p><p id="294d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在seq2seq中，不是预测单个next值，而是预测一个可变长度的新序列。例如</p><pre class="ks kt ku kv gt pk pl pm pn aw po bi"><span id="66dc" class="mn mo it pl b gy pp pq l pr ps">1.2752, 1.2751, 1.2754, 1.2756 -&gt; 1.2758, 1.2760, 1.2761</span></pre><blockquote class="px py pz"><p id="5224" class="ld le qa lf b lg lh kd li lj lk kg ll qb ln lo lp qc lr ls lt qd lv lw lx ly im bi translated">[3] seq2seq学习，其核心是利用递归神经网络将变长输入序列映射为变长输出序列。虽然相对较新，但seq2seq方法不仅在其原始应用(机器翻译)方面取得了最先进的成果(Luong等人，2015bJean等人，2015年a；Luong等人，2015年a；Jean等人，2015bLuong和Manning，2015年)，以及图像字幕生成(Vinyals等人，2015年b)和选区解析(Vinyals等人，2015年a)。</p></blockquote><h1 id="8248" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">放弃</h1><p id="f457" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">这些故事旨在研究深度学习的能力，而不是提供任何金融或交易建议。请勿将此研究和/或代码用于真实货币。</p><h1 id="cfa0" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">结论</h1><p id="5a4d" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">尽管在我们的多步预测图中，并非所有的预测都是正确的，但请记住两件事:</p><p id="e635" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">1 —这仅仅是开始，正如“继续和扩大研究”一节所建议的，该模型还有很大的改进空间。</p><p id="903a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">2——只要有一定比例的预测正确，就足以盈利。</p><p id="9dc1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一开始，我担心结果会遵循“均值回归”趋势，即预测会试图回到之前的平均价格。但事实并非如此。</p><h1 id="22a8" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">第二部分:使用交易平台的模型</h1><p id="c56d" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">在这个故事的第二部分，我将使用在商业算法交易平台cTrader中构建的相同模型来测试它是否会盈利。我将描述将该模型投入生产的端到端方法的剩余部分。我将模型设置为在web服务器下运行，并公开一个RESTful API，让algo交易平台实时请求预测，然后显示一个盈亏图，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qt"><img src="../Images/3c4925c433fd5c559eb474445249fe7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btLCYfc6Uv_zfxSqymre2Q.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">使用此模型对2020年8月24日和2020年8月30日之间的利润模拟1000进行回溯测试。将在第2部分讨论。捕捉自<a class="ae pj" href="https://ctrader.com/" rel="noopener ugc nofollow" target="_blank"> cTrader </a></figcaption></figure><div class="nk nl gp gr nm nn"><a href="https://medium.com/towards-artificial-intelligence/using-a-tensorflow-deep-learning-model-for-forex-trading-ec4eff2ebe60" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">使用TensorFlow深度学习模型进行外汇交易</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在商业平台上建立一个算法机器人，根据模型的预测进行交易</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="qu l ny nz oa nw ob lb nn"/></div></div></a></div><h1 id="b2a5" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">更多阅读</h1><ul class=""><li id="d3e4" class="lz ma it lf b lg nf lj ng lm ot lq ou lu ov ly me mf mg mh bi translated">使用LSTM深度神经网络进行时间序列预测</li><li id="0c37" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><a class="ae pj" href="https://machinelearningmastery.com/lstms-with-python/" rel="noopener ugc nofollow" target="_blank">来自<a class="ae pj" href="https://machinelearningmastery.com/" rel="noopener ugc nofollow" target="_blank">机器学习大师</a>的杰森·布朗利用Python制作的</a>长短期记忆网络电子书。这是关于LSTM的最好的书面书籍，具有实用和更新的Python代码。</li><li id="8c11" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">艾琳·尼尔森的《实用时间序列分析》一书。这是关于这个主题的最好的实用书籍，但有一个小小的警告:这本书时常在Python和R之间摇摆。</li><li id="0791" class="lz ma it lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated"><a class="ae pj" href="https://www.youtube.com/watch?v=v5ijNXvlC5A" rel="noopener ugc nofollow" target="_blank">现代时间序列分析| SciPy 2019教程</a>YouTube上的Aileen Nielsen。</li></ul><h1 id="5c3e" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">关于我</h1><p id="b35c" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">我有20年的软件工程和金融专业背景。我在伦敦金融城担任软件架构师，我最喜欢的语言是C#和Python。我和实用数学有恋爱关系，和机器学习有暧昧关系。</p><h1 id="30e7" class="oi mo it bd mp oj ok ol ms om on oo mv ki op kj my kl oq km nb ko or kp ne os bi translated">参考</h1><p id="7409" class="pw-post-body-paragraph ld le it lf b lg nf kd li lj ng kg ll lm nh lo lp lq ni ls lt lu nj lw lx ly im bi translated">[1]杰森·布朗利(Jason Brownlee)，<a class="ae pj" href="https://machinelearningmastery.com/lstms-with-python/" rel="noopener ugc nofollow" target="_blank">长短期记忆网络与Python </a> (2019)</p><p id="6382" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">[2] Dominic Masters和Carlo Luschi，<a class="ae pj" href="https://arxiv.org/abs/1804.07612" rel="noopener ugc nofollow" target="_blank">重温深度神经网络的小批量训练</a>，arXiv:1804.07612v1 [cs .2018年4月20日</p><p id="5585" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">[3] Minh-Thang Luong，Quoc V. Le，Ilya Sutskever，Oriol Vinyals，Lukasz Kaiser，<a class="ae pj" href="https://arxiv.org/abs/1511.06114" rel="noopener ugc nofollow" target="_blank">多任务序列到序列学习</a>，作为2016年ICLR会议论文发表</p></div></div>    
</body>
</html>