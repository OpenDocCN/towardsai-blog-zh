<html>
<head>
<title>Uber Uses This Framework for Rapid ML Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优步使用这个框架进行快速ML开发</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/uber-uses-this-framework-for-rapid-ml-development-e4a158b1a73e?source=collection_archive---------1-----------------------#2022-05-02">https://pub.towardsai.net/uber-uses-this-framework-for-rapid-ml-development-e4a158b1a73e?source=collection_archive---------1-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b8ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">PyML是一个允许快速开发与优步基础设施兼容的ML模型的框架。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c983b99bede83a3b60c3f221f4375e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ES3xisFicwZKgDTG.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:优步</figcaption></figure><blockquote class="ky kz la"><p id="2e5b" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我最近创办了一份专注于人工智能的教育时事通讯，已经有超过125，000名订户。《序列》是一份无废话(意思是没有炒作，没有新闻等)的ML导向时事通讯，需要5分钟阅读。目标是让你与机器学习项目、研究论文和概念保持同步。请通过订阅以下内容来尝试一下:</p></blockquote><div class="ly lz gp gr ma mb"><a href="https://thesequence.substack.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">序列</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">与机器学习、人工智能和数据发展保持同步的最佳资源…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">thesequence.substack.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ks mb"/></div></div></a></div><p id="6f8a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">优步一直是试图加速实现现实世界机器学习解决方案的最活跃的公司之一。就在今年，优步推出了像<a class="ae mt" href="https://eng.uber.com/michelangelo-pyml/" rel="noopener ugc nofollow" target="_blank">米开朗基罗</a>、<a class="ae mt" href="http://pyro.ai/" rel="noopener ugc nofollow" target="_blank"> Pyro.ai </a>和<a class="ae mt" href="https://eng.uber.com/horovod/" rel="noopener ugc nofollow" target="_blank"> Horovod </a>这样的技术，专注于现实世界中机器学习解决方案的关键组成部分。优步ML栈中一个不太为人所知的领域是PyML，这是一个能够以一种兼容生产运行时的方式快速开发Python应用程序的库。</p><p id="797f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">PyML试图解决的问题是大规模机器学习应用程序中普遍存在的挑战之一。通常，数据科学家用来构建模型原型的工具和框架与相应的生产运行时之间存在明显的不匹配。例如，数据科学家通常使用基于Python的框架(如PyTorch或Keras)来生成实验模型，然后需要适应运行时(如Apache Spark ML Pipelines ),这带来了非常具体的约束。机器学习技术专家将这个问题称为灵活性和资源效率之间的权衡。在优步的案例中，数据科学家正在Python机器学习框架中构建模型，需要由米开朗基罗团队进行重构，以符合Apache Spark管道的限制。</p><p id="5731" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">克服这一限制意味着扩展米开朗基罗的能力，以支持主流机器学习框架中创作的模型，同时保持训练和优化的一致模型。</p><h1 id="9f50" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">输入PyML</h1><p id="eced" class="pw-post-body-paragraph lb lc it le b lf nm ju lh li nn jx lk mq no ln lo mr np lr ls ms nq lv lw lx im bi translated">优步PyML的目标是简化机器学习应用程序的开发，并弥合实验和生产运行时之间的差距。为了实现这一点，PyML关注三个主要方面:</p><p id="e7f2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">1)为机器学习预测模型提供标准合约。</p><p id="6ba8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">2)支持使用Docker容器打包和部署机器学习模型的一致模型。</p><p id="391c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">3)为在线和离线预测模型启用米开朗基罗集成的运行时。</p><p id="5f49" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">下图说明了PyML的基本架构原则。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d8b55bd2fbb8b966f5d8892df74d66a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*qqyfcyl8zO4fagHmIamNhQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:优步</figcaption></figure><h1 id="cc28" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">标准的机器学习合同</h1><p id="43ab" class="pw-post-body-paragraph lb lc it le b lf nm ju lh li nn jx lk mq no ln lo mr np lr ls ms nq lv lw lx im bi translated">PyML模型可以由不同的机器学习框架创作，如TensorFlow、PyTorch或Scikit-Learn。模型可以使用两种主要类型的数据集:<em class="ld"> DataFrames </em>，它存储表格结构数据，以及<em class="ld"> Tensors </em>，它存储命名的多维数组。在创建模型之后，它们被改编成标准的PyML契约定义，该定义实质上是分别从DataFrameModel或TensorModel抽象类继承的类。在这两种情况下，用户只需要实现两种方法:一种是加载模型参数的构造函数，另一种是接受并返回数据帧或张量的predict()方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/7229740f10ae0ad722a0d20e019965c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZv5RsJQJskASEAAaic7Jw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:优步</figcaption></figure><h1 id="7b49" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">打包和部署</h1><p id="f4c1" class="pw-post-body-paragraph lb lc it le b lf nm ju lh li nn jx lk mq no ln lo mr np lr ls ms nq lv lw lx im bi translated">创建PyML模型后，可以使用一致的结构将它们打包到Docker容器中。PyML引入了基于四个基本构件的标准部署格式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/b1fcb64d24cbe0c6dbc50d3a5a747a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bd7Sf14MROqcZwg8W8vGBQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:优步</figcaption></figure><p id="a6c7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">使用该结构，开发人员可以使用下面的代码打包和部署PyML模型。PyML Docker映像将包含模型和所有相应的依赖项。这些模型将立即在米开朗基罗的控制台上运行。</p><h1 id="9ad7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">离线和在线预测</h1><p id="deda" class="pw-post-body-paragraph lb lc it le b lf nm ju lh li nn jx lk mq no ln lo mr np lr ls ms nq lv lw lx im bi translated">PyML支持批处理(离线)和在线预测执行模型。离线预测被建模为PySpark上的抽象。在这种情况下，PyML用户只需提供一个SQL查询，其中的列名和类型与他们的模型所期望的输入相匹配，并提供一个存储输出预测的目标配置单元表的名称。在后台，PyML启动一个容器化的PySpark作业，使用与在线服务模型相同的图像和Python环境，确保离线和在线预测之间没有差异。执行离线预测相对简单，如以下代码所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/705930afcb0af50caf82df565275b6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHsqq8x652qvhJHLYDFsTg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:优步</figcaption></figure><p id="5850" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">PyML模型的标准双操作(init，predict)契约简化了在线预测的实现。PyML通过为Docker容器启用轻量级gRPC接口来启用在线预测，这些容器由一个常见的在线预测服务使用，如下图所示。根据请求，在线预测服务将通过Mesos的API启动相应的特定于PyML模型的Docker映像，作为嵌套的Docker容器。当容器启动时，它启动PyML RPC服务器，并开始监听来自在线预测服务的Unix域套接字上的预测请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/6d19189a521eec27db990de2037e45cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgvAr68iji9o3cNm1VfU-Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:优步</figcaption></figure><p id="3afe" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mq lm ln lo mr lq lr ls ms lu lv lw lx im bi translated">PyML通过弥合实验和运行时环境之间的差距，解决了大规模机器学习应用程序中最重要的挑战之一。除了其具体的技术贡献，PyML的架构可以适应不同的技术栈，应该作为组织开始机器学习之旅的重要参考</p></div></div>    
</body>
</html>