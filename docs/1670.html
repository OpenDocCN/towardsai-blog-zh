<html>
<head>
<title>GAMs and Smoothing Splines(Part-1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gam和平滑样条(第一部分)</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa?source=collection_archive---------0-----------------------#2021-03-15">https://pub.towardsai.net/gams-and-smoothing-splines-part-1-simplified-8c5e2c10dbaa?source=collection_archive---------0-----------------------#2021-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8f2c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/statistics" rel="noopener ugc nofollow" target="_blank">统计数据</a></h2><div class=""/><p id="b75c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">在</span>当今世界，深度学习被用于大多数机器学习应用，可解释性在现实世界的应用中变得至关重要。模型的可解释性对于理解不同变量如何相互作用以生成模型决策至关重要。</p><p id="396e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在这种情况下，我想总结一个强大的可解释模型家族——广义可加模型(GAM)及其构建模块——平滑样条。</p><p id="f987" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">第1部分文章包括:</p><p id="98b6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">1.游戏攻略</p><p id="ca98" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">2.样条曲线和平滑样条曲线简介</p><p id="de19" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">3.GAM fitting (R)的1D自定义示例</p><p id="cbd1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在下一篇第2部分文章中，我将解释与</p><p id="d1d3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">1.二维扩展——张量积样条</p><h1 id="19ed" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak"> 1。GAMs简介:</strong></h1><p id="22c2" class="pw-post-body-paragraph jz ka it kb b kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw im bi translated">每个人都知道广义线性模型的简单形式，其中响应线性依赖于预测变量(结构如下所示):</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/59bf5c1310585f864ba5b7513b6e6134.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*OrpR0cPLTL49bk5l_WVIHA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">线性模型方程</figcaption></figure><p id="2730" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">其中β为未知参数，<em class="mv">‘X _ I’</em>为预测变量的模型矩阵。我们可以看到，即使我们在<em class="mv">‘X1，X2’</em>或<em class="mv">‘sin(X1)’</em>中有非线性，上述所有方程形式都是线性模型。下面是非线性模型形式—参数具有非线性:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/352c704f48ca911feaaf46a05fd7d6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*45X84GoK8QN4dWr7LNsN-Q.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">非线性模型的一般形式</figcaption></figure><p id="7571" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">广义可加模型-因变量和预测值之间的关系可以是非线性的，也可以是线性的。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/d879ffb7006f69d645eed179b19edbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzL7IFH1TTIT3JOuwGjiIQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">通式</figcaption></figure><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/cc254ac0f1c356dafa4dad469ee8e5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*fU6uQk6snvtBmxQ4JtIrtg.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">简化方程</figcaption></figure><p id="f53e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里，每个预测变量都与近似函数f(x)相拟合。f(x)的一般形式如下</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/4a70a482e02aded8ee2d5d6f3e398d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*ob6MuQPwSRgMGdMtoK0vGA.png"/></div></div></figure><p id="22dd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面，β是系数，“b()”被称为“基函数”，并且可以用类似于R 的多项式函数<em class="mv">“poly(x，2)】来代替，以再次得到本质上是线性的多项式回归。但是一般来说，为了逼近f(x ), gam使用平滑样条。</em></p><h1 id="cd34" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak"> 2。a .花键:</strong></h1><p id="0c31" class="pw-post-body-paragraph jz ka it kb b kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw im bi translated">以逼近预测变量的函数(上面的f(x))。有两种插值。</p><ol class=""><li id="279b" class="ne nf it kb b kc kd kg kh kk ng ko nh ks ni kw nj nk nl nm bi translated">多项式插值:将n次多项式拟合到n+1个数据点的过程。用n次多项式表示基函数的最简单的插值类型。</li></ol><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nn"><img src="../Images/eb1456b813d50711154a049327deac9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTGqkNlip7KlwNVh9xZ24w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源——图片由作者提供。生成这个图像的代码可以在我的<a class="ae no" href="https://github.com/saipradeep-peri/GAMs_Tensor_Products_fits/tree/main/1D_Smoothing_Splines_exp" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</figcaption></figure><p id="15f8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们考虑一个点的附近，这些是有用的。但是，假设多项式的阶数变大(n &gt; 10 ),如上图所示，它们可能在整个数据域范围内大幅振荡(误差较大)(查阅<a class="ae no" href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon" rel="noopener ugc nofollow" target="_blank"> Runge的</a>现象，了解更多关于多项式限制的信息。)</p><p id="34ad" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">2.分段插值:分段多项式插值通过在基于节点或断点划分的每个区间或区域中拟合低次局部多项式来解决上述问题。</p><p id="a133" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">样条是k次分段多项式，即k-纽结，它是连续的并且可以k-1次可微。结、断点或控制点用于定义整个数据域的区间或区域。这些结的位置可以用许多方法来选择，如手动选择，分位数定位等。</p><p id="586d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们看下图，我们可以看到由位于“t1”和“t2”的两个结产生的三个不同的区域或区间。现在，样条使用单独的多项式函数，特定于每个区域。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi np"><img src="../Images/11382c1f6b57a2d2f555c14659b4c369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cheZq3yHxUH9Sc3jJFBPIQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated"><strong class="bd li">来源— ESL图书第5章图5.2 </strong>。具有分段线性基函数的样条。上面，你可以看到3个区间和3个不同的线性函数适合这些区间。</figcaption></figure><p id="359d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">虽然有许多不同类型的样条——自然样条、三次样条、p样条、B样条、回归样条，但在本文中，我将讨论<em class="mv">自然三次样条</em>和<em class="mv">平滑样条</em>及其在GAMs中的应用。</p><p id="218a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">三次样条是这样的样条，其中每个区间都用三次多项式拟合，并且施加了平滑约束(连续性)-二阶导数应该在区间边界(结点位置)匹配。</p><p id="3f32" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在边界处进行多项式拟合会使数据趋势的拟合变差。自然三次样条是通过为边界区间拟合线性基函数来处理这一问题的三次样条。</p><p id="982b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">自然三次样条-其中分段多项式函数是具有连续性和边界约束的三次函数。边界区间中的基函数是线性的。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a188a72df3f53a149b78e478c1da56ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*cHM_tZoOwFaK4GmDhKGXvA.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片。上面表示的是带有自然边界条件的自然三次样条。</figcaption></figure><h1 id="fcec" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">2.b .平滑样条:</h1><p id="39e8" class="pw-post-body-paragraph jz ka it kb b kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw im bi translated">这些是自然三次样条上的正则化回归，它具有通过将所有输入视为结来规避结选择的特性(这里的一般想法是您可以选择大量的结)。这里的正则化是基于通过积分曲线的二阶导数来平滑粗糙度，以最小化曲线的摆动。平滑样条的最小化函数如下。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/99dc025e6a7d2361ea5f470bc88ef78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*w7g1b-eQS0QdNY7-aXLOsA.png"/></div></figure><p id="9294" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">其中‘λ’是平滑参数，如果‘λ’= 0，则不会施加惩罚，这可能会导致非常嘈杂的拟合，如果它是无穷大，则是简单的最小二乘拟合。在上式中，f(x)是自然样条函数。(请理解，这里我们并不试图像线性模型那样开关各个特征的权重)</p><h1 id="f685" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">3.gams (R)的1D拟合示例:</h1><p id="87b7" class="pw-post-body-paragraph jz ka it kb b kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw im bi translated">我将使用R来拟合使用' mgcv()'包的gam模型。我不会在Kaggle的样本数据集上展示拟合过程；相反，我将设计一个带有目标曲线的简单玩具问题(人工数据创建)并解决一个回归问题。我相信，在样本实验曲线上拟合模型比解决一些具有高特征的真实示例数据更能帮助你理解概念，因为你不容易想象下面发生了什么(这是我的教授教我的，我喜欢这种方式)。</p><p id="be4f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">首先，我要创造一个玩具问题</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="13b2" class="nx lh it nt b gy ny nz l oa ob">library(tidyverse)<br/>library(dplyr)<br/>library(ggplot2)<br/>library(mgcv)<br/>library(broom)<br/>library(splines)<br/>library(purrr)</span><span id="fba4" class="nx lh it nt b gy oc nz l oa ob"># grid points<br/>num_fine_int &lt;- 80</span><span id="d540" class="nx lh it nt b gy oc nz l oa ob"># A 1D-grid points on x-axis<br/>fine_grid_list &lt;- list(<br/>  x1 = seq(-2, 2, length.out = num_fine_int+1)<br/>) </span><span id="1b08" class="nx lh it nt b gy oc nz l oa ob"># Lets construct a target variable using natural splines of #certain degrees of freedom<br/>fine_grid &lt;- fine_grid_list %&gt;% as.data.frame() %&gt;% tibble::as_tibble()<br/>fine_basis_mat &lt;- model.matrix(~ ns(x1, df = 8) -1, data = fine_grid)<br/>colnames(fine_basis_mat)</span><span id="dfed" class="nx lh it nt b gy oc nz l oa ob"># Create a rondom set of betas<br/>set.seed(4545)<br/>beta_true &lt;- rnorm(n = ncol(fine_basis_mat), mean = 0, sd = 3)<br/>beta_true</span><span id="4392" class="nx lh it nt b gy oc nz l oa ob"># mean trend or Y generated using betas <br/>mean_trend_true &lt;- as.numeric(fine_basis_mat %*% as.matrix(beta_true))<br/>mean_trend_true</span><span id="3edd" class="nx lh it nt b gy oc nz l oa ob">fine_grid_df &lt;- fine_grid %&gt;% mutate(mean_trend = mean_trend_true)</span><span id="7033" class="nx lh it nt b gy oc nz l oa ob">fine_grid_df %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = mean_trend)) +<br/>  geom_line(size = 1.15) +<br/>  theme_bw()</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi od"><img src="../Images/86ccce890ef469b6843aacdedb6988fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoCSpkhjieWQJMgM8_ryYA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="4bae" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">上面，我们使用自然样条和随机正态系数创建了一个样本数据趋势。我们可以在上面的图像中看到目标趋势。</p><p id="1037" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，让我们向完美的趋势线添加一些随机噪声，因为我们的目标是检查我们的gam()模型是否能从噪声数据中正确预测趋势。我们将尝试使用粗网格点来训练模型(40个数据点的一半)，并使用另一半进行预测。</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="6b30" class="nx lh it nt b gy ny nz l oa ob">### generate the noisy observations<br/>sd_noise_1d &lt;- 0.3 # noise</span><span id="cf61" class="nx lh it nt b gy oc nz l oa ob">set.seed(65646)<br/>fine_df_1d &lt;- fine_grid_df %&gt;% <br/>  mutate(y = rnorm(n = n(), mean = mean_trend, sd = sd_noise_1d))</span><span id="30cd" class="nx lh it nt b gy oc nz l oa ob">### work with a coarse grid instead of all of the points in the fine grid<br/>num_coarse_int &lt;- 40</span><span id="f0f7" class="nx lh it nt b gy oc nz l oa ob">coarse_grid_list &lt;- list(<br/>  x1 = seq(-2, 2, length.out = num_coarse_int+1)<br/>)<br/>coarse_grid &lt;- coarse_grid_list %&gt;% as.data.frame() %&gt;% tibble::as_tibble()</span><span id="bc78" class="nx lh it nt b gy oc nz l oa ob">train_df_1d &lt;- fine_df_1d %&gt;% <br/>  right_join(coarse_grid, by = c("x1"))</span><span id="58e7" class="nx lh it nt b gy oc nz l oa ob">train_df_1d %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = mean_trend)) +<br/>  geom_line(size = 1.15) +<br/>  geom_point(mapping = aes(y = y), color = "red") +<br/>  theme_bw()</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oe"><img src="../Images/e58a1bee3b0bdd14e7a3fa33ccaa4c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yq_ldLoV4sEU97lC8RknOg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="2797" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">相对于原始响应，可以在上图中看到噪声列车观测值。红点是我们的训练数据，粗黑线是我们的实际反应。现在我们已经为玩具问题设置了所有变量，现在让我们尝试使用gam()拟合来预测上述数据的平均趋势。</p><p id="70af" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，对于模型拟合，我将向您展示两种建模方法。第一种是使用‘R’的mgcv()包中的gam()函数。第二种方法是首先拟合平滑样条(生成基函数)，然后使用线性模型来拟合这些样条(这是gam正在做的事情，至少在本例中是这样)。</p><p id="6806" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">来自mgcv的gam():</p><p id="8550" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">S() -&gt;暗示平滑样条，bs参数是你想要使用的样条类型(<a class="ae no" href="https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/smooth.terms.html" rel="noopener ugc nofollow" target="_blank">链接</a>获取文档)，你也可以通过参数k指定你想要使用的结数。</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="b83e" class="nx lh it nt b gy ny nz l oa ob"># only training on coarse grid points<br/>model &lt;- gam(y ~ s(x1, bs = 'cs'), data = train_df_1d)<br/>summary(model)</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi of"><img src="../Images/55d512c012b5abc4066a2865a8858c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDdXX_Nl99Su-wQIebkJdA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="a3cc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">可以使用“visreg()”来可视化gam模型预测，如下所示</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="b358" class="nx lh it nt b gy ny nz l oa ob">library(visreg)<br/>visreg(model, "x1",jitter = TRUE, line=list(col="blue"), fill=list(col="orange"))</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi og"><img src="../Images/1b6184d613ac2740fe428b448f2acd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9J1KwMhZjM-PMPnheEXYQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="512c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我更喜欢用“ggplot()”来可视化事物，因为它提供了很大的灵活性。</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="1a79" class="nx lh it nt b gy ny nz l oa ob">#Prediction on the entire dataset<br/>prediction &lt;- predict.gam(model, newdata = fine_df_1d)</span><span id="b4f3" class="nx lh it nt b gy oc nz l oa ob">fine_df_1d %&gt;%<br/>  mutate(y_pred = prediction) %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = mean_trend)) +<br/>  geom_line(size = 1.15) +<br/>  geom_line(mapping = aes(y = y_pred), color = 'green', size = 1.5, linetype = 'dashed') +<br/>  geom_point(mapping = aes(y = y), color = "red") +<br/>  theme_bw()</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oh"><img src="../Images/bd278e136a50439bdd4d48422476c9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZBJk70A5B7UYdtmbtfgzw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="74fc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面的ggplot中，红点是目标；黑线表示平均趋势，绿色虚线表示从gam()模型生成的预测。</p><p id="382b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">上面的方法是通过gam()直接拟合。现在，让我们打破常规，用一个正常的一步一步的过程来拟合上面的模型(我喜欢这种方法，因为这更容易解释)。</p><p id="ec31" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">由于游戏使用平滑样条，让我们基于数据构建一个平滑样条。我将使用mgcv包中的<a class="ae no" href="https://www.rdocumentation.org/packages/mgcv/versions/1.8-33/topics/smoothCon" rel="noopener ugc nofollow" target="_blank">smooths con()</a>——它以给定输入的基矩阵的形式生成函数smooth。</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="1867" class="nx lh it nt b gy ny nz l oa ob"># This creates the basis functions<br/>CubicSplines_smooth = smoothCon(s(x1, bs = 'cs'), data = train_df_1d)[[1]]</span><span id="94fb" class="nx lh it nt b gy oc nz l oa ob">#CubicSplines_smooth$S -&gt; this is the penalty matrix integral part<br/># but not using here.</span><span id="237f" class="nx lh it nt b gy oc nz l oa ob"># Lets visualize all the basis functions<br/>CubicSplines_smooth$X %&gt;% as.data.frame() %&gt;% tibble::as_tibble() %&gt;%<br/>  mutate(x1 = train_df_1d$x1) %&gt;% <br/>  tibble::rowid_to_column() %&gt;% <br/>  tidyr::gather(key = "key", value = "value", -rowid, -x1) %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = value)) +<br/>  geom_line(mapping = aes(color = key),<br/>            size = 1.15) +<br/>  theme_bw() +<br/>  theme(legend.position = "top")</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oi"><img src="../Images/41d04a0d9fc4e82f018a24440c022797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gzjC2HL41qpMLby7Gow2w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="2a34" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果你观察上面的图，它表示每个基函数的趋势，现在再看看下面的样条函数方程。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/4a70a482e02aded8ee2d5d6f3e398d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*ob6MuQPwSRgMGdMtoK0vGA.png"/></div></div></figure><p id="ba50" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">每个b(x)代表一个基函数，所有单个基函数都可以在上图中观察到。对此我遇到的另一种解释是，它就像一个单一的手动层神经网络，但神经元是静态的。每个基函数代表一个神经元和要学习的系数β，最后，所有神经元加在一起(如果你喜欢就用这个解释，如果你认为这不符合你的观点就不用)。</p><p id="7569" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我们有了基本的功能。我们需要做的就是学习贝塔系数。如果你正确地看上面的等式，你会得到这样的想法，问题基本上简化为一个光滑样条基础上的线性模型。所以，你甚至可以用lm()模型来拟合这个，这样会给你等价的结果(你也可以不使用s()而直接使用变量本身来使用同一个gam()，但是我想用lm()模型来展示这一点)。</p><p id="d89b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在下面，正则化部分不包括在内，但如果你想知道如何做到这一点，SmoothCon函数会给你一个惩罚矩阵(在这种情况下是CubicSplines_smooth$S)。所以，你可以用‘广义交叉验证’来调优‘lambda’，结果等同于gam。但是在下面，我不包括正则化部分(请查看我的git hub <a class="ae no" href="https://github.com/saipradeep-peri/GAMs_Tensor_Products_fits" rel="noopener ugc nofollow" target="_blank"> repo </a>来寻找这方面的一些实验)。</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="8fdd" class="nx lh it nt b gy ny nz l oa ob"># Linear regression model on top of Smoothing splines basis.<br/>CubicSplines_smooth_df &lt;- CubicSplines_smooth$X %&gt;% as.data.frame() %&gt;% tbl_df() %&gt;% mutate(y = train_df_1d$y)<br/>CubicSplines_smooth_fit &lt;- lm(y ~ . - 1, data = CubicSplines_smooth_df)<br/>CubicSplines_smooth_fit %&gt;% summary()</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oj"><img src="../Images/66d7b9097f5fda3174f255dd6e1838da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2aFP6XXaKeCR6nozbYxkw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><p id="5346" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，这种方法的预测有点不同，因为您需要构建一个测试基础矩阵，然后使用训练好的线性模型进行预测。</p><pre class="mk ml mm mn gt ns nt nu nv aw nw bi"><span id="e69f" class="nx lh it nt b gy ny nz l oa ob"># Building the test basis matrix using train smoothCon variable.<br/>CubicSplines_smooth_test_basis_df &lt;- PredictMat(CubicSplines_smooth, fine_df_1d) %&gt;% as.data.frame() %&gt;% tbl_df()</span><span id="d713" class="nx lh it nt b gy oc nz l oa ob"># Prediction on test basis matrix<br/>CubicSplines_overfit_test_pred &lt;- predict(CubicSplines_smooth_fit, newdata = CubicSplines_smooth_test_basis_df)</span><span id="6534" class="nx lh it nt b gy oc nz l oa ob">fine_df_1d %&gt;%<br/>  mutate(y_pred = CubicSplines_overfit_test_pred) %&gt;%<br/>  ggplot(mapping = aes(x = x1, y = mean_trend)) +<br/>  geom_line(size = 1.15) +<br/>  geom_line(mapping = aes(y = y_pred), color = 'green', size = 1.5, linetype = 'dashed') +<br/>  geom_point(mapping = aes(y = y), color = "red") +<br/>  theme_bw()</span></pre><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oe"><img src="../Images/2de59fc47fa3e2cca15c5effc96bcb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yl2B2XHaWdKWLG_tLIOng.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">来源—作者提供的图片</figcaption></figure><h2 id="a275" class="nx lh it bd li ok ol dn lm om on dp lq kk oo op lu ko oq or ly ks os ot mc iz bi translated">结论:</h2><p id="3449" class="pw-post-body-paragraph jz ka it kb b kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw im bi translated">在这篇第1部分的文章中，我解释了广义可加模型的一般概念，平滑样条，以及如何使用人工数据在R中使用和解释它们。在第2部分的文章中，我将尝试使用张量样条来解释二维交互样条，并在gam中使用它们。</p><p id="f367" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">查看我的<a class="ae no" href="https://github.com/saipradeep-peri/GAMs_Tensor_Products_fits" rel="noopener ugc nofollow" target="_blank"> Github </a> repo，获得更多关于1D平滑的示例实验代码，使用不同的样条类型和使用optim()函数的手动正则化部分。</p><p id="3274" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">参考资料:</p><ol class=""><li id="8cc5" class="ne nf it kb b kc kd kg kh kk ng ko nh ks ni kw nj nk nl nm bi translated">统计学习的要素——数据挖掘、推理和预测。</li><li id="e298" class="ne nf it kb b kc ou kg ov kk ow ko ox ks oy kw nj nk nl nm bi translated">广义加性模型导论。</li><li id="c38c" class="ne nf it kb b kc ou kg ov kk ow ko ox ks oy kw nj nk nl nm bi translated"><a class="ae no" href="https://m-clark.github.io/generalized-additive-models/" rel="noopener ugc nofollow" target="_blank">https://m-clark.github.io/generalized-additive-models</a></li></ol></div></div>    
</body>
</html>