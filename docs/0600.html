<html>
<head>
<title>Solving an Amazon Interview Question with Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用代码解决亚马逊面试问题</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/solving-an-amazon-interview-question-with-code-afaf2b8d0539?source=collection_archive---------1-----------------------#2020-06-18">https://pub.towardsai.net/solving-an-amazon-interview-question-with-code-afaf2b8d0539?source=collection_archive---------1-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ebe9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a>，<a class="ae ep" href="https://towardsai.net/p/category/software-engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a></h2><div class=""/><div class=""><h2 id="bad4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">让我们来看看在亚马逊、谷歌和优步的面试中用过的一个算法问题。包括一个Python实现。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7c50dbf7e0aac70ef4aca43618b21dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lk9skfaHGYb_Xe-LxW3MDg.png"/></div></div></figure><h1 id="cf92" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">这个问题</h1><p id="a88b" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">我们有两个已排序的数组A和B。如果我们将这两个数组连接起来并排序，我们将得到一个新的数组，称为C。例如，如果A = [1，4，6，7]，B = [2，2，13]，那么C = [1，2，2，4，6，7，13]。</p><p id="d5eb" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我们的任务是在O(log(n+m))时间内确定C的中位数。</p><p id="b3d9" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">问题是我们没有得到C，我们只得到A和B。时间复杂度限制意味着显式计算C是不可行的，因为我们必须对长度为(A) +长度为(B)的数组进行排序。</p><p id="b328" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">所以我们的任务就是找到一个高效的方法来求C的中值。</p><h1 id="c0bb" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">解决问题</h1><h2 id="46ce" class="mw le it bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt iz bi translated">第0部分:中位数和排序数组</h2><p id="6ddf" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">中位数的一个很好的特性是，很容易使一个<em class="nh">排序的</em>数组变小，并保持相同的中位数——只需从中位数上方和下方移除相同数量的元素。</p><p id="9033" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">考虑[1，4，5，6，9]。5在中间，是中位数。但是，如果我们移除顶部和底部的元素，则得到数组[4，5，6]——5仍然是中间值。</p><p id="e707" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">如果我们将这一点发挥到极致，创建具有相同中值的最小可能数组，对于具有偶数个元素的数组，如[1，2，3，4，5，6]，我们将只保留中间的两个元素[3，4]，而对于具有奇数个元素的数组，如[1，3，5，7，9]，我们可以删除所有元素，只保留中间的一个元素，只保留[5]。</p><p id="2eef" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">如果我们的数组分成两个有序的部分呢？我们的策略基本上是一样的，只是稍微复杂一点。我们将想要识别我们确信不是中间两个元素(如果是偶数)或中间元素(如果是奇数)的元素，并且从上面和下面移除相等的数量，从而保持中间值相同。</p><h2 id="4458" class="mw le it bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt iz bi translated">第一部分:我们的算法</h2><ol class=""><li id="5918" class="ni nj it lx b ly lz mb mc me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx jd">我们识别中位数。</strong></li><li id="9350" class="ni nj it lx b ly nr mb ns me nt mi nu mm nv mq nn no np nq bi translated"><strong class="lx jd">我们比较中位数。</strong></li></ol><p id="1ce7" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这使我们可以确定，一定数量的元素高于中值，一些元素低于中值。</p><p id="0161" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">为什么假设B的中位数大于A的中位数。现在，选择一个高于B的中值且也在B中的元素。根据定义，这个元素<em class="nh">保证</em>大于B中低于中值的所有元素。但是<em class="nh">也是</em>保证大于A中低于A中中值的所有元素，因为B的中值大于A中的中值。</p><p id="c906" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">一个简短的例子如下。</p><p id="1ace" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">设A = [1，2，3，4]，B = [1，3，3，5，5，5，f]</p><p id="e4f2" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">A的中位数是2.5，B的中位数是5。我们可以立即推导出1 ≤ f，因为1≤A的中值≤B的中值≤ f</p><p id="8a86" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">3.<strong class="lx jd">我们确定哪个数组的元素更少</strong></p><p id="7d87" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这是必要的，因为我们希望从C的中值上方的T2中移除与从中值下方的T4中移除相同数量的元素。在上面的示例中，如果我们移除了B的单个中间元素上方的3个元素，但仅移除了A的两个中间元素下方的一个元素，那么我们将从C的中值上方移除3个元素，从下方移除1个元素。结果数组可能会有不同的中值。</p><p id="065c" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">4.我们从较短的数组中移除尽可能多的元素，从较长的数组中移除相同数量的元素</p><p id="994f" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这个过程可以在下图中看到。这遵循逻辑in ( <strong class="lx jd"> 3 </strong>)确保我们从C的中值以上和C的中值以下移除尽可能多的元素</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5baaadfc35b030bc3c775ae34789ee0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*ydLmS18QVaQNeWNP7qdktg.png"/></div></figure><p id="6fa7" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">5 <strong class="lx jd">我们重复步骤(1–4 ),直到两个数组中较小的一个足够小。然后我们加入并排序</strong></p><p id="e38b" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">通过重复步骤1-4，我们每次从较短的数组中删除不到一半的元素。这意味着在O(log(min(n，m)))时间内，我们可以得到基本情况。例如，如果一个数组长度为16，另一个长度为1000000，那么将较小的数组减少到只有2个元素需要4个步骤。然后用O(log(max(n，m)))将剩下的2个元素排序到更大的数组中，并计算出中间值。</p><h2 id="74fc" class="mw le it bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt iz bi translated">第二部分:代码实现</h2><p id="b37c" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">在我的python代码中，“基本情况”如下。当第一个数组或第二个数组的长度≤3时，我们只需继续，对两个数组进行排序，并直接找到中间值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3af560103514020fca9816399fc411fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*2x10AEGE4VQVtgTf1_o7tA.png"/></div></figure><p id="0101" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">在我们从顶部和底部移除元素之前，我们要重新标记。我们把元素多的数组叫做longer_array，它的长度是long_num，元素少的数组是shorter _ array，长度是short_num。这是因为，虽然我们可能希望将两者大致分成两半，并且如果一个数组比另一个长得多，则保留每一个的一半，但是我们可能不会从中值以上和中值/以下移除相同数量的元素</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1011a9a7090b84bb27ee214cdd310be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*fdm0P9sd_76p7x_KhZv1mA.png"/></div></figure><p id="2611" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">接下来，我们确定长数组和短数组的中间值</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b00d403e574db9e408115b65c1e92c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*0zQmXcV3UjXCVNp-zFBeLQ.png"/></div></figure><p id="df95" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">为此，我们使用一个我定义的助手函数，称为median_val。这只是接收一个数组及其长度，并返回其中值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/eeb13fb4addc1672ee7ff816c1547bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*iw6uLuGrFjkF13_l0bVx0w.png"/></div></figure><p id="4786" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">在我们定义了两个数组的中值之后，我们有两种情况:第一种情况shorter_array有一个较小的中值，第二种情况shorter_array有一个较大的中值。</p><p id="2cf1" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我们看第一种情况。在这里，我们标识新的缩短数组，并将它们作为递归调用传递回我们的函数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/55f9ed44122839bcc17cdd4791c7cf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dvcf3KidBYiHaUhYff6b6g.png"/></div></div></figure><p id="80de" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我们来分析一下。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="3c05" class="mw le it od b gy oh oi l oj ok">shorter_array[short_num - (short_num//2 + 1):]</span></pre><p id="2594" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">是第一个论点。在这种情况下，由于short_array的中值较小，所以我们只想保留其中较大的一半。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="4e9c" class="mw le it od b gy oh oi l oj ok">[short_num - (short_num//2 + 1):]</span></pre><p id="1633" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">看起来很丑，而且很复杂，但这只是算术。之所以有点混乱，是因为我们想要一个对奇数和偶数大小的数组都适用的方程。</p><p id="7fd1" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我们函数的第二个参数如下</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="47a1" class="mw le it od b gy oh oi l oj ok">short_num//2 + 1</span></pre><p id="1651" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这只是第一个子句中指定的数组长度。如果用python编码，也可以使用<code class="fe ol om on od b">len</code>方法</p><p id="1109" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我们函数的第三和第四个参数是</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="36a1" class="mw le it od b gy oh oi l oj ok">longer_array[0:long_num - ((short_num-1)//2)], long_num - ((short_num-1)//2)</span></pre><p id="4d45" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这与第一个和第二个参数的作用相同——标识我们要保留的数组部分及其长度。请注意较长数组的长度是如何减少(short_num-1)//2的，这与我们减少较短数组长度的量完全相同。</p><p id="92ff" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><em class="nh"> else </em>子句做了同样的事情，但是对于较短的数组有较大的中值的情况。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/2b69b31ddf6de190d880737c00bd4145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Y6pRKzB48D01jUQ4B_Fyw.png"/></div></div></figure><h1 id="e003" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">时间复杂度</h1><p id="03fd" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">如果m是我们较短的数组的大小，我们每次都要移除(几乎)它的一半元素，所以将它减少到我们的基本情况需要log(m)时间。在我们的基本情况下，我们已经从另一个数组中删除了大约m个元素，剩下一个大小大约为n-m的数组。如果您预先确定了基本情况的大小，那么将有限数量的元素(在我们的情况下是3个)添加到一个排序列表中需要O(log(n))的时间。最后，提取中值是对排序列表的O(1)时间操作。这意味着我们的算法是O(log(m) +log(n))，当n≥m时，就是O(log(n)) = O(log(n+m)。</p><p id="19e1" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">要知道为什么O(log(n)) = O(log(n+m))，观察log(n+m) ≤ log(2n) = log(n) + log(2)。</p><p id="51c4" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><em class="nh">感谢您花时间阅读本文，希望您喜欢:)请在下面告诉我您的意见。如果有人想看这个算法的C语言实现，我可以添加。我是剑桥大学的一名数学系学生，也是一名非常业余的程序员:)—你可以在twitter上关注我的(大部分)数学和(一些)编程，我是</em><a class="ae op" href="https://twitter.com/MathmoThe" rel="noopener ugc nofollow" target="_blank"><em class="nh">Ethan _ the _ mathmo</em></a></p></div></div>    
</body>
</html>