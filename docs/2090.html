<html>
<head>
<title>Numpy: Binary Operations with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy:使用Python的二进制运算</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/numpy-binary-operations-with-python-10e6d6827634?source=collection_archive---------2-----------------------#2021-08-12">https://pub.towardsai.net/numpy-binary-operations-with-python-10e6d6827634?source=collection_archive---------2-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1626" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="cf84" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">运算符作用于位来执行逐位运算</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d823b479521908f27cda928e2a460aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*la_W9dFWsliUgMg4"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="li lj lk"><p id="d889" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">二元运算</em> </strong></p></blockquote><p id="1886" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">二元运算是通过组合两个值来创建新值的简单运算。我们使用二元运算符，如按位and、or、xor等。，以执行二进制计算。这些运算符作用于位来执行逐位运算。</p><blockquote class="li lj lk"><p id="2d87" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">numpy . bitwise _ and()</em></strong></p></blockquote><p id="501c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.bitwise_and()函数计算两个给定整数的相应二进制值的按位and，输出以整数形式返回。</p><p id="7e5d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="1d0f" class="mq mr it mm b gy ms mt l mu mv">import numpy as make</span><span id="49e9" class="mq mr it mm b gy mw mt l mu mv">num1 = 30<br/>num2 = 40</span><span id="732a" class="mq mr it mm b gy mw mt l mu mv">print(“Number1: “,num1)<br/>print(“Number2: “,num2)</span><span id="b32c" class="mq mr it mm b gy mw mt l mu mv">output = make.bitwise_and(num1,num2)</span><span id="0c21" class="mq mr it mm b gy mw mt l mu mv">print(“Bitwise of 30 and 40: “,output)</span><span id="4689" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Number1: 30<br/>Number2: 40<br/>Bitwise of 30 and 40: 8</span></pre><p id="7933" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">说明:</strong></p><p id="e074" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">让我们清楚地理解这个概念，考虑如下的和真值表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bd4d57b76e9669ce9208bd7233ada4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*fROwvTQ1Hhk6VVD0j8iHPw.png"/></div></figure><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="2993" class="mq mr it mm b gy ms mt l mu mv">The binary value of 30 = 11110<br/>The binary value of 40 = 101000</span></pre><p id="bb85" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们通过将这两个二进制值相加来获得按位and。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/7e5e8574f06a10fe0e3ed3c6045f71a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*np1qRmeAG578Ygvgmhsscg.png"/></div></figure><blockquote class="li lj lk"><p id="9bfa" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">numpy . bitwise _ or()</em></strong></p></blockquote><p id="3f79" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.bitwise_or函数计算两个给定整数的相应二进制值的位或，输出以整数形式返回。</p><p id="9fb6" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="9dbb" class="mq mr it mm b gy ms mt l mu mv">import numpy as make</span><span id="b261" class="mq mr it mm b gy mw mt l mu mv">num1 = 45<br/>num2 = 17</span><span id="438f" class="mq mr it mm b gy mw mt l mu mv">print(“Number1: “,num1)<br/>print(“Number2: “,num2)</span><span id="596c" class="mq mr it mm b gy mw mt l mu mv">output = make.bitwise_or(num1,num2)</span><span id="3e32" class="mq mr it mm b gy mw mt l mu mv">print(“Bitwise of 45 and 17: “,output)</span><span id="7752" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Number1: 45<br/>Number2: 17<br/>Bitwise of 30 and 40: 61</span></pre><p id="bc5c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解释:</strong></p><p id="05e2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">让我们清楚地理解这个概念，考虑下面的或真值表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1b41d2591cda91419ce9eba91b810896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*zUZYykbb4MlzXwRx-aS8Yg.png"/></div></figure><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="b26b" class="mq mr it mm b gy ms mt l mu mv">The binary value of 45 = 101101<br/>The binary value of 17 = 10001</span></pre><p id="00a9" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们通过将这两个二进制数相加得到按位“或”。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b6b6cce423e2cf5520ca7fccf4176571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*-FFrYl9RzVVrthw4GUWkAg.png"/></div></figure><p id="cc1f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们可以看到，作为和得到的二进制值是111101，换算成十六进制就是61。因此得到的输出是61。</p><blockquote class="li lj lk"><p id="522d" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">numpy . bitwise _ xor()</em></strong></p></blockquote><p id="d010" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.bitwise_xor函数计算两个给定整数的相应二进制值的按位xor，输出以整数形式返回。</p><p id="17d8" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="c6c7" class="mq mr it mm b gy ms mt l mu mv">import numpy as make</span><span id="6851" class="mq mr it mm b gy mw mt l mu mv">num1 = 20<br/>num2 = 17</span><span id="c7c9" class="mq mr it mm b gy mw mt l mu mv">print(“Number1: “,num1)<br/>print(“Number2: “,num2)</span><span id="4b6a" class="mq mr it mm b gy mw mt l mu mv">output = make.bitwise_xor(num1,num2)</span><span id="ecdb" class="mq mr it mm b gy mw mt l mu mv">print(“Bitwise of 20 and 17: “,output)</span><span id="68bb" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Number1: 20<br/>Number2: 17<br/>Bitwise of 20 and 17: 5</span></pre><p id="2152" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解释:</strong></p><p id="03e9" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">让我们清楚地理解这个概念，考虑下面的XOR表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/638a0c00ac607d7c987ebc97484aaf6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*v91jGChDouq5GqhPYid0og.png"/></div></figure><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="5eca" class="mq mr it mm b gy ms mt l mu mv">The binary value of 20 = 101101<br/>The binary value of 17 = 10001</span></pre><p id="9632" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们通过使用上述xor表条件将二进制值相加来获得按位xor:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi na"><img src="../Images/37901a3bf73a4c10112407c9ba78031b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*wECSLTzMyhkp4qHy2HrCYA.png"/></div></div></figure><p id="0c29" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们可以看到，作为和得到的二进制值是0101，换算成十六进制就是5。因此得到的输出是5。</p><blockquote class="li lj lk"><p id="3404" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">【numpy . invert()</em></strong></p></blockquote><p id="e515" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.invert()函数计算数组或整数的位非。</p><p id="46ca" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">注意:</strong>对于有符号整数输入值，返回的输出是二进制补码。这里负数用它们的绝对值来表示。</p><p id="2abb" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="a42b" class="mq mr it mm b gy ms mt l mu mv"><strong class="mm jd">#integer</strong></span><span id="5f83" class="mq mr it mm b gy mw mt l mu mv">import numpy as make</span><span id="f98d" class="mq mr it mm b gy mw mt l mu mv">num1 = 20<br/>print(“Number1: “,num1)</span><span id="a7a1" class="mq mr it mm b gy mw mt l mu mv">output1 = make.invert(num1)<br/>print(“Inversion of number: “,output1)</span><span id="9c97" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">#array<br/></strong>num2 = [1,3,6]<br/>print(“Number2: “,num2)</span><span id="719c" class="mq mr it mm b gy mw mt l mu mv">output2 = make.invert(num2)<br/>print(“Inversion of array: “,output2)</span><span id="fc68" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Number1: 20<br/>Inversion of number -21</span><span id="8ec4" class="mq mr it mm b gy mw mt l mu mv">Number2: [1, 3, 6]<br/>Inversion of array [-2 -4 -7]</span></pre><p id="d7a9" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解说:</strong></p><ul class=""><li id="2d8d" class="nc nd it lo b lp lq ls lt mi ne mj nf mk ng mh nh ni nj nk bi translated">在第一段代码中，要求对整数求逆。所以在这里，20的二进制数是10100。在这个二进制值上加上“1”。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b02b13fad95f394e9b78b4718104b2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*aonC67u6NXcGP09VvzxQKw.png"/></div></figure><ul class=""><li id="14dd" class="nc nd it lo b lp lq ls lt mi ne mj nf mk ng mh nh ni nj nk bi translated">现在，我们只对二进制值为“1”的那些取2x值。还有，前面加减号。因此，我们将“20”、“21”和“22”相加，得到的输出为-21。</li></ul><p id="595b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">同样的方法也适用于数组中的元素。</p><blockquote class="li lj lk"><p id="fea9" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">numpy . left _ shift()</em></strong></p></blockquote><p id="b2aa" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.left_shift()函数的作用是:根据所需的位数，将整数的位数向左移动。例如:如果需要向左移动2位。为此，会在二进制值的最右端追加两个零。</p><p id="3695" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="6df5" class="mq mr it mm b gy ms mt l mu mv">import numpy as trial</span><span id="cae1" class="mq mr it mm b gy mw mt l mu mv">num = 8<br/>shift_bit = 3</span><span id="f5c2" class="mq mr it mm b gy mw mt l mu mv">print(“Number Inputted:”,num)<br/>print(“Number of bits to be shifted:”,shift_bit)</span><span id="0a6c" class="mq mr it mm b gy mw mt l mu mv">output = trial.left_shift(num,shift_bit)<br/>print(“After shifting:”,output)</span><span id="d667" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Number Inputted: 8<br/>Number of bits to be shifted: 3<br/>After shifting: 64</span></pre><p id="a507" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解释:</strong></p><p id="72cc" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这里，二进制值8 = 1000，要移位的位数是3。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e5dbf24a60b7bf6c1b49f9bd47372cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*vElE6aUHIFckDYrtAPVQkA.png"/></div></figure><p id="1c15" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们现在已经向左移动了位。现在，我们只对二进制值为“1”的那些取2x值。在这里，只有‘26’。因此，输出返回为64。</p><blockquote class="li lj lk"><p id="357a" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">【numpy . right _ shift()</em></strong></p></blockquote><p id="cdb1" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.right_shift()函数根据所需的位数将整数的位数向右移动。例如:如果需要向右移动2位。为此，从最右边的位置开始减少两个二进制位。</p><p id="38e5" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="1ad5" class="mq mr it mm b gy ms mt l mu mv">import numpy as trial</span><span id="f739" class="mq mr it mm b gy mw mt l mu mv">num = 8<br/>shift_bit = 3</span><span id="62c8" class="mq mr it mm b gy mw mt l mu mv">print(“Number Inputted:”,num)<br/>print(“Number of bits to be shifted:”,shift_bit)</span><span id="c5a9" class="mq mr it mm b gy mw mt l mu mv">output = trial.right_shift(num,shift_bit)<br/>print(“After shifting:”,output)</span><span id="e346" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Number Inputted: 8<br/>Number of bits to be shifted: 3<br/>After shifting: 1</span></pre><p id="6886" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">说明:</strong></p><p id="502f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这里，二进制值8 = 1000，要移位的位数是3。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/50b223ad8e4c830337bf11f7427edc69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*4GowDyRNwMTrNLT3CZMaFw.png"/></div></figure><p id="ad76" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们现在已经将这些位向右移动了。现在，我们只对二进制值为“1”的那些取2x值。在这里，只有‘20’。因此，输出返回为1。</p><blockquote class="li lj lk"><p id="9436" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">numpy . binary _ repr(number，width=None) </em> </strong></p></blockquote><p id="ab13" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.binary_repr()函数查找输入整数或元素数组的二进制值。</p><p id="3b22" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">注:</strong></p><ul class=""><li id="afc6" class="nc nd it lo b lp lq ls lt mi ne mj nf mk ng mh nh ni nj nk bi translated">当对负数使用width时，返回该宽度的二进制补码，或者在前面加上减号。</li><li id="81fe" class="nc nd it lo b lp nn ls no mi np mj nq mk nr mh nh ni nj nk bi translated">对于有符号整数输入值，二进制补码作为输出返回。同样，二进制补码中的负数用它们的绝对值来表示。</li></ul><p id="4fc4" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="3740" class="mq mr it mm b gy ms mt l mu mv"><strong class="mm jd">#simple program</strong></span><span id="3210" class="mq mr it mm b gy mw mt l mu mv">import numpy as trial</span><span id="7842" class="mq mr it mm b gy mw mt l mu mv">num1 = 70<br/>print(“Number: “,num1)</span><span id="5131" class="mq mr it mm b gy mw mt l mu mv">output1 = trial.binary_repr(num1)<br/>print(“Binary representation of 70: “,output1)</span><span id="bdb1" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">#using arrays without width parameter</strong></span><span id="0738" class="mq mr it mm b gy mw mt l mu mv">import numpy as trial</span><span id="ceb2" class="mq mr it mm b gy mw mt l mu mv">arr = [6,-19]<br/>print(“Array:”,arr)</span><span id="e2f2" class="mq mr it mm b gy mw mt l mu mv">out_arr = trial.binary_repr(arr[0])<br/>print(“Binary representation of 6 without width parameter:”,out_arr)</span><span id="9e75" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">#using arrays with width parameter</strong></span><span id="c55b" class="mq mr it mm b gy mw mt l mu mv">import numpy as trial</span><span id="f5e1" class="mq mr it mm b gy mw mt l mu mv">arr = [6,-19]<br/>print(“Array:”,arr)</span><span id="b662" class="mq mr it mm b gy mw mt l mu mv">out_arr = trial.binary_repr(arr[0], width = 6)<br/>print(“Binary representation of 6 with width parameter:”,out_arr)</span><span id="3dd5" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:</strong></span><span id="dfad" class="mq mr it mm b gy mw mt l mu mv">Number: 70<br/>Binary representation of 70: 1000110</span><span id="ba1e" class="mq mr it mm b gy mw mt l mu mv">Array: [6, -19]<br/>Binary representation of 6 without width parameter: 110</span><span id="7ae6" class="mq mr it mm b gy mw mt l mu mv">Array: [6, -19]<br/>Binary representation of 6 with width parameter: 000110</span></pre><blockquote class="li lj lk"><p id="6965" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">numpy . pack bits(myarray，axis=None) </em> </strong></p></blockquote><p id="053a" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.packbits()函数将一个二进制值数组的元素打包成一个“uint8”数组。通过插入零比特，结果在末尾被填充。输入数组的每个元素代表一个位域，该位域解包为一个二进制值输出数组。并且作为输出获得的形状或者是相同的，或者是沿着指定轴的一维形状。</p><p id="ac7b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="0dc9" class="mq mr it mm b gy ms mt l mu mv">import numpy as np</span><span id="a7f6" class="mq mr it mm b gy mw mt l mu mv">x = np.array([[[1,1,1],[0,0,0]],[[1,0,1],[0,1,0]]])<br/>y = np.packbits(x, axis=-1)</span><span id="6f0b" class="mq mr it mm b gy mw mt l mu mv">print(y)</span><span id="9bcc" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:</strong></span><span id="4a72" class="mq mr it mm b gy mw mt l mu mv">[[[224]<br/>[0]]<br/>[[160]<br/>[64]]]</span></pre><blockquote class="li lj lk"><p id="8f6f" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it">【numpy . unpackbits(myarray，axis=None) </em> </strong></p></blockquote><p id="421f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">numpy.unpackbits()函数与numpy.packbits()函数正好相反。它将“uint8”数组的一个元素解包为二进制值输出数组。</p><p id="152f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">程序:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="37e1" class="mq mr it mm b gy ms mt l mu mv">import numpy as np</span><span id="bd08" class="mq mr it mm b gy mw mt l mu mv">x = np.array([[69], [79], [88]], dtype=np.uint8)<br/>y = np.unpackbits(x, axis=1)</span><span id="2594" class="mq mr it mm b gy mw mt l mu mv">print(y)</span><span id="0e8b" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>[[0 1 0 0 0 1 0 1]<br/>[0 1 0 0 1 1 1 1]<br/>[0 1 0 1 1 0 0 0]]</span></pre><p id="c76e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">结论:</strong></p><p id="f7fd" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">总之，本文涵盖了Numpy二元运算的基础知识。我强烈建议阅读更多的文章，并使用python程序应用这些概念，因为每个模块中都有许多函数，您可以在这个主题上进行实验。</p><p id="b8ce" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="903f" class="ns mr it bd nt nu nv nw nx ny nz oa ob ki oc kj od kl oe km of ko og kp oh oi bi translated">推荐文章</h1><p id="fafc" class="pw-post-body-paragraph ll lm it lo b lp oj kd lr ls ok kg lu mi ol lx ly mj om mb mc mk on mf mg mh im bi translated">1.<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b?source=friends_link&amp;sk=4a5c9f9ad552005636ae720a658281b1">8 Python的主动学习见解收集模块</a> <br/> 2。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a>T5】3。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff?source=friends_link&amp;sk=11c6809f6623dd4f6dd74d43727297cf">熊猫:处理分类数据</a> <br/> 5。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/hyper-parameters-randomseachcv-and-gridsearchcv-in-machine-learning-b7d091cf56f4?source=friends_link&amp;sk=cab337083fb09601114a6e466ec59689">超参数:机器学习中的RandomSeachCV和GridSearchCV</a><br/>6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-distribution-using-numpy-with-python-3b64aae6f9d6?source=friends_link&amp;sk=809e75802cbd25ddceb5f0f6496c9803">数据分发使用Numpy与Python </a> <br/> 9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/decision-trees-vs-random-forests-in-machine-learning-be56c093b0f?source=friends_link&amp;sk=91377248a43b62fe7aeb89a69e590860">机器学习中的决策树vs随机森林</a> <br/> 10。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/standardization-in-data-preprocessing-with-python-96ae89d2f658?source=friends_link&amp;sk=f348435582e8fbb47407e9b359787e41">用Python实现数据预处理的标准化</a></p></div></div>    
</body>
</html>