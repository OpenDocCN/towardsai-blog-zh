<html>
<head>
<title>Python and Multi-CPU-Arch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和多CPU架构</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/python-and-multi-cpu-arch-5c5a8c905ba5?source=collection_archive---------1-----------------------#2022-10-09">https://pub.towardsai.net/python-and-multi-cpu-arch-5c5a8c905ba5?source=collection_archive---------1-----------------------#2022-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4bbc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可靠地修复mac M1/M2上的python工具链损坏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f6d876b78f25c602cfb2851a2d4871c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c_6J1SH00mdfJmd9"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯托夫·高尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="93c8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="71b3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">python的设计目标之一是与平台无关，并且无需修改即可跨环境运行脚本。只要应用程序和库是使用Python脚本编写的，python就能很好地确保这种兼容性。随着python的流行和适应性的增加，越来越多的库开始使用python扩展来包含本机编译的代码，以提高性能和效率。像pandas和NumPy这样的流行python库可以高效地处理大量数据，这要归功于它们的本地扩展。随着越来越多的python库开始使用本机编译的代码，平台兼容性问题开始在python环境中出现。如果你使用的是基于Mx(M1/M2)的MacBooks，你很可能会在python环境中发现平台兼容性问题。本文讨论python库管理器(如pip和conda)如何管理平台相关的二进制文件，它们为什么会崩溃，以及如何在Mac M1/M2系统上以更简单、更可靠和可复制的方式克服它们。</p><p id="4eb0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Python二进制文件和任何其他二进制文件一样，是针对不同的CPU架构和平台(Windows/Mac/Linux)单独编译的。当python在系统中安装Python库时，它会收集和处理特定于本地CPU和平台的元数据。如果python库包含任何本机扩展，则需要将其编译成CPU和特定于平台的二进制文件，以便在本地运行。简要了解python包管理器如‘PIP’和‘conda’如何管理CPU和平台依赖性，将有助于理解它的缺点以及如何克服它们。</p><h1 id="5194" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">PIP多拱支架</h1><p id="f61e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PIP使用“轮子”打包标准来分发python包。“Wheel”是一个打包系统，用于以源代码和编译的二进制格式打包纯python脚本和本机扩展。要更好地了解pip如何维护不同的分发格式，请访问您选择的图书馆的“PIP”网页，然后单击“下载文件”。在这个页面上,“源代码发行版”部分列出了源代码格式的可用包,“构建的发行版”部分列出了所有预构建的二进制格式的可用包。例如，这个页面<a class="ae kv" href="https://pypi.org/project/pandas/#files" rel="noopener ugc nofollow" target="_blank">链接</a>显示了“熊猫”库的源代码和预构建的发行版。这些分发包遵循下面指定的命名约定。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4cab" class="mu kx iq mq b gy mv mw l mx my">{dist}-{version}(-{build})?-{python}-{abi}-{platform}.whl</span></pre><p id="751d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">{括号}中的每一部分都是一个标签或轮子名称的一个组成部分，其中包含一些关于轮子包含的内容以及轮子在哪里可以工作或不可以工作的含义。示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="de52" class="mu kx iq mq b gy mv mw l mx my">pandas-1.5.0-cp311-cp311-macosx_11_0_arm64.whl</span></pre><blockquote class="mz na nb"><p id="6527" class="lo lp nc lq b lr mk jr lt lu ml ju lw nd mm lz ma ne mn md me nf mo mh mi mj ij bi translated">pandas —是库名<br/> 1.5.0 —是库版本<br/> cp11 —最低要求python版本<br/> cp11 —最低要求应用二进制接口(ABI)<br/>ma cosx _ 11 _ 0 _ arm 64—平台标签再细分如下:<br/>—ma cosx—操作系统<br/>—11 _ 0—最低要求MacOS SDK版本<br/>—arm 64—Cpu架构</p></blockquote><p id="1a5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PIP命名约定还支持“通配符”来优化软件包。比如‘chardet-3 . 0 . 4-py2 . py3-none-any . whl’既支持python2又支持python3，对ABI没有依赖性，可以安装在任何平台和CPU架构上。许多python库使用这些通配符选项来优化包包的数量。有关Python“轮子”和PIP的更多信息，请参考<a class="ae kv" href="https://realpython.com/python-wheels/" rel="noopener ugc nofollow" target="_blank">什么是Python轮子，为什么要关注？</a></p><p id="9334" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为什么PIP安装失败？</p><p id="537f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">大多数情况下，PIP安装失败有两个主要原因。首先，如果存储库中没有预构建的库，PIP将在主机系统上编译本机扩展源代码。为此，它希望构建工具和其他依赖库在主机上可用。有时候，这对于本地安装构建依赖项来说是一个挑战，尤其是当依赖树变得很深的时候。</p><p id="058b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第二，由于轮包名称中的“通配符”。MacBook最近推出了基于arm的“M1/M2”CPU架构。一些用于macOS的较旧的wheel包被列为CPU架构的“any ”,因为x86是当时唯一支持的架构。如果PIP将软件包依赖关系解析为这些旧版本中的一个，PIP将在新的CPU架构上安装这个软件包，假设它可以运行。这个问题的一个例子是包“azure-eventhub”。此库依赖于另一个名为“uamqp”的库。本库列出了与M1/M2 arm64处理器不兼容的macOS通用/通配符包。如果你在M1/M2安装“azure-eventhub ”,你会看到这个包会成功安装，但在导入这个包时会抛出一个运行时异常。</p><h1 id="5cb4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">康达多拱支架</h1><p id="da50" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Conda在确保平台可移植性方面更进了一步。Conda不仅打包了python库，还打包了针对不同操作系统和CPU架构的相关库、二进制文件、编译器和python解释器本身。这样可以确保整个工具链可以跨环境移植。因为所有依赖的二进制文件都打包了python库，所以除了标准的C库之外，它不期望对本地系统有任何依赖。那么，如果conda提供了更好的可移植性，并修复了PIP的缺点，会出什么问题呢？问题是在Conda中并不是所有的python包都可用。在conda环境中使用pip来安装在conda中不可用的python包是很常见的；因此，人们暴露了PIP的缺点。再次(不是吹毛求疵)“azure-eventhub”包就是一个相同的例子。</p><p id="03a1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果有人遇到这样的平台兼容性问题，并且在论坛中搜索解决方案时，他会遇到不同的选项，如安装特定版本的python或库，通过其他打包系统(如“brew ”)安装库或安装替代包等。许多这样的修复对于生产来说是不可靠的，并且可能无法跨其他系统复制。下面精选了三个选项，它们是克服python平台兼容性问题的更简单、可靠且可复制的方法。它们是:</p><ul class=""><li id="85d4" class="ng nh iq lq b lr mk lu ml lx ni mb nj mf nk mj nl nm nn no bi translated">Pip从源安装</li><li id="b7a4" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">康达&amp;罗塞塔</li><li id="606c" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">多克多拱建筑</li></ul><h1 id="ff44" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Pip从源安装</h1><p id="7a36" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果一个包的本地代码的编译依赖是最小的，那么可以在主机系统上重新编译它。当python工具链(库)安装失败时，最有可能的是，破坏的不是顶层包，而是嵌套在依赖关系树中的依赖包。可以使用下面的命令来指示pip不要安装软件包的二进制版本。例如，下面的命令将跳过“uamqp”的二进制pip版本，并从源代码编译它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1839" class="mu kx iq mq b gy mv mw l mx my">pip install --no-binary uamqp <!-- -->azure-eventhub</span></pre><h1 id="1677" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">康达&amp;罗塞塔</h1><p id="1b0f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">解决这个问题的另一种方法是利用“Rosetta”。在Rosetta上运行x86版本的python的最简单的选择是使用conda平台覆盖选项。例子</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b884" class="mu kx iq mq b gy mv mw l mx my">CONDA_SUBDIR=osx-64 conda create -n myenv_x86 python=3.10<br/>conda activate myenv_x86<br/>conda config --env --set subdir osx-64</span><span id="eb08" class="mu kx iq mq b gy nu mw l mx my">#Config its using x86_64 platform version of python<br/>python -c "import platform;print(platform.machine())"</span></pre><p id="d89a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在执行conda环境创建命令时,“CONDA_SUBDIR”环境变量会覆盖CONDA的CPU架构。conda config命令始终覆盖新环境中的CPU架构，因此无需为该环境中的所有其他命令设置“CONDA_SUBDIR”。在创建一个新的环境并将conda平台覆盖到x86之后，它的行为就像任何其他conda环境一样。人们可以在这个环境中进行PIP安装，它将安装x86版本的python库。在同一个终端中，多个conda环境之间的切换是无缝的，甚至像VS Code这样的其他工具也可以无缝地工作，没有任何问题。</p><h1 id="2c11" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">多拱码头</h1><p id="0f5a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">第三种选择是再次利用罗塞塔，但通过“码头工人”。这是可跨多个环境和用户工作的最可移植和最无缝的选项。Docker的Multi-Platform功能可用于强制在M1/M2 MacBooks上构建x86 docker映像。当向码头工人运行呈现x86码头工人映像时，其在内部使用Rosetta来运行该映像。以下是构建x86跨平台docker映像的步骤。</p><p id="28c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nc">样本备审文件:</em></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b095" class="mu kx iq mq b gy mv mw l mx my">FROM ubuntu<br/>RUN apt-get update<br/>RUN apt-get install -y python3<br/>CMD ["/usr/bin/python3", "-c", "import platform; print(\"Platform:\", platform.machine())"]</span></pre><p id="5db5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nc">打造x86码头工人形象:</em></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f6ed" class="mu kx iq mq b gy mv mw l mx my">$ docker build <strong class="mq ir">--platform linux/amd64</strong> . -t img_x86</span></pre><p id="7c78" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nc">运行x86码头工人形象:</em></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="46e3" class="mu kx iq mq b gy mv mw l mx my">$ docker run <strong class="mq ir">--platform linux/amd64</strong> -it img_x86<br/>Platform: x86_64</span></pre><p id="dd64" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了更好地跨多个用户和环境进行移植，可以使用Dockerfile的FROM命令中的“平台”选项。这确保即使用户未指定build命令的“platform”选项，也可以使用x86映像。</p><p id="7986" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="nc">样本备审文件:</em></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a8d8" class="mu kx iq mq b gy mv mw l mx my">FROM <strong class="mq ir">--platform=linux/amd64</strong> ubuntu</span><span id="8001" class="mu kx iq mq b gy nu mw l mx my">RUN apt-get update<br/>RUN apt-get install -y python3<br/>CMD ["/usr/bin/python3", "-c", "import platform; print(\"Platform:\", platform.machine())"]</span></pre><p id="dbc5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此码头工人文件将构建x86码头工人映像，而不使用“platform”码头工人构建选项。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f891" class="mu kx iq mq b gy mv mw l mx my">$ docker build . -t img_x86<br/>$ docker run -it img_x86<br/>Platform: x86_64</span></pre><h1 id="69c8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="2774" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">上述选项可能不是可靠地修复python平台兼容性问题的唯一方法，但我相信，对于我们中的许多人来说，它们将成为一种通用的无需思考的方法，可以快速克服此类问题，避免沮丧，并节省寻找自定义解决方案的时间。希望在不久的将来，Python生态系统将进一步发展和成熟，以便无缝地处理多个CPU和平台，而无需用户的任何额外参与。</p></div></div>    
</body>
</html>