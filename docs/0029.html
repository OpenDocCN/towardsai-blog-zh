<html>
<head>
<title>An Introduction to Time-series Analysis Using Python and Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Pandas进行时间序列分析的介绍</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/an-introduction-to-time-series-analysis-using-python-and-pandas-222fe72b191a?source=collection_archive---------1-----------------------#2019-04-12">https://pub.towardsai.net/an-introduction-to-time-series-analysis-using-python-and-pandas-222fe72b191a?source=collection_archive---------1-----------------------#2019-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="be4a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">时间序列分析简介| <a class="ae ep" href="https://towardsai.net" rel="noopener ugc nofollow" target="_blank">走向人工智能</a></h2><div class=""/><div class=""><h2 id="5c1b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">分析和<em class="kr">站产生</em>时间序列的第一步</h2></div><p id="d0c4" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">最近，我有机会作为一名POC来建立一名销售预测员。这是一个具有挑战性的项目，其结果是一个很酷的MVP，通过这篇文章，我将分享我的部分旅程和分析我所获得的数据的发现。</p><h2 id="83fd" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">假设</h2><p id="546d" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">我假设你以前对Python和熊猫都有所了解。</p><h2 id="eea6" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">首先要做的是…</h2><p id="b48e" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">这个项目像其他数据科学项目一样开始:通过检查我们手头的数据。为此，我导入了作为数据源提供的CSV文件。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ad8e" class="lo lp it mq b gy mu mv l mw mx">path_to_csv = r'path\to\csv\file.csv'<br/>data_df = pd.read_csv(path_to_csv)<br/>data_df.head()</span></pre><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi my"><img src="../Images/415c794661ee2a27ea0ab56e6a07868e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwPE7z6jHfv1vog2sAJ1OQ.png"/></div></div></figure><p id="437a" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">一旦我对数据有了一个清晰的概念，我就开始了最初的探索和通常的转换。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d219" class="lo lp it mq b gy mu mv l mw mx"># Check for nulls: <br/>data_df.loc[data_df['cantidad'].isnull()]</span><span id="bb35" class="lo lp it mq b gy ng mv l mw mx"># Check for other odd values: data_df[data_df['cantidad'].isin([np.nan, np.inf, -np.inf])]</span><span id="9630" class="lo lp it mq b gy ng mv l mw mx"># convert column fecha to datetime<br/>data_df['fecha'] = data_df['fecha'].astype('datetime64[ns]')</span><span id="d709" class="lo lp it mq b gy ng mv l mw mx"># Replace NaN values<br/>data_df['cantidad'] = data_df['cantidad'].fillna(0)</span></pre><p id="ee5b" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">为了简化将来对pandas数据帧的操作，我将‘fecha’作为数据帧的索引。由于记录已经按顺序出现，因此很容易执行这种转换，并通过对整个数据帧进行重新采样，将数据帧转换为具有“每日级别”频率的序列。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="636f" class="lo lp it mq b gy mu mv l mw mx">data_df.index = data_df.fecha<br/>data_df = data_df.resample('D').mean()</span></pre><p id="1132" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">更新索引还有助于以更直观的方式检索数据。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ec3b" class="lo lp it mq b gy mu mv l mw mx"># this will work for ranges:<br/>data_df['2014-02-01':'2015-02-02']<br/># this will work for a given year:<br/>data_df['2016']</span></pre><p id="4337" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">完成上述转换后，就可以绘制数据了。在matplotlib库的帮助下，我能够显示这些年来每天销售的产品数量的图表。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f635" class="lo lp it mq b gy mu mv l mw mx">data_df.plot(figsize=(15,8), title= 'Ventas Por Día', fontsize=14)<br/>plt.show()</span></pre><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nh"><img src="../Images/6b973cad0a696ace5aae218a683005c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-4MP9OD-l8aKLbly3DfMQ.png"/></div></div></figure><h2 id="ca4e" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">那么……什么是时间序列，它的特别之处是什么？</h2><p id="b7da" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">从最初的数据探索来看，很明显我们正在处理一个被称为<a class="ae ni" href="https://en.wikipedia.org/wiki/Time_series" rel="noopener ugc nofollow" target="_blank">的时间序列</a>。时间序列只是我们处理按时间顺序索引的数据点的一种奇特方式。</p><p id="3c88" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">通常，在处理时间序列时，我们会在数据中寻找一些特殊的特征，以便能够基于这些特征进行预测。具体来说，我们寻找一个平稳的时间序列。</p><h2 id="b717" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">时间序列的平稳性</h2><p id="f432" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">当时间序列的均值和方差不是时间的函数时，我们可以说时间序列是平稳的(即，它们在时间上是恒定的)。</p><p id="cbe8" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">平稳性很重要，因为大多数进行分析和预测的统计方法都是在假设统计特性(均值、方差、相关性等)的基础上进行的。)在时间上是常数。</p><h2 id="8474" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">如何检验一个时间序列的平稳性？</h2><p id="f988" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">可以通过两种方式评估平稳性:</p><ul class=""><li id="b852" class="nj nk it ku b kv kw ky kz lb nl lf nm lj nn ln no np nq nr bi translated">目视检查数据点，并检查统计特性如何随时间变化。</li><li id="0022" class="nj nk it ku b kv ns ky nt lb nu lf nv lj nw ln no np nq nr bi translated">进行迪基-富勒试验。</li></ul><p id="e95f" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">让我们先来一个视觉化的方法，看看效果如何。</p><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nx"><img src="../Images/00409993682f817d9bf68a75265fd5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1ab0IWQOqvssL6tPmH6zg.png"/></div></div></figure><p id="c22d" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">通过标绘标准偏差和平均值以及原始数据点，我们可以看到它们在时间上是恒定的。然而，它们似乎遵循一种循环行为。</p><p id="fa82" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">虽然视觉方法可以给我们一个线索，但应用Dicky-Fuller测试(DF-test)可以提供一个更精确的方法来测量我们的序列的平稳性。</p><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ny"><img src="../Images/005c2d7d8908b9d0df8ae232696e6cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4xynK13FXRTuPcI2hSvjg.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">DF测试的结果</figcaption></figure><p id="3263" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我不会详细介绍DF测试是如何工作的，但是假设我们需要关心的是我们在“测试统计”和“临界值”中看到的数字。我们总是希望前者小于后者。检验统计值越小越好。</p><p id="dfcc" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">假设检验统计量小于所有临界值，我们的序列是平稳的，尽管不是很多。</p><p id="bd95" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如果你需要的话，下面是我用来评估平稳性的代码。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0926" class="lo lp it mq b gy mu mv l mw mx">def test_stationarity(timeseries):<br/>    <br/>    # Determining rolling statistics<br/>    rolmean = timeseries.rolling(12).mean()<br/>    rolstd = timeseries.rolling(12).std()<br/><br/>    # Plot rolling statistics:<br/>    orig = plt.plot(timeseries, color='blue',label='Original')<br/>    mean = plt.plot(rolmean, color='red', label='Rolling Mean')<br/>    std = plt.plot(rolstd, color='black', label = 'Rolling Std')<br/>    plt.legend(loc='best')<br/>    plt.title('Rolling Mean &amp; Standard Deviation')<br/>    plt.show(block=False)<br/>    <br/>    # Perform Dickey-Fuller test:<br/>    print ('Results of Dickey-Fuller Test:')<br/>    timeseries = timeseries.iloc[:,0].values<br/>    dftest = adfuller(timeseries, autolag='AIC')<br/>    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])<br/>    for key,value in dftest[4].items():<br/>        dfoutput['Critical Value (%s)'%key] = value<br/>    print(dfoutput)</span></pre><h2 id="d07d" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">如果我们的时间序列是非平稳的呢？</h2><p id="0ce3" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">有一些技术可以应用于<em class="od">站出现</em>一个时间序列。我比较熟悉的两个是:</p><ul class=""><li id="b623" class="nj nk it ku b kv kw ky kz lb nl lf nm lj nn ln no np nq nr bi translated">变换:应用对较大值比对较小值惩罚更多的变换。这些可以是取对数、平方根、立方根等。这种方法有助于减少这种趋势。</li><li id="c8c7" class="nj nk it ku b kv ns ky nt lb nu lf nv lj nw ln no np nq nr bi translated">差异:将某一特定时刻的观察值与前一时间点的观察值进行比较。这处理了趋势和季节性，因此提高了平稳性。</li></ul><p id="19fe" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">熊猫和numpy为你提供了应用这些技术的非常实用的方法。</p><p id="b7e4" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">为了便于演示，我将对数据帧应用对数变换。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fd64" class="lo lp it mq b gy mu mv l mw mx"># Transform the dataframe:<br/>ts_log = np.log(data_df)</span><span id="51ea" class="lo lp it mq b gy ng mv l mw mx"># Replace infs with NaN<br/>ts_log.replace([np.inf, -np.inf], np.nan, inplace=True)</span><span id="78ba" class="lo lp it mq b gy ng mv l mw mx"># Remove all the NaN values<br/>ts_log.dropna(inplace=True)</span></pre><p id="9265" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated"><strong class="ku jd">奖励跟踪:</strong>我们甚至可以对转换后的数据集应用平滑技术来消除可能存在的噪声。一种常见的平滑技术是从数据集中减去移动平均值。这可以通过以下方式轻松实现:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="298c" class="lo lp it mq b gy mu mv l mw mx"># Get the moving average of the series<br/>moving_avg = ts_log.rolling(12).mean() # 12 months</span><span id="be86" class="lo lp it mq b gy ng mv l mw mx"># Subtract the moving average of the log-transformed dataframe<br/>ts_log_moving_avg_diff = ts_log - moving_avg</span><span id="29fb" class="lo lp it mq b gy ng mv l mw mx"># Remove all the NaN values<br/>ts_log_moving_avg_diff.dropna(inplace=True)<br/>test_stationarity(ts_log_moving_avg_diff)</span></pre><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oe"><img src="../Images/9bfe4bad3ca86c1a9239e017e98ff687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCAoSxMhevb2hw6xBDTsxA.png"/></div></div></figure><p id="f033" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">显然，我们可以看到，将对数变换+移动平均平滑应用于我们的原始序列产生了更好的序列；在平稳性方面。</p><p id="843c" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">要应用差分，可以使用Pandas shift()函数。在这种情况下，使用以下代码应用一阶差分。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="afd8" class="lo lp it mq b gy mu mv l mw mx">ts_log_diff = ts_log - ts_log.shift()<br/>plt.plot(ts_log_diff)</span></pre><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi of"><img src="../Images/20a6a9b6616b64d302d4d8e8e2484a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwLzkOANs5THuiUhBK974A.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">差分后的对数转换数据集</figcaption></figure><p id="cbfb" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">让我们对这个新的结果系列进行DF测试。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="21c6" class="lo lp it mq b gy mu mv l mw mx">ts_log_diff.dropna(inplace=True)<br/>test_stationarity(ts_log_diff)</span></pre><figure class="ml mm mn mo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi oe"><img src="../Images/433625e69a0f9eee22301af95bd92e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dC9oMJ1K5vnxPT9ItPsWCg.png"/></div></div></figure><p id="969e" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">通过对数变换和差分，检验统计量明显小于临界值，因此该序列比原始序列更加平稳。</p><h2 id="b13b" class="lo lp it bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf iz bi translated">正在总结…</h2><p id="5f74" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">当我们面对一个涉及时间序列的预测任务时，我们需要分析所述序列并确定它是否是平稳的。为了确定平稳性，我们可以绘制数据并直观地检查平均值和其他统计属性，或者执行Dickey-Fuller测试并查看测试统计和临界值。如果序列碰巧是非平稳的，我们可以应用变换或差分等技术使序列平稳。</p><p id="3cc0" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在所有这些分析和准备之后，项目的下一步是用时间序列进行预测，但这是另一篇文章的主题:)</p></div></div>    
</body>
</html>