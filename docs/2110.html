<html>
<head>
<title>How To Iterate a DataFrame in Python Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python Pandas中迭代数据帧</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/iterating-a-dataframe-in-python-pandas-16812526d943?source=collection_archive---------0-----------------------#2021-08-20">https://pub.towardsai.net/iterating-a-dataframe-in-python-pandas-16812526d943?source=collection_archive---------0-----------------------#2021-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9fe3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="290b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">就性能而言，哪种方式最好？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b3e10033284b7f5ea7682865c8e1600e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAQ9Prpi8AD4QFCyfUGvFg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">来自<a class="ae lh" href="https://wall.alphacoders.com/big.php?i=370118" rel="noopener ugc nofollow" target="_blank">壁纸深渊</a></figcaption></figure><p id="fbaf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Pandas是处理数据的最流行的Python包之一。如果你是一名数据分析师\科学家或任何需要你处理数据的角色，你可能每天都会用到熊猫。</p><p id="6ed6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设Github stars和forks在一定程度上准确地模拟了一个包的受欢迎程度，那么让我们来看看pandas与它的一些替代品相比表现如何</p><ul class=""><li id="987b" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><a class="ae lh" href="https://github.com/pandas-dev/pandas" rel="noopener ugc nofollow" target="_blank">熊猫</a> — 30.7k星，12.9k叉</li><li id="6940" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://github.com/apache/spark" rel="noopener ugc nofollow" target="_blank">火花</a> — 30.6k星，24.3k叉</li><li id="02f1" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://github.com/dask/dask" rel="noopener ugc nofollow" target="_blank"> Dask </a> — 8.7k星，1.3k叉</li><li id="abb3" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://github.com/pola-rs/polars" rel="noopener ugc nofollow" target="_blank"> Polars </a> — 2.2k星，120叉</li><li id="4337" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://github.com/vaexio/vaex" rel="noopener ugc nofollow" target="_blank"> Vaex </a> — 6.5k星，505叉</li></ul><p id="e76b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以是的，熊猫很受欢迎，我们现在可以继续了。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="dbe8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">创建一个DataFrame相当容易，下面一行就足够了</p><pre class="ks kt ku kv gt mz na nb nc aw nd bi"><span id="a945" class="ne nf it na b gy ng nh l ni nj">import pandas as pd</span><span id="8cff" class="ne nf it na b gy nk nh l ni nj">df = pd.DataFrame({'col1': [1, 2, 3], 'col2': [4, 5, 6]})</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0c77b2e1602a8c608531dd8949fa5d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*Nu3-D_NAC2dvJW6yG7FpUQ.jpeg"/></div></figure><p id="65ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在假设我们实际上不需要这两列，我们只关心它们相乘的结果。</p><p id="571e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“未受过训练的数据帧”想到的最天真的解决方案是——让我们迭代每一行，并在列值之间相乘。</p><p id="4923" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这个解决方案，我们先用<code class="fe nm nn no na b"><a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iterrows.html" rel="noopener ugc nofollow" target="_blank">iterrows</a>()</code>来介绍一下自己。<br/>从文档中，<em class="np">以(索引，序列)对的形式迭代数据帧行。</em>"，<br/>所以在每次迭代中，我们得到行的索引和行本身。</p><pre class="ks kt ku kv gt mz na nb nc aw nd bi"><span id="5046" class="ne nf it na b gy ng nh l ni nj">def df_iterrows(df):<br/>  result = []<br/>  for index, row in df.iterrows():<br/>    result.append(row['col1'] * row['col2'])<br/>return result</span></pre><p id="4aac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这当然不是唯一的方法，实际上，这是最糟糕的方法。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="acdd" class="ne nf it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of iz bi translated"><a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">数据帧应用</a></h2><p id="6f29" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">第二种方法是对数据帧的行应用函数。在这种情况下，我们不需要自己迭代这些行，这已经很好了。</p><pre class="ks kt ku kv gt mz na nb nc aw nd bi"><span id="238a" class="ne nf it na b gy ng nh l ni nj">def df_apply(df):<br/>  func_to_apply = lambda row: row['col1'] * row['col2']<br/>  return df.apply(func_to_apply, axis=1)</span></pre><p id="7e65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(是的，你可以用一行代码完成，但是我觉得这个版本可读性更强)</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="0902" class="ne nf it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of iz bi translated">列表理解</h2><p id="21a3" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">我认为列表理解是Python中最好的特性之一，它对我们的情况也有帮助</p><pre class="ks kt ku kv gt mz na nb nc aw nd bi"><span id="210f" class="ne nf it na b gy ng nh l ni nj">def list_comp(df):<br/>    return [x * y for x, y in zip(df['col1'], df['col2'])]</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="aaa8" class="ne nf it bd nq nr ns dn nt nu nv dp nw lr nx ny nz lv oa ob oc lz od oe of iz bi translated">…向量化…</h2><p id="1c6f" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">矢量化是将标量程序转换为矢量程序的术语。矢量化程序可以从一条指令中运行多个操作，而标量程序一次只能对成对的操作数进行操作。</p><p id="0b02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们讨论的所有方法都是标量函数——它们只对两个操作数执行运算。</p><p id="866f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将把“col1”和“col2”的所有列值收集到一个向量中，然后执行我们的操作，而不是乘以每行每列的元素。</p><pre class="ks kt ku kv gt mz na nb nc aw nd bi"><span id="8c6a" class="ne nf it na b gy ng nh l ni nj">def vectorize(df):<br/>    return df['col1'] * df['col2']</span></pre><p id="eea7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将要介绍的<em class="np">下一个也是最后一个</em>方法包括一个小小的变化——我们将把Series对象转换成NumPy数组。</p><pre class="ks kt ku kv gt mz na nb nc aw nd bi"><span id="6ad4" class="ne nf it na b gy ng nh l ni nj">def vectorize_numpy(df):<br/>    return df['col1'].to_numpy() * df['col2'].to_numpy()</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="d397" class="ol nf it bd nq om on oo nt op oq or nw ki os kj nz kl ot km oc ko ou kp of ov bi translated">特性试验</h1><p id="47d0" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">现在剩下的就是检查这些方法的表现。</p><p id="877d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#iteration" rel="noopener ugc nofollow" target="_blank">熊猫文献</a>上写着</p><blockquote class="ow ox oy"><p id="3fd8" class="li lj np lk b ll lm kd ln lo lp kg lq oz ls lt lu pa lw lx ly pb ma mb mc md im bi translated">遍历熊猫对象通常很慢。在许多情况下，不需要手动迭代这些行，并且可以避免</p></blockquote><p id="3c26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，当我们看到迭代方法表现最差时，我们不会感到非常惊讶。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/3e1f170a177cd58772f5692326018aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJfWl2Dng94JYKYKMD8esA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">对数标度的两个轴</figcaption></figure><h1 id="833e" class="ol nf it bd nq om pd oo nt op pe or nw ki pf kj nz kl pg km oc ko ph kp of ov bi translated">结论</h1><p id="5865" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">正如Pandas文档中所建议的，您应该尝试并避免迭代数据帧。<br/>总是试图寻找一个矢量化的解决方案，如果你有一个函数不能在完整的数据框架上工作，使用<code class="fe nm nn no na b">apply()</code>而不是迭代。</p><p id="d2e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想向你介绍我的博客，在那里我每周上传计算机科学中相似和不同的主题。</p><p id="d248" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，如果你考虑订阅Medium，并希望支持我，请注册我的<a class="ae lh" href="https://eliran9692.medium.com/membership" rel="noopener">推荐链接</a>。</p></div></div>    
</body>
</html>