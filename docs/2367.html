<html>
<head>
<title>Optimization Tips and Tricks to Improve Python Codes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进Python代码的优化技巧和诀窍</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/optimization-tips-and-tricks-to-improve-python-codes-80785240c99?source=collection_archive---------1-----------------------#2021-11-24">https://pub.towardsai.net/optimization-tips-and-tricks-to-improve-python-codes-80785240c99?source=collection_archive---------1-----------------------#2021-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="389b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="9fa6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">提高python程序的速度和性能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/15ad0aa4ae8f108db4603cfe6e239a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fWvwbrPvZHH2nkiq"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃米尔·佩龙</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e560" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将看到一些python示例，以获得python代码的帮助，使程序在速度和性能方面更加优化。</p><p id="3345" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行时间长的冗长程序你不烦吗？没有问题的读者，因为这篇文章将帮助你指导如何有效地编写你的python代码而不影响它的性能。</p><p id="d293" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">优化您的Python代码是绝对必要的，这将使您的程序更加高效，节省系统内存并更快地获得结果。优化代码的一些方法；列表理解、内置函数和库等。</p><p id="eb18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为编程的初学者，人们选择Python作为他们的第一语言，因为这种语言简单易学，并且已经在多个应用程序中使用。</p><p id="89d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看一些特性，通过它们我们可以使python程序变得更快一点。</p><blockquote class="me mf mg"><p id="8d5d" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">使用内置函数和库</em> </strong></p></blockquote><p id="17dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">内置函数不过是Python中预定义的函数。这些函数的使用减少了你的程序的大小，并使它更加有效。这样，当一个简单的内置函数可以修复它时，就不需要实现复杂的循环。</p><p id="8c0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们考虑一个简单的例子，要求打印给定列表中最大的数字。</p><h2 id="bf73" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序1 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="588d" class="ml mm it ne b gy ni nj l nk nl">Numbers = [4, 5, 7, 9, 10]<br/>max_number = 0</span><span id="6a9c" class="ml mm it ne b gy nm nj l nk nl">for i in Numbers:<br/>    while i &gt; max_number:<br/>        max_number = i</span><span id="60a4" class="ml mm it ne b gy nm nj l nk nl">print(max_number)</span></pre><h2 id="6d29" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序2 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="319d" class="ml mm it ne b gy ni nj l nk nl">list = [4, 5, 7, 9, 10]<br/>print(max(list))</span></pre><h2 id="4486" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出:</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="c48d" class="ml mm it ne b gy ni nj l nk nl">10</span></pre><h2 id="75bc" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><p id="95de" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">从上面的程序中，我们可以了解到，像' max()'这样简单的内置函数消除了第一个程序中繁琐的代码行的使用。这些函数有助于你的程序得到优化。当您运行大量代码时，内置函数非常友好。</p><blockquote class="me mf mg"><p id="ed12" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">使用排序函数中的关键参数</em> </strong></p></blockquote><p id="ad70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“排序”函数返回列表或元组中已排序元素的列表，而不改变原始序列。在“排序”函数中，使用key参数是优化代码的另一种方式。让我们看一个例子。这里的要求是根据列表中元素的长度对列表进行排序:</p><h2 id="e012" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序:</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="839c" class="ml mm it ne b gy ni nj l nk nl">list = [‘aaaaaa’, ‘bb’, ‘ccc’, ‘d’]<br/>print(sorted(list, key=len))</span></pre><h2 id="b3f2" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出:</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="88d8" class="ml mm it ne b gy ni nj l nk nl">[‘d’, ‘bb’, ‘ccc’, ‘aaaaaa’]</span></pre><h2 id="7f76" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="a599" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">上述程序的概念很简单。这里，在print语句中，要求程序对列表进行排序；根据键值显示。在这种情况下，键值是' len '；意味着列表将根据元素的长度进行排序。使用键是一种非常简单的编写程序的方式，而且执行起来花费的时间也少得多；优化代码。</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/pythoneers/forget-html-and-flask-start-using-streamlit-1b394cfe4595" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">忘记HTML和Flask，开始使用Streamlit</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">数据科学和机器学习的WebApp框架</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj lb nv"/></div></div></a></div><blockquote class="me mf mg"><p id="b34f" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">优化循环</em> </strong></p></blockquote><p id="b089" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们知道我们使用循环来执行重复的任务。但是循环语句通常需要时间来执行。为了优化这个过程，我们使用字符串连接。字符串连接提供了比Python中任何其他实现都要快得多的结果。让我们看一个例子，其中的要求是将字符串中的所有小写字母转换成大写字母。</p><h2 id="bff7" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">节目一</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="f384" class="ml mm it ne b gy ni nj l nk nl">s = ‘welcome’<br/>sl = ‘ ’</span><span id="a365" class="ml mm it ne b gy nm nj l nk nl">for i in s:<br/>    sl = sl + i<br/>print (sl.upper())</span></pre><h2 id="88f4" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="37f5" class="ml mm it ne b gy ni nj l nk nl">WELCOME</span></pre><h2 id="d533" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序2 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="e717" class="ml mm it ne b gy ni nj l nk nl">s = ‘welcome’</span><span id="18b6" class="ml mm it ne b gy nm nj l nk nl">sl = ‘’.join([i for i in s])</span><span id="8eb9" class="ml mm it ne b gy nm nj l nk nl">print (sl.upper())</span></pre><h2 id="2a25" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="9a2e" class="ml mm it ne b gy ni nj l nk nl">WELCOME</span></pre><h2 id="e4fd" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><p id="9356" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">从上面两个程序可以看出，得到的输出是一样的。但是正如你所观察到的，这两个程序有一些不同之处。在program1中，创建了两个变量，其中一个存储字符串welcome，另一个为空。在此之后,“for”循环执行，将字符串中的每个字母转换为大写。而在program2中，变量初始化和“for”循环是在一个步骤中编写的；优化代码。这也是在处理冗长项目时简化代码的另一种方式。</p><blockquote class="me mf mg"><p id="5a18" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">用range()代替xrange()函数</em> </strong></p></blockquote><p id="6445" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">优化代码的另一种方法是使用range()函数，而不是xrange()函数。下面给出了两个显示1到7之间数字的例子。</p><p id="3eba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>以下代码在Python解释器中执行。</p><h2 id="6095" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">节目一</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="4085" class="ml mm it ne b gy ni nj l nk nl">&gt;&gt; xrange(1,7)<br/>xrange(1,7)</span><span id="4a47" class="ml mm it ne b gy nm nj l nk nl">&gt;&gt; for i in xrange(1,7):<br/>print i</span><span id="1486" class="ml mm it ne b gy nm nj l nk nl">1<br/>2<br/>3<br/>4<br/>5<br/>6</span></pre><h2 id="3fc1" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序二</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="f2e6" class="ml mm it ne b gy ni nj l nk nl">&gt;&gt; range(1,7)<br/>[1, 2, 3, 4, 5, 6]</span></pre><h2 id="bdd7" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="3454" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">xrange()函数总是返回生成器对象，并且只通过循环显示数字，而range函数只在一行中显示输出。因此，我们可以理解，range()函数比xrange()函数更有助于节省系统内存。</p><blockquote class="me mf mg"><p id="34e8" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">限制循环的使用</em> </strong></p></blockquote><p id="45f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以使用range()来限制循环的使用。range函数打印从零开始的数字序列，默认情况下，以1为增量。这个函数比使用任何循环都要好。下面两个程序展示了使用和不使用range函数的区别。</p><p id="e291" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要求是打印范围从奇数到10的数字。</p><h2 id="5e4a" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序1 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="7e6d" class="ml mm it ne b gy ni nj l nk nl">i=0<br/>while i &lt;= 10:<br/>    if ( i % 3==0):<br/>        print (i, end=’, ‘)<br/>    i+=1</span></pre><h2 id="be0c" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序2 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="093a" class="ml mm it ne b gy ni nj l nk nl">odd = [ i for i in range(10) if i%3 == 0]<br/>print (odd)</span></pre><h2 id="9531" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="5a40" class="ml mm it ne b gy ni nj l nk nl">[0, 3, 6, 9]</span></pre><h2 id="b3a1" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="ceda" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">在程序1中，你可以看到我们使用了一个while循环来执行这个程序。而在program2中，使用range函数和列表理解的概念减少了代码行数；这种方法所用的时间比程序1少得多。</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/why-data-science-is-booming-e240b1a64645"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">数据科学为何蓬勃发展？</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">对他们的企业和整个社会的宝贵贡献</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">pub.towardsai.net</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj lb nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/network-programming-of-sockets-server-sockets-client-sockets-with-python-5ce556276b0b"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jd gy z fp oa fr fs ob fu fw jc bi translated">用Python对套接字、服务器套接字、客户端套接字进行网络编程</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">低级和高级接入网内编程</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">pub.towardsai.net</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj lb nv"/></div></div></a></div><blockquote class="me mf mg"><p id="fbbd" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">采用多种编码方式</em> </strong></p></blockquote><p id="9d4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在python程序中，有不同的方法可以编写代码，其中一些方法可能长或短。从长远来看，一个高效的程序员总是遵循捷径；以使程序优化并易于阅读。下面是一个例子，有两种方法来存储字典中每个字母的计数。</p><h2 id="d49b" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">节目一</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="9242" class="ml mm it ne b gy ni nj l nk nl">wd = {}<br/>word = ‘thanksthanking’</span><span id="4343" class="ml mm it ne b gy nm nj l nk nl">for i in word:<br/>    if i not in wd:<br/>        wd[i] = 0<br/>    wd[i] += 1</span><span id="dbf7" class="ml mm it ne b gy nm nj l nk nl">print(wd)</span></pre><h2 id="3461" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序2 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="4e4d" class="ml mm it ne b gy ni nj l nk nl">wd = {}<br/>word = ‘thanksthanking’</span><span id="f37e" class="ml mm it ne b gy nm nj l nk nl">for i in word:<br/>    try:<br/>        wd[i] += 1<br/>    except KeyError:<br/>        wd[i] = 1</span><span id="6ac0" class="ml mm it ne b gy nm nj l nk nl">print (wd)</span></pre><h2 id="9bbe" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="cb59" class="ml mm it ne b gy ni nj l nk nl">{‘t’: 2, ‘h’: 2, ‘a’: 2, ’n’: 3, ‘k’: 2, ‘s’: 1, ‘i’: 1, ‘g’: 1}</span></pre><h2 id="4aa9" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">说明:</strong></h2><p id="aa16" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">在program1中，您可以看到我们在“for”循环中使用if-else子句来初始化字典元素。而在program2中，一个简单的try-except方法是执行相同的过程。这两个程序的区别在于，在program1中，编译器每次检查单词中的字母时都必须检查if-else语句，这使得program1比program2运行的时间更长。因此，使用try-except方法是一种更加高效和优化的代码编写方式。</p><blockquote class="me mf mg"><p id="7d81" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">简化变量交换</em> </strong></p></blockquote><p id="64c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在python中优化代码的另一种方法是通过简化代码来交换变量。下图显示了该计划的两种不同方法。</p><h2 id="3841" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序1 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="db09" class="ml mm it ne b gy ni nj l nk nl">a = 2<br/>b = 6</span><span id="ef2b" class="ml mm it ne b gy nm nj l nk nl">temp = a<br/>a = b<br/>b = temp</span><span id="08a3" class="ml mm it ne b gy nm nj l nk nl">print (a,b)</span></pre><h2 id="d2d2" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序2 </strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="57b0" class="ml mm it ne b gy ni nj l nk nl">a,b = 2,6</span><span id="4a0d" class="ml mm it ne b gy nm nj l nk nl">a,b = b,a</span><span id="f805" class="ml mm it ne b gy nm nj l nk nl">print (a,b)</span></pre><h2 id="9d3c" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="8434" class="ml mm it ne b gy ni nj l nk nl">6 2</span></pre><h2 id="5ee8" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="17e8" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">在程序1中，你可以看到‘a’和‘b’的值存储在另一个变量中；命名为“temp”来交换变量。但是在program2中，这个过程以一种非常简化的方式陈述(a，b = b，a)；节省系统内存。因此，program2是一种更有效的交换变量的方式。</p><blockquote class="me mf mg"><p id="19d0" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">使用局部变量而不是全局变量</em> </strong></p></blockquote><p id="6609" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">练习使用局部变量而不是全局变量是优化代码的另一个技巧。下面给出的是分别使用全局变量和局部变量的编程例子。</p><h2 id="0097" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序1:全局变量</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="ef08" class="ml mm it ne b gy ni nj l nk nl">def f():<br/>    print(“Inside Func: “, s)</span><span id="64a9" class="ml mm it ne b gy nm nj l nk nl"># Global scope<br/>s = “welcome to programming”<br/>f()</span></pre><h2 id="dcdc" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="fb86" class="ml mm it ne b gy ni nj l nk nl">Inside Func: welcome to programming</span></pre><h2 id="d9a8" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">程序2:局部变量</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="3d17" class="ml mm it ne b gy ni nj l nk nl">def f():<br/>    # local variable<br/>    s = “welcome to programming”<br/>    print(s)<br/>f()</span></pre><h2 id="27a0" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">输出</strong></h2><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="c625" class="ml mm it ne b gy ni nj l nk nl">welcome to programming</span></pre><h2 id="3913" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated"><strong class="ak">解释:</strong></h2><p id="0a9e" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">在这个程序1中，函数f()被调用。但是在函数中，当Python搜索变量‘s’时。因为变量不在函数中，所以它从函数中出来，取值为“s”。由于这个搜索，这个程序的执行变得很慢。</p><p id="8eb5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是在program2中，存储字符串的变量存在于函数内部；不需要用Python来搜索。因此，这个程序的执行时间比程序1少得多。</p><blockquote class="me mf mg"><p id="c567" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">结论:</em> </strong></p></blockquote><p id="479f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总之，本文介绍了一些优化Python代码的基本技巧。我强烈建议阅读更多的文章并应用这些概念，因为有许多方法可以让你尝试这个话题。</p><p id="f982" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="5dd3" class="om mm it bd mn on oo op mq oq or os mt ki ot kj mw kl ou km mz ko ov kp nc ow bi translated">推荐文章</h1><p id="9876" class="pw-post-body-paragraph li lj it lk b ll nn kd ln lo no kg lq lr np lt lu lv nq lx ly lz nr mb mc md im bi translated">1.<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b?source=friends_link&amp;sk=4a5c9f9ad552005636ae720a658281b1">8 Python的主动学习见解收集模块</a> <br/> 2。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a>T5】3。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff?source=friends_link&amp;sk=11c6809f6623dd4f6dd74d43727297cf">熊猫:处理分类数据</a> <br/> 5。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/hyper-parameters-randomseachcv-and-gridsearchcv-in-machine-learning-b7d091cf56f4?source=friends_link&amp;sk=cab337083fb09601114a6e466ec59689">超参数:机器学习中的RandomSeachCV和GridSearchCV</a><br/>6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-distribution-using-numpy-with-python-3b64aae6f9d6?source=friends_link&amp;sk=809e75802cbd25ddceb5f0f6496c9803">数据分发使用Numpy与Python </a> <br/> 9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/decision-trees-vs-random-forests-in-machine-learning-be56c093b0f?source=friends_link&amp;sk=91377248a43b62fe7aeb89a69e590860">机器学习中的决策树vs随机森林</a> <br/> 10。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/standardization-in-data-preprocessing-with-python-96ae89d2f658?source=friends_link&amp;sk=f348435582e8fbb47407e9b359787e41">用Python实现数据预处理的标准化</a></p></div></div>    
</body>
</html>