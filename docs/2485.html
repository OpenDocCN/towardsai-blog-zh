<html>
<head>
<title>Pandas Complete Tutorial for Data Science in 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫2022年完成数据科学教程</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/pandas-complete-tutorial-for-data-science-in-2022-685a4c6df347?source=collection_archive---------1-----------------------#2022-01-14">https://pub.towardsai.net/pandas-complete-tutorial-for-data-science-in-2022-685a4c6df347?source=collection_archive---------1-----------------------#2022-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="348f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="fb1c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">熊猫初级到高级指南</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b4d68195f7710a0d0aa328b93479f14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oMLHthCBf_qvVBpb"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@heylagostechie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉格斯技术人员</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b05e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Pandas是数据科学家、数据分析和机器学习工程师中最受欢迎的python框架之一。这个框架是数据加载、预处理和分析的基本工具。</p><blockquote class="mb mc md"><p id="a9dd" class="lf lg me lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated">在学习熊猫之前，你必须了解什么是数据帧？数据框是一种二维数据结构，类似于2d数组，或者类似于具有行和列的表。</p></blockquote><p id="2117" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于本文，我使用我的虚拟在线商店数据集，它位于我的<a class="ae le" href="https://www.kaggle.com/mountboy/online-store-customer-data" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>帐户和<a class="ae le" href="https://github.com/norochalise/pandas-tutorial-article-2022/blob/main/dataset/online_store_customer_data.csv" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中。你可以从这两个网站下载。还有，我会在我的GitHub账号上给你提供所有这些练习笔记本，你可以随意使用。</p><p id="7b48" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在开始这篇文章之前，这里是我们涉及的主题。</p><h2 id="c486" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">目录</h2><ol class=""><li id="88f4" class="na nb iq lh b li nc ll nd lo ne ls nf lw ng ma nh ni nj nk bi translated">设置</li><li id="b4e7" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">加载不同的数据格式</li><li id="2e0a" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">数据预处理</li><li id="d6eb" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">内存管理</li><li id="56ec" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">数据分析</li><li id="99b8" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">数据可视化</li><li id="d5b1" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">最终想法</li><li id="4d11" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">参考</li></ol><p id="4376" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="me">随时查看本教程的</em><a class="ae le" href="https://github.com/norochalise/pandas-tutorial-article-2022" rel="noopener ugc nofollow" target="_blank"><em class="me">GitHub</em></a><em class="me">repo。</em></p><h2 id="d1bb" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">1.设置</h2><h2 id="f2be" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">导入</h2><p id="e61e" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在继续学习熊猫之前，我们首先需要安装并导入它们。如果你在你的本地机器上安装了<a class="ae le" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> Anaconda发行版</a>或者使用<a class="ae le" href="https://research.google.com/colaboratory" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>那么熊猫就已经可以在那里使用了，否则，你可以从<a class="ae le" href="https://pandas.pydata.org/docs/getting_started/install.html" rel="noopener ugc nofollow" target="_blank">熊猫官方网站</a>按照这个安装过程。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="3e45" class="mi mj iq nu b gy ny nz l oa ob"># Importing libraries<br/>import numpy as np<br/>import pandas as pd</span></pre><h2 id="c295" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">设置显示选项</h2><p id="6791" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">熊猫显示选项的默认设置有列和行显示的限制。当我们需要显示更多的行或列时，我们可以使用<code class="fe oc od oe nu b">set_option()</code>函数来显示大量的行或列。对于这个函数，我们可以设置任意数量的行和列值。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="a912" class="mi mj iq nu b gy ny nz l oa ob"># we can set numbers for how many rows and columns will be displayed<br/>pd.set_option('display.min_rows', 10) #default will be 10 <br/>pd.set_option('display.max_columns', 20)</span></pre><h2 id="680f" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">2.将不同的数据格式加载到熊猫数据框中</h2><p id="43dd" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">熊猫是一个简单的工具，用于读写不同类型的文件格式。使用这些工具，我们可以轻松加载CSV、Excel、Pdf、JSON、HTML、HDF5、SQL、Google BigQuery等文件。</p><p id="cb4b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里有一些方法，我会告诉你我们如何使用文件格式最频繁地读写。</p><h2 id="419c" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">正在读取CSV文件</h2><p id="c661" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">CSV(逗号分隔文件)是最流行的文件格式。读取这个文件时，我们使用了简单的<code class="fe oc od oe nu b">read.csv()</code>函数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="ecc7" class="mi mj iq nu b gy ny nz l oa ob"># read csv file<br/><br/>df = pd.read_csv('dataset/online_store_customer_data.csv')<br/>df.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/aeb8b256453a11f5c13518ec19d421bf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1wLBHFi9eJjyV-Q4MqFWqw.png"/></div></figure><p id="4844" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以添加一些公共参数来调整这个函数。如果我们需要跳过数据框中的一些第一行，那么我们可以使用关键字参数<code class="fe oc od oe nu b">skiprows</code>。例如，如果我们想跳过第一行，那么我们使用<code class="fe oc od oe nu b">skiprows=2</code>。类似地，如果我们不想持续2行，那么我们可以简单地使用<code class="fe oc od oe nu b">skipfooter=2</code>。如果我们不想加载列标题，那么我们可以使用<code class="fe oc od oe nu b">header=None</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="12f2" class="mi mj iq nu b gy ny nz l oa ob"># Loading csv file with skip first 2 rows without header<br/>df_csv = pd.read_csv('dataset/online_store_customer_data.csv', skiprows=2, header=None)<br/>df_csv.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/186408f236baa42f06297bc2efd5abe9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*j1PTiYp5xIZuK8Zi3BH8lg.png"/></div></figure><h2 id="9f85" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">从URL读取CSV文件</h2><p id="3c8b" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">对于读取CSV文件形式的URL，可以直接传递链接。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0abf" class="mi mj iq nu b gy ny nz l oa ob"># Read csv file from url<br/>url="<a class="ae le" href="https://raw.githubusercontent.com/norochalise/pandas-tutorial-article-2022/main/dataset/online_store_customer_data.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/norochalise/pandas-tutorial-article-2022/main/dataset/online_store_customer_data.csv</a>"<br/>df_url = pd.read_csv(url)<br/>df_url.head(3)<br/></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/aeb8b256453a11f5c13518ec19d421bf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1wLBHFi9eJjyV-Q4MqFWqw.png"/></div></figure><h2 id="800f" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">写入CSV文件</h2><p id="593d" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">当您想要将数据帧保存在CSV文件中时，您可以简单地使用<code class="fe oc od oe nu b">to.csv()</code>功能。您还需要传递文件名，它将保存该文件。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="864c" class="mi mj iq nu b gy ny nz l oa ob"># saving df_url dataframe to csv file<br/>df_url.to_csv('dataset/csv_from_url.csv')<br/>df_url.to_csv('dataset/demo_text.txt')</span></pre><h2 id="5769" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">读取文本文件</h2><p id="bca6" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">读取一个纯文本文件，我们可以使用<code class="fe oc od oe nu b">read_csv()</code>这个函数。在这个函数中，你需要传递<code class="fe oc od oe nu b"> <em class="me">.txt</em></code>文件名。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="53ad" class="mi mj iq nu b gy ny nz l oa ob"># read plain text file<br/>df_txt = pd.read_csv("dataset/demo_text.txt")</span></pre><h2 id="5213" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">读取Excel文件</h2><p id="a56b" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">要读取一个Excel文件，我们应该使用<code class="fe oc od oe nu b">read_excel()</code>pandas包的功能。如果我们有多个工作表名称，那么我们可以用这个函数传递工作表名称参数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="3118" class="mi mj iq nu b gy ny nz l oa ob"># read excel file<br/>df_excel = pd.read_excel('dataset/excel_file.xlsx', sheet_name='Sheet1')<br/>df_excel</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/9bcd00ee69e4751fb2af419ecbd879ba.png" data-original-src="https://miro.medium.com/v2/format:webp/1*umNV_RxUIYz-pfTWCfp_ag.png"/></div></figure><h2 id="3a08" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">编写Excel文件</h2><p id="5be5" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我们可以将数据框保存为与CSV文件相同的excel文件。可以使用带有文件名和位置的<code class="fe oc od oe nu b">to_excel()</code>功能。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="135c" class="mi mj iq nu b gy ny nz l oa ob"># save dataframe to the excel file<br/>df_url.to_csv('demo.xlsx')</span></pre><h2 id="b6fd" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">3.数据预处理</h2><p id="c64a" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">数据预处理是将原始数据加工成干净数据的过程。这是数据科学最关键的部分。在这一节中，我们将首先浏览数据，然后删除不需要的列，删除重复项，处理丢失的数据等。在这一步之后，我们从原始数据中获得干净的数据。</p><h2 id="90b0" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">3.1数据探索</h2><h2 id="070f" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">从数据框中检索行。</h2><p id="e3fe" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">加载数据后，我们做的第一件事是查看我们的数据。为此，我们使用<code class="fe oc od oe nu b">head()</code>和<code class="fe oc od oe nu b">tail()</code>功能。head函数将显示第一行，tail函数将显示最后一行。默认情况下，它显示5行。假设我们想显示前3行和后6行。我们可以这样做。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="5206" class="mi mj iq nu b gy ny nz l oa ob"># display first 3 rows<br/>df.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/aeb8b256453a11f5c13518ec19d421bf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1wLBHFi9eJjyV-Q4MqFWqw.png"/></div></figure><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="1868" class="mi mj iq nu b gy ny nz l oa ob"># display last 6 rows<br/>df.tail(6)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/72b77465870b3d3bb25af131df018b96.png" data-original-src="https://miro.medium.com/v2/format:webp/1*S9cpj9N-L0RH27fpsZgU5g.png"/></div></figure><h2 id="49fc" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">从数据框中检索样本行。</h2><p id="2501" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们想要显示样本数据，那么我们可以使用<code class="fe oc od oe nu b">sample()</code>一个具有期望行数的函数。它将显示所需的随机行数。如果我们想要取7个样本，我们需要在<code class="fe oc od oe nu b">sample(7)</code>函数中传递7个。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="5745" class="mi mj iq nu b gy ny nz l oa ob"># Display random 7 sample rows<br/>df.sample(7)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/f212faf454a127374a57ae2a99ad3d80.png" data-original-src="https://miro.medium.com/v2/format:webp/1*P7GEviwyGg3Ep7YP2XNSKw.png"/></div></figure><h2 id="ad52" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">检索关于数据框的信息</h2><p id="f0e3" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">要显示数据帧信息我们可以使用<code class="fe oc od oe nu b">info()</code>的方法。它将显示列数据类型，计算每列的非空值总数及其内存空间。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="d6cc" class="mi mj iq nu b gy ny nz l oa ob">df.info()</span><span id="946f" class="mi mj iq nu b gy og nz l oa ob">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 2512 entries, 0 to 2511<br/>Data columns (total 11 columns):<br/> #   Column            Non-Null Count  Dtype  <br/>---  ------            --------------  -----  <br/> 0   Transaction_date  2512 non-null   object <br/> 1   Transaction_ID    2512 non-null   int64  <br/> 2   Gender            2484 non-null   object <br/> 3   Age               2470 non-null   float64<br/> 4   Marital_status    2512 non-null   object <br/> 5   State_names       2512 non-null   object <br/> 6   Segment           2512 non-null   object <br/> 7   Employees_status  2486 non-null   object <br/> 8   Payment_method    2512 non-null   object <br/> 9   Referal           2357 non-null   float64<br/> 10  Amount_spent      2270 non-null   float64<br/>dtypes: float64(3), int64(1), object(7)<br/>memory usage: 216.0+ KB</span></pre><p id="ecea" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">显示每一列的数据类型我们可以使用<code class="fe oc od oe nu b">dtypes</code>属性。我们可以在dtypes中添加<code class="fe oc od oe nu b">value_counts()</code>方法来显示所有数据类型的值计数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0c4e" class="mi mj iq nu b gy ny nz l oa ob"># display datatypes<br/>df.dtypes</span><span id="a2e0" class="mi mj iq nu b gy og nz l oa ob">Transaction_date     object<br/>Transaction_ID        int64<br/>Gender               object<br/>Age                 float64<br/>Marital_status       object<br/>State_names          object<br/>Segment              object<br/>Employees_status     object<br/>Payment_method       object<br/>Referal             float64<br/>Amount_spent        float64<br/>dtype: object</span><span id="23af" class="mi mj iq nu b gy og nz l oa ob">df.dtypes.value_counts()</span><span id="b3ba" class="mi mj iq nu b gy og nz l oa ob">object     7<br/>float64    3<br/>int64      1<br/>dtype: int64</span></pre><h2 id="212b" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">显示行数和列数。</h2><p id="e262" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了显示行数和列数，我们使用了<code class="fe oc od oe nu b">shape</code>属性。第一个数字和最后一个数字分别显示行数和列数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0a1c" class="mi mj iq nu b gy ny nz l oa ob">df.shape</span><span id="6c8b" class="mi mj iq nu b gy og nz l oa ob">(2512, 11)</span></pre><h2 id="14f8" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">显示列名和数据</h2><p id="64f4" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了显示数据框的列名，我们使用了<code class="fe oc od oe nu b">columns</code>属性。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0a0d" class="mi mj iq nu b gy ny nz l oa ob">df.columns</span><span id="4c3e" class="mi mj iq nu b gy og nz l oa ob">Index(['Transaction_date', 'Transaction_ID', 'Gender', 'Age', 'Marital_status',<br/>       'State_names', 'Segment', 'Employees_status', 'Payment_method',<br/>       'Referal', 'Amount_spent'],<br/>      dtype='object')</span></pre><p id="fd7c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们想显示单个或多个列的数据，只需用数据框传递列名。为了显示多列数据信息，我们需要传递列名列表。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="33ea" class="mi mj iq nu b gy ny nz l oa ob"># display Age columns first 3 rows data<br/>df['Age'].head(3)</span><span id="4728" class="mi mj iq nu b gy og nz l oa ob">0    19.0<br/>1    49.0<br/>2    63.0<br/>Name: Age, dtype: float64</span><span id="0c21" class="mi mj iq nu b gy og nz l oa ob"># display first 4 rows of Age, Transaction_date and Gender columns<br/>df[['Age', 'Transaction_date', 'Gender']].head(4)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/4309b1f07acf84a72120d54ad650d69e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9Z4JhbdWSx80R9ccuBBsdA.png"/></div></figure><h2 id="e808" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">检索一系列行</h2><p id="249a" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们想显示特定范围的行，我们可以使用切片。例如，如果我们想得到第2到第6行，我们可以简单地使用<code class="fe oc od oe nu b">df[2:7]</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="9000" class="mi mj iq nu b gy ny nz l oa ob"># for display 2nd to 6th rows<br/>df[2:7]<br/><br/># for display starting to 10th<br/>df[:11]<br/><br/># for display last two rows<br/>df[-2:]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/ca067d67faea6e486e3da46ad8b59ea3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*tqbv-Hz09WEYu6Qx7cx6Dg.png"/></div></figure><h2 id="35e3" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">3.2数据清理</h2><p id="95d4" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">探索后，我们的数据集可能需要清理它们，以便更好地分析。数据来自多个来源，因此某些值可能有错误。这就是数据清理变得极其重要的地方。在本节中，我们将删除不需要的列、重命名列、更正适当的数据类型等。</p><h2 id="6283" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">删除列名</h2><p id="af5e" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我们可以使用drop函数从数据框中删除不需要的列。别忘了加上<code class="fe oc od oe nu b">inplace = True</code>和<code class="fe oc od oe nu b">axis=1</code>。它将更改数据框中的值。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="8d20" class="mi mj iq nu b gy ny nz l oa ob"># Drop unwanted columns<br/>df.drop(['Transaction_ID'], axis=1, inplace=True)</span></pre><h2 id="27ec" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">更改列名</h2><p id="fb2b" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">要更改列名，我们可以使用<code class="fe oc od oe nu b">rename()</code>函数传递列字典。在字典中，我们将像旧的列名那样传递键，并将值作为新的所需列名。比如现在我们要把<code class="fe oc od oe nu b">Transaction_date</code>和<code class="fe oc od oe nu b">Gender</code>改成<code class="fe oc od oe nu b">Date</code>和<code class="fe oc od oe nu b">Sex</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0cf6" class="mi mj iq nu b gy ny nz l oa ob"># create new df_col dataframe from df.copy() method. <br/>df_col = df.copy()<br/><br/># rename columns name<br/>df_col.rename(columns={"Transaction_date": "Date", "Gender": "Sex"}, inplace=True)<br/>df_col.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/761666a0d02bd1b0c675040308d3533b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zTJljLmj9pJwR_bMaMfRaA.png"/></div></figure><h2 id="7659" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">向数据框添加新列</h2><p id="5176" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">您可以向现有的pandas数据框中添加一个新列，只需为新列名赋值即可。例如，以下代码在<code class="fe oc od oe nu b">df_col</code>数据帧中创建了名为<code class="fe oc od oe nu b">new_col</code>的第三列:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="f58e" class="mi mj iq nu b gy ny nz l oa ob"># Add a new_col column which value will be amount_spent * 100<br/>df_col['new_col'] = df_col['Amount_spent'] * 100</span><span id="695a" class="mi mj iq nu b gy og nz l oa ob">df_col.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/9e8ffca49087d39f3b1efa9ab074f804.png" data-original-src="https://miro.medium.com/v2/format:webp/1*W3fP8KorIekFh63pRM-3SA.png"/></div></figure><h2 id="882f" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">字符串值更改或替换</h2><p id="5f4a" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我们可以用旧值替换新值，用<code class="fe oc od oe nu b">.loc()</code>这个方法借助条件。比如现在我们在性别一栏里把女的改成女的，男的改成男的。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="84df" class="mi mj iq nu b gy ny nz l oa ob">df_col.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/9e8ffca49087d39f3b1efa9ab074f804.png" data-original-src="https://miro.medium.com/v2/format:webp/1*W3fP8KorIekFh63pRM-3SA.png"/></div></figure><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="faca" class="mi mj iq nu b gy ny nz l oa ob"># changing Female to Woman and Male to Man in Sex column.<br/>#first argument in loc function is condition and second one is columns name. <br/>df_col.loc[df_col.Sex == "Female", 'Sex'] = 'Woman' <br/>df_col.loc[df_col.Sex == "Male", 'Sex'] = 'Man'</span><span id="dede" class="mi mj iq nu b gy og nz l oa ob">df_col.head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/386c9662af6a4afbc4275234759af493.png" data-original-src="https://miro.medium.com/v2/format:webp/1*yUmWx4c1m_yO4g_2iZf9pw.png"/></div></figure><p id="6531" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在性别栏的值由女性改为女性，由男性改为男性。</p><h2 id="86ae" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">数据类型更改</h2><p id="7f5c" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">当我们处理不同类型的数据类型时，有时这是一项乏味的任务。如果我们想处理一个日期，我们必须用确切的日期格式来改变它。否则，我们就有问题了。这项任务对熊猫来说很容易。我们可以使用<code class="fe oc od oe nu b">astype()</code>函数将一种数据类型转换成另一种。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="6390" class="mi mj iq nu b gy ny nz l oa ob">df_col.info()</span><span id="c54e" class="mi mj iq nu b gy og nz l oa ob">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 2512 entries, 0 to 2511<br/>Data columns (total 11 columns):<br/> #   Column            Non-Null Count  Dtype  <br/>---  ------            --------------  -----  <br/> 0   Date              2512 non-null   object <br/> 1   Sex               2484 non-null   object <br/> 2   Age               2470 non-null   float64<br/> 3   Marital_status    2512 non-null   object <br/> 4   State_names       2512 non-null   object <br/> 5   Segment           2512 non-null   object <br/> 6   Employees_status  2486 non-null   object <br/> 7   Payment_method    2512 non-null   object <br/> 8   Referal           2357 non-null   float64<br/> 9   Amount_spent      2270 non-null   float64<br/> 10  new_col           2270 non-null   float64<br/>dtypes: float64(4), object(7)<br/>memory usage: 216.0+ KB</span></pre><p id="b317" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我们的<code class="fe oc od oe nu b">Date</code>列中，它是对象类型，所以现在我们将把它转换成日期类型，我们也将把<code class="fe oc od oe nu b">Referal</code>列float64转换成float32。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="5e43" class="mi mj iq nu b gy ny nz l oa ob"># change object type to datefime64 format<br/>df_col['Date'] = df_col['Date'].astype('datetime64[ns]')<br/><br/># change float64 to float32 of Referal columns<br/>df_col['Referal'] = df_col['Referal'].astype('float32')</span><span id="5473" class="mi mj iq nu b gy og nz l oa ob">df_col.info()</span><span id="3997" class="mi mj iq nu b gy og nz l oa ob">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 2512 entries, 0 to 2511<br/>Data columns (total 11 columns):<br/> #   Column            Non-Null Count  Dtype         <br/>---  ------            --------------  -----         <br/> 0   Date              2512 non-null   datetime64[ns]<br/> 1   Sex               2484 non-null   object        <br/> 2   Age               2470 non-null   float64       <br/> 3   Marital_status    2512 non-null   object        <br/> 4   State_names       2512 non-null   object        <br/> 5   Segment           2512 non-null   object        <br/> 6   Employees_status  2486 non-null   object        <br/> 7   Payment_method    2512 non-null   object        <br/> 8   Referal           2357 non-null   float32       <br/> 9   Amount_spent      2270 non-null   float64       <br/> 10  new_col           2270 non-null   float64       <br/>dtypes: datetime64[ns](1), float32(1), float64(3), object(6)<br/>memory usage: 206.2+ KB</span></pre><h2 id="bb4f" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">3.3删除重复</h2><p id="f5c3" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在数据预处理部分，我们需要删除重复的条目。由于各种原因，有时我们的数据帧有多个重复条目。在熊猫功能的帮助下，可以很容易地删除重复条目。首先，我们使用<code class="fe oc od oe nu b">duplicated()</code>函数来识别重复条目，然后使用<code class="fe oc od oe nu b">drop_duplicates()</code>来删除它们。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="abb5" class="mi mj iq nu b gy ny nz l oa ob"># Display duplicated entries <br/>df.duplicated().sum()</span><span id="fe91" class="mi mj iq nu b gy og nz l oa ob">12</span><span id="8d11" class="mi mj iq nu b gy og nz l oa ob"># duplicate rows dispaly, keep arguments will--- 'first', 'last' and False<br/>duplicate_value = df.duplicated(keep='first')<br/><br/>df.loc[duplicate_value, :]</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/afa8c5e03b9443454fdae9a4f7fb0689.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-Kz6xwoeFmTSR-FyZN7_yg.png"/></div></figure><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="83fc" class="mi mj iq nu b gy ny nz l oa ob"># dropping ALL duplicate values<br/>df.drop_duplicates(keep = 'first', inplace = True)</span></pre><h2 id="fb05" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">3.4处理缺失值</h2><p id="ee87" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在数据预处理部分处理常见任务中的缺失值。出于多种原因，大多数时候我们会遇到缺失值。不解决这个问题，我们就无法进行正确的模型构建。对于这一部分，我们将首先找出丢失的值，然后决定如何处理它们。我们可以通过删除受影响的列或行或者替换那里的适当值来处理这个问题。</p><h2 id="ccd2" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">显示缺失值信息</h2><p id="c241" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了显示缺失值，我们可以使用<code class="fe oc od oe nu b">isna()</code>功能。我们使用<code class="fe oc od oe nu b">.sum()</code>和<code class="fe oc od oe nu b">sort_values(ascending=False)</code>函数按升序计算每一列中缺失值的总数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="e48b" class="mi mj iq nu b gy ny nz l oa ob">df.isna().sum().sort_values(ascending=False)</span><span id="96ce" class="mi mj iq nu b gy og nz l oa ob">Amount_spent        241<br/>Referal             154<br/>Age                  42<br/>Gender               28<br/>Employees_status     26<br/>Transaction_date      0<br/>Marital_status        0<br/>State_names           0<br/>Segment               0<br/>Payment_method        0<br/>dtype: int64</span></pre><h2 id="8c8a" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">删除Nan行</h2><p id="c359" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们有更小的Nan值，那么我们可以通过<code class="fe oc od oe nu b">dropna()</code>函数删除整行。对于这个函数，我们将在子集参数中添加列名。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0847" class="mi mj iq nu b gy ny nz l oa ob"># df copy to df_copy<br/>df_new = df.copy()</span><span id="eee0" class="mi mj iq nu b gy og nz l oa ob">#Delete Nan rows of Job Columns<br/>df_new.dropna(subset = ["Employees_status"], inplace=True)</span></pre><h2 id="5012" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">删除整列</h2><p id="9213" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们在特定的列中有大量的Nan值，那么删除这些列可能是一个好的决定，而不是进行估算。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="5722" class="mi mj iq nu b gy ny nz l oa ob">df_new.drop(columns=['Amount_spent'], inplace=True)</span><span id="0d9d" class="mi mj iq nu b gy og nz l oa ob">df_new.isna().sum().sort_values(ascending=False)</span><span id="af36" class="mi mj iq nu b gy og nz l oa ob">Referal             153<br/>Age                  42<br/>Gender               27<br/>Transaction_date      0<br/>Marital_status        0<br/>State_names           0<br/>Segment               0<br/>Employees_status      0<br/>Payment_method        0<br/>dtype: int64</span></pre><h2 id="65f6" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">估算缺失值</h2><p id="a257" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">有时，如果我们删除整列，那将不是适当的方法。删除列会影响我们的模型构建，因为我们会失去我们的主要特征。对于估算，我们有许多方法，所以这里有一些最流行的技术。</p><p id="e1d9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">方法1 </strong> —输入固定值，如0、‘未知’或‘缺失’等。我们在性别栏中填入未知</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="cdf8" class="mi mj iq nu b gy ny nz l oa ob">df['Gender'].fillna('Unknown', inplace=True)</span></pre><p id="5d05" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">方法2 </strong> —估算平均值、中值和众数</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="956c" class="mi mj iq nu b gy ny nz l oa ob"># Impute Mean in Amount_spent columns<br/>mean_amount_spent = df['Amount_spent'].mean()<br/>df['Amount_spent'].fillna(mean_amount_spent, inplace=True)<br/><br/>#Impute Median in Age column<br/>median_age = df['Age'].median()<br/>df['Age'].fillna(median_age, inplace=True)<br/><br/># Impute Mode in Employees_status column<br/>mode_emp = df['Employees_status'].mode().iloc[0]<br/>df['Employees_status'].fillna(mode_emp, inplace=True)</span></pre><p id="621e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">方法三</strong>——通过<code class="fe oc od oe nu b">ffill</code>和<code class="fe oc od oe nu b">bfill</code>输入正向填充或回填。在<code class="fe oc od oe nu b">ffill</code>中，缺失值从上一行的值估算，对于<code class="fe oc od oe nu b">bfill</code>则从下一行的值获取。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="5b23" class="mi mj iq nu b gy ny nz l oa ob">df['Referal'].fillna(method='ffill', inplace=True)</span><span id="8f4b" class="mi mj iq nu b gy og nz l oa ob">df.isna().sum().sum()</span><span id="f8eb" class="mi mj iq nu b gy og nz l oa ob">0</span></pre><p id="801f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们用不同的方法处理所有的缺失值。所以现在我们没有任何空值。</p><h2 id="900e" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">4.内存管理</h2><p id="23ea" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">当我们处理大型数据集时，我们会遇到一个大问题，那就是内存问题。我们需要太多的资源来处理这件事。但是熊猫有一些方法来处理这个问题。这里有一些方法或策略来帮助熊猫解决这个问题。</p><h2 id="ec7d" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">更改数据类型</h2><p id="08a9" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">从改变一种数据类型到另一种数据类型，我们可以节省大量的内存。一个流行的技巧是改变对象的类别，这将大大减少我们的数据帧内存。</p><p id="9f1b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们将把之前的<code class="fe oc od oe nu b">df </code>数据帧复制到<code class="fe oc od oe nu b">df_memory </code>，并使用<code class="fe oc od oe nu b">memory_usage(deep=True)</code>方法计算该数据帧的总内存使用量。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="c094" class="mi mj iq nu b gy ny nz l oa ob">df_memory = df.copy()</span><span id="bbbf" class="mi mj iq nu b gy og nz l oa ob">memory_usage = df_memory.memory_usage(deep=True)<br/>memory_usage_in_mbs = round(np.sum(memory_usage / 1024 ** 2), 3)<br/>print(f" Total memory taking df_memory dataframe is : {memory_usage_in_mbs:.2f} MB ")</span><span id="c70d" class="mi mj iq nu b gy og nz l oa ob">Total memory taking df_memory dataframe is : 1.15 MB</span></pre><h2 id="fbbd" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">将对象更改为类别数据类型</h2><p id="d2e5" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我们的数据框很小。也就是1.15 MB。现在我们将把我们的对象数据类型转换成类别。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="7aca" class="mi mj iq nu b gy ny nz l oa ob"># Object datatype to category convert<br/>df_memory[df_memory.select_dtypes(['object']).columns] = df_memory.select_dtypes(['object']).apply(lambda x: x.astype('category'))</span><span id="76b1" class="mi mj iq nu b gy og nz l oa ob"># convert object to category<br/>df_memory.info(memory_usage="deep")</span><span id="7d61" class="mi mj iq nu b gy og nz l oa ob">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 2500 entries, 0 to 2511<br/>Data columns (total 10 columns):<br/> #   Column            Non-Null Count  Dtype   <br/>---  ------            --------------  -----   <br/> 0   Transaction_date  2500 non-null   category<br/> 1   Gender            2500 non-null   category<br/> 2   Age               2500 non-null   float64 <br/> 3   Marital_status    2500 non-null   category<br/> 4   State_names       2500 non-null   category<br/> 5   Segment           2500 non-null   category<br/> 6   Employees_status  2500 non-null   category<br/> 7   Payment_method    2500 non-null   category<br/> 8   Referal           2500 non-null   float64 <br/> 9   Amount_spent      2500 non-null   float64 <br/>dtypes: category(7), float64(3)<br/>memory usage: 189.1 KB</span></pre><p id="705a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在它减少了1.15兆字节到216.6 KB。差不多减少了5.5倍。</p><h2 id="308c" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">将int64或float64更改为int 32、16或8</h2><p id="ca47" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">默认情况下，pandas将数值存储到int64或float64。这需要更多的内存。如果我们必须存储小数字，那么我们可以将64改为32、16等等。例如，我们的<code class="fe oc od oe nu b">Referral </code>列只有0和1值，因此我们不需要存储在float64。所以现在我们把它改成float16。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="ae60" class="mi mj iq nu b gy ny nz l oa ob"># Change Referal column datatypes<br/>df_memory['Referal'] = df_memory['Referal'].astype('float32')</span><span id="d0bd" class="mi mj iq nu b gy og nz l oa ob"># convert object to category<br/>df_memory.info(memory_usage="deep")</span><span id="9d45" class="mi mj iq nu b gy og nz l oa ob">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 2500 entries, 0 to 2511<br/>Data columns (total 10 columns):<br/> #   Column            Non-Null Count  Dtype   <br/>---  ------            --------------  -----   <br/> 0   Transaction_date  2500 non-null   category<br/> 1   Gender            2500 non-null   category<br/> 2   Age               2500 non-null   float64 <br/> 3   Marital_status    2500 non-null   category<br/> 4   State_names       2500 non-null   category<br/> 5   Segment           2500 non-null   category<br/> 6   Employees_status  2500 non-null   category<br/> 7   Payment_method    2500 non-null   category<br/> 8   Referal           2500 non-null   float32 <br/> 9   Amount_spent      2500 non-null   float64 <br/>dtypes: category(7), float32(1), float64(2)<br/>memory usage: 179.3 KB</span></pre><p id="54f6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">仅更改一列的数据类型后，我们将216 KB减少到179 KB。</p><blockquote class="mb mc md"><p id="465a" class="lf lg me lh b li lj ka lk ll lm kd ln mf lp lq lr mg lt lu lv mh lx ly lz ma ij bi translated"><strong class="lh ja">注意:在改变数据类型之前，请确定它的后果。</strong></p></blockquote><h2 id="7395" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">5.数据分析</h2><h2 id="9444" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">5.1.计算基本统计测量</h2><p id="a4df" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在数据分析部分，我们需要计算一些统计测量值。为了计算这个，熊猫有多种有用的功能。第一个有用的功能是<code class="fe oc od oe nu b">describe()</code>，它将显示大多数基本的统计测量值。对于此功能，您可以添加<code class="fe oc od oe nu b">.T</code>来转换显示。当有多个列时，这将使查看变得容易。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="e579" class="mi mj iq nu b gy ny nz l oa ob">df.describe().T</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/fb6baf4b35bf5829fdd4b4b6748796f5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*sstF8k9fPA55tOk3-FVMSQ.png"/></div></figure><p id="0a71" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上述函数只显示数字列信息。<code class="fe oc od oe nu b">count</code>显示有多少个值。<code class="fe oc od oe nu b">mean</code>显示每列的平均值。<code class="fe oc od oe nu b">std</code>显示列的标准偏差，它测量一组值的变化量或离差。<code class="fe oc od oe nu b">min</code>是各列的最小值。<code class="fe oc od oe nu b">25%</code>、<code class="fe oc od oe nu b">50%</code>和<code class="fe oc od oe nu b">75%</code>示出了分组中总值，最后<code class="fe oc od oe nu b">max</code>示出了各列的最大值。</p><p id="1aed" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们已经知道上面的代码将只显示数字列的基本统计信息。对于对象或类别列，我们可以使用<code class="fe oc od oe nu b">describe(include=object)</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="b610" class="mi mj iq nu b gy ny nz l oa ob">df.describe(include=object).T</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/e975d2c5cff03b18e5e91282bd3bb63d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QwXAh0Jy67PPHN_0aiQ3jw.png"/></div></figure><p id="9ad0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以上信息，<code class="fe oc od oe nu b">count</code>显示有多少个值。<code class="fe oc od oe nu b">unique</code>表示该列中有多少个值是唯一的。<code class="fe oc od oe nu b">top</code>是该类别中最大数量的值。<code class="fe oc od oe nu b">freq</code>显示有多少值经常位于顶部值上。</p><p id="4af8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以计算各个列的平均值、中值、众数、最大值、最小值，我们只需使用这些函数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="5934" class="mi mj iq nu b gy ny nz l oa ob"># Calculate Mean<br/>mean = df['Age'].mean()<br/><br/># Calculate Median<br/>median = df['Age'].median()<br/><br/>#Calculate Mode<br/>mode = df['Age'].mode().iloc[0]<br/><br/># Calculate standard deviation<br/>std = df['Age'].std()<br/><br/># Calculate Minimum values<br/>minimum = df['Age'].min()<br/><br/># Calculate Maximum values<br/>maximum = df.Age.max()<br/><br/>print(f" Mean of Age : {mean}")<br/>print(f" Median of Age : {median}")<br/>print(f" Mode of Age : {mode}")<br/>print(f" Standard deviation of Age : {std:.2f}")<br/>print(f" Maximum of Age : {maximum}")<br/>print(f" Menimum of Age : {minimum}")</span><span id="c323" class="mi mj iq nu b gy og nz l oa ob">Mean of Age : 46.636<br/> Median of Age : 47.0<br/> Mode of Age : 47.0<br/> Standard deviation of Age : 18.02<br/> Maximum of Age : 78.0<br/> Menimum of Age : 15.0</span></pre><p id="8ac9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在pandas中，我们可以显示不同数字列的相关性。为此，我们可以使用<code class="fe oc od oe nu b">.corr()</code>功能。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="51f6" class="mi mj iq nu b gy ny nz l oa ob"># calculate correlation<br/>df.corr()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/4d9d99b4f44f7057380486ce6e5c854b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*r4qcYw71tjZ_9KgJ2k0qHg.png"/></div></figure><h2 id="768c" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">5.2用于数据分析的基本内置函数</h2><p id="0daf" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在熊猫，有这么多有用的基本功能可用于数据分析。在本节中，我们将探索一些最常用的函数。</p><h2 id="70c9" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">类别列中唯一值的数量</h2><p id="7db0" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了显示所有唯一值的总和，我们使用<code class="fe oc od oe nu b">nunique()</code>所需列名的函数。例如，在State_names列中显示总的唯一值，我们使用此函数:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="7f4a" class="mi mj iq nu b gy ny nz l oa ob"># for display how many unique values are there in State_names column<br/>df['State_names'].nunique()</span><span id="082c" class="mi mj iq nu b gy og nz l oa ob">50</span></pre><h2 id="1f7d" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">显示所有唯一值</h2><p id="8c4f" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了显示所有唯一值，我们使用带有所需列名的<code class="fe oc od oe nu b">unique()</code>函数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="ebd2" class="mi mj iq nu b gy ny nz l oa ob"># for display uniqe values of State_names column<br/>df['State_names'].unique()</span><span id="d36d" class="mi mj iq nu b gy og nz l oa ob">array(['Kansas', 'Illinois', 'New Mexico', 'Virginia', 'Connecticut',<br/>       'Hawaii', 'Florida', 'Vermont', 'California', 'Colorado', 'Iowa',<br/>       'South Carolina', 'New York', 'Maine', 'Maryland', 'Missouri',<br/>       'North Dakota', 'Ohio', 'Nebraska', 'Montana', 'Indiana',<br/>       'Wisconsin', 'Alabama', 'Arkansas', 'Pennsylvania',<br/>       'New Hampshire', 'Washington', 'Texas', 'Kentucky',<br/>       'Massachusetts', 'Wyoming', 'Louisiana', 'North Carolina',<br/>       'Rhode Island', 'West Virginia', 'Tennessee', 'Oregon', 'Alaska',<br/>       'Oklahoma', 'Nevada', 'New Jersey', 'Michigan', 'Utah', 'Arizona',<br/>       'South Dakota', 'Georgia', 'Idaho', 'Mississippi', 'Minnesota',<br/>       'Delaware'], dtype=object)</span></pre><h2 id="ffc9" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">唯一值的计数</h2><p id="3d71" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">为了显示唯一值计数，我们使用<code class="fe oc od oe nu b">value_counts()</code>方法。此函数将显示唯一的值，每个值出现一个数字。例如，如果我们想知道<code class="fe oc od oe nu b">Gender </code>列中有多少个值频率为的唯一值，那么我们使用下面的方法。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="8d96" class="mi mj iq nu b gy ny nz l oa ob">df['Gender'].value_counts()</span><span id="622a" class="mi mj iq nu b gy og nz l oa ob">Female     1351<br/>Male       1121<br/>Unknown      28<br/>Name: Gender, dtype: int64</span></pre><p id="1605" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们想用出现的百分比而不是数字来显示，我们可以在<code class="fe oc od oe nu b">value_counts()</code>函数中使用<code class="fe oc od oe nu b">normalize=True</code>参数</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="3dd1" class="mi mj iq nu b gy ny nz l oa ob"># Calculate percentage of each category<br/>df['Gender'].value_counts(normalize=True)</span><span id="7804" class="mi mj iq nu b gy og nz l oa ob">Female     0.5404<br/>Male       0.4484<br/>Unknown    0.0112<br/>Name: Gender, dtype: float64</span><span id="21c6" class="mi mj iq nu b gy og nz l oa ob">df['State_names'].value_counts().sort_values(ascending = False).head(20)</span><span id="2de5" class="mi mj iq nu b gy og nz l oa ob">Illinois         67<br/>Georgia          64<br/>Massachusetts    63<br/>Maine            62<br/>Kentucky         59<br/>Minnesota        59<br/>Delaware         56<br/>Missouri         56<br/>New York         55<br/>New Mexico       55<br/>Arkansas         55<br/>California       55<br/>Arizona          55<br/>Nevada           55<br/>Vermont          54<br/>New Jersey       53<br/>Oregon           53<br/>Florida          53<br/>West Virginia    53<br/>Washington       52<br/>Name: State_names, dtype: int64</span></pre><h2 id="e4e7" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">排序值</h2><p id="e528" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们想按特定的列对数据帧进行排序，我们需要使用<code class="fe oc od oe nu b">sort_values()</code>方法。我们可以使用升序或降序排序。默认情况下，它按升序排列。如果我们想使用降序，那么我们只需要在函数的<code class="fe oc od oe nu b">sort_values()</code>中传递<code class="fe oc od oe nu b">ascending=False</code>参数。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="ccc6" class="mi mj iq nu b gy ny nz l oa ob"># Sort Values by State_names<br/>df.sort_values(by=['State_names']).head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/87396d79a64a7ab29fde5f74f3b4c691.png" data-original-src="https://miro.medium.com/v2/format:webp/1*M4MgokyJ9yxnrQGjjPxcMQ.png"/></div></figure><p id="aae6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">按照<code class="fe oc od oe nu b">Amount_spent </code>升序排列我们的数据帧:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="a0b2" class="mi mj iq nu b gy ny nz l oa ob"># Sort Values Amount_spent with ascending order<br/>df.sort_values(by=['Amount_spent']).head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/ed7f41d54f6dd87023adb422cf88d66b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TVW42jdV7NUJOMwnVC9hgg.png"/></div></figure><p id="52f7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">按照<code class="fe oc od oe nu b">Amount_spent </code>降序排列我们的数据帧:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="2a53" class="mi mj iq nu b gy ny nz l oa ob"># Sort Values Amount_spent with descending order<br/>df.sort_values(by=['Amount_spent'], ascending=False).head(3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/4c8ba59b5fe4b66e7f81bbac2d10da31.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OwWrGoqJwqgKVceVsnLK-g.png"/></div></figure><p id="49d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">或者，我们可以使用<code class="fe oc od oe nu b">nlargest()</code>和<code class="fe oc od oe nu b">nsmallest()</code>功能显示所需数字的最大值和最小值。例如，如果我们想要显示4个最大的<code class="fe oc od oe nu b">Amount_spent </code>行，那么我们使用这个:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="3eff" class="mi mj iq nu b gy ny nz l oa ob"># nlargest<br/>df.nlargest(4, 'Amount_spent').head(10) # first argument is how many rows you want to disply and second one is columns name</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/7426e06536f4c1323977e0b5f3719efc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dEYqqsx9v3iQSw6fJIG2Lw.png"/></div></figure><p id="0af7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于3个最小的<code class="fe oc od oe nu b">Amount_spent </code>行</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="f980" class="mi mj iq nu b gy ny nz l oa ob"># nsmallest<br/>df.nsmallest(3, 'Age').head(10)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/344f5417331af4638669ba4b10b744ae.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hp_iC66gqNJULAx9XsD_kw.png"/></div></figure><h2 id="3c6a" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">对数据的条件查询</h2><p id="ba81" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">如果我们想要应用单个条件，那么首先我们将给出一个条件，然后我们传递数据帧。例如，如果我们想要显示所有行，其中<code class="fe oc od oe nu b">Payment_method </code>是PayPal，那么我们使用这个:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="657b" class="mi mj iq nu b gy ny nz l oa ob"># filtering - Only show Paypal users<br/>condition = df['Payment_method'] == 'PayPal'<br/>df[condition].head(4)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/f600548d1c36b279fde6c6e1c5dfd7a3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Hm6pDdEg0iYUGfJgC3j7sA.png"/></div></figure><p id="8891" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以像以前一样应用多个条件查询。例如，如果我们想显示所有居住在纽约的已婚女性，那么我们使用以下代码:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="9f0f" class="mi mj iq nu b gy ny nz l oa ob"># first create 3 condition<br/>female_person = df['Gender'] == 'Female'<br/>married_person = df['Marital_status'] == 'Married'<br/>loc_newyork = df['State_names'] == 'New York'<br/><br/># we passing condition on our dataframe<br/>df[female_person &amp; married_person &amp; loc_newyork].head(4)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/1c4c851be7449e63dd2159c5d4dfa203.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OywkNj5c2IMiX7xG-usKCg.png"/></div></figure><h2 id="1a6e" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">5.3汇总或分组数据</h2><h2 id="80fe" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">分组依据</h2><p id="0414" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在Pandas中，按功能分组在数据分析部分更受欢迎。它允许分割和分组数据，应用一个函数，并结合结果。我们可以通过下面的例子来理解这个功能和用法:</p><p id="bd03" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">按一列分组:</strong>例如，如果我们想通过<code class="fe oc od oe nu b">Gender</code>找到<code class="fe oc od oe nu b">Age</code>和<code class="fe oc od oe nu b">Amount_spent</code>的<code class="fe oc od oe nu b">maximum</code>值，那么我们可以使用这个:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="92a7" class="mi mj iq nu b gy ny nz l oa ob">df[['Age', 'Amount_spent']].groupby(df['Gender']).max()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/47d456954a625266d3bd91cba30e2d96.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NobOtgkCmJuM-PsmNgUpCA.png"/></div></figure><p id="d539" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过<code class="fe oc od oe nu b">Gender</code>找到<code class="fe oc od oe nu b">Age</code>和<code class="fe oc od oe nu b">Amount_spent</code>的<code class="fe oc od oe nu b">mean</code>、<code class="fe oc od oe nu b">count</code>和<code class="fe oc od oe nu b">max</code>值，然后我们可以使用<code class="fe oc od oe nu b">agg()</code>函数和<code class="fe oc od oe nu b">groupby()</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="d0f6" class="mi mj iq nu b gy ny nz l oa ob"># Group by one columns<br/>state_gender_res = df[['Age','Gender','Amount_spent']].groupby(['Gender']).agg(['count', 'mean', 'max'])<br/>state_gender_res</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/8527ed40010f0ade04cd9999cf854eb6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Pv62FwJealWF_AaaXnmvcw.png"/></div></figure><p id="ad8c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">多列分组:</strong>通过<code class="fe oc od oe nu b">State_names</code>、<code class="fe oc od oe nu b">Gender</code>、<code class="fe oc od oe nu b">Payment_method </code>找到<code class="fe oc od oe nu b">Amount_spent</code>的总计数、最大值和最小值，然后我们可以在<code class="fe oc od oe nu b">groupby()</code>函数下传递这些列名，并添加带有<code class="fe oc od oe nu b">count</code>、<code class="fe oc od oe nu b">mean</code>、<code class="fe oc od oe nu b">max</code>参数的<code class="fe oc od oe nu b">.agg()</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="fb77" class="mi mj iq nu b gy ny nz l oa ob">#Group By multiple columns<br/>state_gender_res = df[['State_names','Gender','Payment_method','Amount_spent']].groupby([ 'State_names','Gender', 'Payment_method']).agg(['count', 'min', 'max'])<br/>state_gender_res.head(12)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/8d86a10c8bc4fe73271849a2e4b11a46.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-BDAYcow11AVJT9ex2Pe7Q.png"/></div></figure><h2 id="91a4" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">交叉制表(交叉标签)</h2><p id="2076" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">交叉制表(也称为cross tab)是一种定量分析多个变量之间关系的方法。也称为列联表。这将有助于理解不同变量之间的相关性。为了创建这个表，pandas有一个内置函数<code class="fe oc od oe nu b">crosstab()</code>。</p><p id="2243" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了在<code class="fe oc od oe nu b">Maritatal_status</code>和<code class="fe oc od oe nu b">Payment_method</code>列之间创建一个简单的交叉标签，我们只需使用带有两个列名的<code class="fe oc od oe nu b">crosstab()</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="46fe" class="mi mj iq nu b gy ny nz l oa ob">pd.crosstab(df.Marital_status, df.Payment_method)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/a91f1bcc52df8734a04a33453b97dce3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*14a_6OS7eW54hc02HpSr5Q.png"/></div></figure><p id="6031" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以通过<code class="fe oc od oe nu b">margins</code>参数包括小计:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="6b79" class="mi mj iq nu b gy ny nz l oa ob">pd.crosstab(df.Marital_status, df.Payment_method, margins=True, margins_name="Total")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/ad310c26fab86aaa66219cffa70ac09a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GS9jDpaTgzDLIcoG4Lv1Kg.png"/></div></figure><p id="047e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们想要一个显示百分比的比<code class="fe oc od oe nu b">normalize=True</code>参数帮助</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="1d1e" class="mi mj iq nu b gy ny nz l oa ob">pd.crosstab(df.Marital_status, df.Payment_method, normalize=True, margins=True, margins_name="Total")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/de9c69ed7e541115a4632c47ab2a73de.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2g7IRKeVcZC6C_ToKx3g8Q.png"/></div></figure><p id="f340" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这些跨选项卡特性中，我们可以传递多个列名来分组和分析数据。例如，如果我们想知道<code class="fe oc od oe nu b">Marital_status</code>如何分配<code class="fe oc od oe nu b">Payment_method</code>和<code class="fe oc od oe nu b">Employees_status</code>，那么我们将在<code class="fe oc od oe nu b">crosstab()</code>函数中传递这些列的名称，如下所示。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="2d28" class="mi mj iq nu b gy ny nz l oa ob">pd.crosstab(df.Marital_status, [df.Payment_method, df.Employees_status])</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/7f8ace79747440e7ebf9f06dacde6db0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Dqddr7ktNrW80sUY2UyQog.png"/></div></figure><h2 id="7117" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.数据可视化</h2><p id="0ea5" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">可视化是数据分析的关键。最流行的可视化python包是matplotlib和seaborn，但有时熊猫对你来说会很方便。熊猫也很容易提供一些可视化的情节。对于基础分析部分，会比较好用。在这一节中，我们将探索一些不同类型的使用熊猫的情节。以下是情节。</p><h2 id="897b" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.1线形图</h2><p id="c7ef" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">线形图是所有图形图中最简单的。线形图用于跟踪连续时间内的变化，并将信息显示为一系列。折线图是比较多个变量和可视化单个和多个变量趋势的理想工具。</p><p id="3f57" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了在pandas中创建一个线图，我们使用<code class="fe oc od oe nu b">.plot()</code>两列的名称作为参数。例如，我们从一个虚拟数据集创建一个线图。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="38fd" class="mi mj iq nu b gy ny nz l oa ob">dict_line = {<br/>    'year': [2016, 2017, 2018, 2019, 2020, 2021],<br/>    'price': [200, 250, 260, 220, 280, 300]<br/>}<br/>df_line = pd.DataFrame(dict_line)</span><span id="4707" class="mi mj iq nu b gy og nz l oa ob"># use plot() method on the dataframe<br/>df_line.plot('year', 'price');</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/7b1d2098f1a128a47e37264215326e40.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IMA5D0sgJiBmttyYyPLP3w.png"/></div></figure><p id="b290" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上面的折线图显示了不同时间的价格。它显示了价格趋势。</p><h2 id="875e" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.2条形图</h2><p id="5dad" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">条形图也称为条形图，显示不同类别项目的定量或定性值。在条形图中，图数据以条形图的形式表示。条形的长度或高度用于表示每个项目的定量值。条形图可以水平或垂直绘制。为了创造这些情节，请看下面。</p><p id="d03d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">对于单杠:</strong></p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="94e1" class="mi mj iq nu b gy ny nz l oa ob">df['Employees_status'].value_counts().plot(kind='bar');</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/8e5b601e2b5c8685606c52fd7158c141.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QCOBqis_8U2KAYHfIYnexg.png"/></div></figure><p id="9ad1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">对于竖条:</strong></p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="8d81" class="mi mj iq nu b gy ny nz l oa ob">df['Employees_status'].value_counts().plot(kind='barh');</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/4c55112d98b8b1b569189348192eaafd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TBWS_u0pnKfdv5ajv096NQ.png"/></div></figure><h2 id="76f0" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.3饼图</h2><p id="1e5c" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">饼图也称为饼图。饼图是一个圆形图形，表示总值及其组成部分。圆的面积代表总值，圆的不同部分代表不同的部分。在该图中，数据以百分比表示。每个组成部分都表示为总值的百分比。</p><p id="96db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以熊猫为创作派的情节。我们在数据框列或系列中使用<code class="fe oc od oe nu b">plot()</code>函数中的<code class="fe oc od oe nu b">kind=pie</code>。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="df97" class="mi mj iq nu b gy ny nz l oa ob">df['Segment'].value_counts().plot(<br/>    kind='pie');</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/a433f24ed76ff0ddd43ad7c2bfc5d796.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jcrL88m1GzkaSwC_q27e4w.png"/></div></figure><h2 id="8793" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.4箱线图</h2><p id="6d66" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">箱形图也称为箱须图。此图用于显示变量基于其四分位数的分布。箱形图显示一组数据的五个数字的汇总。五位数汇总是最小值、第一个四分位数、中值、第三个四分位数和最大值。识别异常值也将很受欢迎。</p><p id="9fc2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以用一列或多列来绘制。对于多列，我们需要在<code class="fe oc od oe nu b">y</code>变量中传递列名作为列表。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="03ef" class="mi mj iq nu b gy ny nz l oa ob">df.plot(y=['Amount_spent'], kind='box');</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/6cef419ee647de69b4090109ae870945.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Sda9bkls8G4aPKCkJcSinA.png"/></div></figure><p id="2006" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在箱线图中，我们可以绘制出分类变量相对于数值变量的分布，并对它们进行比较。让我们用<code class="fe oc od oe nu b">Employees_status </code>和<code class="fe oc od oe nu b">Amount_spent</code>列画熊猫<code class="fe oc od oe nu b">boxplot()</code>的方法:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0439" class="mi mj iq nu b gy ny nz l oa ob">import matplotlib.pyplot as plt<br/><br/>np.warnings.filterwarnings('ignore', category=np.VisibleDeprecationWarning) <br/>fig, ax = plt.subplots(figsize=(6,6)) <br/><br/>df.boxplot(by ='Employees_status', column =['Amount_spent'],ax=ax, grid = False);</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/c8ba6d8d225835517f299f288ffb8e9e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*iMnJ17_9zOYnyICG8A1jvA.png"/></div></figure><h2 id="ad4a" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.5直方图</h2><p id="b80b" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">直方图显示了数据项分组值之间定量测量的频率和分布。它通常用于统计，以显示在特定范围或时段内某一类型的变量出现的数量。下面我们将绘制一个直方图来观察年龄分布。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="ed34" class="mi mj iq nu b gy ny nz l oa ob">df.plot(<br/>    y='Age',<br/>    kind='hist',<br/>    bins=10<br/>);</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/2571ffc02422f68a4f2388accf694041.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0sxnb1yZSpEI8qRc6uP0vg.png"/></div></figure><h2 id="c3c7" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.6 KDE情节</h2><p id="e10b" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">核密度估计(KDE)图是一种可视化数据集中观察值分布的方法，类似于直方图。KDE使用一维或多维的连续概率密度曲线来表示数据。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="4db3" class="mi mj iq nu b gy ny nz l oa ob">df.plot(<br/>    y='Age',<br/>    xlim=(0, 100),<br/>    kind='kde'<br/>);</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/c2ff474866b572d4cede014aaa156a15.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Z0Oqzd1940uCA4JeCX7JhQ.png"/></div></figure><h2 id="04dc" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">6.7散点图</h2><p id="f992" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">散点图用于观察和显示不同类别项目的两个定量变量之间的关系。数据集的每个成员都被绘制成一个点，其x-y坐标与其两个变量的值相关。下面我们将绘制一个散点图来显示<code class="fe oc od oe nu b">Age</code>和<code class="fe oc od oe nu b">Amount_spent</code>列之间的关系。</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="c50d" class="mi mj iq nu b gy ny nz l oa ob">df.plot(<br/>    x='Age',<br/>    y='Amount_spent',<br/>    kind='scatter'<br/>);</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/ef7d18a901f7300bfdbfc98808301862.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PmZ9b8IPjbIHze4pRWYBIg.png"/></div></figure><h2 id="f651" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">7.最后的想法</h2><p id="2197" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">在本文中，我们知道如何使用pandas来读取、预处理、分析和可视化数据。它还可以用于内存管理，以更少的资源实现快速计算。这篇文章的主要动机是帮助那些好奇的人们了解熊猫以进行数据分析。</p><p id="b1fd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您对本文有任何疑问或帮助，请随时通过LinkedIn联系我。如果你觉得这篇文章有帮助，那么请跟我来进一步学习。欢迎您的建议和反馈。感谢您阅读我的文章。有精彩的学习。</p><p id="d695" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="me">随时查看本教程的</em> <a class="ae le" href="https://github.com/norochalise/pandas-tutorial-article-2022" rel="noopener ugc nofollow" target="_blank"> <em class="me"> GitHub </em> </a> <em class="me">回购。</em></p><h2 id="6653" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lo mr ms mt ls mu mv mw lw mx my mz iw bi translated">8.参考</h2><ol class=""><li id="179f" class="na nb iq lh b li nc ll nd lo ne ls nf lw ng ma nh ni nj nk bi translated"><a class="ae le" href="https://pandas.pydata.org/docs/user_guide/index.html" rel="noopener ugc nofollow" target="_blank">熊猫用户指南</a></li><li id="0be2" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://www.packtpub.com/product/pandas-1-x-cookbook-second-edition/9781839213106" rel="noopener ugc nofollow" target="_blank">熊猫1.x食谱</a></li><li id="f0d2" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://www.packtpub.com/product/the-data-wrangling-workshop-second-edition/9781839215001" rel="noopener ugc nofollow" target="_blank">数据争论研讨会</a></li><li id="52a9" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://www.oreilly.com/library/view/python-for-data/9781449323592/" rel="noopener ugc nofollow" target="_blank">用于数据分析的Python</a></li><li id="7d2b" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://www.youtube.com/watch?v=BaV4PRXYNIY&amp;list=PLyMom0n-MBrpzC91Uo560S4VbsiLYtCwo" rel="noopener ugc nofollow" target="_blank">用Python进行数据分析:从零到熊猫——Jovian YouTube频道</a></li><li id="bb3d" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://www.youtube.com/watch?v=hl-TGI4550M&amp;list=PL5-da3qGB5IBITZj_dYSFqnd_15JgqwA6" rel="noopener ugc nofollow" target="_blank">熊猫最佳实践——数据学校YouTube频道</a></li><li id="ea05" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://www.youtube.com/watch?v=ZyhVh-qRZPA&amp;list=PL-osiE80TeTsWmV9i9c58mdDCSskIFdDS" rel="noopener ugc nofollow" target="_blank">熊猫教程——科里·斯查费YouTube频道</a></li><li id="1da6" class="na nb iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://pbpython.com/pandas-crosstab.html" rel="noopener ugc nofollow" target="_blank">熊猫交叉表讲解</a></li></ol><p id="c2a9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="me">跟我上</em> </strong> <a class="ae le" href="https://norochalise.medium.com/" rel="noopener"> <strong class="lh ja"> <em class="me">中</em></strong></a><strong class="lh ja"><em class="me"/></strong><a class="ae le" href="https://twitter.com/norochalise" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="me">推特</em></strong></a><strong class="lh ja"><em class="me">&amp;</em></strong><a class="ae le" href="https://www.linkedin.com/in/norochalise/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="me">领英</em> </strong> </a></p></div></div>    
</body>
</html>