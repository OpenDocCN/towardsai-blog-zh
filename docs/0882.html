<html>
<head>
<title>5 Tricky SQL Queries Solved</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决了5个棘手的SQL查询</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/5-tricky-sql-queries-solved-919266e2d524?source=collection_archive---------0-----------------------#2020-09-03">https://pub.towardsai.net/5-tricky-sql-queries-solved-919266e2d524?source=collection_archive---------0-----------------------#2020-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9772" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="9021" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">解释解决一些复杂SQL查询的方法。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7ffb8a8b80df89c875cc8f6f4c71e314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7r7HSYkbn73NrmR_skvh5w.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@olav_ahrens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Olav Ahrens rtne</a>在<a class="ae lh" href="https://unsplash.com/s/photos/problem?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1258" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQL(结构化查询语言)是数据科学家工具箱中非常重要的工具。掌握SQL不仅从面试的角度来看是必要的，而且通过能够解决复杂的查询来很好地理解SQL将使我们在竞争中处于领先地位。在这篇文章中，我将谈谈我发现的5个棘手的问题以及我解决它们的方法。</p><blockquote class="me mf mg"><p id="beb9" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd">注意— </strong>每个查询可以用不同的方式编写。在讨论我的解决方案之前，试着思考一下方法。你也可以在回复部分建议不同的方法。</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="6941" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询1</h1><p id="7c8e" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们得到一个由两列组成的表格，<strong class="lk jd">姓名、</strong>和<strong class="lk jd">职业</strong>。我们需要查询括号中职业列第一个字母后面紧跟着的所有名字。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/871280f3391134cfc7d0f38d958aa26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*AxTZq5TpmSErpr46YsY_oQ.png"/></div></figure><h2 id="76be" class="nq mt it bd mu nr ns dn my nt nu dp nc lr nv nw ne lv nx ny ng lz nz oa ni iz bi translated">我的解决方案</h2><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="e45a" class="nq mt it oc b gy og oh l oi oj"><strong class="oc jd">SELECT</strong><br/><strong class="oc jd">CONCAT</strong>(Name, ’(‘, <strong class="oc jd">SUBSTR</strong>(Profession, 1, 1), ’)’) <br/><strong class="oc jd">FROM</strong> table;</span></pre><p id="8976" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们需要结合姓名和职业，所以我们可以使用<code class="fe ok ol om oc b">CONCAT</code>。我们还需要在括号内只有一个字母。因此，我们将使用<code class="fe ok ol om oc b">SUBSTR</code>并传递列名、起始索引和子串长度，因为我们只需要第一个字母，我们将传递1，1。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f2e8" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询2</h1><p id="c98a" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">Tina被要求从她创建的employees表中计算所有雇员的平均工资，但是在结果显示一个非常低的平均值后，她意识到键盘上的0键不起作用。她想让我们帮忙找出计算平均值和实际平均值之间的差异。我们必须编写一个查询来查找错误(实际的AVG —计算的AVG)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/eebde6a25508815c0a4fca4f2a9f6402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzOP57HoTn9KyDSWdcIfSg.png"/></div></div></figure><h2 id="f076" class="nq mt it bd mu nr ns dn my nt nu dp nc lr nv nw ne lv nx ny ng lz nz oa ni iz bi translated">我的解决方案</h2><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="3d57" class="nq mt it oc b gy og oh l oi oj"><strong class="oc jd">SELECT  </strong><br/><strong class="oc jd">AVG</strong>(Salary) - <strong class="oc jd">AVG</strong>(<strong class="oc jd">REPLACE</strong>(Salary, 0, ’’))  <br/><strong class="oc jd">FROM</strong> table;</span></pre><p id="cc1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里需要注意的一点是，我们只有一个包含实际工资值的表。为了创建错误场景，我们使用<code class="fe ok ol om oc b">REPLACE</code>来替换0。我们将传递列名、要替换的值以及我们将用来替换<code class="fe ok ol om oc b">REPLACE</code>方法的值。然后，我们使用聚合函数<code class="fe ok ol om oc b">AVG</code>找出平均值的差异。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5dd8" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询3</h1><p id="f864" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们得到一个表，它是一个由两列<strong class="lk jd">节点</strong>和<strong class="lk jd">父节点组成的<a class="ae lh" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">二叉查找树</a>。我们必须编写一个查询，返回按节点值升序排序的节点类型。有3种类型。<br/> 1。根-如果节点是根节点<br/> 2。叶-如果节点是叶节点<br/> 3。内部-如果节点既不是根也不是叶。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/7f3851401a1385f5ec7242cb165993c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVuAi8w9RPMgLoRHcbcaJw.png"/></div></div></figure><h2 id="c3ad" class="nq mt it bd mu nr ns dn my nt nu dp nc lr nv nw ne lv nx ny ng lz nz oa ni iz bi translated">我的解决方案</h2><p id="ae79" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">经过初步分析，我们可以得出结论，如果一个给定的节点N的P值为空，那么它就是根。并且对于给定的节点N，如果它存在于P列中，则它是内部节点。基于这个想法，让我们写一个查询。</p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="149d" class="nq mt it oc b gy og oh l oi oj"><strong class="oc jd">SELECT CASE</strong><br/>    <strong class="oc jd">WHEN</strong> P <strong class="oc jd">IS NULL</strong> <strong class="oc jd">THEN</strong> <strong class="oc jd">CONCAT</strong>(N, ' Root')<br/>    <strong class="oc jd">WHEN</strong> N <strong class="oc jd">IN</strong> <strong class="oc jd">(SELECT DISTINCT</strong> P from BST) <strong class="oc jd">THEN</strong> <strong class="oc jd">CONCAT</strong>(N, ' Inner')<br/>    <strong class="oc jd">ELSE</strong> <strong class="oc jd">CONCAT</strong>(N, ' Leaf')<br/>    <strong class="oc jd">END</strong><br/><strong class="oc jd">FROM</strong> BST<br/><strong class="oc jd">ORDER BY</strong> N asc;</span></pre><p id="b389" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用<code class="fe ok ol om oc b">CASE</code>作为开关函数。正如我提到的，如果对于给定的节点N，P为空，那么N就是根。因此，我们使用<code class="fe ok ol om oc b">CONCAT</code>来组合节点值和标签。类似地，如果给定的节点N在列P中，则它是内部节点。为了获取P列中的所有节点，我们编写了一个子查询，该子查询返回P列中的所有不同节点。因为我们被要求按节点值升序排列输出，所以我们使用了<code class="fe ok ol om oc b">ORDER BY</code>子句。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b3ad" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询4</h1><p id="0e1c" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们得到一个交易表，该表由<strong class="lk jd">交易标识、用户标识、交易日期、产品标识和数量</strong>组成。我们需要查询在多天内购买产品的用户数量(注意，给定的用户可以在一天内购买多种产品)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/555a815ada9efcdb1de271855896deab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TK-GrUUsd3dmMR_GwRAFpQ.png"/></div></div></figure><h2 id="21a6" class="nq mt it bd mu nr ns dn my nt nu dp nc lr nv nw ne lv nx ny ng lz nz oa ni iz bi translated">我的解决方案</h2><p id="318f" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">为了解决这个查询，我们不能直接计算user_id的出现次数，如果出现多次，则返回user_id，因为给定的用户在一天中可能有多次交易。因此，如果给定的user_id有多个相关联的不同日期，这意味着他在多个日期购买了产品。按照同样的方法，我编写了一个查询。(内部查询)</p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="58a0" class="nq mt it oc b gy og oh l oi oj"><strong class="oc jd">SELECT COUNT</strong>(user_id)<br/><strong class="oc jd">FROM</strong><br/>(<br/><strong class="oc jd">SELECT</strong> user_id<br/><strong class="oc jd"> FROM </strong>orders<br/><strong class="oc jd"> GROUP BY </strong>user_id<br/><strong class="oc jd"> HAVING COUNT</strong>(<strong class="oc jd">DISTINCT DATE</strong>(date)) &gt; 1<br/>) t1</span></pre><p id="da84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于问题询问的是user_id的数量，而不是user _ id本身，所以我们在外部查询中使用了<code class="fe ok ol om oc b">COUNT</code>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9e92" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询5</h1><p id="5c1d" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们得到一个订阅表，其中包含每个用户的订阅开始和结束日期。我们需要编写一个查询，根据与其他用户的日期重叠，为每个用户返回true/false。例如，如果用户1的订阅期与任何其他用户重叠，查询必须为用户1返回<strong class="lk jd"> True </strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/89c60a0cb7e70b1931a3a2cf78f94e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*yOGhkVgqUDlYYwtU0a-wvQ.png"/></div></figure><h2 id="f540" class="nq mt it bd mu nr ns dn my nt nu dp nc lr nv nw ne lv nx ny ng lz nz oa ni iz bi translated">我的解决方案</h2><p id="d61e" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">经过初步分析，我们知道必须将每个订阅与其他订阅进行比较。让我们把<strong class="lk jd">用户A </strong>的开始和结束日期看作<code class="fe ok ol om oc b"><strong class="lk jd">startA</strong></code>和<code class="fe ok ol om oc b"><strong class="lk jd">endA</strong></code>，同样对于<strong class="lk jd">用户B </strong>、<code class="fe ok ol om oc b"><strong class="lk jd">startB</strong></code>和<code class="fe ok ol om oc b"><strong class="lk jd">endB</strong></code> <strong class="lk jd">。</strong></p><p id="1b66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果<code class="fe ok ol om oc b"><strong class="lk jd">startA</strong></code> <strong class="lk jd"> ≤ </strong> <code class="fe ok ol om oc b"><strong class="lk jd">endB</strong></code> <strong class="lk jd">和</strong> <code class="fe ok ol om oc b"><strong class="lk jd">endA</strong></code> <strong class="lk jd"> ≥ </strong> <code class="fe ok ol om oc b"><strong class="lk jd">startB</strong></code>那么我们可以说这两个日期范围重叠了。让我们举两个例子。让我们先比较一下U1和U3。<br/><code class="fe ok ol om oc b">startA</code>= 2020–01–01<br/><code class="fe ok ol om oc b">endA</code>= 2020–01–31<br/>T10】= 2020–01–16<br/>T11】= 2020–01–26</p><p id="dc49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们可以看到<code class="fe ok ol om oc b"><strong class="lk jd">startA</strong></code>(2020–01–01)小于<code class="fe ok ol om oc b"><strong class="lk jd">endB</strong></code><strong class="lk jd">(</strong>2020–01–26)，同样，<strong class="lk jd">endA</strong>(2020–01–31)大于<code class="fe ok ol om oc b"><strong class="lk jd">startB</strong></code>(2020–01–16)，因此可以得出日期重叠的结论。类似地，如果比较U1和U4，上述条件不成立，将返回false。</p><p id="9fb8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还必须确保不会将用户与他自己的订阅进行比较。我们还想在自身上运行一个左连接，将一个用户与满足我们条件的每个其他用户匹配起来。我们现在将创建同一个表的两个副本s1和s2。</p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="e7be" class="nq mt it oc b gy og oh l oi oj"><strong class="oc jd">SELECT</strong> *<br/><strong class="oc jd">FROM</strong> subscriptions <strong class="oc jd">AS</strong> s1<br/><strong class="oc jd">LEFT</strong> <strong class="oc jd">JOIN</strong> subscriptions <strong class="oc jd">AS</strong> s2<br/>    <strong class="oc jd">ON</strong> s1.user_id != s2.user_id<br/>        AND s1.start_date &lt;= s2.end_date<br/>        AND s1.end_date &gt;= s2.start_date</span></pre><p id="5f48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">给定条件连接，在日期之间存在重叠的情况下，对于s1中的每个user_id，s2中的user_id应该存在。</p><h2 id="2f02" class="nq mt it bd mu nr ns dn my nt nu dp nc lr nv nw ne lv nx ny ng lz nz oa ni iz bi translated">输出—</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/f03297d506f4bbecc484f98788e61d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqESA3R2KKwn1Vlb9nK19Q.png"/></div></div></figure><p id="6b07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，在日期重叠的情况下，每个用户都有另一个用户。对于用户1，有2行表示他与2个用户匹配。对于用户4，相应的id为空，表示他与任何其他用户都不匹配。</p><p id="7132" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以根据s1.user_id字段进行分组，并检查s2.user_id不为NULL的用户是否有任何值为true。</p><p id="91cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">最终查询</strong></p><pre class="ks kt ku kv gt ob oc od oe aw of bi"><span id="de63" class="nq mt it oc b gy og oh l oi oj"><strong class="oc jd">SELECT</strong><br/>    s1.user_id<br/>    , (<strong class="oc jd">CASE</strong> <strong class="oc jd">WHEN</strong> s2.user_id <strong class="oc jd">IS</strong> NOT NULL <strong class="oc jd">THEN</strong> 1 <strong class="oc jd">ELSE</strong> 0 <strong class="oc jd">END</strong>) <strong class="oc jd">AS</strong> overlap<br/><strong class="oc jd">FROM</strong> subscriptions <strong class="oc jd">AS</strong> s1<br/><strong class="oc jd">LEFT</strong> <strong class="oc jd">JOIN</strong> subscriptions <strong class="oc jd">AS</strong> s2<br/>    <strong class="oc jd">ON</strong> s1.user_id != s2.user_id<br/>        AND s1.start_date &lt;= s2.end_date<br/>        AND s1.end_date &gt;= s2.start_date<br/><strong class="oc jd">GROUP</strong> <strong class="oc jd">BY</strong> s1.user_id</span></pre><p id="ff6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用<code class="fe ok ol om oc b">CASE</code>子句根据给定用户的s2.user_id值来标记1和0。最终的输出看起来像这样-</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/122275258f9f7aa58f1ce21ce21aaee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVzcUEKXr-IGGBKvZ4ka8g.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="56b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在结束之前，我想推荐一本关于SQL的好书，我非常喜欢并且觉得非常有用。</p><p id="63bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://www.amazon.in/gp/product/B0026OR3KI/ref=as_li_tl?ie=UTF8&amp;camp=3638&amp;creative=24630&amp;creativeASIN=B0026OR3KI&amp;linkCode=as2&amp;tag=kurasaiteja-21&amp;linkId=e1ca4cf824b67c4fff6865a5163712c2" rel="noopener ugc nofollow" target="_blank"> SQL Cookbook:数据库开发人员的查询解决方案和技术(Cookbook(O ' Reilly))</a></p><h1 id="7534" class="ms mt it bd mu mv or mx my mz os nb nc ki ot kj ne kl ou km ng ko ov kp ni nj bi translated"><strong class="ak">点击</strong> <a class="ae lh" href="https://medium.com/towards-artificial-intelligence/5-tricky-sql-queries-solved-part-ii-8acceec170b0" rel="noopener"> <strong class="ak">此处</strong> </a> <strong class="ak">查看本文第二部分更具挑战性的问题。</strong></h1><h1 id="9910" class="ms mt it bd mu mv or mx my mz os nb nc ki ot kj ne kl ou km ng ko ov kp ni nj bi translated">结论</h1><p id="039e" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">掌握SQL需要大量的练习。在这篇文章中，我提出了5个棘手的问题，并解释了解决它们的方法。SQL的特点是每个查询可以用许多不同的方式编写。请在回复中分享你的方法。我希望你今天学到了新东西！</p><p id="f4b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果想联系，<strong class="lk jd">在</strong><a class="ae lh" href="https://www.linkedin.com/in/saiteja-kura-49803b13b/" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">LinkedIn</strong></a><strong class="lk jd">上联系我。</strong></p></div></div>    
</body>
</html>