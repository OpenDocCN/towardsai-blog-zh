<html>
<head>
<title>Airflow Production Tips — Grouped Failures and Retries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流生成提示—分组故障和重试</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/airflow-production-tips-grouped-failures-and-retries-8f18df405364?source=collection_archive---------1-----------------------#2022-10-25">https://pub.towardsai.net/airflow-production-tips-grouped-failures-and-retries-8f18df405364?source=collection_archive---------1-----------------------#2022-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e7177822358508466842d5f57cd318c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sJCDPRT_jllfM77v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@simmerdownjpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克森煨</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="b5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apache Airflow已经成为数据编排的事实标准<em class="lb">de</em><em class="lb"/>。然而，随着时间的推移和版本的变化，它积累了一系列的细微差别和错误，这可能会阻碍它在生产中的使用。</p><p id="dfe4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一系列文章旨在引导Apache Airflow用户克服这些问题，也就是我所面临的问题。</p><blockquote class="lc ld le"><p id="b639" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">注意:像往常一样，所有的代码都可以在我的GitHub资源库中获得，这里的<a class="ae kc" href="https://github.com/Guilherme-B/airflow-utils" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a>。</p></blockquote><h1 id="7eeb" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">分组失败和重试</h1><blockquote class="lc ld le"><p id="cf65" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir"> TLDR </strong>:在Airflow中，将多个任务视为一个任务是很常见的，常见的用例是运行操作符与其传感器操作符一起使用。如果传感器任务失败，那么从技术上讲，整个过程都失败了，应该重新启动。但是，默认情况下，Airflow只会重试传感器任务，而不会重试运行运行任务。在这篇文章中，你会发现如何修复它。</p><p id="5be2" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir"> TLDR #2 </strong>:这里<a class="ae kc" href="#2f3d" rel="noopener ugc nofollow">可以直接跳到解决方案</a></p></blockquote><h1 id="2f0e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题陈述</h1><p id="ccb4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">通常情况下，我们都面临着创建任务集的需求，我们希望这些任务集要么失败(并重试)，要么整体成功。</p><p id="f451" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑运行名为<em class="lb"> TaskRun </em>的<em class="lb">AzureDataFactoryRunPipelineOperator、<em class="lb">azuredatafactorypeipelinerunstatussensor</em>名为<em class="lb"> TaskSensor </em>的相应传感器来检索其状态的情况。</em></p><p id="c82a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然<em class="lb"> TaskRun </em>可以成功触发作业，但是Azure数据工厂运行实例总是有可能失败，在这种情况下,<em class="lb"> TaskSensor </em>将被标记为失败并等待重试。但是<strong class="kf ir">、<em class="lb">任务运行</em>仍然会成功</strong>，因此<strong class="kf ir">不会被重试</strong>。</p><p id="845f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，我们希望相关的任务要么失败，要么作为一个整体成功。</p><h2 id="3be3" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">为什么会这样？</h2><p id="fc84" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在Apache Airflow中，尽管任务是通过依赖关系建立(通过<em class="lb"> &lt; &lt;、</em> &gt; &gt;依赖关系操作符或者<em class="lb"> set_downstream </em>和<em class="lb"> set_upstream </em>函数)来链接的，但是，这仅仅是帮助定义任务的流——或者直接非循环图——虽然它定义了单向依赖关系(下游任务),但是它并不传达关于上游依赖关系的信息。换句话说，如果我们使用适当的依赖操作符将<em class="lb"> TaskRun </em>与<em class="lb"> TaskSensor </em>结合起来:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/410884dbfbd78238ca8632a5d26cc6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*1z-RQGDDTwDn0aa6GlOVDw.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个任务操作符，后跟相应的传感器操作符</figcaption></figure><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="2110" class="ml lj iq nd b gy nh ni l nj nk">TaskRun = AzureDataFactoryRunPipelineOperator(...)<br/>TaskSensor = AzureDataFactoryPipelineRunStatusSensor(...)<br/>TaskRun &gt;&gt; TaskSensor</span></pre><p id="2aa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apache Airflow知道如果<em class="lb"> TaskRun </em>失败，<em class="lb"> TaskSensor </em>将被跳过，因为它检查TaskRun的<em class="lb">下游</em>任务(<em class="lb"> TaskSensor </em>)并跳过它们。然而，不能从相反的方面推断同样的情况，因为上游任务可能确实已经成功了，并且我们可能不想重复它。例如，如果不是<em class="lb"> TaskRun </em>和<em class="lb"> TaskSensor，</em>我们会有一个<em class="lb"> TaskExtract </em>和<em class="lb"> TaskTransform </em>按上述顺序，并且<em class="lb"> TaskExtract </em>成功，但是<em class="lb"> TaskTransform </em>失败，我们不希望TaskExtract被重试，这是Airflow的默认行为，当然，这是正确的。</p><h1 id="2f3d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决方案</h1><p id="09a6" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">不像在我们之前的文章中，我们探索了使用ORM来提取<em class="lb"> DAGRun </em>信息，我们的问题的解决方案直接围绕着任务，因为它们包含关于它们上游任务的知识，因此我们的问题的解决方案要简单得多。</p><p id="1e68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们问题的解决方案分为两个简单的步骤:</p><ol class=""><li id="f0e5" class="nl nm iq kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">提取指定<em class="lb">任务实例</em>的所有<em class="lb">上游</em>任务实例<em class="lb">的列表</em></li><li id="7534" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">根据必要的行为，将<em class="lb">上游</em>任务实例标记为重试或失败</li><li id="eba7" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">向<em class="lb">任务</em>定义中添加适当的回调函数</li></ol></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="9c77" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">第一步:提取指定<em class="og">任务实例</em>的所有<em class="og">上游</em>任务实例<em class="og">的列表</em></h2><p id="bbc4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">第一步可能是最复杂的，因为有两种不同的解决问题的方法:</p><ol class=""><li id="1508" class="nl nm iq kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">我们可以在指定的<em class="lb">上游</em>深度<em class="lb">内标记任务</em></li><li id="5e7a" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">或者我们可以根据任务的<em class="lb">任务</em> ID来标记任务</li></ol><p id="bfb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将探索和准备每种方法，并最终将它们结合起来实现扩展功能。</p><p id="4ddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从第一个也是最简单的方法开始，包括四个步骤:</p><ol class=""><li id="97e5" class="nl nm iq kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">根据名称获取要标记的<em class="lb">任务</em>的列表</li><li id="f9fd" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">检索名称在提供的<em class="lb">任务</em>名称中的<em class="lb">任务实例</em>实例</li></ol><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="a910" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二种方法更加复杂和脆弱，并且只在特定的假设下工作:所有要标记的上游任务<em class="lb">只是线性依赖，意味着在指定的<em class="lb">扫描深度</em>内不涉及<em class="lb">分支</em>。</em></p><ol class=""><li id="004c" class="nl nm iq kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">对每个指定的<em class="lb">扫描深度</em> <em class="lb">级别</em>进行迭代，从较低级别向较高级别推进</li><li id="d27d" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">在指定的<em class="lb">扫描深度级别</em>检索并验证<em class="lb">任务</em>的<em class="lb">上游任务id</em>的数量</li><li id="9776" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">追加检索到的<em class="lb">上游任务ID </em></li><li id="bef2" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">继续执行下一个<em class="lb">扫描深度级别</em>的任务循环的下一步</li><li id="db82" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">循环完成后，检索与检索到的<em class="lb">任务id相关联的<em class="lb">任务实例</em>。</em></li></ol><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="a760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这两种方法结合起来，并将其封装在一个可重用的函数中，这是我们的第一步，也是主要的一步:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="a894" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">步骤2:根据必要的行为，将<em class="og">上游</em>任务实例标记为重试或失败。</h2><p id="ac67" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">第二步是一个简单的实现，它利用先前定义的<em class="lb">_ get _ upstream _ task _ instance _ list</em>，并简单地用期望的状态标记关联的<em class="lb"> TaskInstances </em>。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="12d3" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">步骤3:将适当的回调函数添加到<em class="og">任务</em>定义中</h2><p id="c824" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">既然我们已经添加了提取与给定TaskInstance相关联的所有上游task instance并将其标记为所需状态的可能性，我们必须让Airflow知道如何利用它们。</p><p id="da13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步只是简单地将我们的函数与<em class="lb"> on_failure_callback </em>和<em class="lb"> on_retry_callback </em> <em class="lb">任务</em>定义回调相关联:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><blockquote class="lc ld le"><p id="09c2" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">如果你觉得这些资源有用，请在评论中告诉我，像往常一样，你可以在我的<a class="ae kc" href="https://github.com/Guilherme-B/airflow-utils" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到这些代码！</p></blockquote></div></div>    
</body>
</html>