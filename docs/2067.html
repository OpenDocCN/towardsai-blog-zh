<html>
<head>
<title>Introduction to Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python简介</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/python-for-beginners-7388aaeee696?source=collection_archive---------4-----------------------#2021-08-05">https://pub.towardsai.net/python-for-beginners-7388aaeee696?source=collection_archive---------4-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e00c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><p id="4d00" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本教程中，我们将探索Python编程语言的基础。</p><p id="b392" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">改编自<a class="ae kx" href="http://jrjohansson.github.io" rel="noopener ugc nofollow" target="_blank"> J.R .约翰逊</a></p><h2 id="894d" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">Python程序文件</h2><ul class=""><li id="ad8c" class="lq lr it kb b kc ls kg lt kk lu ko lv ks lw kw lx ly lz ma bi translated">Python代码通常存储在以“<code class="fe mb mc md me b">.py</code>”结尾的文本文件中:</li><li id="b1b4" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated"><code class="fe mb mc md me b">myprogram.py</code></li><li id="63ae" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">Python程序文件中的每一行都被假定为Python语句或其一部分。</li><li id="96b3" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">唯一的例外是注释行，它以字符<code class="fe mb mc md me b">#</code>开始(可选地以任意数量的空白字符开头，即制表符或空格)。Python解释器通常会忽略注释行。</li><li id="3789" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">要从命令行运行我们的Python程序，我们使用:</li><li id="5e27" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated"><code class="fe mb mc md me b">$ python myprogram.py</code></li></ul><h2 id="d385" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">IPython笔记本</h2><p id="d705" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">这个文件——一个IPython笔记本——不遵循文本文件中Python代码的标准模式。相反，IPython笔记本以<a class="ae kx" href="http://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>格式存储为一个文件。优点是我们可以混合格式化文本、Python代码和代码输出。它需要IPython笔记本服务器来运行它，因此不是一个独立的Python程序，如上所述。除此之外，进入程序文件的Python代码和IPython笔记本之间没有任何区别。</p><h2 id="ded3" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">模块</h2><p id="0df3" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">Python中的大多数功能都是由<strong class="kb jd">模块</strong>提供的。Python标准库是一个大型的模块集合，它提供了通用设施的<em class="mn">跨平台</em>实现，比如访问操作系统、文件I/O、字符串管理、网络通信等等。</p><h2 id="4325" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">参考</h2><ul class=""><li id="ef45" class="lq lr it kb b kc ls kg lt kk lu ko lv ks lw kw lx ly lz ma bi translated">Python语言参考:<a class="ae kx" href="https://docs.python.org/3/reference/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/index.html</a></li><li id="7b12" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">Python标准库参考:<a class="ae kx" href="https://docs.python.org/3/library/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/index.html</a></li></ul><p id="41ff" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">要在Python程序中使用一个模块，首先必须将其导入。可以使用<code class="fe mb mc md me b">import</code>语句导入一个模块。例如，要导入包含许多标准数学函数的模块，我们可以这样做:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="99aa" class="ky kz it me b gy mw mx l my mz">import math</span></pre><p id="7a8e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这包括整个模块，并使它在程序的后面可用。例如，我们可以这样做:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="16a4" class="ky kz it me b gy mw mx l my mz">import math<br/><br/>x = math.cos(2 * math.pi)<br/><br/>print(x)</span><span id="6315" class="ky kz it me b gy na mx l my mz">1.0</span></pre><p id="b0d9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们还可以导入一个模块，并使用<em class="mn">作为</em>关键字对其进行重命名:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="5898" class="ky kz it me b gy mw mx l my mz">import math as m<br/><br/>x = m.cos(2 * m.pi)<br/>print(x)</span><span id="a8a2" class="ky kz it me b gy na mx l my mz">1.0</span></pre><p id="44b3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习1: </strong>计算…的值</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/302966a547ebe359b9fa934e7ae18116.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*_Wx1000kkj4LsKpU2Ltbvw.png"/></div></figure><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="6fb9" class="ky kz it me b gy mw mx l my mz">m.sin(3*m.pi)</span><span id="e11a" class="ky kz it me b gy na mx l my mz">3.6739403974420594e-16</span></pre><p id="1173" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">或者，我们可以选择将模块中的所有符号(函数和变量)导入到当前的名称空间(这样我们就不需要在每次使用来自<code class="fe mb mc md me b">math</code>模块的东西时都使用前缀“<code class="fe mb mc md me b">math.</code>”:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="10cd" class="ky kz it me b gy mw mx l my mz">from math import *<br/><br/>x = cos(2 * pi)<br/><br/>print(x)</span><span id="b396" class="ky kz it me b gy na mx l my mz">1.0</span></pre><p id="d08f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这种模式可能非常方便，但是在包含许多模块的大型程序中，通过使用<code class="fe mb mc md me b">import math</code>模式，将每个模块的符号保存在它们自己的名称空间中通常是一个好主意。这将消除命名空间冲突的潜在混淆问题。</p><p id="b066" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">作为第三种选择，我们可以选择只从一个模块中导入一些选定的符号，方法是明确列出我们想要导入的符号，而不是使用通配符<code class="fe mb mc md me b">*</code>:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="200a" class="ky kz it me b gy mw mx l my mz">from math import cos, pi<br/><br/>x = cos(2 * pi)<br/><br/>print(x)</span><span id="49ef" class="ky kz it me b gy na mx l my mz">1.0</span></pre><h2 id="e798" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">变量和类型</h2><h2 id="9979" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">符号名称</h2><p id="795f" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">Python中的变量名可以包含字母数字字符<code class="fe mb mc md me b">a-z</code>、<code class="fe mb mc md me b">A-Z</code>、<code class="fe mb mc md me b">0-9</code>和一些特殊字符如<code class="fe mb mc md me b">_</code>。普通变量名必须以字母开头。</p><p id="dda2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">按照惯例，变量名以小写字母开头，类名以大写字母开头。</p><h2 id="27ca" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">分配</h2><p id="f271" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">Python中的赋值运算符是<code class="fe mb mc md me b">=</code>。Python是一种动态类型语言，所以我们在创建变量时不需要指定变量的类型。</p><p id="b04f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">为新变量赋值会创建变量:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="d087" class="ky kz it me b gy mw mx l my mz"># variable assignments<br/>x = 1.0<br/>my_variable = 12.2</span></pre><p id="2fbc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">虽然没有明确指定，但是变量确实有关联的类型。该类型是从分配给它的值派生的。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="aedd" class="ky kz it me b gy mw mx l my mz">type(x)</span><span id="1e10" class="ky kz it me b gy na mx l my mz">float</span></pre><p id="1933" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们给一个变量赋值，它的类型会改变。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="4904" class="ky kz it me b gy mw mx l my mz">x = 1</span><span id="ac24" class="ky kz it me b gy na mx l my mz">type(x)</span><span id="32bd" class="ky kz it me b gy na mx l my mz">int</span></pre><p id="2c8d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们试图使用一个尚未定义的变量，我们会得到一个<code class="fe mb mc md me b">NameError</code>:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="da85" class="ky kz it me b gy mw mx l my mz">print(y)</span><span id="6ab0" class="ky kz it me b gy na mx l my mz">---------------------------------------------------------------------------<br/><br/>NameError                                 Traceback (most recent call last)<br/><br/>&lt;ipython-input-13-d9183e048de3&gt; in &lt;module&gt;<br/>----&gt; 1 print(y)<br/><br/><br/>NameError: name 'y' is not defined</span></pre><h2 id="e932" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">基本类型</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="0e25" class="ky kz it me b gy mw mx l my mz"># integers<br/>x = 1<br/>type(x)</span><span id="4422" class="ky kz it me b gy na mx l my mz">int</span><span id="441a" class="ky kz it me b gy na mx l my mz"># float<br/>x = 1.0<br/>type(x)</span><span id="3937" class="ky kz it me b gy na mx l my mz">float</span></pre><p id="cec5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们也可以对浮点类型使用科学记数法:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="54cd" class="ky kz it me b gy mw mx l my mz">x = 5e3<br/>print(x)<br/>print(type(x))</span><span id="f4b3" class="ky kz it me b gy na mx l my mz">5000.0<br/>&lt;class 'float'&gt;</span><span id="32ad" class="ky kz it me b gy na mx l my mz"># boolean<br/>b1 = True<br/>b2 = False<br/><br/>type(b1)</span><span id="32b6" class="ky kz it me b gy na mx l my mz">bool</span><span id="e171" class="ky kz it me b gy na mx l my mz"># complex numbers: note the use of `j` to specify the imaginary part<br/>x = 1.0 - 1.0j<br/>type(x)</span><span id="ef76" class="ky kz it me b gy na mx l my mz">complex</span><span id="7c7a" class="ky kz it me b gy na mx l my mz">print(x)</span><span id="e62d" class="ky kz it me b gy na mx l my mz">(1-1j)</span><span id="8bd9" class="ky kz it me b gy na mx l my mz">print(x.real, x.imag)</span><span id="975e" class="ky kz it me b gy na mx l my mz">1.0 -1.0</span></pre><h2 id="043e" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">铅字铸造</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="b5b9" class="ky kz it me b gy mw mx l my mz">x = 1.5<br/><br/>print(x, type(x))</span><span id="fd53" class="ky kz it me b gy na mx l my mz">1.5 &lt;class 'float'&gt;</span><span id="e4de" class="ky kz it me b gy na mx l my mz">x = int(x)<br/><br/>print(x, type(x))</span><span id="3082" class="ky kz it me b gy na mx l my mz">1 &lt;class 'int'&gt;</span><span id="3d4f" class="ky kz it me b gy na mx l my mz">z = complex(x)<br/><br/>print(z, type(z))</span><span id="ee82" class="ky kz it me b gy na mx l my mz">(1+0j) &lt;class 'complex'&gt;</span></pre><p id="2aa6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以使用<code class="fe mb mc md me b">isinstance(obj, class)</code>方法来确定一个变量是否属于某个类(类型):</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="ec36" class="ky kz it me b gy mw mx l my mz">x = 3<br/>print(isinstance(x, float))<br/>print(isinstance(x, int))</span><span id="525b" class="ky kz it me b gy na mx l my mz">False<br/>True</span><span id="c673" class="ky kz it me b gy na mx l my mz">x = 3.0<br/>print(isinstance(x, float))<br/>print(isinstance(x, int))</span><span id="6f74" class="ky kz it me b gy na mx l my mz">True<br/>False</span></pre><p id="fbb0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习3: </strong>打印变量<code class="fe mb mc md me b">x=3.5e3</code>的类型，然后将其转换为<strong class="kb jd"> int </strong></p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="dfc8" class="ky kz it me b gy mw mx l my mz">x=3.5e3<br/>print(type(x))<br/>x=int(x)<br/>print(x)</span><span id="b52f" class="ky kz it me b gy na mx l my mz">&lt;class 'float'&gt;<br/>3500</span></pre><h2 id="a51e" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">运算符和比较</h2><p id="d744" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">Python中的大多数操作符和比较符都像预期的那样工作:</p><ul class=""><li id="e776" class="lq lr it kb b kc kd kg kh kk nf ko ng ks nh kw lx ly lz ma bi translated">算术运算符<code class="fe mb mc md me b">+</code>、<code class="fe mb mc md me b">-</code>、<code class="fe mb mc md me b">*</code>、<code class="fe mb mc md me b">/</code>、<code class="fe mb mc md me b">//</code>(整数除法)、“**”幂</li></ul><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="40ee" class="ky kz it me b gy mw mx l my mz">1 + 2, 1 - 2, 1 * 2, 1 / 2</span><span id="accb" class="ky kz it me b gy na mx l my mz">(3, -1, 2, 0.5)</span><span id="bda5" class="ky kz it me b gy na mx l my mz">1.0 + 2.0, 1.0 - 2.0, 1.0 * 2.0, 1.0 / 2.0</span><span id="e3cc" class="ky kz it me b gy na mx l my mz">(3.0, -1.0, 2.0, 0.5)</span><span id="f70b" class="ky kz it me b gy na mx l my mz"># Integer division of float numbers<br/>3.0 // 2.0</span><span id="a36e" class="ky kz it me b gy na mx l my mz">1.0</span><span id="e80a" class="ky kz it me b gy na mx l my mz"># Note! The power operators in python isn't ^, but **<br/>2 ** 2</span><span id="3265" class="ky kz it me b gy na mx l my mz">4</span></pre><p id="c099" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">注意:在Python 3.x中,<code class="fe mb mc md me b">/</code>操作符总是执行浮点除法。在Python 2.x中不是这样的，在Python 2 . x中，如果操作数是整数，那么<code class="fe mb mc md me b">/</code>的结果总是整数。更具体的说，Python 3.x中的<code class="fe mb mc md me b">1/2 = 0.5</code> ( <code class="fe mb mc md me b">float</code>)，Python 2.x中的<code class="fe mb mc md me b">1/2 = 0</code> ( <code class="fe mb mc md me b">int</code>)(但Python 2.x中的<code class="fe mb mc md me b">1.0/2 = 0.5</code>)。</p><ul class=""><li id="8bdd" class="lq lr it kb b kc kd kg kh kk nf ko ng ks nh kw lx ly lz ma bi translated">布尔运算符拼写为单词<code class="fe mb mc md me b">and</code>、<code class="fe mb mc md me b">not</code>、<code class="fe mb mc md me b">or</code>。</li></ul><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="0262" class="ky kz it me b gy mw mx l my mz">True and False</span><span id="7a2a" class="ky kz it me b gy na mx l my mz">False</span><span id="7c26" class="ky kz it me b gy na mx l my mz">not False</span><span id="53dd" class="ky kz it me b gy na mx l my mz">True</span><span id="3749" class="ky kz it me b gy na mx l my mz">True or False</span><span id="1ee3" class="ky kz it me b gy na mx l my mz">True</span></pre><ul class=""><li id="b475" class="lq lr it kb b kc kd kg kh kk nf ko ng ks nh kw lx ly lz ma bi translated">比较运算符<code class="fe mb mc md me b">&gt;</code>、<code class="fe mb mc md me b">&lt;</code>、<code class="fe mb mc md me b">&gt;=</code>(大于或等于)、<code class="fe mb mc md me b">&lt;=</code>(小于或等于)、<code class="fe mb mc md me b">==</code>相等、<code class="fe mb mc md me b">is</code>相同。</li></ul><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="a58a" class="ky kz it me b gy mw mx l my mz">2 &gt; 1, 2 &lt; 1</span><span id="3f10" class="ky kz it me b gy na mx l my mz">(True, False)</span><span id="46a6" class="ky kz it me b gy na mx l my mz">2 &gt; 2, 2 &lt; 2</span><span id="dc98" class="ky kz it me b gy na mx l my mz">(False, False)</span><span id="9ab6" class="ky kz it me b gy na mx l my mz">2 &gt;= 2, 2 &lt;= 2</span><span id="1cca" class="ky kz it me b gy na mx l my mz">(True, True)</span><span id="3cd6" class="ky kz it me b gy na mx l my mz"># equality<br/>[1,2] == [1,2]</span><span id="2e70" class="ky kz it me b gy na mx l my mz">True</span><span id="ec00" class="ky kz it me b gy na mx l my mz"># objects identical?<br/>l1 = l2 = [1,2]<br/><br/>l1 is l2</span><span id="6c60" class="ky kz it me b gy na mx l my mz">True</span></pre><h2 id="442f" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">复合类型:字符串、列表和字典</h2><h2 id="efcb" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">用线串</h2><p id="9d08" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">字符串是用于存储文本消息的变量类型。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="03db" class="ky kz it me b gy mw mx l my mz">s = "Hello world"<br/>type(s)</span><span id="d312" class="ky kz it me b gy na mx l my mz">str</span><span id="3fcd" class="ky kz it me b gy na mx l my mz"># length of the string: the number of characters<br/>len(s)</span><span id="fb38" class="ky kz it me b gy na mx l my mz">11</span><span id="f995" class="ky kz it me b gy na mx l my mz"># replace a substring in a string with something else<br/>s2 = s.replace("world", "test")<br/>print(s2)</span><span id="24b4" class="ky kz it me b gy na mx l my mz">Hello test</span></pre><p id="06f2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以使用<code class="fe mb mc md me b">[]</code>索引字符串中的一个字符:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="55c8" class="ky kz it me b gy mw mx l my mz">s[0]</span><span id="77a4" class="ky kz it me b gy na mx l my mz">'H'</span></pre><p id="58e3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">平视MATLAB用户:</strong>索引从0开始！</p><p id="8931" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以使用语法<code class="fe mb mc md me b">[start:stop]</code>提取字符串的一部分，提取索引<code class="fe mb mc md me b">start</code>和<code class="fe mb mc md me b">stop</code> -1之间的字符(不包括索引<code class="fe mb mc md me b">stop</code>处的字符):</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="e13b" class="ky kz it me b gy mw mx l my mz">s[0:5]</span><span id="bd27" class="ky kz it me b gy na mx l my mz">'Hello'</span><span id="9b78" class="ky kz it me b gy na mx l my mz">s[4:5]</span><span id="96dc" class="ky kz it me b gy na mx l my mz">'o'</span></pre><p id="4a5f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们从<code class="fe mb mc md me b">[start:stop]</code>中省略<code class="fe mb mc md me b">start</code>或<code class="fe mb mc md me b">stop</code>中的一个(或两个),默认分别是字符串的开头和结尾:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="d14b" class="ky kz it me b gy mw mx l my mz">s[:5]</span><span id="8b10" class="ky kz it me b gy na mx l my mz">'Hello'</span><span id="cdc6" class="ky kz it me b gy na mx l my mz">s[6:]</span><span id="2b0a" class="ky kz it me b gy na mx l my mz">'world'</span><span id="ccf6" class="ky kz it me b gy na mx l my mz">s[:]</span><span id="0874" class="ky kz it me b gy na mx l my mz">'Hello world'</span></pre><p id="9719" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们还可以使用语法<code class="fe mb mc md me b">[start:end:step]</code>定义步长(正如我们在上面看到的，<code class="fe mb mc md me b">step</code>的默认值是1):</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="1dc0" class="ky kz it me b gy mw mx l my mz">s[::1]</span><span id="bb40" class="ky kz it me b gy na mx l my mz">'Hello world'</span><span id="1c93" class="ky kz it me b gy na mx l my mz">s[::2]</span><span id="e14f" class="ky kz it me b gy na mx l my mz">'Hlowrd'</span></pre><p id="cce1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这种技术叫做<em class="mn">切片</em>。在这里阅读更多关于语法的内容:<a class="ae kx" href="http://docs.python.org/release/2.7.3/library/functions.html?highlight=slice#slice" rel="noopener ugc nofollow" target="_blank">http://docs . python . org/release/2 . 7 . 3/library/functions . html？高亮显示=切片#切片</a></p><p id="355c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">Python有一套非常丰富的文本处理函数。更多信息参见例如<a class="ae kx" href="http://docs.python.org/2/library/string.html" rel="noopener ugc nofollow" target="_blank">http://docs.python.org/2/library/string.html</a>。</p><p id="6118" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习5: </strong>提取“男人的帽子是黑色的”中的“帽子”一词</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="fa11" class="ky kz it me b gy mw mx l my mz">s = "The man's hat is black"<br/>w = s[10:13]<br/>print(w)</span><span id="ad03" class="ky kz it me b gy na mx l my mz">hat</span></pre><p id="3783" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习6: </strong>把短语“男人的帽子是黑色的”中的“猫”换成“帽子”</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="b35b" class="ky kz it me b gy mw mx l my mz">s2 = s.replace('hat', 'cat')<br/>print(s2)</span><span id="cf1b" class="ky kz it me b gy na mx l my mz">The man's cat is black</span></pre><h2 id="d2f1" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">字符串格式示例</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="b733" class="ky kz it me b gy mw mx l my mz">print("str1", "str2", "str3")  # The print statement concatenates strings with a space</span><span id="19f3" class="ky kz it me b gy na mx l my mz">str1 str2 str3</span><span id="c710" class="ky kz it me b gy na mx l my mz">print("str1" + "str2" + "str3") # strings added with + are concatenated without space</span><span id="9496" class="ky kz it me b gy na mx l my mz">str1str2str3</span><span id="150c" class="ky kz it me b gy na mx l my mz"># this formatting creates a string<br/>s2 = "value1 = %.2f. value2 = %d" % (3.1415, 1.5)<br/><br/>print(s2)</span><span id="cda6" class="ky kz it me b gy na mx l my mz">value1 = 3.14. value2 = 1</span><span id="06c5" class="ky kz it me b gy na mx l my mz"># alternative, more intuitive way of formatting a string <br/>s3 = 'value1 = {0}, value2 = {1}'.format(3.1415, 1.5)<br/><br/>print(s3)</span><span id="332f" class="ky kz it me b gy na mx l my mz">value1 = 3.1415, value2 = 1.5</span></pre><h2 id="1a5a" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">目录</h2><p id="cda3" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">列表非常类似于字符串，除了每个元素可以是任何类型。</p><p id="5f65" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在Python中创建列表的语法是<code class="fe mb mc md me b">[...]</code>:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="cb64" class="ky kz it me b gy mw mx l my mz">l = [1,2,3,4]<br/><br/>print(type(l))<br/>print(l)</span><span id="6c93" class="ky kz it me b gy na mx l my mz">&lt;class 'list'&gt;<br/>[1, 2, 3, 4]</span></pre><p id="cddd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以使用与字符串相同的切片技术来操作列表:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="aea3" class="ky kz it me b gy mw mx l my mz">print(l)<br/><br/>print(l[1:3])<br/><br/>print(l[::2])</span><span id="71c1" class="ky kz it me b gy na mx l my mz">[1, 2, 3, 4]<br/>[2, 3]<br/>[1, 3]</span></pre><p id="deff" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">抬头MATLAB用户:</strong>索引从0开始！</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="57d9" class="ky kz it me b gy mw mx l my mz">l[0]</span><span id="72e4" class="ky kz it me b gy na mx l my mz">1</span></pre><p id="fa7f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">列表中的元素不必都是同一类型:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="64bf" class="ky kz it me b gy mw mx l my mz">l = [1, 'a', 1.0, 1-1j]<br/><br/>print(l)</span><span id="e684" class="ky kz it me b gy na mx l my mz">[1, 'a', 1.0, (1-1j)]</span></pre><p id="19ce" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">列表在Python中起着非常重要的作用。例如，它们用在环路和其他流量控制结构中(下面讨论)。有许多方便的函数可以生成各种类型的列表，例如，<code class="fe mb mc md me b">range</code>函数:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="fa7d" class="ky kz it me b gy mw mx l my mz">start = 10<br/>stop = 30<br/>step = 2<br/><br/>range(start, stop, step)</span><span id="45b8" class="ky kz it me b gy na mx l my mz">range(10, 30, 2)</span><span id="ab96" class="ky kz it me b gy na mx l my mz"># in python 3 range generates an iterator, which can be converted to a list using 'list(...)'.<br/># It has no effect in python 2<br/>list(range(start, stop, step))</span><span id="e914" class="ky kz it me b gy na mx l my mz">[10, 12, 14, 16, 18, 20, 22, 24, 26, 28]</span><span id="93f2" class="ky kz it me b gy na mx l my mz">list(range(-10, 10))</span><span id="17d1" class="ky kz it me b gy na mx l my mz">[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre><p id="3816" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习7: </strong>创建一个范围从0到20的偶数列表</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="5fa1" class="ky kz it me b gy mw mx l my mz">list(range(0,22,2))</span><span id="a19f" class="ky kz it me b gy na mx l my mz">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span></pre><h2 id="3688" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">添加、插入、修改和删除列表中的元素</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="b4a3" class="ky kz it me b gy mw mx l my mz"># create a new empty list<br/>l = []<br/><br/># add an elements using `append`<br/>l.append("A")<br/>l.append("d")<br/>l.append("d")<br/><br/>print(l)</span><span id="9931" class="ky kz it me b gy na mx l my mz">['A', 'd', 'd']</span></pre><p id="b7eb" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以通过给列表中的元素赋值来修改列表。用技术术语来说，列表是可变的。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="93bf" class="ky kz it me b gy mw mx l my mz">l[1] = "p"<br/>l[2] = "p"<br/><br/>print(l)</span><span id="becd" class="ky kz it me b gy na mx l my mz">['A', 'p', 'p']</span><span id="2c3a" class="ky kz it me b gy na mx l my mz">l[1:3] = ["d", "d"]<br/><br/>print(l)</span><span id="f209" class="ky kz it me b gy na mx l my mz">['A', 'd', 'd']</span></pre><p id="2f9f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">使用<code class="fe mb mc md me b">insert</code>在特定索引处插入一个元素</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="e163" class="ky kz it me b gy mw mx l my mz">l.insert(0, "i")<br/>l.insert(1, "n")<br/>l.insert(2, "s")<br/>l.insert(3, "e")<br/>l.insert(4, "r")<br/>l.insert(5, "t")<br/><br/>print(l)</span><span id="4ac8" class="ky kz it me b gy na mx l my mz">['i', 'n', 's', 'e', 'r', 't', 'A', 'd', 'd']</span></pre><p id="6924" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">使用“移除”移除具有特定值的第一个元素</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="7786" class="ky kz it me b gy mw mx l my mz">l.remove("A")<br/><br/>print(l)</span><span id="e2ea" class="ky kz it me b gy na mx l my mz">['i', 'n', 's', 'e', 'r', 't', 'd', 'd']</span></pre><p id="6dd4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">使用<code class="fe mb mc md me b">del</code>移除特定位置的元件:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="4cc9" class="ky kz it me b gy mw mx l my mz">del l[7]<br/>del l[6]<br/><br/>print(l)</span><span id="654c" class="ky kz it me b gy na mx l my mz">['i', 'n', 's', 'e', 'r', 't']</span></pre><p id="ec7b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">更多细节见<code class="fe mb mc md me b">help(list)</code>，或者阅读在线文档</p><h2 id="aaf0" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">元组</h2><p id="013a" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">元组就像列表，除了它们一旦被创建就不能被修改，也就是说它们是不可变的。</p><p id="ed5e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在Python中，使用语法<code class="fe mb mc md me b">(..., ..., ...)</code>甚至<code class="fe mb mc md me b">..., ...</code>创建元组:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="ac2f" class="ky kz it me b gy mw mx l my mz">point = (10, 20)<br/><br/>print(point, type(point))</span><span id="1c4a" class="ky kz it me b gy na mx l my mz">(10, 20) &lt;class 'tuple'&gt;</span></pre><p id="6bdc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以通过将元组分配给逗号分隔的变量列表来解包元组:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="818a" class="ky kz it me b gy mw mx l my mz">x, y = point<br/><br/>print("x =", x)<br/>print("y =", y)</span><span id="2c3f" class="ky kz it me b gy na mx l my mz">x = 10<br/>y = 20</span></pre><h2 id="ecd5" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">字典</h2><p id="8ef1" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">字典也类似于列表，只是每个元素都是一个键值对。字典的语法是<code class="fe mb mc md me b">{key1 : value1, ...}</code>:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="ca05" class="ky kz it me b gy mw mx l my mz">params = {"parameter1" : 1.0,<br/>          "parameter2" : 2.0,<br/>          "parameter3" : 3.0,}<br/><br/>print(type(params))<br/>print(params)</span><span id="f017" class="ky kz it me b gy na mx l my mz">&lt;class 'dict'&gt;<br/>{'parameter1': 1.0, 'parameter2': 2.0, 'parameter3': 3.0}</span><span id="e2a6" class="ky kz it me b gy na mx l my mz">print("parameter1 = " + str(params["parameter1"]))<br/>print("parameter2 = " + str(params["parameter2"]))<br/>print("parameter3 = " + str(params["parameter3"]))</span><span id="d688" class="ky kz it me b gy na mx l my mz">parameter1 = 1.0<br/>parameter2 = 2.0<br/>parameter3 = 3.0</span></pre><p id="7c7c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习8: </strong>为一个人创建一个属性字典，包括姓名、年龄和职业</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="be23" class="ky kz it me b gy mw mx l my mz">p = {'name':'John Doe', 'age':20, 'profession':'student'}</span></pre><h2 id="7618" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">控制流</h2><h2 id="3817" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">条件语句:if，elif，else</h2><p id="fcba" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">代码条件执行的Python语法使用关键字<code class="fe mb mc md me b">if</code>、<code class="fe mb mc md me b">elif</code> (else if)、<code class="fe mb mc md me b">else</code>:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="9342" class="ky kz it me b gy mw mx l my mz">statement1 = False<br/>statement2 = False<br/><br/>if statement1:<br/>    print("statement1 is True")<br/>    <br/>elif statement2:<br/>    print("statement2 is True")<br/>    <br/>else:<br/>    print("statement1 and statement2 are False")</span><span id="b612" class="ky kz it me b gy na mx l my mz">statement1 and statement2 are False</span></pre><p id="25af" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在这里，我们第一次遇到了Python编程语言的一个奇特而不寻常的方面:程序块是由它们的缩进级别定义的。</p><p id="c49b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在Python中，代码块的范围由缩进级别定义(通常是一个制表符或四个空格)。这意味着我们必须小心地正确缩进我们的代码，否则我们会得到语法错误。</p><h2 id="9cb6" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">示例:</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="d708" class="ky kz it me b gy mw mx l my mz">statement1 = statement2 = True<br/><br/>if statement1:<br/>    if statement2:<br/>        print("both statement1 and statement2 are True")</span><span id="a578" class="ky kz it me b gy na mx l my mz">both statement1 and statement2 are True</span><span id="bc2c" class="ky kz it me b gy na mx l my mz"># Bad indentation!<br/>if statement1:<br/>    if statement2:<br/>    print("both statement1 and statement2 are True")  # this line is not properly indented</span><span id="ffa0" class="ky kz it me b gy na mx l my mz">File "&lt;ipython-input-80-ac4109c9123a&gt;", line 4<br/>    print("both statement1 and statement2 are True")  # this line is not properly indented<br/>        ^<br/>IndentationError: expected an indented block</span><span id="503b" class="ky kz it me b gy na mx l my mz">statement1 = False <br/><br/>if statement1:<br/>    print("printed if statement1 is True")<br/>    <br/>    print("still inside the if block")</span><span id="8371" class="ky kz it me b gy na mx l my mz">if statement1:<br/>    print("printed if statement1 is True")<br/>    <br/>print("now outside the if block")</span><span id="1abf" class="ky kz it me b gy na mx l my mz">now outside the if block</span></pre><p id="d40b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习9: </strong>使用Ex中创建的person字典。8，创建一个条件语句来验证某人是否超过30岁。如果是，打印他们的职业，否则打印他们的年龄。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="b9fc" class="ky kz it me b gy mw mx l my mz">if p['age'] &gt; 30:<br/>    print(p['profession'])<br/>else:<br/>    print(p['age'])</span><span id="20e7" class="ky kz it me b gy na mx l my mz">20</span></pre><h2 id="2ead" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">环</h2><p id="8f8d" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">在Python中，循环可以用多种不同的方式编程。最常见的是<code class="fe mb mc md me b">for</code>循环，它与可迭代对象(如列表)一起使用。基本语法是:</p><h2 id="5efd" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated"><code class="fe mb mc md me b"><strong class="ak">for</strong></code> <strong class="ak">循环</strong>:</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="0987" class="ky kz it me b gy mw mx l my mz">for x in [1,2,3]:<br/>    print(x)</span><span id="be9e" class="ky kz it me b gy na mx l my mz">1<br/>2<br/>3</span></pre><p id="47c3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><code class="fe mb mc md me b">for</code>循环遍历所提供列表的元素，并对每个元素执行一次包含块。在<code class="fe mb mc md me b">for</code>循环中可以使用任何类型的列表。例如:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="538d" class="ky kz it me b gy mw mx l my mz">for x in range(4): # by default range start at 0<br/>    print(x)</span><span id="bfdc" class="ky kz it me b gy na mx l my mz">0<br/>1<br/>2<br/>3</span></pre><p id="db67" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">注:<code class="fe mb mc md me b">range(4)</code>不包括4！</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="c93a" class="ky kz it me b gy mw mx l my mz">for x in range(-3,3):<br/>    print(x)</span><span id="c3dc" class="ky kz it me b gy na mx l my mz">-3<br/>-2<br/>-1<br/>0<br/>1<br/>2</span><span id="b042" class="ky kz it me b gy na mx l my mz">for word in ["scientific", "computing", "with", "python"]:<br/>    print(word)</span><span id="c948" class="ky kz it me b gy na mx l my mz">scientific<br/>computing<br/>with<br/>python</span></pre><p id="e8f8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">要迭代字典的键值对:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="f55c" class="ky kz it me b gy mw mx l my mz">for key, value in params.items():<br/>    print(key + " = " + str(value))</span><span id="57bf" class="ky kz it me b gy na mx l my mz">parameter1 = A<br/>parameter2 = B<br/>parameter3 = 3.0<br/>parameter4 = D</span></pre><p id="667a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">有时候，当遍历一个列表时，访问值的索引是很有用的。为此，我们可以使用<code class="fe mb mc md me b">enumerate</code>功能:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="5234" class="ky kz it me b gy mw mx l my mz">for idx, x in enumerate(range(-3,3)):<br/>    print(idx, x)</span><span id="b7d8" class="ky kz it me b gy na mx l my mz">0 -3<br/>1 -2<br/>2 -1<br/>3 0<br/>4 1<br/>5 2</span></pre><p id="e2ed" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习10: </strong>打印0到100之间的所有3和5的倍数</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="e5f2" class="ky kz it me b gy mw mx l my mz">for i in range(101):<br/>    if i%3 ==0 and i%5==0:<br/>        print(i)</span><span id="7881" class="ky kz it me b gy na mx l my mz">0<br/>15<br/>30<br/>45<br/>60<br/>75<br/>90</span></pre><h2 id="b5d4" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">列表理解:使用<code class="fe mb mc md me b">for</code>循环创建列表:</h2><p id="619f" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">一种方便而简洁的初始化列表的方法:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="9ba1" class="ky kz it me b gy mw mx l my mz">l1 = [x**2 for x in range(0,5)]<br/><br/>print(l1)</span><span id="a8c5" class="ky kz it me b gy na mx l my mz">[0, 1, 4, 9, 16]</span></pre><h2 id="84a2" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated"><code class="fe mb mc md me b">while</code>循环:</h2><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="f531" class="ky kz it me b gy mw mx l my mz">i = 0<br/><br/>while i &lt; 5:<br/>    print(i)<br/>    <br/>    i = i + 1<br/>    <br/>print("done")</span><span id="7749" class="ky kz it me b gy na mx l my mz">0<br/>1<br/>2<br/>3<br/>4<br/>done</span></pre><p id="1c02" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">注意，由于缩进的不同，<code class="fe mb mc md me b">print("done")</code>语句不是<code class="fe mb mc md me b">while</code>循环体的一部分。</p><h2 id="2e92" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">功能</h2><p id="40ab" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">Python中的函数是使用关键字定义的，后跟函数名、括号内的签名和冒号<code class="fe mb mc md me b">:</code>。下面的代码是函数体，增加了一层缩进。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="7f9b" class="ky kz it me b gy mw mx l my mz">def func0():   <br/>    print("test")</span><span id="47b5" class="ky kz it me b gy na mx l my mz">func0()</span><span id="8381" class="ky kz it me b gy na mx l my mz">test</span></pre><p id="6088" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">可选地，但是强烈推荐，我们可以定义一个所谓的“docstring ”,它是对函数目的和行为的描述。docstring应该紧跟在函数定义之后，函数体代码之前。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="7060" class="ky kz it me b gy mw mx l my mz">def func1(s):<br/>    """<br/>    Print a string 's' and tell how many characters it has    <br/>    """<br/>    <br/>    print(s + " has " + str(len(s)) + " characters")</span><span id="c9c7" class="ky kz it me b gy na mx l my mz">help(func1)</span><span id="7a73" class="ky kz it me b gy na mx l my mz">Help on function func1 in module __main__:<br/><br/>func1(s)<br/>    Print a string 's' and tell how many characters it has</span><span id="626f" class="ky kz it me b gy na mx l my mz">func1("test")</span><span id="d6cb" class="ky kz it me b gy na mx l my mz">test has 4 characters</span></pre><p id="a1a8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">返回值的函数使用<code class="fe mb mc md me b">return</code>关键字:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="a288" class="ky kz it me b gy mw mx l my mz">def square(x):<br/>    """<br/>    Return the square of x.<br/>    """<br/>    return x ** 2</span><span id="f754" class="ky kz it me b gy na mx l my mz">square(4)</span><span id="9e65" class="ky kz it me b gy na mx l my mz">16</span></pre><p id="67fb" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们可以使用元组从一个函数返回多个值(见上文):</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="b9f1" class="ky kz it me b gy mw mx l my mz">def powers(x):<br/>    """<br/>    Return a few powers of x.<br/>    """<br/>    return x ** 2, x ** 3, x ** 4</span><span id="f2e2" class="ky kz it me b gy na mx l my mz">powers(3)</span><span id="be6a" class="ky kz it me b gy na mx l my mz">(9, 27, 81)</span><span id="70fc" class="ky kz it me b gy na mx l my mz">x2, x3, x4 = powers(3)<br/><br/>print(x3)</span><span id="1e01" class="ky kz it me b gy na mx l my mz">27</span></pre><p id="e2dd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习11: </strong>创建一个函数，它接收一个数字列表并返回另一个列表，该列表中只包含3和5的倍数</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="6609" class="ky kz it me b gy mw mx l my mz">def multiples(l):<br/>    newList = []<br/>    for i in l:<br/>        if i%3==0 and i%5==0:<br/>            newList.append(i)<br/>    return newList</span></pre><p id="1edf" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">或者更简单的版本:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="341a" class="ky kz it me b gy mw mx l my mz">def multiples(l):<br/>    return [i for i in l if i%3==0 and i%5==0]</span><span id="fc6f" class="ky kz it me b gy na mx l my mz">multiples([3,15,12,20,31])</span><span id="9f5d" class="ky kz it me b gy na mx l my mz">[15]</span></pre><h2 id="f4c4" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">默认参数和关键字参数</h2><p id="89df" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">在函数的定义中，我们可以给函数的参数赋予默认值:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="0fbc" class="ky kz it me b gy mw mx l my mz">def myfunc(x, p=2, debug=False):<br/>    if debug:<br/>        print("evaluating myfunc for x = " + str(x) + " using exponent p = " + str(p))<br/>    return x**p</span></pre><p id="6297" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们在调用函数<code class="fe mb mc md me b">myfunc</code>时不提供参数<code class="fe mb mc md me b">debug</code>的值，它将默认为函数定义中提供的值:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="0ea0" class="ky kz it me b gy mw mx l my mz">myfunc(5)</span><span id="579b" class="ky kz it me b gy na mx l my mz">25</span><span id="a220" class="ky kz it me b gy na mx l my mz">myfunc(5, debug=True)</span><span id="eb3c" class="ky kz it me b gy na mx l my mz">evaluating myfunc for x = 5 using exponent p = 2<br/><br/><br/><br/><br/><br/>25</span></pre><p id="aa28" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果我们在函数调用中明确列出参数的名称，它们不需要按照函数定义中的顺序出现。这被称为<em class="mn">关键字</em>参数，在需要大量可选参数的函数中非常有用。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="e1e3" class="ky kz it me b gy mw mx l my mz">myfunc(p=3, debug=True, x=7)</span><span id="ec8e" class="ky kz it me b gy na mx l my mz">evaluating myfunc for x = 7 using exponent p = 3<br/><br/><br/><br/><br/><br/>343</span></pre><p id="50bb" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习12: </strong>创建一个接收数字列表的函数</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/06de71e69fc3a450424acdea0c70cd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*8w5AOAC_j4WArV_VOxqL8A.png"/></div></figure><p id="10a6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">和一个可选的指数<em class="mn"> p </em>，然后返回对应于</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/b2f8f9c808d7d65fbc2cb4a52625fa01.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*srHVzSqNytOm96pDq4EPjw.png"/></div></figure><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="4f38" class="ky kz it me b gy mw mx l my mz">def lExp(l, p=1):<br/>    return [i**p for i in l]</span><span id="d7d7" class="ky kz it me b gy na mx l my mz">lExp([1,2,3,4])</span><span id="58df" class="ky kz it me b gy na mx l my mz">[1, 2, 3, 4]</span><span id="b8ab" class="ky kz it me b gy na mx l my mz">lExp([1,2,3,4], 2)</span><span id="bbc6" class="ky kz it me b gy na mx l my mz">[1, 4, 9, 16]</span></pre><h2 id="fe77" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">班级</h2><p id="40cd" class="pw-post-body-paragraph jz ka it kb b kc ls ke kf kg lt ki kj kk mk km kn ko ml kq kr ks mm ku kv kw im bi translated">类是面向对象编程的关键特征。类是表示对象和可以在对象上执行的操作的结构。</p><p id="f0d1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在Python中，一个类可以包含<em class="mn">属性</em>(变量)和<em class="mn">方法</em>(函数)。</p><p id="01ca" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">类的定义几乎和函数一样，但是使用了<code class="fe mb mc md me b">class</code>关键字，并且类定义通常包含许多类方法定义(类中的一个函数)。</p><ul class=""><li id="2173" class="lq lr it kb b kc kd kg kh kk nf ko ng ks nh kw lx ly lz ma bi translated">每个类方法应该有一个参数<code class="fe mb mc md me b">self</code>作为它的第一个参数。这个对象是一个自引用。</li><li id="776b" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">一些类方法名有特殊的含义，例如:</li><li id="e92f" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated"><code class="fe mb mc md me b">__init__</code>:第一次创建对象时调用的方法的名称。</li><li id="1bcb" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated"><code class="fe mb mc md me b">__str__</code>:当需要类的简单字符串表示时调用的方法，例如在打印时。</li><li id="ee5d" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">还有很多，见<a class="ae kx" href="http://docs.python.org/2/reference/datamodel.html#special-method-names" rel="noopener ugc nofollow" target="_blank">http://docs . python . org/2/reference/data model . html # special-method-names</a></li></ul><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="d4d6" class="ky kz it me b gy mw mx l my mz">class Point:<br/>    """<br/>    Simple class for representing a point in a Cartesian coordinate system.<br/>    """<br/>    <br/>    def __init__(self, x, y):<br/>        """<br/>        Create a new Point at x, y.<br/>        """<br/>        self.x = x<br/>        self.y = y<br/>        <br/>    def translate(self, dx, dy):<br/>        """<br/>        Translate the point by dx and dy in the x and y direction.<br/>        """<br/>        self.x += dx<br/>        self.y += dy<br/>        <br/>    def __str__(self):<br/>        return("Point at [%f, %f]" % (self.x, self.y))</span></pre><p id="9daf" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">要创建类的新实例:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="7a20" class="ky kz it me b gy mw mx l my mz">p1 = Point(0, 0) # this will invoke the __init__ method in the Point class<br/><br/>print(p1)         # this will invoke the __str__ method</span><span id="108a" class="ky kz it me b gy na mx l my mz">Point at [0.000000, 0.000000]</span></pre><p id="4162" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">调用类实例<code class="fe mb mc md me b">p</code>中的类方法:</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="aaa5" class="ky kz it me b gy mw mx l my mz">p2 = Point(1, 1)<br/><br/>p1.translate(0.25, 1.5)<br/><br/>print(p1)<br/>print(p2)</span><span id="01d7" class="ky kz it me b gy na mx l my mz">Point at [0.250000, 1.500000]<br/>Point at [1.000000, 1.000000]</span></pre><p id="6363" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">请注意，调用类方法可以修改特定类实例的状态，但不会影响其他类实例或任何全局变量。</p><p id="d935" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这是面向对象设计的一个好处:函数和相关变量等代码被分组到单独和独立的实体中。</p><p id="d841" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">练习13: </strong>扩展前面的类，创建一个计算原点和点之间的欧几里德距离的方法<code class="fe mb mc md me b">abs</code>。</p><pre class="mo mp mq mr gt ms me mt mu aw mv bi"><span id="613f" class="ky kz it me b gy mw mx l my mz">class Point:<br/>    """<br/>    Simple class for representing a point in a Cartesian coordinate system.<br/>    """<br/>    <br/>    def __init__(self, x, y):<br/>        """<br/>        Create a new Point at x, y.<br/>        """<br/>        self.x = x<br/>        self.y = y<br/>        <br/>    def translate(self, dx, dy):<br/>        """<br/>        Translate the point by dx and dy in the x and y direction.<br/>        """<br/>        self.x += dx<br/>        self.y += dy<br/>        <br/>    def __str__(self):<br/>        return("Point at [%f, %f]" % (self.x, self.y))<br/>    <br/>    def abs(self):<br/>        """<br/>        Return the Euclidian norm of a vector from origin to the Point<br/>        """<br/>        return math.sqrt(self.x**2+self.y**2)</span><span id="85fb" class="ky kz it me b gy na mx l my mz">p = Point(3,4)<br/>print(p.abs())</span><span id="9126" class="ky kz it me b gy na mx l my mz">5.0</span></pre><h2 id="e8f5" class="ky kz it bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp iz bi translated">进一步阅读</h2><ul class=""><li id="cda4" class="lq lr it kb b kc ls kg lt kk lu ko lv ks lw kw lx ly lz ma bi translated"><a class="ae kx" href="http://www.python.org" rel="noopener ugc nofollow" target="_blank">http://www.python.org</a>—Python编程语言的官方网页。</li><li id="438a" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated"><a class="ae kx" href="http://www.python.org/dev/peps/pep-0008" rel="noopener ugc nofollow" target="_blank">http://www.python.org/dev/peps/pep-0008</a>—Python编程风格指南。强烈推荐。</li><li id="68c2" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated">http://www.greenteapress.com/thinkpython/—一本关于Python编程的免费书籍。</li><li id="5f66" class="lq lr it kb b kc mf kg mg kk mh ko mi ks mj kw lx ly lz ma bi translated"><a class="ae kx" href="http://www.amazon.com/Python-Essential-Reference-4th-Edition/dp/0672329786" rel="noopener ugc nofollow" target="_blank"> Python必备参考</a> —一本很好的Python编程参考书。</li></ul><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/aa86753e9823af47a4add9b63232d5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoejZMy3yBybSirlliy6jQ.jpeg"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">来源:<a class="ae kx" href="https://travelingroup.com/wp-content/uploads/2018/05/02visit-seville-in-group.jpg" rel="noopener ugc nofollow" target="_blank">谷歌图片</a></figcaption></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="2023" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">最初，我是一名机械工程师，但一直对数学和人工智能充满热情，后来我在这两个领域都找到了理想的职业，成为一名数据科学家。我热衷于将这些学科的严谨性应用于复杂的分析问题。我热爱教学，我兼职辅导A-Level数学、物理和化学。我也是一个受自然启发的优化爱好者(查看我的 <a class="ae kx" href="https://www.researchgate.net/publication/317803017_An_Experimental_Study_on_Competitive_Coevolution_of_MLP_Classifiers" rel="noopener ugc nofollow" target="_blank"> <em class="mn">发表的pape </em> </a> <em class="mn"> r)和一个板球和网球的超级粉丝。在</em><a class="ae kx" href="https://www.linkedin.com/in/rahullalchandani-" rel="noopener ugc nofollow" target="_blank"><em class="mn">LinkedIn</em></a><em class="mn">上找我！</em></p></div></div>    
</body>
</html>