<html>
<head>
<title>Genetic Algorithm — Stop Overfitting Trading Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法——停止过度适应交易策略</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1?source=collection_archive---------0-----------------------#2021-02-04">https://pub.towardsai.net/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1?source=collection_archive---------0-----------------------#2021-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2e7c8800bc610d7cd68b99f947739be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mm0H5MMQ_Y2wtY7_.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来源:由<a class="ae jg" href="https://pixabay.com/images/search/genetics/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/illustrations/dna-string-biology-3d-1811955/" rel="noopener ugc nofollow" target="_blank">奇摩诺</a>和<a class="ae jg" href="https://pixabay.com/illustrations/matrix-code-computer-pc-data-356024/" rel="noopener ugc nofollow" target="_blank">康弗里</a>衍生而来</figcaption></figure><h2 id="5a90" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>、<a class="ae ep" href="https://towardsai.net/p/category/optimization" rel="noopener ugc nofollow" target="_blank">优化</a>、<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="e8df" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">变异系数如何让遗传算法更稳健？</h2></div><p id="a82b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在之前的博客中，我们已经讨论了如何使用遗传算法来优化交易策略的参数，以及任何给定合适的适应度/成本函数的非线性函数的参数。可以说，我们还没有触及的最重要的部分是，我们如何确保GA是合适的，而不是过度合适的。</p><p id="e567" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这一次，我们将以相同的MACD策略为例，来研究如何在应用于时间序列问题时确保稳健的遗传算法训练过程。如果你没有读过我的关于如何将遗传算法应用于交易策略优化的博客，我强烈建议你浏览一下教程或者浏览一下GitHub上的完整脚本<a class="ae jg" href="https://gist.github.com/wululoo/a93983cbe1be92d12d8cdc036e2f89ab" rel="noopener ugc nofollow" target="_blank">这里</a>，因为这个博客将从我们离开的地方继续。</p><div class="is it gp gr iu md"><a href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">Python中交易策略优化的遗传算法</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">遗传算法如何帮助缩小问题空间并收敛到更好的解决方案？</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">medium.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ja md"/></div></div></a></div><blockquote class="ms mt mu"><p id="9e4b" class="lh li mv lj b lk ll kt lm ln lo kw lp mw lr ls lt mx lv lw lx my lz ma mb mc im bi translated">注意:我们将一节一节地讨论代码。如果你觉得很难跟上或者把它们粘在一起，不要担心！完整脚本的链接在博客的末尾。</p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><blockquote class="ms mt mu"><p id="9edf" class="lh li mv lj b lk ll kt lm ln lo kw lp mw lr ls lt mx lv lw lx my lz ma mb mc im bi translated">另一个注意事项:这只是一个演示，说明如何在优化交易策略时避免过度适应g a，并不打算盲目遵循。</p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="26ad" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">遗传算法快速介绍</h2><p id="2f47" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">达尔文启发的迭代启发式搜索算法的全局最优解，也称为遗传算法。它将一个<strong class="lj jt">候选解(个体)</strong>表示为一个<strong class="lj jt">参数(基因)</strong>列表。<strong class="lj jt">一个个体(适应值)</strong>有多成功是由一个<strong class="lj jt">适应函数</strong>决定的。解决方案繁殖的概率一般遵循<strong class="lj jt">“适者生存”(选择策略)</strong>。最合适的解决方案然后<strong class="lj jt">繁殖子代(交叉)</strong>、孙代和曾孙代。解决方案参数中的一些慷慨的突变也加入了进去，这样鱼就可以最终进化成能够运行另一种遗传算法的人类。</p><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">进化人类GIF —来源:<a class="ae jg" href="https://giphy.com/gifs/o37e1VlwzOvFS" rel="noopener ugc nofollow" target="_blank"> Giphy </a></figcaption></figure><p id="6100" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">所以这是一个非常浓缩的速成课程，关于遗传算法如何在类比中工作。如果你对每个概念都感兴趣，我已经写了一个更详细的关于每个组件的含义的速成课程。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="12d7" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">遗传算法中的过拟合</h2><p id="5ff3" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">请原谅我，这不是另一个过度适应的释义。相反，我们将简要讨论GA或神经架构搜索(NAS)的一种特定类型的过拟合:</p><p id="2484" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">膨胀:</strong>这是一种像GA这样的参数/超参数优化算法决定使用非常复杂的解决方案来实现适应度的边际收益的现象。由于遗传算法被赋予了在设定的迭代次数内与自身竞争的自由，最终解决方案的复杂性可能会不受控制地增长，并变得如此过度适应噪声，以至于它将只是一个不可理解的复杂而无用的黑盒。</p><p id="3f72" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">近年来，一种称为随机子集选择(RSS)的技术已经被开发出来，用于加速遗传算法的训练过程，并减少其过拟合。背后的直觉很简单:</p><blockquote class="oj"><p id="4653" class="ok ol jj bd om on oo op oq or os mc dk translated">如果一个解决方案在群体的多个子集上表现一致，它可能更适用于看不见的数据。</p></blockquote><p id="33ce" class="pw-post-body-paragraph lh li jj lj b lk ot kt lm ln ou kw lp lq ov ls lt lu ow lw lx ly ox ma mb mc im bi translated">RSS的各种分支已经在几篇研究论文中进行了讨论，并应用于一些众所周知的开放数据集，如<a class="ae jg" href="http://personal.disco.unimib.it/Vanneschi/toxicity.txt" rel="noopener ugc nofollow" target="_blank"><em class="mv"/></a><a class="ae jg" href="http://personal.disco.unimib.it/Vanneschi/bioavailability.txt" rel="noopener ugc nofollow" target="_blank"><em class="mv">生物利用度</em> </a>等，每个分支都略有改进，但有一个共同点使其不太适用于我们:</p><ol class=""><li id="25ab" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pd pe pf pg bi translated"><strong class="lj jt">我们的问题陈述不是严格意义上的分类问题:</strong>与它们的数据集不同，我们的问题陈述没有固定的标签/分类。事实上，我们潜在问题的结果是交易百分比回报的累积产物；一项交易是否有利可图完全取决于进场和出场策略。</li><li id="ce4c" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pd pe pf pg bi translated"><strong class="lj jt">我们的解决方案空间具有3个参数的一致复杂性:</strong>尽管我们的潜在问题听起来比他们的复杂，但我们的解决方案实际上并不复杂。不同于试图提出一个可以破解新冠肺炎的蛋白质链，或建立一个多层森林模型来对化合物的毒性进行分类，我们的MACD策略解决方案有且只有3个参数:快、慢和信号周期。</li></ol><h2 id="b31a" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">扩展RSS:变异系数</h2><p id="a858" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">RSS的核心概念是找到数据集各个部分一致的解决方案，而不仅仅是整个数据集。如果我们把这句话分解开来，我们需要记住两件事:</p><ul class=""><li id="469f" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pm pe pf pg bi translated"><strong class="lj jt">为训练分割大量集合</strong>——当我们的MACD策略需要一两个月才能完成时，在一天内评估交易表现是没有意义的。</li><li id="2c00" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">低表现差异</strong> —一个好的策略需要经受住牛市和熊市的考验。</li></ul><p id="ec6f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了结合这两个概念，我们可以利用一个称为<a class="ae jg" href="https://en.wikipedia.org/wiki/Coefficient_of_variation" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">变异系数</strong> </a> (CV)的统计概念，我们可以简单地将其计算为来自训练集的一些随机切片的适应值的<strong class="lj jt">标准差</strong>和<strong class="lj jt">均值</strong>之间的比率。CV在金融数学中也叫<strong class="lj jt">偏差风险度量</strong>，在精算学中也叫<strong class="lj jt">单位化风险</strong>。</p><blockquote class="oj"><p id="1849" class="ok ol jj bd om on oo op oq or os mc dk translated">变异系数越高，交易策略的偏差和风险就越大</p></blockquote><figure class="po pp pq pr ps iv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/c5b719d2e1038b38dde8646553324390.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*lCr3-t1v8onc935ZRn-HSw.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">变异系数公式—作者图片</figcaption></figure><blockquote class="ms mt mu"><p id="c985" class="lh li mv lj b lk ll kt lm ln lo kw lp mw lr ls lt mx lv lw lx my lz ma mb mc im bi translated">注:计算CV时应使用比率尺度数据，而不是绝对值(如绝对利润)或区间尺度数据(如摄氏度)。这种数据应该有一个绝对零度，以便对比率进行有意义的测量(例如，20K的温度是10K的两倍)</p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="0910" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">既然我们已经涵盖了这篇博文的所有核心概念，让我们直接进入代码吧！</p><figure class="od oe of og gt iv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/d6a0ac1ef48fbb3e3963e2c928fb2419.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/0*kgZcXEsoCK9FNMwu.gif"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://giphy.com/gifs/fail-meme-dive-KmlTchPoFQT84" rel="noopener ugc nofollow" target="_blank"> Giphy </a></figcaption></figure><h2 id="f0e1" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">1.快速回顾</h2><p id="1565" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">在之前的博文中，我们已经用<code class="fe pu pv pw px b">alphavantage</code>、<code class="fe pu pv pw px b">backtrader</code>和<code class="fe pu pv pw px b">deap</code>开发了我们的MACD策略和遗传算法参数优化。我们从<code class="fe pu pv pw px b">alphavantage</code>下载的<a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d#687d" rel="noopener">底层数据集</a>是NVDA的日用烛台。我们的遗传算法具有以下配置:</p><ul class=""><li id="9d94" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pm pe pf pg bi translated"><strong class="lj jt">基因:</strong>我们的MACD策略的参数是<code class="fe pu pv pw px b">fast_period</code>、<code class="fe pu pv pw px b">slow_period</code>和<code class="fe pu pv pw px b">signal_period</code></li><li id="7991" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">初始群体:</strong>我们的初始群体将有100个个体，每个个体的随机整数<code class="fe pu pv pw px b">fast_period</code>在<code class="fe pu pv pw px b">[1, 151)</code>的范围内，<code class="fe pu pv pw px b">slow_period</code>在<code class="fe pu pv pw px b">[10, 251)</code>的范围内，<code class="fe pu pv pw px b">signal_period</code>在<code class="fe pu pv pw px b">[1, 301)</code>的范围内</li><li id="4cbd" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">适应度函数:</strong><code class="fe pu pv pw px b">Total Profit / Maximum Draw Down</code>MACD策略</li><li id="b8ef" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">选择策略:</strong> <a class="ae jg" href="https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)#Tournament_Selection" rel="noopener ugc nofollow" target="_blank">锦标赛</a>每轮锦标赛的获胜者将被选为下一代的种子</li><li id="370b" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated">交叉策略:我们将使用均匀交叉，每个基因有50%的机会交叉</li><li id="be0b" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">突变策略:</strong>我们将在<code class="fe pu pv pw px b">[1, 101)</code>范围内使用整数的均匀分布，每个基因的突变概率为30%</li><li id="8a26" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">结束条件:</strong>一旦完成20次迭代，算法将停止</li></ul><p id="60dc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们得到的最优解是<code class="fe pu pv pw px b">fast_period=36</code>、<code class="fe pu pv pw px b">slow_period=84</code>、<code class="fe pu pv pw px b">signal_period=5</code>，其中<code class="fe pu pv pw px b">Total Profit / Maximum Draw Down</code>为5.33，总利润为518.85美元。</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/424c2efb74a756afea0d4e12df1a0064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6cxkq4eGi-NaILtupi-Mg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">我们的基准来自之前的博文——作者图片</figcaption></figure><h2 id="0126" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">2.独立的训练和测试设备</h2><p id="460f" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">为了防止我们的遗传算法过于擅长处理训练集，以至于它获得的知识不能被归纳和应用到看不见的数据上，让我们首先改变数据加载脚本，并创建一个测试集，该算法将不会在其上进行训练。这套测试将作为我们的期末考试，以检查结果是否可以在未来应用:</p><pre class="od oe of og gt py px pz qa aw qb bi"><span id="3d3d" class="ng nh jj px b gy qc qd l qe qf"># let's look at how many rows of data we have got<br/>df = read_alpha_vantage(ticker=TICKER)<br/>print(df.shape, df.index.min(), df.index.max())</span><span id="70a4" class="ng nh jj px b gy qg qd l qe qf">(5327, 5) 1999-11-01 2020-12-31</span><span id="8acd" class="ng nh jj px b gy qg qd l qe qf"># let's keep 4 years of testing data<br/>TRAIN_TEST_SPLIT_DATE = datetime.datetime(2017, 1, 1)<br/>df_train = df[df.index &lt; TRAIN_TEST_SPLIT_DATE]<br/>df_test = df[df.index &gt;= TRAIN_TEST_SPLIT_DATE]<br/>print(df_train.shape, df_train.index.min().date(), df_train.index.max().date())</span><span id="fa50" class="ng nh jj px b gy qg qd l qe qf">(4320, 5) 1999-11-01 2016-12-30</span><span id="ff2d" class="ng nh jj px b gy qg qd l qe qf">print(df_test.shape, df_test.index.min().date(), df_test.index.max().date())</span><span id="c83c" class="ng nh jj px b gy qg qd l qe qf">(1007, 5) 2017-01-03 2020-12-31</span><span id="f0e8" class="ng nh jj px b gy qg qd l qe qf"># this training set is all that the algorithm will use<br/>data = bt.feeds.PandasData(dataname=df_train, name=TICKER)</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="0e5d" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">3.作为适应度函数的变异系数</h2><p id="d9f8" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">新的标杆确立了，是时候换里面的肉了。要将CV纳入我们的适应度函数，我们需要首先向适应度函数添加2个超参数:</p><ul class=""><li id="63a0" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pm pe pf pg bi translated"><strong class="lj jt"> n: </strong>训练数据的随机切片数</li><li id="c5db" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt"> l: </strong>随机切片的长度</li></ul><blockquote class="ms mt mu"><p id="3ccd" class="lh li mv lj b lk ll kt lm ln lo kw lp mw lr ls lt mx lv lw lx my lz ma mb mc im bi translated">注意:与参数不同，在这种情况下，超参数不会增加我们的解决方案的复杂性。</p></blockquote><p id="9564" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还需要调整适应值的计算方式。回想一下，CV只有在基础测量是基于比例的并且有一个有意义的0时才起作用。这意味着我们不能再使用我们原来的适应度函数<code class="fe pu pv pw px b">Total Profit / Maximum Draw Down</code>，因为它没有绝对零点。相反，我们会将其更新为<code class="fe pu pv pw px b">Final Value / (Initial Capital * (1 — Maximum Percentage Draw Down))</code>。由于<code class="fe pu pv pw px b">backtrader</code>不允许负资产，当适应值为零时，这实际上意味着我们已经失去了一切，不能再糟糕了，也就是说，这可以用作绝对零。</p><p id="8ae5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设我们将<strong class="lj jt"> n </strong>设置为10，将<strong class="lj jt"> l </strong>设置为0.2。这意味着我们的适应度函数现在将抽取10个连续样本，每个样本占整个训练集的20%。然后，它将计算新的适合度值，作为我们新度量的CV，<code class="fe pu pv pw px b">f</code>，如下所示。</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi qh"><img src="../Images/ffef066796f694d8dfcb00a9a9410e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sirSUm2JK_Zl8-lbkYAdjw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">我们的新指标——作者图片</figcaption></figure><p id="a45f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">分割训练集时要注意的另一件事是，训练集需要至少与最大参数一样长。例如，如果我们的<code class="fe pu pv pw px b">fast_period</code>是15天，那么对于任何有效信号的发生，切片至少需要16天。为了避免训练集切片中的数据不足，让我们定义<code class="fe pu pv pw px b">slice_length = int(len(df_train) * l + max(parameters))</code>，使得每个切片现在的长度为<code class="fe pu pv pw px b">slice_length</code>。这样，我们将确保每个切片都有相同长度的交易窗口。我们的新<code class="fe pu pv pw px b">evaluate</code>现在看起来像这样:</p><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="qi oi l"/></div></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="a4d3" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">4.估价</h2><p id="8702" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">有了新的fitness函数，我们可以将它插回到我们在上一篇博文中运行GA时使用的脚本中:</p><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="qi oi l"/></div></figure><p id="4d33" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">运行该代码片段后，我们得到了以下结果</p><pre class="od oe of og gt py px pz qa aw qb bi"><span id="8ed4" class="ng nh jj px b gy qc qd l qe qf">HALL OF FAME:<br/>    0: [136, 145, 150], Fitness: 0.010034400410587742<br/>    1: [136, 145, 138], Fitness: 0.00872738799658447<br/>    2: [135, 136, 138], Fitness: 0.008081687727270134</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6b5c1137e754edb857999d5e43d7a4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CO08F8lkbZhwMESEp527pg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">遗传算法的收敛——作者图像</figcaption></figure><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/988d5225b1a58094ec722f64151ddf92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xwhjhZ34391BnfgkYTxEvQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">最终性能比以前稍好—图片由作者提供</figcaption></figure><ul class=""><li id="a06a" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pm pe pf pg bi translated"><strong class="lj jt">使用较小的训练数据集的可比性能:</strong>使用90%的数据和随机样本子集进行训练，我们的新GA找到了一种更长期的策略，最终获得了比以前更好的利润。</li><li id="57c7" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">更少的黄牛，更少的交易成本:</strong>与之前的<code class="fe pu pv pw px b">fast_period=36</code>、<code class="fe pu pv pw px b">slow_period=84</code>和<code class="fe pu pv pw px b">signal_period=5</code>相比，我们的<code class="fe pu pv pw px b">fast_period=136</code>、<code class="fe pu pv pw px b">slow_period=145</code>和<code class="fe pu pv pw px b">signal_period=150</code>新策略的进场信号更少。因此，我们支付的交易费用减少了。</li><li id="d349" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">表现出色的霍德林:</strong>这永远是令人欣慰的消息。经验法则:如果一个策略比买入并持有更糟糕，那么这根本不是一个可行的策略。</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="4962" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">5.结束语</h2><p id="d242" class="pw-post-body-paragraph lh li jj lj b lk ny kt lm ln nz kw lp lq oa ls lt lu ob lw lx ly oc ma mb mc im bi translated">在这篇博客中，我们研究了如何调整遗传算法，使其在变异系数和随机子集选择方面更加稳健。我们已经用整个数据集的81%取得了更好的最终结果。然而，这绝不是用遗传算法进行参数优化的黄金入场券。这里有一些额外的想法，你可能想看看:</p><ul class=""><li id="64d3" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pm pe pf pg bi translated"><strong class="lj jt">理解数据偏差:</strong>这会导致非常严重的过度拟合。例如，如果整体市场是看涨的，那么GA给你好的结果是有道理的，即使它只是HODL。想象一下，如果你在市场看跌时也这么做。</li><li id="cd1f" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">统计代表性:</strong>如果测试集在统计上与训练集不同，你可能要做的就是添加一个验证集，它需要在统计上与测试集相似。然后，训练过程需要考虑训练集和测试集中的适应值。</li><li id="2b2e" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">多目标:</strong>我们可以将它们作为单独的健康值，并让<code class="fe pu pv pw px b">deap</code>对它们进行不同的加权，而不是像我们在这篇博客中所做的那样，将指标组合成比率。如果我们想为GA添加更多的度量来优化，这可能会使我们的GA更具可解释性。但是请记住，添加更多的度量标准可能会以过度拟合为代价。</li><li id="e88d" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><strong class="lj jt">扩展我们的训练集:</strong>这几乎是任何机器学习问题最常见的答案。但是要记住几件事— (1)虽然稍微混合一下训练集的统计分布以便算法暴露于不同的场景通常是一个好主意，但是我们仍然需要确保训练、验证和测试集仍然在某种程度上相关，以及(2)回到第一个结束想法，您不应该仅仅为了可以有一个更大的训练集而冒险过多地偏向您的训练集。</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="f740" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇博文就讲到这里吧！正如承诺的那样，<a class="ae jg" href="https://gist.github.com/wululoo/b690b527add16e6721c09d23ec6cfdae" rel="noopener ugc nofollow" target="_blank">这里是完整的脚本</a>。我希望你已经发现这是有用的。如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="be81" class="oy oz jj lj b lk ll ln lo lq pa lu pb ly pc mc pm pe pf pg bi translated"><a class="ae jg" href="https://towardsdatascience.com/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2" rel="noopener" target="_blank">改进数据科学工作流程的7种简单方法</a></li><li id="8353" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><a class="ae jg" href="https://towardsdatascience.com/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce" rel="noopener" target="_blank">熊猫数据帧上的高效条件逻辑</a></li><li id="a4b5" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><a class="ae jg" href="https://towardsdatascience.com/memory-efficiency-of-common-python-data-structures-88f0f720421" rel="noopener" target="_blank">常见Python数据结构的内存效率</a></li><li id="4089" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><a class="ae jg" href="https://towardsdatascience.com/parallelism-with-python-part-1-196f0458ca14" rel="noopener" target="_blank">与Python并行</a></li><li id="d845" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><a class="ae jg" href="https://towardsdatascience.com/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72" rel="noopener" target="_blank">数据科学的基本Jupyter扩展设置</a></li><li id="413f" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated"><a class="ae jg" href="https://towardsdatascience.com/mastering-root-searching-algorithms-in-python-7120c335a2a8" rel="noopener" target="_blank">Python中高效的根搜索算法</a></li></ul><div class="is it gp gr iu md"><a href="https://www.linkedin.com/in/louis-chan-b55b9287/" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd jt gy z fp mi fr fs mj fu fw js bi translated">Louis Chan-FTI Consulting | LinkedIn数据科学总监</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">www.linkedin.com</p></div></div><div class="mm l"><div class="qj l mo mp mq mm mr ja md"/></div></div></a></div><figure class="od oe of og gt iv gh gi paragraph-image"><a href="https://www.buymeacoffee.com/louischan"><div class="gh gi qk"><img src="../Images/2e4f8f85dfae888815f32da8c93c86b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*YV5xbeRjR1ZVZ3M-.png"/></div></a></figure><h2 id="163d" class="ng nh jj bd ni nj nk dn nl nm nn dp no lq np nq nr lu ns nt nu ly nv nw nx jp bi translated">参考资料:</h2><ul class=""><li id="8ddb" class="oy oz jj lj b lk ny ln nz lq ql lu qm ly qn mc pm pe pf pg bi translated">伊沃·贡萨尔维斯和席尔瓦·萨拉。"遗传程序设计中控制过拟合的实验."第15届葡萄牙人工智能会议录:人工智能的进展，EPIA。第84卷。2011.</li><li id="2f15" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated">兰登，W. B遗传规划中最小化测试〉。11.10 (2011年):1。</li><li id="0b59" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated">《遗传规划中过拟合控制的随机抽样技术》基因编程。施普林格柏林海德堡，2012。218–229.</li><li id="1ae4" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated">伊沃·贡萨尔维斯和席尔瓦·萨拉。用训练数据的交错采样平衡遗传编程中的学习和过拟合。施普林格柏林海德堡，2013。</li><li id="1685" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated">伊沃·贡萨尔维斯和席尔瓦·萨拉。"遗传程序设计中控制过拟合的实验."第15届葡萄牙人工智能会议录:人工智能的进展，EPIA。第84卷。2011.</li><li id="aca7" class="oy oz jj lj b lk ph ln pi lq pj lu pk ly pl mc pm pe pf pg bi translated">扬·埃格克利茨和彼得·波希奇。"遗传规划中的模型选择和过拟合:实证研究."GECCO Companion ' 15:2015年遗传和进化计算年会的配套出版物会议录。计算机械协会，2015年。1527–1528.</li></ul></div></div>    
</body>
</html>