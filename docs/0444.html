<html>
<head>
<title>An Offbeat Approach to Brain Tumor Classification using Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用计算机视觉进行脑肿瘤分类的另类方法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/an-offbeat-approach-to-brain-tumor-classification-using-computer-vision-19c9e7b84664?source=collection_archive---------1-----------------------#2020-04-30">https://pub.towardsai.net/an-offbeat-approach-to-brain-tumor-classification-using-computer-vision-19c9e7b84664?source=collection_archive---------1-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="62cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算机视觉在医学科学领域发挥着非常关键的作用，这项在医学科学中应用计算机视觉的研究被广泛称为<em class="ko">医学成像</em>。现在，计算机视觉是通过将机器学习或深度学习方法或两者(混合)部署到生产中来实现的。</p><p id="64d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将介绍一种这样的机器学习方法，该方法使用深度学习模块，使其成为脑瘤分类的混合模型。</p><blockquote class="kp kq kr"><p id="8eaf" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">脑瘤分类的混合模型开发</strong></p></blockquote><ul class=""><li id="a585" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated"><em class="ko">数据集</em>:Kaggle中可用的脑部MRI图像数据集，用于模型开发(<a class="ae le" href="https://www.kaggle.com/navoneel/brain-mri-images-for-brain-tumor-detection/download" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">下载</strong> </a>)。该数据集包含253张大脑的MRI图像。示例图像如下所示。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4d9b351e033864c2b2c84d5db50df26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ettKgOT8LLIsKOaf8R-mmQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">肿瘤性(左)</strong> &amp; <strong class="bd lv">非肿瘤性(右)</strong></figcaption></figure><ul class=""><li id="4467" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated"><em class="ko">用于图像特征提取的三层前馈卷积神经网络</em>:提出的CNN架构如下图所示:</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/06c6909941eb9ed4d8ea589520c47f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*PP0ddzNwPKAAyo0p4vLVMQ.png"/></div></figure><p id="08a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种CNN架构仅向前传递一次(<strong class="js iu">无反向传播</strong>)用于特征提取。这就是上面讨论的深度学习模块。</p><ul class=""><li id="6f08" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated"><em class="ko">支持向量机(SVM)-RBF核</em> : SVM的RBF核被实例化并训练用于预测模型开发。ML模块是使用Scikit-Learn开发的。</li></ul><blockquote class="kp kq kr"><p id="cc0e" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">实施CNN-SVM混合模式</strong></p></blockquote><p id="338b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CNN模型是使用Keras框架开发的:</p><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="13d9" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing all necessary libraries</strong><br/>from keras.models import Sequential<br/>from keras.layers import Convolution2D<br/>from keras.layers import MaxPooling2D<br/>from keras.layers import Flatten<br/>from keras.layers import Dense<br/><strong class="ly iu"># CNN Model Development<br/></strong>classifier = Sequential()<br/><strong class="ly iu"># CONVOLUTION (1st Layer)</strong><br/>classifier.add(Convolution2D(32,(3,3),strides = (3,3),input_shape=(1000,1000,3),activation='relu'))<br/><strong class="ly iu"># Max-Pooling for 1st Convolutional Layer</strong><br/>classifier.add(MaxPooling2D(pool_size=(2,2)))<br/><strong class="ly iu"># CONVOLUTION (2nd Layer)</strong><br/>classifier.add(Convolution2D(32,(3,3),strides = (3,3), activation = 'relu'))<br/><strong class="ly iu"># Max-Pooling for 2nd Convolutional Layer </strong><br/>classifier.add(MaxPooling2D(pool_size=(2,2)))<br/><strong class="ly iu"># CONVOLUTION (3rd Layer)</strong><br/>classifier.add(Convolution2D(32,(3,3),strides = (3,3), activation = 'relu'))<br/><strong class="ly iu"># Max-Pooling for 3rd Convolutional Layer</strong><br/>classifier.add(MaxPooling2D(pool_size=(2,2)))<br/><strong class="ly iu"># FLATTENING</strong><br/>classifier.add(Flatten())</span></pre><p id="7e22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">深入探究CNN模型实例化:</p><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="bdf9" class="mc md it ly b gy me mf l mg mh">classifier.summary()</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mi"><img src="../Images/342054da27b3e5714d647ffe74011fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GfjDlXNMPN2-ollv65nYdw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">显示将提取总共512个图像特征的模型概要</strong></figcaption></figure><p id="b892" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用通过整个方法的原始实验获得的预先保存的权重来加载CNN模型(还没有讨论剩余的步骤)。权重可在以下链接中的分级数据格式(H5)文件中找到:</p><div class="mj mk gp gr ml mm"><a href="https://github.com/navoneel1092283/Brain_Tumor_Detection_HybridCNN-SVM_Weights/blob/master/Brain_Tumor_PCA.h5" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">navoneel 1092283/脑肿瘤_检测_杂交CNN-SVM _权重</h2><div class="mt l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lp mm"/></div></div></a></div><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="85dd" class="mc md it ly b gy me mf l mg mh">classifier.load_weights("Brain_Tumor_PCA.h5")</span></pre><blockquote class="kp kq kr"><p id="b33e" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">使用实例化的CNN模型的图像特征提取</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="3eea" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing the necessary libraries</strong><br/>import numpy as np<br/>import cv2<br/>import os<br/><strong class="ly iu"># initializing the feature matrix</strong><br/>X = np.ones((253, 512))<br/><strong class="ly iu"># image loading and feature extraction<br/></strong>i = 0<br/>os.chdir('.../MRI_IMAGES/train/yes')<br/>for filename in os.listdir('.../MRI_IMAGES/train/yes'):<br/>    img = cv2.imread(filename)<br/>    img = cv2.resize(img,(1000,1000))<br/>    img = np.divide(img,255)<br/>    img = img.reshape(1,1000,1000,3)<br/>    X[i] = classifier.predict(img)<br/>    i = i + 1<br/>os.chdir('.../MRI_IMAGES/train/no')<br/>for filename in os.listdir('.../MRI_IMAGES/train/no'):<br/>    img = cv2.imread(filename)<br/>    img = cv2.resize(img,(1000,1000))<br/>    img = np.divide(img,255)<br/>    img = img.reshape(1,1000,1000,3)<br/>    X[i] = classifier.predict(img)<br/>    i = i + 1<br/>os.chdir('.../MRI_IMAGES/test/yes')<br/>for filename in os.listdir('.../MRI_IMAGES/test/yes'):<br/>    img = cv2.imread(filename)<br/>    img = cv2.resize(img,(1000,1000))<br/>    img = np.divide(img,255)<br/>    img = img.reshape(1,1000,1000,3)<br/>    X[i] = classifier.predict(img)<br/>    i = i + 1<br/>os.chdir('.../MRI_IMAGES/test/no')<br/>for filename in os.listdir('.../MRI_IMAGES/test/no'):<br/>    img = cv2.imread(filename)<br/>    img = cv2.resize(img,(1000,1000))<br/>    img = np.divide(img,255)<br/>    img = img.reshape(1,1000,1000,3)<br/>    X[i] = classifier.predict(img)<br/>    i = i + 1</span><span id="aa7a" class="mc md it ly b gy na mf l mg mh"><strong class="ly iu"># Preparing the Actual Labels</strong><br/>y = np.concatenate((np.ones(121), np.zeros(79), np.ones(34), np.zeros(19)))</span></pre><blockquote class="kp kq kr"><p id="1edb" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">使用主成分分析的维数减少</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="7545" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing necessary libraries</strong><br/>from sklearn.decomposition import PCA</span><span id="9ba0" class="mc md it ly b gy na mf l mg mh">pca = PCA(n_components = 2)<br/>pca.fit(X.T)<br/>Z = pca.components_.T</span></pre><blockquote class="kp kq kr"><p id="68fd" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">数据集的散点图可视化</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="6eaf" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing the necessary libraries</strong><br/>import matplotlib.pyplot as plt</span><span id="ffbe" class="mc md it ly b gy na mf l mg mh">plt.scatter(Z.T[0], Z.T[1], c = y, s = 10, marker = 'x')<br/>plt.title('Scatter Plot Visualization (VIOLET -&gt; Non-Tumorous, YELLOW -&gt; Tumorous)')<br/>plt.xlabel("F1_PCA")<br/>plt.ylabel("F2_PCA")</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/1fba6eb4cc0251b8f6d24bf6f3f5ae04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*aS0iSsXSc0-y4YFdJU--7w.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">散点图</strong></figcaption></figure><p id="b00b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，从散点图来看，显然没有线性分离原始特征空间的最大似然算法适用于此。</p><blockquote class="kp kq kr"><p id="67c6" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">将数据集拆分为训练集和测试集</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="2d02" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing necessary libraries</strong><br/>from sklearn.model_selection import train_test_split</span><span id="ba06" class="mc md it ly b gy na mf l mg mh">X_train, X_test, y_train, y_test = train_test_split(Z,y, test_size=0.1, random_state=1234)</span></pre><blockquote class="kp kq kr"><p id="4e15" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu"> SVM (RBF内核)预测模型开发和网格搜索调整，用于选择最佳超参数，即C(支持向量机中的惩罚参数)</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="25ed" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing necessary libraries<br/></strong>from sklearn.svm import SVC<br/>from sklearn.model_selection import GridSearchCV<br/><strong class="ly iu"># MODEL INSTANTIATION<br/></strong>model = SVC(kernel = 'rbf')<br/>parameters = {'C':[0.1,1,10,100,1000,10000,100000]}<br/>grid_search = GridSearchCV(param_grid = parameters, estimator = model, verbose = 3)<br/><strong class="ly iu"># MODEL TRAINING AND GRID-SEARCH TUNING<br/></strong>grid_search = grid_search.fit(X_train,y_train)</span></pre><blockquote class="kp kq kr"><p id="3d14" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">获得最佳超参数，即C，惩罚参数</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="3fb1" class="mc md it ly b gy me mf l mg mh">print(grid_search.best_params_)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/246c58c585a0e0b134cf33539bd726a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*vr6TMb7aEaRcYHytifVnKQ.png"/></div></figure><p id="68b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且，SVM (RBF内核)的“gamma”参数在Scikit-Learn中设置为(1/特征数)作为默认值。所以，<em class="ko">γ= 0.5</em></p><blockquote class="kp kq kr"><p id="679f" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">车型性能分析</strong></p></blockquote><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="e879" class="mc md it ly b gy me mf l mg mh">print("Validation Accuracy:",grid_search.score(X_test,y_test))<br/>print("Training Accuracy:  ",grid_search.score(X_train, y_train))</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nd"><img src="../Images/73d947e3577d7df8f3e2efdcaa34ace3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmGTF9p1FNqNzfmpTEe-wQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">训练准确率:76.21%，验证准确率:76.92%(完全符合)</strong></figcaption></figure><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="506d" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing the necessary library</strong><br/>from sklearn.metrics import classification_report</span><span id="5423" class="mc md it ly b gy na mf l mg mh">print(classification_report(y_test,grid_search.predict(X_test)))</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e1196664ade18c407f7a98620e32d9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*UqHAuswbyKbjAvyXQ1oryg.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">分类报告</strong></figcaption></figure><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="0ef5" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing the necessary libraries<br/></strong>import matplotlib.pyplot as plt<br/>%matplotlib inline<br/>import itertools<br/>from sklearn.metrics import confusion_matrix</span><span id="cb89" class="mc md it ly b gy na mf l mg mh">def plot_confusion_matrix(cm, classes,<br/>                          normalize=False,<br/>                          title='Confusion matrix',<br/>                          cmap=plt.cm.Blues):<br/>    if normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    else:<br/>        print('Confusion matrix, without normalization')</span><span id="ad59" class="mc md it ly b gy na mf l mg mh">print(cm)</span><span id="8c96" class="mc md it ly b gy na mf l mg mh">plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)</span><span id="a69b" class="mc md it ly b gy na mf l mg mh">fmt = '.2f' if normalize else 'd'<br/>    thresh = cm.max() / 2.<br/>    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        plt.text(j, i, format(cm[i, j], fmt),<br/>                 horizontalalignment="center",<br/>                 color="white" if cm[i, j] &gt; thresh else "black")</span><span id="7887" class="mc md it ly b gy na mf l mg mh">plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')</span><span id="043d" class="mc md it ly b gy na mf l mg mh">plt.figure()<br/>plot_confusion_matrix(confusion_matrix(y_test, grid_search.predict(X_test)), classes=[0,1], normalize=True,<br/>                      title='Confusion Matrix')</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/3608453098c9c3026f2d7650ace5fef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*jfiAnPiPlmOiNA87Pp3aGA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">归一化混淆矩阵</strong></figcaption></figure><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="61bb" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing the necessary modules</strong><br/>from sklearn.metrics import roc_curve, auc</span><span id="e60f" class="mc md it ly b gy na mf l mg mh">y_roc = np.array(y_test)<br/>fpr, tpr, thresholds = roc_curve(y_roc, grid_search.decision_function(X_test))<br/>roc_auc = auc(fpr, tpr)<br/>print("Area under the ROC curve : %f" % roc_auc)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/efb1e017dcc88d2d6f8be4dc46620b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVmztQD_LA71WPkPYkO_Mw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv">受试者操作特征曲线下面积(AUROC) </strong></figcaption></figure><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="8c66" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu"># Importing the necessary libraries</strong><br/>import pylab as pl</span><span id="fbc5" class="mc md it ly b gy na mf l mg mh">pl.clf()<br/>pl.plot(fpr, tpr, label='ROC curve (area = %0.2f)' % roc_auc)<br/>pl.plot([0, 1], [0, 1], 'k--')<br/>pl.xlim([0.0, 1.0])<br/>pl.ylim([0.0, 1.0])<br/>pl.xlabel('False Positive Rate')<br/>pl.ylabel('True Positive Rate')<br/>pl.legend(loc="lower right")<br/>pl.show()</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8a93ec9ad021a3354e3c176d397a331e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*PYEpXmbNvHV0W_uj3AyUFg.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><strong class="bd lv"> AUROC曲线</strong></figcaption></figure><blockquote class="kp kq kr"><p id="4912" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">通过决策边界进行逻辑调整</strong></p></blockquote><p id="1e49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">逻辑推理对于任何人工智能模型都是非常重要的，无论是基于机器学习还是深度学习，这种方法也不例外。在医学成像涉及的深度学习模型中，逻辑推理是使用Grad Cam可视化完成的，后来由医生进行验证。因此，纯深度学习模型占据上风。</p><p id="7807" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，该方法基于支持向量机，支持向量机是使用N维特征空间几何的基于模式识别的机器学习算法。因此，<strong class="js iu">决策边界可视化</strong>是整个方法论的最佳逻辑论证方式。</p><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="e4af" class="mc md it ly b gy me mf l mg mh">x_min, x_max = X_train[:, 0].min(), X_train[:, 0].max()<br/>y_min, y_max = X_train[:, 1].min(), X_train[:, 1].max()<br/>xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.001),<br/>                     np.arange(y_min, y_max, 0.001))</span><span id="d3be" class="mc md it ly b gy na mf l mg mh">h = grid_search.predict(np.c_[xx.ravel(), yy.ravel()])<br/>h = h.reshape(xx.shape)<br/>plt.contourf(xx, yy, h)<br/>plt.scatter(X_train[:, 0], X_train[:, 1], c=y_train, s = 10, marker = 'o', edgecolor = 'k')<br/>plt.title('Scatter Plot Visualization of Training Set (VIOLET -&gt; Non-Tumorous, YELLOW -&gt; Tumorous)')<br/>plt.xlabel('F1_PCA')<br/>plt.ylabel('F2_PCA')</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ni"><img src="../Images/1dfd9bd50abb30188c81576a36c25367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ypuifw9invSzR5esUGN0hw.png"/></div></div></figure><pre class="lg lh li lj gt lx ly lz ma aw mb bi"><span id="164a" class="mc md it ly b gy me mf l mg mh">x_min, x_max = X_test[:, 0].min(), X_test[:, 0].max()<br/>y_min, y_max = X_test[:, 1].min(), X_test[:, 1].max()<br/>xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.001),<br/>                     np.arange(y_min, y_max, 0.001))</span><span id="c78e" class="mc md it ly b gy na mf l mg mh">h = grid_search.predict(np.c_[xx.ravel(), yy.ravel()])<br/>h = h.reshape(xx.shape)<br/>plt.contourf(xx, yy, h)<br/>plt.scatter(X_test[:, 0], X_test[:, 1], c = y_test, s = 10, marker = 'o', edgecolor = 'k')<br/>plt.title('Scatter Plot Visualization of Test Set (VIOLET -&gt; Non-Tumorous, YELLOW -&gt; Tumorous)')<br/>plt.xlabel('F1_PCA')<br/>plt.ylabel('F2_PCA')</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nj"><img src="../Images/bd08b5eccbc69a818313054658b6d991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJacAoWDGWOSx2BdeRm-GQ.png"/></div></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="ea64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以这种方式，开发了深度学习-机器学习混合模型，产生了76.9%的测试准确率和0.8的AUROC，以及上面提到的其他性能指标。通过包括所有512个提取的特征(通过跳过PCA步骤)并且使用从原始实验获得的不同CNN权重，可以显著提高性能。此外，在最近的过去，在医学成像领域发表了研究会议论文，部署了类似的深度学习-机器学习混合模型:</p><ol class=""><li id="bea8" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn nr lb lc ld bi translated">查克拉巴蒂，纳沃尼尔，和Subhrasankar查特吉。"一种用计算机视觉检测糖尿病视网膜病变的另类技术."<em class="ko"> 2019年第十届国际计算、通信和网络技术大会</em>。IEEE，2019。(<a class="ae le" href="https://ieeexplore.ieee.org/document/8944633" rel="noopener ugc nofollow" target="_blank">https://ieeexplore.ieee.org/document/8944633</a>)</li><li id="8ff2" class="kv kw it js b jt ns jx nt kb nu kf nv kj nw kn nr lb lc ld bi translated">查克拉巴蒂，纳沃尼尔，和Subhrasankar查特吉。"一种使用计算机视觉进行青光眼筛查的新方法."<em class="ko"> 2019智能系统与发明技术国际会议(ICSSIT) </em>。IEEE，2019。(<a class="ae le" href="https://ieeexplore.ieee.org/document/8987803" rel="noopener ugc nofollow" target="_blank">https://ieeexplore.ieee.org/document/8987803</a>)</li></ol></div></div>    
</body>
</html>