<html>
<head>
<title>How to Make a Model with Textual Input Benefit From User’s Age</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使文本输入的模型受益于用户的年龄</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/enriching-sequential-lstm-model-with-non-sequential-features-7224b5262132?source=collection_archive---------1-----------------------#2021-02-17">https://pub.towardsai.net/enriching-sequential-lstm-model-with-non-sequential-features-7224b5262132?source=collection_archive---------1-----------------------#2021-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0bd9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="514a" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated"><strong class="ak">用非序列特征丰富序列LSTM模型</strong></h2></div><p id="f528" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">序列数据可以在机器学习的各个领域和用例中找到，例如时间序列预测、生物信息学、语音识别或自然语言处理。随着深度学习的趋势，通常使用递归神经网络的变体对序列进行建模，递归神经网络在每个时间步长在<em class="lk">顺序地获取输入。</em></p><p id="f17e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，有时我们可能会有可用的<strong class="kq ja">附加特性</strong>，这些特性<strong class="kq ja">是非连续的</strong>，但仍然与我们试图解决的任务相关。例如，这些可能是我们试图预测其股票的公司的地理位置，我们试图识别其声音的说话者的性别，或者写产品评论的人的年龄。</p><p id="fb91" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这些特性可能不会成就或破坏你的模型，但是通常可以帮助你获得一点点性能。在本文中，我将向您展示如何将这些非顺序特性与LSTM结合起来，并训练一个单一的端到端模型。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/99f0dc3f8d45b57439ea6fe0c3bb261a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZO5CzHf9NOSo6PuLVspY2A.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">不集中的光线，模糊的声音(2020)由<a class="ae mb" href="http://www.jurajpoliak.sk" rel="noopener ugc nofollow" target="_blank">尤拉杰·波利亚克</a></figcaption></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="cc89" class="mj mk iq bd ml mm mn dn mo mp mq dp mr kx ms mt mu lb mv mw mx lf my mz na iw bi translated">资料组</h2><p id="9f18" class="pw-post-body-paragraph ko kp iq kq b kr nb ka kt ku nc kd kw kx nd kz la lb ne ld le lf nf lh li lj ij bi translated">因为我的背景主要是自然语言处理，所以我决定用一个相关的用例来演示这个原理。为此，我选择了名为<a class="ae mb" href="https://www.kaggle.com/nicapotato/womens-ecommerce-clothing-reviews" rel="noopener ugc nofollow" target="_blank">女装电商服装评论</a>的数据集。</p><p id="8653" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">数据集包含以<em class="lk">自由文本</em>编写的客户评论，这些评论对应于我们的序列数据(令牌序列——单词)。此外，它还包含客户年龄、产品ID、产品部门、客户对产品的评级以及客户是否会向其他人推荐产品等特性。在我们的实验中，对他人的产品推荐实际上不会作为一个特征，而是作为<em class="lk">我们将尝试预测的目标值</em>。</p><h2 id="f4c7" class="mj mk iq bd ml mm mn dn mo mp mq dp mr kx ms mt mu lb mv mw mx lf my mz na iw bi translated">基线</h2><p id="384c" class="pw-post-body-paragraph ko kp iq kq b kr nb ka kt ku nc kd kw kx nd kz la lb ne ld le lf nf lh li lj ij bi translated">让我们首先创建一个序列模型，它只接受输入的评审的<em class="lk">文本，并且可以作为我们的基线。</em></p><p id="2e07" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这里使用的模型相对简单。首先使用<a class="ae mb" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank"> Glove:单词表示的全局向量</a>用单词嵌入来表示评论的文本。之后，该模型由一个双向LSTM层和一个全连接层组成。输出层使用<em class="lk">一个sigmoid函数</em>，因为我们的输出只是0或1，对应于客户是否会推荐产品。</p><p id="7744" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在Keras中，模型可能是这样的:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4516" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">所描述的模型已经在所提到的数据集(以90:10的比例分割)上被训练和评估。这使得<em class="lk">的准确率达到了89% </em>。</p><h2 id="b28c" class="mj mk iq bd ml mm mn dn mo mp mq dp mr kx ms mt mu lb mv mw mx lf my mz na iw bi translated">添加非连续特征</h2><p id="b559" class="pw-post-body-paragraph ko kp iq kq b kr nb ka kt ku nc kd kw kx nd kz la lb ne ld le lf nf lh li lj ij bi translated">现在，让我们向刚刚定义的同一个模型中添加非顺序特性。我看到有几种方法可以做到这一点。</p><p id="2860" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">其中之一是在序列的开头添加特征作为特殊标记。这样，<em class="lk">任何序列的前N个记号</em>将总是对应于这些特征。我不觉得这个解决方案特别干净，主要是因为这些特征需要以某种方式编码，并伪装成单词嵌入(或其他序列表示)。这可能会有一点麻烦和令人疲惫，主要是如果要素是不同的数据类型。</p><p id="0660" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我更喜欢并且发现更干净的解决方案是用<strong class="kq ja"> 2个独立输入</strong>构建模型。这样，第一个输入可以纯粹用于顺序特征，第二个输入用于非顺序特征。顺序输入通常通过嵌入和LSTM层，然后与非顺序输入连接<em class="lk"> </em>。<em class="lk">产生的组合向量</em>然后通过全连接层，最后通过输出层。下图展示了这种架构。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ni"><img src="../Images/34e482ad698009484c080579e47a539d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgFN89aays_Ndr50apC1Hg.jpeg"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">具有顺序和非顺序输入的模型的体系结构。图片作者。</figcaption></figure><p id="6b27" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Keras中相应的代码如下所示:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1c0b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我在这个模型中使用的非顺序特征是<em class="lk">客户年龄</em>和提供的<em class="lk">产品评级</em>。我发现，客户的年龄与客户是否会推荐该产品只有轻微的相关性(0.0342)，因此，我决定也使用产品评级，这显然是强相关的(0.7928)。这样做是为了演示添加非顺序特性的效果，然而，实际上我们可能没有这么强的特性。</p><p id="4310" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">要训练模型，您需要提供如下单独的输入:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d030" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最终的模型达到了<em class="lk">94%</em>的精确度，在我们的例子中，与基线相比<strong class="kq ja">增加了5%</strong>。当然，改进完全依赖于提供给模型的特性的质量，但是一般来说，任何与您的目标值至少有一点相关的非顺序特性都应该有所帮助。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="dc44" class="mj mk iq bd ml mm mn dn mo mp mq dp mr kx ms mt mu lb mv mw mx lf my mz na iw bi translated">结论</h2><p id="a66b" class="pw-post-body-paragraph ko kp iq kq b kr nb ka kt ku nc kd kw kx nd kz la lb ne ld le lf nf lh li lj ij bi translated">在本文中，我们演示了如何将两种不同类型的输入组合成一个端到端模型。在实践中，我们不需要将自己限制在任何给定的输入数量，而是添加我们想要的数量。你可以想象另一个输入，例如<em class="lk">一个图像</em>，在与其余输入连接之前，它通过几个卷积层。</p><p id="eb92" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我希望这种方法能对您未来的项目有所帮助。</p><p id="59d4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我用过的所有<strong class="kq ja">代码</strong>都在<a class="ae mb" href="https://www.kaggle.com/sebastianpoliak/sequential-model-with-non-sequential-features" rel="noopener ugc nofollow" target="_blank">这个kaggle笔记本</a>里。</p><p id="3e00" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">感谢您的阅读！</p><div class="nj nk gp gr nl nm"><a href="https://towardsdatascience.com/1-to-5-star-ratings-classification-or-regression-b0462708a4df" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ja gy z fp nr fr fs ns fu fw iz bi translated">1到5星评级—分类还是回归？</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">通过实验找出答案。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">towardsdatascience.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa lv nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://towardsdatascience.com/systematically-tuning-your-model-by-looking-at-bias-and-variance-4986662315b2" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ja gy z fp nr fr fs ns fu fw iz bi translated">通过观察偏差和方差来系统地调整你的模型</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">有没有想过是否有比盲目猜测超参数或…更系统的方法来调整您的模型</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">towardsdatascience.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa lv nm"/></div></div></a></div></div></div>    
</body>
</html>