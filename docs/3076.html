<html>
<head>
<title>Build Semantic Segmentation App with Deep Java Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用深度Java库构建语义切分App</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/build-semantic-segmentation-app-with-deep-java-library-723adbbaf225?source=collection_archive---------1-----------------------#2022-08-29">https://pub.towardsai.net/build-semantic-segmentation-app-with-deep-java-library-723adbbaf225?source=collection_archive---------1-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/32ddac9cf2b1bd66d17e4b539ac37fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*sE3VXJTY_V-jNTKvL80drA.jpeg"/></div></figure><p id="a5d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Deep Java Library (DJL)有几个PyTorch Android演示应用，可以在你的手机上本地运行深度学习推理。这些例子很容易用作构建自己的应用程序的基础。今天，我想关注一个我为开源项目贡献的例子，语义分割:自动驾驶汽车和医学成像机器等广泛使用的深度学习领域。</p><p id="cd38" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">语义分割是一个深度学习过程，它对图像进行排序以找到对象。语义分割模型通过图像逐个像素地进行，将每个像素分类为对象或背景。它不区分两个相同类型的对象，而是识别它们。例如，通过语义分割，图像中的两只狗都被着色为相同的颜色，但是模型不一定关心这是两只不同的狗。当运行推理的算法根据分类识别和着色每个像素时，分割部分就开始了，当它完成时，允许我们看到着色的对象。简而言之，模型将在你给它的图像中找到的任何对象中着色。<a class="ae ks" href="https://www.jeremyjordan.me/semantic-segmentation/" rel="noopener ugc nofollow" target="_blank">本文</a>对语义分割模型及其层次结构进行了更深入的探讨。</p><h1 id="617d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设置</h1><p id="f426" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在您的本地计算机/开发人员环境中，从GitHub克隆<code class="fe lw lx ly lz b">djl-demo</code>存储库。你需要这样做，以便运行语义分段应用程序(或其他DJL应用程序之一)。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="6d42" class="mi ku iq lz b gy mj mk l ml mm">git clone <a class="ae ks" href="https://github.com/deepjavalibrary/djl-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/deepjavalibrary/djl-demo.git</a></span></pre><p id="9911" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">按照这些<a class="ae ks" href="https://github.com/awslabs/djl/blob/master/docs/development/setup.md" rel="noopener ugc nofollow" target="_blank">指令</a>设置您的开发环境。</p><p id="5627" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要在您自己的Android手机上运行该应用程序，请在您电脑的终端中执行以下步骤:</p><ol class=""><li id="6d54" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated"><code class="fe lw lx ly lz b">cd djl-demo/android/pytorch_android</code></li><li id="5230" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">然后再次进入你想运行的应用程序。如果你想运行语义分割，那么运行这个命令:<code class="fe lw lx ly lz b">cd semantic_segmentation</code></li><li id="cee0" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">从这里，根据您的计算机操作系统运行项目:</li></ol><p id="f52e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Mac: <code class="fe lw lx ly lz b">./gradlew iD</code></p><p id="6ecb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">视窗:<code class="fe lw lx ly lz b">..\gradlew iD</code></p><p id="3b23" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你没有Android手机，你可以安装Android Studio来运行应用程序。</p><p id="dda8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要在Android Studio仿真器中运行应用程序，请按照以下步骤操作:</p><ol class=""><li id="2341" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated">在Android Studio中打开<code class="fe lw lx ly lz b">djl-demo</code>目录的<code class="fe lw lx ly lz b">pytorch_android</code>文件夹。这将显示4个现有的DJL PyTorch应用程序，你可以运行。你可能得等一会儿，让格雷尔给这个项目编索引。</li><li id="c1d0" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">点击右上角要运行的应用程序名称旁边的绿色播放按钮，以及所选的模拟器，就可以了。</li></ol><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/7273d3d4565da9413b8b35a92aa6b6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJbZK554tgxUoKO4j0kpxg.jpeg"/></div></div></figure><p id="456a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就模型输入和输出而言，它们相对简单。输入是一个PNG或JPG图像，它被模型限制为600x800或更小。输出是一个带有彩色对象的图像，大小为600x800。翻译者将图像尺寸缩小到其原始尺寸。</p><h1 id="7fde" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">推理</h1><p id="0122" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">下面的代码块直接取自SemanticSegmentationTranslator.java在GitHub上的DJL库。翻译器为模型准备输入，从模型的输出中获取信息，并将其转换为对人类有直观意义的输出。在创建语义分割应用程序时，我发现翻译器的创建对我理解DJL贡献最大。我学习了DJL提供的数据类型和结构，以及使用它们的有效方法。探索是有趣和令人兴奋的，就像把隐藏的碎片拼在一起。DJL让您轻松找到合适的作品，并将其与您现有的作品搭配起来。</p><p id="c111" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面的代码是语义分割翻译器的核心后处理，最终创建图像输出。没有它，您只剩下一些对最终用户没有任何意义的输出数组。后处理对于深度学习模型的使用至关重要。</p><p id="f8dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们深入研究一些翻译器代码，以了解发生了什么。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="bcd7" class="mi ku iq lz b gy mj mk l ml mm">int imageSize = width * height;<br/>ByteBuffer bb = manager.allocateDirect(CHANNEL * imageSize);<br/>int r = 0; // adjustment for red pixel<br/>int g = 1; // adjustment for green pixel<br/>int b = 2; // adjustment for blue pixel<br/>byte[][] colors = new byte[CLASSNUM][3];</span><span id="0abd" class="mi ku iq lz b gy ng mk l ml mm">// randomly assign colors for each time the model is run<br/>for (int i = 0; i &lt; CLASSNUM; i++) {<br/>    byte red = (byte) RandomUtils.nextInt(256);<br/>    byte green = (byte) RandomUtils.nextInt(256);<br/>    byte blue = (byte) RandomUtils.nextInt(256);<br/>    colors[i][r] = red;<br/>    colors[i][g] = green;<br/>    colors[i][b] = blue;<br/>}</span></pre><p id="d58f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的代码是在图像经过预处理并通过模型运行后的后处理方法中。这将创建一个随机生成的颜色的2D字节数组，每次进行推理时，这些颜色对应于图像中不同的已知对象。</p><p id="b12a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面的代码紧跟在颜色生成之后；此代码将分类的像素映射到它们的颜色，这些颜色随后被转换为图像。这是后期加工的肉。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="6c07" class="mi ku iq lz b gy mj mk l ml mm">// double for loop to loop through each pixel<br/>for (int h = 0; h &lt; height; h++) {<br/>    for (int w = 0; w &lt; width; w++) {<br/>        int index = h * width + w;<br/>        int maxi = 0;<br/>        double maxnum = -Double.MAX_VALUE;<br/>        <br/>       // loops through each object probability at the specific pixel<br/>        for (int i = 0; i &lt; CLASSNUM; i++) {<br/>            // get score for each i at the h,w pixel of the image<br/>            float score = scores[i * (imageSize) + index];<br/>            if (score &gt; maxnum) {<br/>                maxnum = score;<br/>                maxi = i;<br/>            }<br/>        }<br/>        <br/>       // if an object was probabilistically found, color it in<br/>        if (maxi &gt; 0) {<br/>            bb.put(colors[maxi][r]);<br/>            bb.put(colors[maxi][g]);<br/>            bb.put(colors[maxi][b]);<br/>        } else {<br/>            bb.position(bb.position() + 3);<br/>        }<br/>    }<br/>}</span><span id="7c17" class="mi ku iq lz b gy ng mk l ml mm">// image creation from the buffer<br/>bb.rewind();<br/>int originW = (int) ctx.getAttachment("originalWidth");<br/>int originH = (int) ctx.getAttachment("originalHeight");<br/>NDArray fullImage =<br/>        manager.create(bb, new Shape(height, width, CHANNEL), DataType.UINT8);<br/>NDArray resized = NDImageUtils.resize(fullImage, originW, originH);</span><span id="84e7" class="mi ku iq lz b gy ng mk l ml mm">return ImageFactory.getInstance().fromNDArray(resized);</span></pre><p id="eb6d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顶部的双for循环遍历我们的<code class="fe lw lx ly lz b">scores</code>数组中的每个像素，这是从模型的输出中返回的。对于图像中的每个像素，有一个数组包含该像素是对应于该数组索引的对象的概率。如果没有概率大于0索引处的概率，则像素保持不着色(黑色)并成为背景的一部分。如果概率在非0的索引处最大，则像素被赋予代表该对象的相应的红色、绿色和蓝色值。</p><p id="d923" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦着色完成，图像就会生成一个完整的600 x 800大小的数组。然后将其缩小到图像的原始宽度和高度，并原样返回。</p><p id="f05c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是从应用程序看起来的样子。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/cdc6f6d4129bbc04dbf2727c774e68c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1MuSvRNS7x2wQsTOWNgM5g.gif"/></div></figure><p id="d3f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">真的就这么简单。当然，像任何其他项目一样，理解DJL工具需要一个学习曲线，但是一旦你这样做了，你就真正开始理解DJL给你的力量。</p><h1 id="5d44" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="4c0e" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">起初，我怀疑自己能否开始研究并理解DJL。我是一名即将进入迈阿密大学四年级的大学生，之前从未从事过开源项目。我原以为这将是极其困难的，但我实际上发现它非常有趣，它吸引了我。我很好奇每天能找到哪些新的DJL功能来帮助我更好地构建我的应用程序或未来的DJL应用程序。</p><p id="e321" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">语义分割可以大大扩展，超出这里显示的简单用法。正如我之前暗示的，这不是DJL唯一的应用。在写这篇博客的时候，实际上还有另外三个人。其中一个应用程序是Quickdraw Recognition，它可以实时识别和分类你在应用程序中绘制的对象。另一个应用程序是Style Transfer，它使用你拍摄的图像，并将其转换为符合文森特·梵高或克洛德·莫内等艺术家的风格。第三种是神经机器翻译，它接受法语文本输入，并返回翻译后的英语输出。因此，即使语义分割不完全符合你想要构建的应用程序的风格，DJL还有其他几个选项和示例可以帮助你开始！</p></div></div>    
</body>
</html>