<html>
<head>
<title>The Beginners’ Guide to Elasticsearch — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索初学者指南——第二部分</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-beginners-guide-to-elasticsearch-part-2-3206a8a42051?source=collection_archive---------3-----------------------#2020-09-16">https://pub.towardsai.net/the-beginners-guide-to-elasticsearch-part-2-3206a8a42051?source=collection_archive---------3-----------------------#2020-09-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="d6c3" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="4e26" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">节点、索引、文档、分片、复制和路由等关键概念解释清楚</h2></div><figure class="ks kt ku kv gu kw gi gj paragraph-image"><div class="ab gv cl kx"><img src="../Images/878fbabb1a6d2c224060756f3095730c.png" data-original-src="https://miro.medium.com/v2/format:webp/0*Xgk5q3nRgqsfakKo.jpeg"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">图片来自官方页面:<a class="ae le" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank">elastic.co</a></figcaption></figure></div><div class="ab cl lf lg hy lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="in io ip iq ir"><p id="adee" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在<a class="ae le" href="https://medium.com/towards-artificial-intelligence/the-beginners-guide-to-elasticsearch-part-1-2e50d3761e3c" rel="noopener"> <strong class="lo je">第一部分</strong> </a>中，我们已经介绍了什么是Elasticsearch，我们为什么要使用它，它的竞争对手等等。在本文中，我们将介绍一些关键概念，如什么是弹性搜索节点、索引、分片、文档、路由、复制。这将帮助你很好地了解<strong class="lo je"><em class="mi">elastic search如何工作</em> </strong>。</p><figure class="ks kt ku kv gu kw gi gj paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gi gj mj"><img src="../Images/9a4b1232c0293a637f78ccb5e6921822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksc8CocSUGFyNCxw9G-bow.png"/></div></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">作者图片</figcaption></figure><h1 id="a0bb" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated">结节</h1><p id="f085" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">Elasticsearch运行在Java虚拟机上。每个运行Elasticsearch的JVM实例都可以被认为是一个Elasticsearch节点。每当我们启动一个Elasticsearch实例时，我们都是在启动一个节点。如果您运行的是Elasticsearch的单个节点，那么您的集群只有一个节点。但是在现实生活中，一个集群会有许多节点。</p><p id="d8d1" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">节点可以扮演<code class="fe nl nm nn no b">master-eligible</code>、<code class="fe nl nm nn no b">data</code>、<code class="fe nl nm nn no b">ingest</code>、<code class="fe nl nm nn no b">machine learning</code>、<code class="fe nl nm nn no b">transform</code>、&amp;、<code class="fe nl nm nn no b">coordination</code>等不同的角色。这些节点角色通过设置<code class="fe nl nm nn no b">node.roles</code>来配置。如果没有配置节点角色，那么默认情况下每个节点都有以下角色:<code class="fe nl nm nn no b">master</code>、<code class="fe nl nm nn no b">data</code>、<code class="fe nl nm nn no b">ingest</code>、<code class="fe nl nm nn no b">ml</code>。</p><figure class="ks kt ku kv gu kw gi gj paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gi gj np"><img src="../Images/443bece471d08885b6bbe1dacadd598d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_-SRTPY8eIzTpR9B9sz8A.png"/></div></div><figcaption class="la lb gk gi gj lc ld bd b be z dk translated">作者图片</figcaption></figure><h1 id="ee47" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated"><strong class="ak">集群</strong></h1><p id="a556" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">集群是运行在一台或多台机器(虚拟机或物理机)上的一个或多个Elasticsearch节点的集合。默认情况下，集群名称为<code class="fe nl nm nn no b">elasticsearch</code>，可以根据需要进行更改。我们可以在单台机器或不同的机器上设置节点。在生产环境中，我们将在不同的机器上设置节点，以实现高可用性。在非生产环境中，我们可能在同一台机器上设置多个节点，但是我们可能无法测试高可用性特性。</p><p id="b64b" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们可以在群集中添加或删除节点，群集会自动重新组织数据，并在所有节点间平均分配数据。如上所述，集群中的每个节点都有一个指定的角色。</p><p id="74a4" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">对集群默认设置的任何更改都通过<code class="fe nl nm nn no b">elasticsearch.yml</code>文件进行配置。</p><h1 id="a891" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated"><strong class="ak">文件</strong></h1><p id="aeb7" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">文档是存储在Elasticsearch中的JSON对象。这类似于RDBMS系统中的行/记录。JSON对象包含零个或多个键值对。每个文档都存储在一个索引中，并有一个<code class="fe nl nm nn no b">id</code>。如无特别说明，此<code class="fe nl nm nn no b">id</code>由Elasticsearch指定。索引后请参考下面的示例文档。</p><h1 id="4cc4" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated"><strong class="ak">索引</strong></h1><p id="7cbf" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated"><code class="fe nl nm nn no b">index</code>类似于关系数据库系统(RDBMS)中的数据库。Elasticsearch中的每个文档都存储在一个索引中，该索引是具有相似特征的文档的集合。您可以在Elasticsearch中定义任意多的指数。例如，用于存储客户信息的<em class="mi">客户</em>索引和用于存储客户人口统计信息的<em class="mi">人口统计数据</em>索引等。</p><h1 id="1423" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated"><strong class="ak">分片</strong></h1><p id="fc55" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">将索引拆分成多个部分的过程称为<code class="fe nl nm nn no b">sharding</code>。这些多个片段可以存储在集群中的同一节点或不同节点上。默认情况下，索引将有一个碎片。一旦创建了索引，我们就不能改变碎片数量的值。这是因为路由(下面讨论)使用许多碎片，所以如果我们要改变碎片的数量，将导致识别错误的碎片进行处理。此外，碎片的数量取决于需求或用例。</p><p id="ff88" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo je"> <em class="mi">我们为什么需要分片</em> </strong> <em class="mi"> —我们知道数据是存储在索引中的。由于可以存储在索引中的文档数量没有限制，因此索引的大小可能会超出服务器的处理能力。这是弹性搜索索引开始失败的主要原因。为了克服这一点，引入了分片。</em></p><blockquote class="nq nr ns"><p id="c460" class="lm ln mi lo b lp lq ke lr ls lt kh lu nt lw lx ly nu ma mb mc nv me mf mg mh in bi translated">非常大的碎片会对群集从故障中恢复的能力产生负面影响。尽管对碎片的大小没有限制，但建议使用50GB的碎片大小。</p></blockquote><h1 id="e367" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated"><strong class="ak">复制</strong></h1><p id="4af4" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated"><code class="fe nl nm nn no b">Replication</code>是创建碎片的多个副本的过程，这些副本被称为<code class="fe nl nm nn no b">replica shards</code>。被复制的碎片称为<code class="fe nl nm nn no b">primary shards. </code><code class="fe nl nm nn no b">primary shards</code>&amp;<code class="fe nl nm nn no b">replica shards</code>合起来称为<code class="fe nl nm nn no b">replication group</code>。为了确保高可用性，副本碎片不会存储在同一节点上。</p><p id="1910" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">碎片数量的默认值为1，但可以随时修改。我们需要确保不要使用太少或太多的碎片，因为这会影响性能和速度。</p><h1 id="1d77" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated"><strong class="ak">路由</strong></h1><p id="d2dc" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">所有数据都存储在主碎片中。您要查找的文档存储在任何一个主碎片中。<code class="fe nl nm nn no b">Routing</code>确定<em class="mi">该文档将驻留在哪个</em>碎片中的过程。默认的路由设置效果最好，可以确保文档均匀分布在碎片上。默认的路由方法使用文档的<code class="fe nl nm nn no b">_id</code>来查找碎片。这既适用于用户提供的<code class="fe nl nm nn no b">_ids</code>，也适用于Elasticsearch随机生成的<code class="fe nl nm nn no b">_ids</code>。</p><h2 id="61d7" class="nw mp iu bd mq nx ny dn mu nz oa dp my lv ob oc na lz od oe nc md of og ne ja bi translated">当我们需要自定义路由时</h2><p id="0833" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">Elasticsearch还提供了使用<code class="fe nl nm nn no b">custom routing</code>的选项。考虑一个有20-25个碎片的指数。当搜索请求到达查找文档的节点时，Elasticsearch不知道如何找到拥有所请求数据的节点。因此节点会将请求广播给索引中的所有碎片。现在，每个碎片将执行一个搜索查询，并将响应发送回节点。最后，来自所有碎片的响应在一个专用节点上合并、排序，然后发送给用户。这可能会导致性能问题。为了避免这个潜在的问题，Elasticsearch提供了使用自定义路由的选项。使用这个选项，您可以直接在一个特定的碎片中查找，而不是将搜索请求广播给所有的碎片。路由确保具有相同路由值的所有文档都将定位到同一个碎片，消除了广播搜索的需要。</p><h1 id="ccc5" class="mo mp iu bd mq mr ms mt mu mv mw mx my kj mz kk na km nb kn nc kp nd kq ne nf bi translated">结论</h1><p id="3f2f" class="pw-post-body-paragraph lm ln iu lo b lp ng ke lr ls nh kh lu lv ni lx ly lz nj mb mc md nk mf mg mh in bi translated">希望你已经理解了Elasticsearch中的关键概念。基于您从<a class="ae le" href="https://medium.com/towards-artificial-intelligence/the-beginners-guide-to-elasticsearch-part-1-2e50d3761e3c" rel="noopener"> <strong class="lo je">第1部分</strong> </a>和<strong class="lo je">第2部分</strong>(本文)中获得的知识，我将在<strong class="lo je"> </strong>即将发布的文章中解释<strong class="lo je">elastic search如何工作</strong> <em class="mi"> </em>。敬请期待！！</p><p id="9f65" class="pw-post-body-paragraph lm ln iu lo b lp lq ke lr ls lt kh lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><em class="mi">阅读更多关于Python和数据科学的此类有趣文章，</em> <a class="ae le" href="https://pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo je"> <em class="mi">订阅</em> </strong> </a> <em class="mi">到我的博客</em><a class="ae le" href="http://www.pythonsimplified.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lo je"><em class="mi">【www.pythonsimplified.com】</em></strong></a><strong class="lo je"><em class="mi">。</em> </strong>你也可以通过<a class="ae le" href="https://www.linkedin.com/in/chetanambi/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo je"> LinkedIn </strong> </a>联系我。</p></div><div class="ab cl lf lg hy lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="in io ip iq ir"><h1 id="67dc" class="mo mp iu bd mq mr oh mt mu mv oi mx my kj oj kk na km ok kn nc kp ol kq ne nf bi translated">参考</h1><div class="om on gq gs oo op"><a href="https://www.elastic.co/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd je gz z fq ou fs ft ov fv fx jd bi translated">开源搜索:Elasticsearch、ELK Stack &amp; Kibana | Elastic的创造者</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">我们是Elastic (ELK) Stack的创造者——Elastic search、Kibana、Beats和Logstash。安全可靠地…</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">www.elastic.co</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ky op"/></div></div></a></div></div></div>    
</body>
</html>