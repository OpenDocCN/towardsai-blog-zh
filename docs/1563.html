<html>
<head>
<title>Finding Time-shift Between Two Timeseries for Maximum Correlation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找两个时间序列之间的时移以获得最大相关性</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/finding-time-shift-between-two-timeseries-for-maximum-correlation-fc3010f1344e?source=collection_archive---------3-----------------------#2021-02-21">https://pub.towardsai.net/finding-time-shift-between-two-timeseries-for-maximum-correlation-fc3010f1344e?source=collection_archive---------3-----------------------#2021-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d189" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>、<a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a>、<a class="ae ep" href="https://towardsai.net/p/category/statistics" rel="noopener ugc nofollow" target="_blank">统计</a></h2><div class=""/><div class=""><h2 id="d82b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">只需几行代码就可以通过检索适当的时移找到两个时间序列之间的最大相关性</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/50bb860df8bf1ece223b7b6655b6e9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_yzgKU6lJzKA1acr2eAMw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由作者生成的图像</figcaption></figure><p id="4e71" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一些工程和科学应用程序处理时间序列数据。例如，在自动驾驶的情况下，几个增强的车载传感器收集关于速度、加速度、燃料使用等信息。以时间序列数据的形式。</p><p id="f8fa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通常，从涉及某种传感器融合的多个传感器收集同类信息，以围绕收集的数据集建立可信度。然而，由于这些传感器背后固有的物理特性，从各种传感器收集的数据总是存在某种滞后。</p><p id="8d3e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">统计科学为寻找两个时间序列之间的时移提供了丰富的工具。对于时间轴上均匀分布的时间序列数据，P <strong class="lj jd"> earson和Spearman相关性</strong>或<strong class="lj jd">互相关性</strong>函数提供了计算滞后并最终确定正确时移的方法。</p><p id="ce0e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，当两个时间序列不是等间距的，并且两个时间序列的采样时间不同时，事情就不那么简单了。例如，考虑我们正在使用两种传感器从一辆汽车测量领头车辆的速度:雷达和激光雷达。实际上，两个传感器将具有不同的采样时间，并且一个特定传感器本身的采样时间也不会相同。</p><p id="53f3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在寻找两个时间序列之间的正确时移方面，不一致的采样时间增加了额外的困难。</p><h1 id="7070" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">重采样和互相关</h1><p id="67b0" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">处理非均匀采样时间的一种方法是以相等的间隔对数据集进行重新采样。</p><p id="4675" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦我们对时间序列进行了统一采样，我们就可以使用互相关来找出一个时间序列中相对于另一个时间序列滞后的样本数量。滞后的样本数量可用于计算时移。</p><p id="a846" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数学上，</p><p id="42d5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">离散数据集<em class="na"> f </em>和<em class="na"> g </em>的互相关</strong>定义为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/77993b3596c9ee9e91c8e0b07ea9bfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*ajtFvwAUbFF1yqKxCf39sQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">互相关函数</figcaption></figure><p id="3bf0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中<em class="na"> n </em>为滞后。</p><p id="99fa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是寻找两个时间序列<code class="fe nc nd ne nf b">df1</code>和<code class="fe nc nd ne nf b">df2:</code>之间最大相关性的时移的函数</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="a799" class="nk me it nf b gy nl nm l nn no">def time_shift(df1, df2, time_col1 = 'Time', time_col2='Time', msg_col1 = 'Message', msg_col2= 'Message'):<br/>    """<br/>    Compute the time shift specified by `time_col2` of df2 with respect to <br/>    time of df1 specified by `time_col1`. Once we get time shift we will add it to <br/>    time axis of second dataframe<br/>       <br/>    <br/>    """<br/>    resample_time = np.max([np.median(np.diff(df1[time_col1])), np.median(np.diff(df2[time_col1]))])<br/>    <br/>    df1_re = strymread.resample(df1, rate = 1./resample_time, cont_method= 'nearest')<br/>    df2_re = strymread.resample(df2, rate = 1./resample_time, cont_method= 'nearest')<br/>    <br/>    initial_time_gap = df1_re[time_col1][0] - df2_re[time_col2][0]<br/>    <br/>    x = df1_re[msg_col1].values<br/>    y = df2_re[msg_col2].values</span><span id="b31f" class="nk me it nf b gy np nm l nn no">correlation = signal.correlate(x, y, mode="full")<br/>    lags = signal.correlation_lags(x.size, y.size, mode="full")<br/>    lag = lags[np.argmax(correlation)]<br/>    <br/>    lag_in_time_units = lag*resample_time<br/>    <br/>    total_time_shift = initial_time_gap + lag_in_time_units<br/>    return total_time_shift</span></pre><h1 id="738e" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated"><strong class="ak">例子</strong></h1><p id="2ad7" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">我已经将上述功能包含在一个python包<code class="fe nc nd ne nf b">strym</code>中，我正在积极开发这个包，用于分析车辆的传感器数据，以方便使用。</p><p id="4520" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果数据帧至少有两列，列名分别为<strong class="lj jd">时间</strong>和<strong class="lj jd">消息</strong>，Strym会将任何pandas数据帧识别为时间序列数据。</p><p id="492b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以使用pip安装<code class="fe nc nd ne nf b">strym</code></p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="9309" class="nk me it nf b gy nl nm l nn no">pip install strym</span></pre><p id="af09" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面，我将展示一个使用模拟数据集的示例，以展示timeshift的一个使用案例:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="7738" class="nk me it nf b gy nl nm l nn no">import strym<br/>from strym import strymread<br/>from scipy import signal</span><span id="beb1" class="nk me it nf b gy np nm l nn no">print(strym.__version__)<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span></pre><h2 id="87e4" class="nk me it bd mf nq nr dn mj ns nt dp mn lq nu nv mp lu nw nx mr ly ny nz mt iz bi translated">让我们为这个例子加载数据集</h2><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="8683" class="nk me it nf b gy nl nm l nn no">speed = pd.read_csv('../data/non_uniform_speed.csv')</span></pre><p id="503b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个例子的数据集可以从我的GitHub repo下载:<a class="ae oa" href="https://github.com/rahulbhadani/medium.com" rel="noopener ugc nofollow" target="_blank">https://github.com/rahulbhadani/medium.com</a></p><p id="691e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们可以生成两个时间序列，其中一个相对于另一个发生了偏移，但同时也向其中一个时间序列添加了一些噪声(本例中为伽马噪声)</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="cd80" class="nk me it nf b gy nl nm l nn no">df1 = speed.copy(deep=True)<br/>df2 = speed.copy(deep=True)<br/>df2['Time'] = df2['Time'] + 50.242212<br/>df1['Message'] = df1['Message'] +np.random.gamma(0.2, 2.94, len(df1['Message']))</span></pre><p id="7264" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们先将数据可视化:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="a976" class="nk me it nf b gy nl nm l nn no">fig, ax = strymread.create_fig(1)<br/>ax[0].scatter(x = df1['Time'], y = df1['Message'], s=4, label='df1', c= '#131342')<br/>ax[0].scatter(x = df2['Time'], y = df2['Message'],  s=1, label = 'df2', c= '#f34283')<br/>ax[0].legend()<br/>fig.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/30483b1a9e74c5841bd50c35cc5d8daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSoG0VPEOY7O23AIC_edBg.png"/></div></div></figure><p id="efb9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们可以使用<code class="fe nc nd ne nf b">strym</code>包中<code class="fe nc nd ne nf b">strymread</code>的<code class="fe nc nd ne nf b">time_shift</code>函数来找出最佳的时间偏移</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="ee6d" class="nk me it nf b gy nl nm l nn no">time_shift = strymread.time_shift(df1, df2)<br/>print(time_shift)</span></pre><p id="c186" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这给了</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="9a21" class="nk me it nf b gy nl nm l nn no"><em class="na">-50.24221205711365</em></span></pre><p id="0971" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们可以在时移后可视化数据:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="923c" class="nk me it nf b gy nl nm l nn no">fig, ax = strymread.create_fig(1)<br/>ax[0].scatter(x = df1['Time'], y = df1['Message'], s=4, label='Time Series 1', c= '#131342')<br/>ax[0].scatter(x = df2['Time']+time_shift, y = df2['Message'],  s=1, label = 'Time Series 2', c= '#f34283')<br/>ax[0].legend(loc='lower right')<br/>fig.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f16b031442289adad6b8507c0950e057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fzbXRdQSWQ-VprUsNvi-Q.png"/></div></div></figure><p id="7df0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如我们所见，<code class="fe nc nd ne nf b">time_shift</code>函数即使在有噪声的情况下也能确定正确的时移。</p><h2 id="ce2e" class="nk me it bd mf nq nr dn mj ns nt dp mn lq nu nv mp lu nw nx mr ly ny nz mt iz bi translated">警告</h2><p id="871a" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">但是，请注意，当两个时间序列之间的初始和最终数据点存在显著差异时，此方法可能不起作用。</p><p id="4720" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，当两个时间序列之间没有显著的结构相似性时，基于互相关的方法失败。我们真的不能比较苹果和橘子。然而，两个不同种类的苹果(来自两个不同传感器的相同数据)是可以比较的。</p><p id="938b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">参考</strong></p><p id="2c87" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae oa" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.correlate.html" rel="noopener ugc nofollow" target="_blank">https://docs . scipy . org/doc/scipy/reference/generated/scipy . signal . correlate . html</a></p><h2 id="8742" class="nk me it bd mf nq nr dn mj ns nt dp mn lq nu nv mp lu nw nx mr ly ny nz mt iz bi translated">承认</h2><p id="68c5" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">这篇文章是我在国家科学基金会和能源部资助下的研究的副产品。</p></div></div>    
</body>
</html>