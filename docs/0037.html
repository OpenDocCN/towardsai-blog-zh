<html>
<head>
<title>Bias-Variance Tradeoff Illustration Using Pylab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pylab的偏差-方差权衡图</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/bias-variance-tradeoff-illustration-using-pylab-202943bf4c78?source=collection_archive---------0-----------------------#2019-05-07">https://pub.towardsai.net/bias-variance-tradeoff-illustration-using-pylab-202943bf4c78?source=collection_archive---------0-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e4f1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">解决偏差-方差问题| <a class="ae ep" href="https://towardsai.net" rel="noopener ugc nofollow" target="_blank">走向人工智能</a></h2><div class=""/><p id="6bf8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在统计学和机器学习中，偏差-方差权衡是一组预测模型的属性，其中在参数估计中具有较低偏差的模型在样本间具有较高的参数估计方差，反之亦然。偏差-方差困境或问题是试图同时最小化这两个误差源的冲突，这两个误差源阻止监督学习算法推广到它们的训练集之外:</p><ul class=""><li id="b709" class="kx ky it kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><em class="lg">偏差</em>是学习算法中错误假设产生的误差。高偏差会导致算法错过特征和目标输出之间的相关关系(欠拟合)。</li><li id="ccf8" class="kx ky it kb b kc lh kg li kk lj ko lk ks ll kw lc ld le lf bi translated"><em class="lg">方差</em>是对训练集中的小波动的敏感性的误差。高方差会导致算法模拟训练数据中的随机噪声，而不是预期的输出(过拟合)。</li></ul><p id="4200" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本文中，我们使用<a class="ae lm" href="https://scipy.github.io/old-wiki/pages/PyLab" rel="noopener ugc nofollow" target="_blank"> PyLab </a>来说明偏差-方差问题。通过一个例子，我们讨论了欠拟合(偏差误差)和过拟合(方差误差)的概念。</p><h1 id="7f71" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">举例:向上抛向空中的物体的位置</strong></h1><p id="fbad" class="pw-post-body-paragraph jz ka it kb b kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw im bi translated">我们考虑一个实验，其中一个物体被抛向空中，其位置作为时间的函数被测量。从这个假设实验中获得的数据如下所示:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9467" class="mz lo it mv b gy na nb l nc nd"><strong class="mv jd">#import necessary libraries</strong><br/>import pylab<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="db7a" class="mz lo it mv b gy ne nb l nc nd"><strong class="mv jd">#create the dataset</strong><br/>t = np.linspace(0,1,11)<br/>h = np.array([1.67203, 1.79792, 2.37791,2.66408,2.11245, 2.43969,1.88843, 1.59447,1.79634,1.07810,0.21066])</span></pre><figure class="mq mr ms mt gt ng gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/adae1b800f5d50a676a8e44dde8234f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*DVYJXedq_GmtcuPdcIHo9Q.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated"><strong class="bd lp">在不同时间测量的颗粒高度。</strong></figcaption></figure><p id="b22f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">从我们对力学的研究中，我们知道高度应该随着时间的平方而变化，因此我们应该使用二次曲线来代替数据的线性拟合:</p><figure class="mq mr ms mt gt ng gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e815131e577d172f2e1d8ac09af5d255.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*YQOg345lDO5kYEmdd9vtVw.png"/></div></figure><p id="32cd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">为了说明偏差-方差问题，让我们回到位置数据，并对数据拟合一个线性、一个二次和一个10次多项式:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="eba8" class="mz lo it mv b gy na nb l nc nd">plt.figure(figsize=(15,5))</span><span id="71a9" class="mz lo it mv b gy ne nb l nc nd"># fig 1<br/>plt.subplot(131)<br/>#<strong class="mv jd">perform linear fit using pylab</strong><br/>degree = 1<br/>model=pylab.polyfit(t,h,degree)<br/>est_h=pylab.polyval(model,t)</span><span id="7c79" class="mz lo it mv b gy ne nb l nc nd">#calculating R-squared value<br/>R2 = 1 - ((h-est_h)**2).sum()/((h-h.mean())**2).sum()</span><span id="712e" class="mz lo it mv b gy ne nb l nc nd">#plot of observed and modeled data<br/>pylab.scatter(t,h, c='b', label='observed')<br/>pylab.plot(t,est_h, c='r', label='predicted:' + ' R2' '='+ ' ' + str(round(R2,4)))<br/>pylab.xlabel('t(s)')<br/>pylab.ylabel('h(m)')<br/>pylab.title('linear model is not good (underfit)')<br/>pylab.legend()</span><span id="241a" class="mz lo it mv b gy ne nb l nc nd"># fig 2<br/>plt.subplot(132)<br/>#<strong class="mv jd">perform quadratic fit using pylab</strong><br/>degree = 2<br/>model=pylab.polyfit(t,h,degree)<br/>est_h=pylab.polyval(model,t)</span><span id="d2c0" class="mz lo it mv b gy ne nb l nc nd">#calculating R-squared value<br/>R2 = 1 - ((h-est_h)**2).sum()/((h-h.mean())**2).sum()</span><span id="b65c" class="mz lo it mv b gy ne nb l nc nd">#plot of observed and modeled data<br/>pylab.scatter(t,h, c='b', label='observed')<br/>pylab.plot(t,est_h, c='r', label='predicted:' + ' R2' '='+ ' ' + str(round(R2,4)))<br/>pylab.xlabel('t(s)')<br/>pylab.ylabel('h(m)')<br/>pylab.title('quadratic model is what we need')<br/>pylab.legend()</span><span id="8992" class="mz lo it mv b gy ne nb l nc nd"># fig 3<br/>plt.subplot(133)<br/>#<strong class="mv jd">perform higher-degree fit using pylab</strong><br/>degree = 10<br/>model=pylab.polyfit(t,h,degree)<br/>est_h=pylab.polyval(model,t)</span><span id="8947" class="mz lo it mv b gy ne nb l nc nd">#calculating R-squared value<br/>R2 = 1 - ((h-est_h)**2).sum()/((h-h.mean())**2).sum()</span><span id="ff2a" class="mz lo it mv b gy ne nb l nc nd">#plot of observed and modeled data<br/>pylab.scatter(t,h, c='b', label='observed')<br/>pylab.plot(t,est_h, c='r', label='predicted:' + ' R2' '='+ ' ' + str(round(R2,4)))<br/>pylab.xlabel('t(s)')<br/>pylab.ylabel('h(m)')<br/>pylab.title('degree=10 captures random error (overfit)')<br/>pylab.legend()</span><span id="d686" class="mz lo it mv b gy ne nb l nc nd">pylab.show()</span></pre><figure class="mq mr ms mt gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/ef659795100751b99e7bc121c83222bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgSKQVuwiQe4Ba_WP47u4w.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated"><strong class="bd lp">偏差误差(欠拟合)和方差误差(过拟合)的图示。</strong></figcaption></figure><p id="7410" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">对于线性拟合，R2 (R平方)参数为0.3953，非常低。如果我们有一个很好的拟合，我们会期望R2值更接近1.0。对于二次拟合，R2值为0.8895。因此，二次拟合比线性拟合有了相当大的改进。使用次数= 10的多项式，我们发现R2值等于1.0。我们看到高次多项式捕捉到了真实的和随机的效果。在这个问题中，我们的力学知识表明，在二次模型之外进行高阶近似是没有好处的。</p><p id="4660" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">总之，我们用一个非常简单的例子讨论了偏差-方差问题。我们已经看到，决定一个好的拟合的主要因素是你要拟合的函数形式的有效性。当然，只要有可能，关于物理问题的理论或分析信息都应该整合到模型中。通常，与过于复杂的模型相比，模型参数较少的简单模型总是更容易解释。</p><h1 id="6941" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">参考</h1><ol class=""><li id="17dd" class="kx ky it kb b kc ml kg mm kk nt ko nu ks nv kw nw ld le lf bi translated">维基百科上的偏差-方差权衡。</li><li id="7ec2" class="kx ky it kb b kc lh kg li kk lj ko lk ks ll kw nw ld le lf bi translated">《计算物理学的第一课》,作者:Paul L. DeVries，John Wiley &amp; Sons，1994年。</li></ol></div></div>    
</body>
</html>