<html>
<head>
<title>A Short Journey To Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习的短暂旅程</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-short-journey-to-deep-learning-396ddf02f57f?source=collection_archive---------4-----------------------#2022-07-28">https://pub.towardsai.net/a-short-journey-to-deep-learning-396ddf02f57f?source=collection_archive---------4-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0d38" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Example…🫀理解人工神经网络</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ceafd4b550988d0ea55c7a86a620c93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGda5E8cT6V-eZNtJtJm9w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Mahdis Mousavi 在<a class="ae kv" href="https://unsplash.com/s/photos/deep-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4ac1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">文章概述</h1><p id="f066" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本文主要是关于人工神经网络及其工作流程的理解。当你听到这些话时，你可能会有很多疑问，比如:</p><blockquote class="mk ml mm"><p id="c8b9" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">什么是深度学习？</p><p id="8460" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">生物和人工神经元是如何工作的？</p><p id="fb2a" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">什么是感知器(ANN)？</p><p id="df2b" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">深度学习模型是如何得到训练的？</p></blockquote><p id="9b82" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">所有这些问题在这篇文章中都有所涉及。文章中包含了对该示例的详细解释，其步骤如下:</p><blockquote class="mk ml mm"><p id="df43" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">数据集的描述</p><p id="c1dc" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">导入包和数据集</p><p id="6774" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">探索性数据分析</p><p id="6350" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">数据预处理</p><p id="5180" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">创建、训练、预测和评估人工神经网络模型</p></blockquote><h1 id="c3b2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我们开始吧</h1><h1 id="6c5f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是深度学习？</h1><p id="d490" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">深度学习是机器学习的一部分，主要关注试图模仿大脑的人工神经网络。深度学习是在50年代初引入的，但近年来由于面向人工智能的应用程序和公司产生的数据的增加而变得流行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/bbca942482e4f9a11ebb6139fed3a86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjPczWGV1HJMfUSibFYczw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@agk42?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae kv" href="https://unsplash.com/s/photos/deep-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="2d87" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">在我看来，单独理解这些概念很容易，但是当你一起实现它们时，就很难理解模型内部发生了什么。这就是为什么深度学习模型通常被称为黑盒模型。然而，它会给我们的商业问题带来惊人的结果，而且它有很多应用。</p><h1 id="1faa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">生物和人工神经元是如何工作的？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/323121ffcaa83e5002bc47f5612a713a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*uZ8aajRO5PYfYPvU7kavCw.png"/></div></figure><p id="6978" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">让我来解释一个场景，当你用手触摸一个热的物体时，你会感到疼痛，并立即把手拿开。这个动作和反应在几分之一秒内完成。你有没有感觉到这是怎么发生的？</p><p id="d2de" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">当你触摸一个热的物体时，电脉冲会从你手中的神经元传递到你大脑中的神经元。然后做出决定，电脉冲立即传回到手边的神经元，指示移除它。</p><p id="d43f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">在神经元内部，<strong class="lq ir">树突</strong>除了充当<strong class="lq ir">输入层</strong>之外，什么都不充当神经受体。<strong class="lq ir">轴突</strong>除了<strong class="lq ir">输出层以外，什么都不充当神经递质。</strong>细胞核是动作电位与阈值比较的地方。如果动作电位<strong class="lq ir">比阈值</strong>大，电脉冲将<strong class="lq ir">传递</strong>到另一个神经元。如果动作电位<strong class="lq ir">比阈值</strong>小，电脉冲<strong class="lq ir">不会传递</strong>到另一个神经元。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/16ba8b0c3a239cc0e6ddb421fa3978d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFuu5DpIShUBp_CpYD5mMQ.jpeg"/></div></div></figure><p id="a79c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">类似地，人工神经元<strong class="lq ir">从<strong class="lq ir">输入层</strong>接收</strong>信息，并且<strong class="lq ir">通过<strong class="lq ir">输出层将</strong>信息传输给其他神经元。在这里，神经元是相互连接的，并且特定的权重被分配给那个特定的连接。这些<strong class="lq ir">权重</strong>代表连接的<strong class="lq ir">强度</strong>，它们在神经元的激活中起着重要作用。<strong class="lq ir">偏差</strong>类似于线性方程中的<strong class="lq ir">截距</strong>。</strong></p><p id="4f4f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">这里，输入(x1至xn)与相应的权重(w1至wn)相乘，然后与偏差相加。结果将被作为激活函数的输入，这是决策发生的地方，并且激活函数的输出被传送到其他神经元。存在不同类型的激活函数，一些是线性的、阶跃的、sigmoid的、RelU的等等。</p><h1 id="1304" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是感知器？</h1><p id="9a86" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">感知器是一种让神经元从给定信息中学习的算法。它有两种类型，<strong class="lq ir">单层感知器</strong>不含隐藏层<strong class="lq ir">。鉴于，<strong class="lq ir">多层感知器</strong>包含<strong class="lq ir">一个或多个隐藏层</strong>。<strong class="lq ir">单层感知器</strong>是<strong class="lq ir">人工神经网络</strong> ANN <strong class="lq ir">的<strong class="lq ir">最简单形式</strong>。</strong></strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/eb3b29f6fab9c4f2f4a8a81abebc7069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGUh-DUl9E6T8n_d_fRuQQ.jpeg"/></div></div></figure><h1 id="0eab" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">深度学习模型是如何得到训练的？</h1><p id="cbd4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在<strong class="lq ir">正向传播</strong>中，<strong class="lq ir">信息</strong>从<strong class="lq ir">输入</strong> <strong class="lq ir">层</strong>到<strong class="lq ir">输出</strong> <strong class="lq ir">层</strong>。这里，输入乘以相应的权重，然后与偏差相加，然后激活函数应用于该结果。这一过程一直持续到到达具有预测值(输出)的输出层。<strong class="lq ir">损失函数</strong>将找到<strong class="lq ir">预测</strong>和<strong class="lq ir">实际</strong>输出之间的<strong class="lq ir">误差</strong>。</p><p id="9adc" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">反向传播</strong>的整体思想是<strong class="lq ir">通过更新权重来减小误差</strong>。这可以在优化器的帮助下实现。这里，通过实现导数规则，权重从最后一层更新到第一层。所以，这两个步骤都要继续，直到你得到想要的精度。</p><h1 id="124a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">例子</h1><p id="be11" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">考虑一个例子，让我们在<strong class="lq ir">心力衰竭预测</strong>数据集上工作。这是一个分类问题，我们将预测患者是否患有心力衰竭。</p><h2 id="e528" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">关于数据集</h2><p id="f7e0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">该数据集包含2015年在费萨拉巴德心脏病研究所收集的299个条目。在数据集中，年龄范围在40到95岁之间的有105名女性和194名男性。它包含13个功能，分别是:</p><ul class=""><li id="adc5" class="nm nn iq lq b lr mo lu mp lx no mb np mf nq mj nr ns nt nu bi translated">年龄:患者的年龄</li><li id="474e" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">贫血:患者的血红蛋白是否低于正常范围</li><li id="03e4" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">肌酐_磷酸激酶:血液中肌酸磷酸激酶的水平(微克/升)</li><li id="4b26" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">糖尿病:患者是否患有糖尿病</li><li id="0790" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">射血分数:它是左心室在每次收缩中泵出的血液的量度。</li><li id="f394" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">高血压:患者是否患有高血压</li><li id="63e7" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">血小板:血液中血小板的数量(千血小板/毫升)</li><li id="e3e2" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">血清肌酸酐:血液中的血清肌酸酐水平(mg/dL)</li><li id="8a84" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">血清钠:血液中的血清钠水平(毫克当量/升)</li><li id="4e8e" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">性别:患者的性别</li><li id="efba" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">吸烟:患者是否吸烟</li><li id="4166" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">时间:患者对疾病的随访时间，以月为单位</li><li id="115c" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">死亡_事件:患者是否死于心力衰竭</li></ul><h2 id="0d2b" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">导入包</h2><p id="5959" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，导入浏览、可视化和预处理数据所需的包。这些可以在pandas、Scipy、NumPy、matplolib和seaborn库的帮助下完成。让我们也导入警告库来忽略代码生成的警告。</p><p id="0bf1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="3214" class="na kx iq ob b gy of og l oh oi">import pandas as pd<br/>import numpy as np<br/>import scipy<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>%matplotlib inline<br/>import warnings<br/>warnings.filterwarnings('ignore')</span></pre><h2 id="b320" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">导入数据集</h2><p id="9ca9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">借助pandas包中的read_csv方法导入数据集(<strong class="lq ir">heart _ failure _ clinical _ records _ dataset . CSV</strong>)。</p><p id="e889" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="98c6" class="na kx iq ob b gy of og l oh oi">df=pd.read_csv('heart_failure_clinical_records_dataset.csv')<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/486d73c98b3287c19fda649edd0250f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1QRglrY5IFlLefX8sWtAA.png"/></div></div></figure><h2 id="86f5" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">探索性数据分析</h2><p id="814a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">关于数据集，有很多东西需要探索。让我们借助describe和info方法，从数据集的描述和信息开始。</p><p id="79b0" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="ef7a" class="na kx iq ob b gy of og l oh oi">df.describe()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/d1eb8cd31b8ea45e14b73c54679903ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjEH_CQuwW9dSRUGH_gcZw.png"/></div></div></figure><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="2d70" class="na kx iq ob b gy of og l oh oi">df.info()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/1b6b513f412ed7f0009b2e82d9393152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9GAhfbRwlyt-No5-Z-CTQ.png"/></div></div></figure><h2 id="b16f" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated"><strong class="ak">检查空值</strong></h2><p id="fd4d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">检查数据集中是否有空值总是很重要的。如果存在，必须进行处理，因为它可能会影响模型的准确性，您可能会得到不希望的结果。</p><p id="706f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代号:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="823c" class="na kx iq ob b gy of og l oh oi">df.isnull().sum()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/4e4301022b187456953c378b6ea26250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWu_dyLTNMS7kfjg1g9AeQ.png"/></div></div></figure><p id="d683" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">幸运的是，数据集不包含任何缺失值。否则，需要借助插补、删除等技术进行处理。</p><h2 id="57ae" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated"><strong class="ak">数据可视化</strong></h2><p id="7e8f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它是一种通过以图形、图表、曲线图等形式可视化趋势和模式来分析数据的方法。它们是不同类型的可视化:</p><ul class=""><li id="49be" class="nm nn iq lq b lr mo lu mp lx no mb np mf nq mj nr ns nt nu bi translated">单变量分析:处理一个变量并找出变量中的模式</li><li id="50f0" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">双变量分析:处理两个变量，主要关注它们之间的关系。</li><li id="456b" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">多变量分析:处理两个以上的变量，同时检查变量的整体行为。</li></ul><p id="c3cf" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir"> 1。</strong>让我们从<strong class="lq ir"> target </strong>变量开始数据可视化，使用seaborn库的countplot方法检查康复和死亡的患者数量。</p><p id="dbc6" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="c3e9" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(3,3),dpi=150)<br/>sns.countplot(x="DEATH_EVENT", data=df,palette='rocket')<br/>plt.title('0 - Survived, 1 - Deceased')<br/>plt.ylabel("Count")<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/0e08906d76be508e9f1cbfaeaed6d59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRBFgoDdSc7aRKLNQukz_w.png"/></div></div></figure><p id="c558" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从图上看，治愈率几乎是病人死亡率的两倍。这里，数据有点不平衡。通常使用SMOTE技术来平衡数据。从现在开始，让我们保持这样。</p><p id="1f3a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir"> 2。</strong>检查<strong class="lq ir">分类变量</strong>，以及它们相对于目标变量的表现。</p><p id="4655" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="ceac" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(4,3),dpi=150)<br/>sns.countplot(x=”sex”,hue=’DEATH_EVENT’, data=df,palette=’viridis’)<br/>plt.ylabel(“Count”)<br/>plt.xlabel(“Gender”)<br/>plt.title(‘0 — Female, 1 — Male’)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/526b776769d3e8125992544ba42133d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5i2iQKCiIelo8oDcc8How.png"/></div></div></figure><p id="2780" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从剧情来看，男性患者的数量几乎是女性患者的两倍。我们可以得出结论，这两类死亡率几乎是存活率的一半。</p><p id="5099" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代号:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="783e" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(4,3),dpi=150)<br/>sns.countplot(x=”high_blood_pressure”,hue=’DEATH_EVENT’, data=df)<br/>plt.ylabel(“Count”)<br/>plt.xlabel(“Blood Pressure”)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/396e1337a52abc521fc2b3f4613e63b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0mSbyoocRQruOUm7NCM4g.png"/></div></div></figure><p id="6525" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从图上看，不患高血压的人数几乎是患高血压人数的两倍。我们可以得出结论，当一个人有高血压时，他更有可能心力衰竭。</p><p id="af13" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="0a6f" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(4,3),dpi=150)<br/>sns.countplot(x=”smoking”,hue=’DEATH_EVENT’, data=df,palette=’mako’)<br/>plt.ylabel(“Count”)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/5854c111206415d0ff2e061375d99c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4WL7yDeXSpAWRvvbvyuxw.png"/></div></div></figure><p id="311e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从剧情来看，不吸烟的患者几乎是吸烟患者的两倍。我们可以得出结论，这两类死亡率几乎是存活率的一半。</p><p id="34bc" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir"> 3。</strong>检查<strong class="lq ir">连续变量</strong>，以及它们的趋势和模式如何分布。</p><p id="d0d0" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="59ab" class="na kx iq ob b gy of og l oh oi">print(‘The mean value is’, df[‘age’].mean())<br/>print(‘The kurtosis value is’, df[‘age’].kurt())<br/>plt.figure(figsize=(4,3),dpi=150)<br/>sns.distplot(df[‘age’],color=’orange’)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/459221ae1e937ed9766dfc3858fe6536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3PV5qQD7m1oHKyQfPDT0Q.png"/></div></div></figure><p id="83c8" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从图表中，我们可以说患者年龄的平均值约为60岁，范围在40到95岁之间。偏度值为正，这意味着在图表的右侧有更多的观察值，并得出更多的人小于60岁的结论。</p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="8c6f" class="na kx iq ob b gy of og l oh oi">print('The mean value is', df['serum_sodium'].mean())<br/>print('The kurtosis value is', df['serum_sodium'].kurt())<br/>print('The skewness value is', df['serum_sodium'].skew())<br/>plt.figure(figsize=(4,3),dpi=150)<br/>sns.distplot(df['serum_sodium'],color='black')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/4bf2c8c76deebdee3315c4b50f053d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIAGTw8Z8RfcEMqnwsme1g.png"/></div></div></figure><p id="c75c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从上面的图中，我们可以说大多数患者的血清钠水平的平均值为136 (mEq/L ),并且大多数患者的值大于该值。</p><p id="3188" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="0f1d" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(4,3),dpi=150)<br/>sns.boxplot(data=df,x='DEATH_EVENT',y='platelets')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/e2874ea0baa741765d8fe5df6c4a8bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGl5v-5cN5Dij6DbUc2e4Q.png"/></div></div></figure><p id="0ce9" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从上图中，我们可以说存活患者的计数中存在更多的极值。两个类别的平均值几乎相同。看起来，这个特性中也存在一些异常值，这些需要处理。</p><p id="aa91" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir"> 4。</strong>让我们通过多变量分析来检查这些特征是如何相互展示趋势的。在<strong class="lq ir">热图</strong>和<strong class="lq ir"> pairplot </strong>方法的帮助下，这是可能的。热图法决定了变量之间的关联程度。而pairplot方法确定变量之间关系的形状。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/12bb4840a4d1faca95951c9e5e23d7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uA_qygnKxV2po4KkQaJLYg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/4d79ebaac1d79434e323941338a82913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZ-4aeFt3NjuruD-1XTpSA.png"/></div></div></figure><p id="ebfa" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从这些图中，我们可以说这些特征彼此之间没有很强的相关性。所以在这里，有需要担心的协方差问题，可以考虑所有的特征来预测输出。</p><p id="b316" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir"> 5。</strong>最后，在探索性数据分析中，有一个神奇而强大的包可以自动完成我们到目前为止已经完成的所有工作，这就是<strong class="lq ir"> pandas_profiling </strong>包。当你有较少的时间，并且想要集中更多的精力在模型上时，最好选择自动化EDA。我将附上由<strong class="lq ir"> ProfileReport </strong>方法生成的HTML模板的第一页，您可以稍后浏览。</p><p id="8efa" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="3513" class="na kx iq ob b gy of og l oh oi">from pandas_profiling import ProfileReport<br/>profile = ProfileReport(df)<br/>profile</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/79cb9d57b2ad56d5544bafdc69a990b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5czu_-EgVlfgjv6JRydtQ.png"/></div></div></figure><h2 id="01e8" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">数据预处理</h2><h2 id="b08b" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">离群点检测</h2><p id="b9bf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据集中的异常值会严重影响预期结果的模型输出。因此，最好借助任何技术，如<strong class="lq ir">四分位数间距</strong>方法、DBSCAN等，首先检测它们。<strong class="lq ir"> IQR </strong>方法将比<strong class="lq ir">下尾</strong>小<strong class="lq ir">的值和比<strong class="lq ir">上尾</strong>大<strong class="lq ir">的值视为<strong class="lq ir">异常值</strong>。</strong></strong></p><p id="9770" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="ea1d" class="na kx iq ob b gy of og l oh oi">def iqr_method(data_frame,column_name):<br/>    q1 = data_frame[column_name].quantile(0.25)<br/>    q3 = data_frame[column_name].quantile(0.75)<br/>    iqr = q3-q1<br/>    Lower_tail = q1 - 1.5 * iqr<br/>    Upper_tail = q3 + 1.5 * iqr<br/>    return(pd.concat([data_frame[data_frame[column_name]&lt;Lower_tail],data_frame[data_frame[column_name]&gt;Upper_tail]]))<br/>iqr_method(df[:],'serum_sodium')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/a2c326667ca3d49aebf8c93ebbc02c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nw7yROZE7YqTkG3SIGfL8g.png"/></div></div></figure><p id="bebe" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">以上是血清钠中存在的异常值。类似地，其他特性中也存在一些异常值。</p><h2 id="d4c0" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">异常值处理</h2><p id="c8ed" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所以，我们可以用<strong class="lq ir">来转换</strong>这个变量，这样<strong class="lq ir">就消除了</strong>中的异常值。因为<strong class="lq ir">最好不要删除</strong>条目，因为<strong class="lq ir">数据集的大小小于</strong>。在这里，我使用了<strong class="lq ir"> boxcox变换</strong>来处理离群值，并编写了一个代码用于自动处理离群值的<strong class="lq ir"/>。</p><p id="1b0b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="6304" class="na kx iq ob b gy of og l oh oi">def automated_handling_outliers(df1):<br/>    outlier_feature_names=[]<br/>    for i in df1.columns:<br/>        if len(iqr_method(df1[:],i))&gt;0:<br/>            print(i)<br/>            outlier_feature_names.append(i)<br/>    for i in outlier_feature_names:<br/>        df1[i],fitted_lambda= scipy.stats.boxcox(df1[i] ,lmbda=None)<br/>    return(df1)<br/>df=automated_handling_outliers(df[:])</span></pre><h2 id="8637" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">分割数据集</h2><p id="786c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">此步骤的目的是将数据集分为测试数据集和训练数据集，以便为模型训练和预测提供不同的数据。这可以通过使用train_test_split函数来完成。一般来说，<strong class="lq ir">(70–30)%</strong>或<strong class="lq ir">(60–40)%</strong>比率被认为是将数据集拆分为训练和测试数据。</p><p id="7a7b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代号:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="25d9" class="na kx iq ob b gy of og l oh oi">X = df.drop('DEATH_EVENT',axis=1)<br/>y = df['DEATH_EVENT']<br/>from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.35,random_state=101)</span></pre><h2 id="deae" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">缩放数据</h2><p id="b5c1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据缩放是数据预处理步骤中的一个重要步骤。如果数据具有不同的幅度范围，则人工神经网络模型很难设置权重并修改它们以获得最佳结果。这里，最小-最大缩放器用于将整个数据带入0到1之间的特定范围，同时保留数据的行为(趋势)。</p><p id="bfbd" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="55d2" class="na kx iq ob b gy of og l oh oi">from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler()<br/>X_train= scaler.fit_transform(X_train)<br/>X_test = scaler.transform(X_test)</span></pre><h2 id="c81a" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">创建人工神经网络模型</h2><p id="3d6a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了创建一个模型，我们有一些强大的库，如<strong class="lq ir"> Tensorflow </strong>和<strong class="lq ir"> Keras </strong>包，它们使这个过程在更短的时间内变得非常简单。Keras 包会让事情变得简单，因为它有所有你需要的功能，你只需要定义它们，并在任何你想要的地方使用它们。以前，这些包是独立的，但现在它们被集成到<strong class="lq ir"> TensorFlow </strong>包的<strong class="lq ir">最新</strong> <strong class="lq ir">版本</strong>中。让我们导入这些包来创建一个模型。</p><p id="8a62" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="03c3" class="na kx iq ob b gy of og l oh oi">from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Dense<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.callbacks import EarlyStopping</span></pre><p id="b737" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">导入包和功能后，使用这些功能创建一个模型。首先，我们必须创建一个可以连续工作的<strong class="lq ir">模型布局</strong>。</p><p id="dc66" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="9c23" class="na kx iq ob b gy of og l oh oi">model = Sequential()</span></pre><p id="cd61" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">现在，<strong class="lq ir">将</strong>的<strong class="lq ir">密集层</strong>添加到序列模型中。<strong class="lq ir">每个密集层</strong>都有<strong class="lq ir">个神经元</strong>和<strong class="lq ir">每个神经元</strong>都有一个对应的<strong class="lq ir">激活函数</strong>。总有一个<strong class="lq ir">输入层</strong>会先到达<strong class="lq ir"/>，其中<strong class="lq ir">神经元</strong> <strong class="lq ir">等于数据集中<strong class="lq ir">特征</strong>的数量。一般来说，大多数人认为<strong class="lq ir">整流线性单元(</strong> relu <strong class="lq ir"> ) </strong>为该层所有神经元的激活函数，除非是输出层。</strong></p><p id="4227" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">添加隐藏层，因为你的愿望，也将有一些规则。大多数人建议让神经元的数量为2的幂，比如(16，32，64，..)与单层中的<strong class="lq ir"> relu </strong>激活功能。对于输出层，我们可以有一个具有<strong class="lq ir"> sigmoid </strong>激活函数的神经元，因为这是<strong class="lq ir">二元分类</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/b65445fbd6862347a5cf2440183a42e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UIwc1e7oaK3KOFMAzoBdA.png"/></div></div></figure><p id="c945" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="5a8a" class="na kx iq ob b gy of og l oh oi">model = Sequential()<br/>model.add(Dense(12,activation='relu'))<br/>model.add(Dense(24,activation='relu'))<br/>model.add(Dense(24,activation='relu'))<br/>model.add(Dense(1,activation='sigmoid'))</span></pre><p id="7d32" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">然后，通过定义损失函数和优化器来编译模型。这里，<strong class="lq ir">损失函数</strong>被认为是<strong class="lq ir">二元交叉熵</strong>，因为这是一个<strong class="lq ir">二元分类</strong>问题，优化器被认为是<strong class="lq ir"> adam </strong>以获得模型的最佳性能。</p><p id="4f18" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="0124" class="na kx iq ob b gy of og l oh oi">model.compile(loss='binary_crossentropy', optimizer='adam')</span></pre><h2 id="895b" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">训练和评估模型</h2><p id="c609" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通过给定特征的<strong class="lq ir">训练数据集</strong>和<strong class="lq ir">目标</strong>变量，在<strong class="lq ir">拟合</strong>方法的帮助下训练模型。对于这种方法，我们可以将<strong class="lq ir">验证数据</strong>作为参数传递，然后在模型训练时<strong class="lq ir">确定</strong>验证损失<strong class="lq ir"/>。在这种情况下，测试数据可用于验证目的。</p><p id="828e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">还有一个更重要的参数<strong class="lq ir"> epoch。</strong>如果<strong class="lq ir">一个时期</strong>完成，则<strong class="lq ir"> </strong>表示<strong class="lq ir">模型经过</strong>一次<strong class="lq ir">的<strong class="lq ir">训练数据</strong></strong>。该值可以设置为一个较大的值，但不能太大。如果<strong class="lq ir">纪元</strong>参数设置为<strong class="lq ir">大</strong>值，则<strong class="lq ir">过拟合</strong>问题可能会发生。</p><p id="1f16" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="6992" class="na kx iq ob b gy of og l oh oi">model.fit(x=X_train,y=y_train.values,validation_data=(X_test,y_test.values),epochs=200)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/da059bf2be55e559aca6073f54951771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crTeL2xZR0m17IcEcUUrPw.png"/></div></div></figure><p id="ba25" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">一旦模型在训练数据集上得到训练，最好检查模型的历史，这意味着它在验证数据上的性能。</p><p id="671a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="cc0b" class="na kx iq ob b gy of og l oh oi">model_loss_1 = pd.DataFrame(model.history.history)<br/>plt.figure(figsize=(4,3),dpi=150)<br/>plt.plot(model_loss_1['loss'],color='r',data=model_loss_1,label='loss')<br/>plt.plot(model_loss_1['val_loss'],color='g',data=model_loss_1,label='val_loss')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/a1cabbdde18d7dbcfe5b64c68a48f5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7_nT-iAkj3ZisiwQ6jWUA.png"/></div></div></figure><p id="1e40" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从图中，我们可以说训练损失和验证损失都暂时减少了。经过阈值的历元后，<strong class="lq ir">验证损失</strong>开始<strong class="lq ir">增加</strong>，而<strong class="lq ir">训练损失</strong>保持<strong class="lq ir">减少</strong>。这个问题叫做<strong class="lq ir">过拟合</strong>。</p><p id="db43" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">为了克服上述问题，Keras库中有一个叫做<strong class="lq ir">提前停止回调</strong>的概念。这种提前停止技术<strong class="lq ir">停止<strong class="lq ir">模型</strong>基于给定参数进一步<strong class="lq ir">训练</strong>。让我们通过重新创建模型来实现这一点。通过将<strong class="lq ir">监视器</strong>参数设置为<strong class="lq ir">验证损失</strong>来定义提前停止方法。这里的<strong class="lq ir">耐心</strong>参数无非是<strong class="lq ir">即使在注意到监控参数的剧烈变化后，模型还要等待</strong>多久才能继续训练。</strong></p><p id="5a6d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="cc82" class="na kx iq ob b gy of og l oh oi">model = Sequential()<br/>model.add(Dense(units=12,activation='relu'))<br/>model.add(Dense(units=24,activation='relu'))<br/>model.add(Dense(units=24,activation='relu'))<br/>model.add(Dense(units=1,activation='sigmoid'))<br/>model.compile(loss='binary_crossentropy', optimizer='adam')<br/>early_stop = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=2)<br/>model.fit(x=X_train, y=y_train,epochs=600,validation_data=(X_test, y_test),verbose=1,callbacks=[early_stop])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/3a35720e54d04c693a477a242915eb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awaUh0JXy8axajM1CpGqBw.png"/></div></div></figure><p id="8000" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">当您将提前停止的功能添加到模型中时，它<strong class="lq ir">不</strong> <strong class="lq ir">依赖于历元</strong>的<strong class="lq ir">数，即使它是一个<strong class="lq ir">大数</strong>。现在，让我们通过绘制模型的训练损失和验证损失来检查模型的历史。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/df9ed226a395764e23ae027dd64e7bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8HOq9n5GDqnTK8MBi5c6g.png"/></div></div></figure><p id="fa40" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从图中，我们可以看出模型训练已经停止了大约100个时期。在模型训练期间没有发生过拟合。</p><h2 id="5b4a" class="na kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">预测数据</h2><p id="6906" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这一步可以在<strong class="lq ir">预测</strong>方法的帮助下完成，您可以将数据作为模型的参数进行测试。</p><p id="b484" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="e497" class="na kx iq ob b gy of og l oh oi">df_y=pd.DataFrame()<br/>df_y['y']=y_test<br/>df_y['y_hat']=model.predict(X_test)<br/>df_y['y_hat']=df_y['y_hat'].apply(lambda x: 1 if x&gt;0.5 else 0)</span></pre><p id="4ef2" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">让我们从sklearn包中导入决定模型的准确度、精确度和召回率的模块。</p><p id="0f40" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="ef63" class="na kx iq ob b gy of og l oh oi">print("Accuracy Score of the model:",accuracy_score(df_y['y'],df_y['y_hat']))<br/>print("Precision Score of the model:",precision_score(df_y['y'],df_y['y_hat']))<br/>print("Recall Score of the model:",recall_score(df_y['y'],df_y['y_hat']))<br/>print(classification_report(df_y['y'],df_y['y_hat']))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/7c1cb34322644a5df43de5e3ebf124d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvIBfVAWFs8uWA0ak0N-dg.png"/></div></div></figure><p id="74c0" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">嗯，我得到了82%的整体准确率，还不错。根据模型的数据预处理和调整，您可能会获得不同的精度。除此之外，您还可以尝试在模型之间集成dropout层，以减少模型过度拟合的机会。在结束之前，让我们通过绘制它的历史来比较提前停止和不提前停止的模型的性能。</p><p id="e83e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="c7e3" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(8,6),dpi=100)<br/>plt.plot(model_loss_1['loss'],data=model_loss_1,label='loss with out early stopping')<br/>plt.plot(model_loss_2['loss'],data=model_loss_2,label='loss with early stopping')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/6a2edf11b3db23581314f07fb48b69c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF_6pGhAn4s_fudOFlnaHA.png"/></div></div></figure><p id="601f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><strong class="lq ir">代码:</strong></p><pre class="kg kh ki kj gt oa ob oc od aw oe bi"><span id="3991" class="na kx iq ob b gy of og l oh oi">plt.figure(figsize=(8,6),dpi=100)<br/>plt.plot(model_loss_1['val_loss'],data=model_loss_1,label='val_loss with out early stopping')<br/>plt.plot(model_loss_2['val_loss'],data=model_loss_2,label='val_loss with early stopping')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/0c98169e7e9997c8e5499fcc9fbba619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDyzvbS6jJS7GrbNuAxJ8Q.png"/></div></div></figure><h1 id="eaa4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">源代码</h1><div class="pb pc gp gr pd pe"><a href="https://github.com/balupeddireddy08/Heart-Failure-Prediction-Using-ANN/blob/main/DL_medium.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">心力衰竭预测-使用-ANN/DL_medium.ipynb在主…</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">通过在GitHub上创建一个帐户，为balupeddireddy 08/Heart-Failure-Prediction-Using-ANN开发做出贡献。</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps kp pe"/></div></div></a></div><h1 id="2d18" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="35e0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">因此，我想说的是，有许多很酷的应用程序可供开发，你可以用ANN来实现它们。我本想在文章中加入一些更有趣的东西，但它已经很长了。我将在接下来的文章中尝试添加这些内容。</p><p id="ee96" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">我希望你有一个有趣的阅读，这篇文章对你有用…🤝</p><p id="8102" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">如果你有任何疑问，请告诉我，如果文章有任何错误，请纠正我。所有的建议都是accepted…✌</p><h1 id="0603" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">快乐学习😎</h1></div></div>    
</body>
</html>