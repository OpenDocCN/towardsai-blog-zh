<html>
<head>
<title>Object Tracking with Particle Filters In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中基于粒子滤波器的目标跟踪</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/object-tracking-with-particle-filters-in-python-77a61bb4fd91?source=collection_archive---------0-----------------------#2022-11-29">https://pub.towardsai.net/object-tracking-with-particle-filters-in-python-77a61bb4fd91?source=collection_archive---------0-----------------------#2022-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="349b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">得益于训练数据和算法的改进，以及廉价GPU和大量带标签训练数据集的可用性，计算机视觉在过去几年中取得了快速进展。计算机视觉的主要任务之一是目标跟踪。目标跟踪广泛应用于视频监控、汽车跟踪、人物检测和跟踪等领域。我们将使用粒子过滤器来跟踪一个移动的物体。粒子过滤器是解决机器人、人工智能甚至金融问题的强大而高效的解决方案。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/86422ae0c4a53fc97d393d2446ddfa19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QV0wBEVUua2p3f1qnnylNw.gif"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">Python中基于粒子滤波器的目标跟踪</figcaption></figure><h1 id="1c19" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">目录:</h1><ol class=""><li id="0e9a" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn mo mp mq mr bi translated"><strong class="js iu">粒子滤波简介</strong></li><li id="5e9e" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">使用OpenCV </strong>加载&amp;显示视频帧</li><li id="694f" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">初始化粒子滤波器</strong></li><li id="0243" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">根据速度状态移动粒子</strong></li><li id="e0bc" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">防止颗粒从边缘掉落</strong></li><li id="9160" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">测量每个粒子的质量</strong></li><li id="4a4d" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">给粒子分配权重</strong></li><li id="c7e0" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">根据权重对粒子进行重采样</strong></li><li id="d92a" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">使颗粒变模糊</strong></li><li id="7987" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><strong class="js iu">参考文献</strong></li></ol><div class="mx my gp gr mz na"><a href="https://github.com/youssefHosni/Practical-Computer-Vision-In-Python" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">GitHub-youssefHosni/Python中的实用计算机视觉</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">这将是一系列的计算机视觉项目，将涵盖大部分的计算机视觉任务和应用…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com\</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ld na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="51ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你想免费学习数据科学和机器学习，看看这些资源:</strong></p><ul class=""><li id="6d73" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">免费互动路线图，自学数据科学和机器学习。从这里开始:<a class="ae oa" href="https://aigents.co/learn/roadmaps/intro" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn/roadmaps/intro</a></li><li id="5ec4" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">数据科学学习资源搜索引擎(免费)。将你最喜欢的资源加入书签，将文章标记为完整，并添加学习笔记。<a class="ae oa" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></li><li id="d26e" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">想要在导师和学习社区的支持下从头开始学习数据科学吗？免费加入这个学习圈:<a class="ae oa" href="https://community.aigents.co/spaces/9010170/" rel="noopener ugc nofollow" target="_blank">https://community.aigents.co/spaces/9010170/</a></li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="c01f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想在数据科学&amp;人工智能领域开始职业生涯，但不知道如何开始。我提供数据科学指导课程和长期职业指导:</p><ul class=""><li id="922f" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">长期指导:<a class="ae oa" href="https://lnkd.in/dtdUYBrM" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dtdUYBrM</a></li><li id="c794" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">辅导课程:<a class="ae oa" href="https://lnkd.in/dXeg3KPW" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dXeg3KPW</a></li></ul><p id="d774" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ob">加入</em> </strong> <a class="ae oa" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="ob">中等会员</em> </strong> </a> <strong class="js iu"> <em class="ob">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em>T13】</strong></p><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="oc l nl nm nn nj no ld na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="8397" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">1.粒子滤波器简介</h1><p id="009b" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">粒子滤波器是一种用于函数优化的通用算法，其中使用粒子(采样)来搜索解搜索空间。那么这意味着什么呢？在我们的例子中，每个粒子都包含了关于物体在粒子所在位置的可能性的测试。在对粒子进行评估之后，根据粒子的好坏来分配权重。然后好的粒子倍增，坏的粒子通过重采样过程去除。</p><p id="080d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一代粒子会预测物体可能在哪里。然后对这一代进行评估，循环重复。</p><p id="11a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与卡尔曼滤波器相反，粒子滤波器可以模拟非线性物体运动，因为运动模型不应该像离散卡尔曼滤波器那样写成状态转移矩阵。<strong class="js iu">此外，粒子滤波器相当容易理解，但有一个负面的东西:滤波器的性能取决于粒子数，其中粒子数越高，估计越好，但成本也越高。</strong>然而，粒子滤波器主要用于通用函数优化，包括对象跟踪。下图显示了粒子滤波器的两个主要步骤:预测和校正。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ol"><img src="../Images/166a07dd2b4ecefef8b0a11052588e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNhxikwpmN1aMZOxFr7yUA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">粒子过滤器的循环/由<a class="ae oa" href="https://www.codeproject.com/script/Membership/View.aspx?mid=5380146" rel="noopener ugc nofollow" target="_blank"><strong class="bd ll">Darko juri ci</strong></a></figcaption></figure><p id="f96a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">粒子滤波器的循环从一般概率密度开始。首先，滤波器根据所提供的状态转换(例如，运动模型)预测下一个状态，然后，如果适用，将噪声测量信息并入校正阶段，并且在此之后重复该循环。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="0178" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">2.使用OpenCV加载和显示视频帧</h1><p id="5f7e" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">让我们首先导入NumPy数学库和OpenCV计算机视觉库，因为它们将在整个项目中广泛使用。然后我们设置随机种子，这样每次运行代码时，我们都会得到一致的结果。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="66e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以加载视频帧，并使用OpenCV显示它们，代码如下:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="78ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们首先从OpenCV调用一个名为<strong class="js iu"> VideoCapture，</strong>的函数，它将返回一个视频捕获对象。当视频打开时，我们想要读取帧。所以我们将调用这个视频对象的<strong class="js iu"> read </strong>方法，它将返回一个状态标志，然后是帧，它实际上是一个像素颜色值的数组。</p><p id="bf77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只要这个标志有效，我们就放弃这个框架。这就把这个函数变成了一个Python生成器，我们会反复调用它，它会不断循环并生成帧。如果状态不好，我们就跳出循环，释放资源，什么也不产生。然后，我们将连续显示每一帧30毫秒，如果该帧已经结束或如果您按下<strong class="js iu"> q </strong>键，循环将会中断。</p><p id="27e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是能够在这里显示的GIF格式的视频，但它最初是mp4格式的:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi os"><img src="../Images/7fa6e65bfa76241602cfb724736922dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2Nnv2dO0GpX8YG1Tsardjg.gif"/></div></div></figure><p id="b7ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们将在不同的函数中使用帧值，正如我们将很快看到的，所以最好创建一个函数来获取视频路径并返回每个帧的值:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5e62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们创建一个显示函数来显示粒子和被跟踪的粒子。所以我们要做的第一件事是检查是否有粒子要显示。如果是这样，我们将遍历它们，并将它们的值作为像素坐标。所以如果你想这么做，我们必须把它们转换成整型。接下来，我们将这些粒子绘制成视频帧顶部的一个小圆圈。我们可以使用OpenCV的<strong class="js iu">圆形函数</strong>，递给它视频帧，以及圆心和半径一，然后我们将设置颜色。</p><p id="6c58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次我们使用OpenCV时，颜色惯例是BGR而不是RGB。所以这次我们用绿色，设置一个很小的曲线，厚度为一个像素。这就解决了粒子问题。</p><p id="111a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，如果我们得到了粒子的位置，我们会尝试在整个视频中跟踪它。我们想在那里画一个漂亮的圆。所以这个位置实际上是一个(x，y)元组，所以我们可以直接使用它。我们将使用一个稍大的圆，15像素，这次使用红色，曲线厚度为5像素。接下来，我们要展示视频画面。OpenCV中有一个图像显示函数。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="471f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们想给自己一个暂停和停止视频播放的方法。所以，在显示完视频帧后，我们可以使用OpenCV的<strong class="js iu"> waitKey </strong>函数等待30毫秒，看看用户是否按了Escape键。如果有，我们可以就此打住。因此，如果我们用0调用waitKey，那么它将无限期地等待下一次按键。如果用户按了两次Escape键，那么我们返回True，让程序的其余部分知道回放应该停止。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="5e31" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated"><strong class="ak"> 3。初始化粒子过滤器</strong></h1><p id="a627" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">为了初始化我们将在视频顶部显示的粒子，我们需要估计目标的状态，即它在视频帧中的位置和速度。视频一开始，我们不知道那个状态。我们只知道位置应该在框架内的某个地方，速度可以是任何方向，但不能太快。</p><p id="1cb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将用一组粒子来表达我们对目标态的估计。每个粒子都有自己的位置和速度。由于我们还没有关于目标的信息，我们的粒子将均匀地分散在框架中，它们将具有随机的速度。</p><p id="8ce4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以从初始化粒子数为<strong class="js iu"> 5000粒子</strong>和初始速度范围为每帧一个像素开始。然后我们将创建粒子阵列。它将被随机数字填充，每个粒子有一行和四列。前两个是粒子的坐标，后两个是它们的速度。前两列的值介于零和框架的长度和高度之间。</p><p id="f7c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">速度将取初始值0.5，我们将把它居中到零，以便有可能向两个方向移动。我们要把速度范围减少一半。这将会使速度下降，所以一切都以零为中心。你会注意到粒子随机均匀分布。这里的每一行代表一个粒子，前两列是几百，这里是x和y位置，然后我们有速度分量，小于1。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="8952" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用下面的代码显示视频:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi os"><img src="../Images/86d85c14af28dbb8221a5d1d7855b4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Tops2Z-5sgRAE2C1G2xUCw.gif"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">带有初始化粒子的行走视频</figcaption></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="b51c" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">4.根据速度状态移动粒子</h1><p id="e429" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">你可能已经注意到，在视频播放过程中，粒子并没有移动，即使它们有速度。原因是我们没有根据速度更新它们的位置。</p><p id="d188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用下面的代码解决这个问题。我们将用第三列中的x方向速度分量来增加粒子的x坐标。我们对y轴也做了类似的事情。所以让我们运行代码，防止粒子从视频帧的边缘掉落，看看它是否有效。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d537" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你看到的是粒子按照它们的速度运动，使用下面的代码:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ot"><img src="../Images/48018b0d9532496ff5b6d56dba96180c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gK6iQ3aBeSm2rIdG0Be9RQ.gif"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">粒子按照它们的速度运动</figcaption></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="7413" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">5.防止颗粒从边缘掉落</h1><p id="27b9" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">接下来，我们将添加一些逻辑来防止它们从帧的边缘脱落，并决定哪些粒子比其他粒子更相关。我们将通过限制粒子的坐标(x，y)来做到这一点。为此，我们将循环遍历所有粒子，并在x和y坐标上添加上下边界。x坐标的新值将是<strong class="js iu">宽度-1</strong>和当前值的最小值。因为y坐标将是<strong class="js iu">高度-1</strong>和当前值的最小值。</p><p id="190d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这样做，我们将防止x值变得大于WIDTH-1，并且我们减去1，因为帧坐标是从零开始的。因此，如果你有一个100像素宽的帧，你会希望坐标从0到99。然后我们要给这个值设定一个下限。我们将取零的最大值和上限值。所以这会阻止x和y低于零。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="f618" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用下面的代码显示视频:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ot"><img src="../Images/96e1a3618177c0c194c6b6e748a735e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o-k2IsRblexXAy9Ci6HX9w.gif"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">防止颗粒从边缘掉落。</figcaption></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="4ff0" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">6.测量每个粒子的质量</h1><p id="de19" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">为了改进我们的状态估计，我们希望检查每个粒子下的像素的颜色，并将其与目标颜色进行比较。因此，现在，为了获得目标颜色的精确值，我们可以暂停视频，截图并在gimp或其他类似的软件中打开它，然后，使用吸管工具，我们可以找到一些像素的BGR值。</p><p id="5644" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们希望跟踪人的肘部。所以如果我们检查一下，你会发现它是105，63，66。你可以选择另一个像素来代表整个目标。不太亮，也不太暗。</p><p id="5352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将创建一个NumPy数组来存储这些颜色差异，并将其称为错误，我们将从零开始填充它。然后我们将遍历所有的粒子，我们想用它们的x和y位置作为像素坐标。因为我们需要它们是整数，所以我们要转换X和Y的位置。所以要取出那个位置的像素值，全靠NumPy索引。这里我们索引视频帧。所以帧是按行和列存储的。所以我们先用y，再用x，然后取出所有三个像素的值。<br/>最后，我们想要一个单一的值来表示该像素的色差。一种方法是取两种颜色之间的均方差。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="c7df" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">7.为粒子指定权重</h1><p id="a4e6" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">在本节中，我们将计算粒子权重并对粒子过滤器进行重新采样。我们将使用我们计算的误差来计算每个粒子的权重。当误差较低时，我们希望权重较高。这意味着粒子位于像素颜色与目标颜色非常匹配的位置。</p><p id="8bd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们能做的最简单的事情就是反转误差。从这个意义上说:如果我们找出最大的错误，然后减去errors数组，这将是按元素进行的，权重数组的元素数将与errors数组的一样多。接下来，我们要防止粒子沿着边缘堆积。所以我们想把边上粒子的权重设为零。</p><p id="3346" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以设定一个条件，x等于零。那是沿着框架的左手边。我们可以做一个逻辑OR，并设置条件，如果x粒子值等于宽度-1。这是框架的右边缘，我们对y做同样的事情，所以y在框架的上边缘为零，在下边缘，它等于高度-1。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="c6cd" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">8.根据粒子的权重对粒子进行重采样</h1><p id="af75" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">现在我们要用这些重物做一些很酷的事情。如果我们将它们归一化，使它们总和为1，我们就可以用它们作为粒子的概率分布。所以，换句话说，我们要通过从当前粒子中采样来构建一个新的粒子数组。权重高的会被多次选中，权重低的可能根本不会被选中。</p><p id="4f40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NumPy对于这种重采样有一个非常有用的函数。我们将调用<strong class="js iu">选择</strong>函数。</p><ul class=""><li id="31e0" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">这个函数的第一个参数是采样范围。所以如果我们只给它一个整数，它足够聪明地知道我们想要在从零到最大值的范围内重新采样。</li><li id="1cb7" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">我们需要传递给函数的第二个参数是取多少样本。因为我们要替换整个粒子阵列，所以我们需要和粒子一样多的样本。</li><li id="9a0a" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">最后，我们只告诉它概率分布。</li></ul><p id="4c3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以一旦我们完成了这个重采样，我们就有了新的指数，它指向我们采样的当前粒子。然后我们只是根据这些索引号重建一个粒子数组。最后，如果我们能得出一个单一的x，y位置，那就太好了，这是我们对目标粒子位置的最佳猜测。</p><p id="1ff2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经用所有粒子表达了我们的状态估计。但是我们希望有一个最佳的猜测。这很容易做到，只要取所有粒子的平均x和y位置。我们将返回粒子数组，并返回一个将x和y转换为整数的元组。所以这将允许我们使用这个元组直接以一个索引<br/>作为像素坐标。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="b6d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在下面代码生成的视频结尾所看到的，看起来粒子云塌陷到一个像素上并停止了移动。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ou"><img src="../Images/fee635ce97ce743b68d43e8c4e578526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oFYB3VNo66JRBfdf8nf57A.gif"/></div></div></figure><p id="cc86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码还给出以下错误:概率包含NaN，它代表非数字。所以基本上，程序崩溃了。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ov"><img src="../Images/b91041da2d63a4a1ea60df1e0b2ed41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dzx88CJN5obEAfv7L5JKLw.png"/></div></div></figure><p id="013b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以当所有的粒子都在同一个像素上时，它们都有相同的误差。因为我们计算重量的方式，重量都是零，然后我们把它们除以所有重量的总和。所以被零除不是一个好主意，我们应该修正它。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="c3c6" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">9.使颗粒变模糊</h1><p id="f5cb" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb oi kd ke kf oj kh ki kj ok kl km kn im bi translated">在之前的任务中，我们的粒子过滤器在一个像素上做得很好。但它不是目标上的一个像素。我们需要它来定位目标并保持跟踪目标，即使它在帧周围移动或光照条件发生变化。解决这个问题的方法就是添加噪声。在粒子滤波器中，我们可以使用噪声来表达我们对目标状态的不确定性。</p><p id="3a70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将生成一些高斯噪声，并添加到每个粒子。如果目标在下一帧发生变化，由于我们添加的噪声的变化，一些粒子会以同样的方式发生变化，所以它们会随着目标一起移动。没有随目标移动的其他粒子将有更多的颜色误差，并且不会被重新采样。下面是完成这项工作的代码:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="4473" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用高斯噪声，因此我们将指定位置的标准偏差。我们可以用一个像素的标准偏差，对于速度，可能是每帧半个像素。接下来，我们创建噪声:我们将一次创建一列，然后将所有列连接成一个数组。下面的代码生成的输出视频如下所示:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ou"><img src="../Images/aa301e2701e6f1c73c2ea21db6ac7ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tDcYWJLZWAIIffvkl0-IMg.gif"/></div></div></figure><p id="8779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来粒子云分布在不同的物体上，没有被吸引到目标上。事实证明，仅仅调整参数并没有真正改善粒子滤波器的行为，改变标准偏差或粒子数量。我们真正想做的是让权重对色差更敏感，这样只有目标上面的权重会被重新采样。一个可能的解决方案是平方权重，因为当我们平方大于1的数字时，最大的数字会比较小的数字增加更多。因此，较大的权重变得更大，这些粒子将被重新采样更多，所以这可能会使权重对颜色更敏感。让我们在平方权重后再次运行代码，并查看下面的输出:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ou"><img src="../Images/6b06c0890880d00ce394ac8fb53b9031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ra8HdbMS9mryV89VH5mUSg.gif"/></div></div></figure><p id="8e2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到，粒子更多地被吸引到t恤和砖块上，似乎它无法区分皮肤，所以我们可以将权重的幂增加到8。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ou"><img src="../Images/291c5862bca9db12190af3e7f8783a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2sxo4yILrkk1IVzeG2gK3w.gif"/></div></div></figure><p id="a6d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你从视频中看到的，现在好多了，但粒子云仍有一些扩散，它需要很长时间才能到达目标，但它已经锁定目标，并保持锁定。如果我们把权重提高到更高的幂，比如16，会怎么样？</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ot"><img src="../Images/83a21e23f2bd38c2d5d611c275ec1823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZV_fbui6iCrPnB0rrwYAdw.gif"/></div></div></figure><p id="818e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在它工作得更快更好了。所以我们不想再增加了。如果权重变得对颜色太敏感，那么如果照明条件改变一点，过滤器可能会有问题，并且它不再能找到与原始目标颜色非常接近的匹配。像现在这样已经很不错了。你也可以试着将权重增加到32，看看会发生什么。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="12c9" class="lj lk it bd ll lm od lo lp lq oe ls lt lu of lw lx ly og ma mb mc oh me mf mg bi translated">10.参考</h1><ol class=""><li id="28f4" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn mo mp mq mr bi translated"><a class="ae oa" href="https://www.codeproject.com/Articles/865934/Object-Tracking-Particle-Filter-with-Ease" rel="noopener ugc nofollow" target="_blank">物体跟踪:轻松粒子滤波</a></li></ol><p id="eeec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<a class="ae oa" href="https://github.com/youssefHosni/Practical-Computer-Vision-In-Python/tree/main/Tracking%20Objects%20in%20Video%20with%20Particle%20Filters" rel="noopener ugc nofollow" target="_blank">数据&amp;全文使用的代码</a></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="172d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ob">喜爱文章？成为</em> </strong> <a class="ae oa" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="ob">中等会员</em> </strong> </a> <strong class="js iu"> <em class="ob">继续无限制学习。如果你免费使用下面的链接，我会收到一小部分会员费。</em> </strong></p><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="oc l nl nm nn nj no ld na"/></div></div></a></div><p id="9937" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ob">感谢阅读！如果你喜欢这篇文章，一定要鼓掌(高达50！)并在</em></strong><a class="ae oa" href="https://www.linkedin.com/in/youssef-hosni-b2960b135/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="ob">LinkedIn</em></strong></a><strong class="js iu"><em class="ob">上与我联系，并在</em> </strong> <a class="ae oa" href="https://youssefraafat57.medium.com/" rel="noopener"> <strong class="js iu"> <em class="ob">上关注我，以便随时更新我的新文章。</em>T41】</strong></a></p></div></div>    
</body>
</html>