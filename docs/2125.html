<html>
<head>
<title>Python List Vs. Tuple: An In-Depth Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python列表与Tuple:一个深入的比较</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/python-list-vs-tuple-an-in-depth-comparison-42c59348d8a8?source=collection_archive---------0-----------------------#2021-08-26">https://pub.towardsai.net/python-list-vs-tuple-an-in-depth-comparison-42c59348d8a8?source=collection_archive---------0-----------------------#2021-08-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="39d1" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><figure class="gm go kb kc kd ke gi gj paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gi gj ka"><img src="../Images/6a446f4b0e28bdcebcfa16a9aa897fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avdaVImvPxN94lgcHyMjAQ.png"/></div></div><figcaption class="kl km gk gi gj kn ko bd b be z dk translated">作者图片</figcaption></figure></div><div class="ab cl kp kq hy kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="in io ip iq ir"><h1 id="64ff" class="kw kx iu bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h1><p id="cf35" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">即使对于初学者，列表和元组也不需要介绍。这两个是Python中常用的数据结构。但是两者的相同点和不同点是什么，你应该更喜欢哪一个，什么时候？这正是我们在这篇文章中要讨论的内容。让我们开始吧。</p><h1 id="bc7d" class="kw kx iu bd ky kz ms lb lc ld mt lf lg lh mu lj lk ll mv ln lo lp mw lr ls lt bi translated">类似</h1><h2 id="53ed" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated">序列类型</h2><p id="4c5a" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">列表和元组都是<strong class="lw je">序列数据类型</strong>，其中的元素以序列的形式存储。元素插入的顺序是保持的，这就是序列类型也被称为<strong class="lw je">有序</strong>集的原因。</p><p id="bd87" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">列表和元组都支持可变和不可变类型所共有的操作和函数。常见的操作有<strong class="lw je"> <em class="nn">串联、重复、索引、切片</em> </strong> <em class="nn">。</em>常用功能有<strong class="lw je"> <em class="nn">最小值、最大值、长度、计数、索引</em> </strong>。</p><p id="3324" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><em class="nn">你可能想看看我们以前的文章</em> <a class="ae no" href="https://pythonsimplified.com/python-sequence-types-an-introduction/" rel="noopener ugc nofollow" target="_blank"> <strong class="lw je"> <em class="nn">这里</em> </strong> <em class="nn"> </em> </a> <em class="nn">关于</em> <strong class="lw je"> <em class="nn">序列类型</em> </strong> <em class="nn">然后再继续深入。</em></p><h2 id="53c8" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated"><strong class="ak">同质/异质数据</strong></h2><p id="cb85" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">虽然列表和元组通常用于保存同类数据，但它们也可以包含异类数据，这意味着它们包含不同的数据类型作为元素。参考下面的例子，它显示了列表和元组可以包含同类和异类数据。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="57fc" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; mylist_1 = [10, 20, 30, 40, 50]<br/>&gt;&gt;&gt; mylist_2 = ["Python", "Simplified", ".com"]<br/>&gt;&gt;&gt; mylist_3 = ["Python", "Simplified", [1,2], (3,4)]</span><span id="902a" class="mx kx iu nu b gz oc nz l oa ob">&gt;&gt;&gt; mytuple_1 = (10, 20, 30, 40, 50)<br/>&gt;&gt;&gt; mytuple_2 = ("Python", "Simplified", ".com")<br/>&gt;&gt;&gt; mytuple_3 = ("Python", "Simplified", (1,2), [3,4])</span></pre><h1 id="2bf1" class="kw kx iu bd ky kz ms lb lc ld mt lf lg lh mu lj lk ll mv ln lo lp mw lr ls lt bi translated">差异</h1><h2 id="b4d4" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated">句法</h2><p id="05a2" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">列表是包含在方括号<strong class="lw je"> [ ] </strong>中的元素集合，而元组包含在圆括号<strong class="lw je"> ( ) </strong>中。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="c50b" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; mylist = [10, 20, 30, 40, 50]<br/>&gt;&gt;&gt; mytuple = (10, 20, 30, 40, 50)</span></pre><h2 id="f295" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated">可变与不可变</h2><p id="e17b" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">这是列表和元组的主要区别之一。列表是可变对象，而元组是不可变对象。可变意味着一旦对象被创建，其内容可以被改变(插入、修改或删除)。在不可变对象的情况下，它们的内容一旦被创建就不能被修改。</p><p id="131b" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">请参考下面的列表示例，其中列表的内容发生了变化。由于列表是可变对象，我们可以修改它们的内容。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="de49" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; mylist_1 = [10, 20, 30, 40, 50]<br/>&gt;&gt;&gt; mylist_1.append(60)<br/>&gt;&gt;&gt; mylist_1[0] = 100<br/>&gt;&gt;&gt; del mylist_1[-1]<br/>&gt;&gt;&gt; mylist_1<br/>[100, 20, 30, 40, 50]</span></pre><p id="3b55" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">另一方面，由于元组是不可变的对象，所以不允许改变它们的内容。否则，您将遇到如下所示的TypeError。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="3d89" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; mytuple_1 = (10, 20, 30, 40, 50)<br/>&gt;&gt;&gt; mytuple_1[0] = 100<br/>Traceback (most recent call last):<br/> File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object does not support item assignment</span></pre><p id="94d1" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><em class="nn">如果需要刷新Python中的可变性和不变性知识，可以通过</em> <a class="ae no" href="https://pythonsimplified.com/mutability-immutability-in-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="lw je"> <em class="nn">这篇</em> </strong> <em class="nn"> </em> </a> <em class="nn">文章。</em></p><h2 id="3533" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated">内置方法</h2><p id="6611" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">由于列表是一个可变对象，我们可以插入、删除或修改它的内容。因此list有很多内置的方法，比如——insert等。</p><p id="a1b9" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">另一方面，元组只支持几个内置方法，因为元组是不可变的。因为不允许修改不可变对象，所以元组没有很多内置函数是有意义的。</p><p id="30e4" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">您可以运行<strong class="lw je"> dir(list) </strong>和<strong class="lw je"> dir(tuple) </strong>来查看list和tuple支持的内置函数。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="7fe3" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; dir(list)<br/>&gt;&gt;&gt; dir(tuple)</span></pre><h2 id="5233" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated">存储效率</h2><p id="a1b3" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">元组比列表的存储效率更高。这在行动中更好理解。</p><p id="de54" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><strong class="lw je"> List: </strong>你已经知道List是一个可变对象。当向列表追加元素时，Python以特定的间隔<em class="nn">过度分配内存(这个间隔是由一个你不用担心的算法决定的)</em>。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="475f" class="mx kx iu nu b gz ny nz l oa ob">prev = 56<br/>mylist_1 = []<br/>print(f”No. of elements: {0}, size: {sys.getsizeof(mylist_1)}, Diff: {0}”)</span><span id="7f93" class="mx kx iu nu b gz oc nz l oa ob">for num in range(1, 20):<br/> mylist_1.append(num)<br/> temp_size = sys.getsizeof(mylist_1)<br/> diff, prev = temp_size — prev, temp_size<br/> print(f”No. of elements: {num}, size: {temp_size}, Diff: {diff}”)</span></pre><p id="761a" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">该代码输出以下详细信息。正如你所看到的，一个空列表需要56个字节。但是当你把一个元素追加到一个空列表中时，Python会分配32个字节。但是正如您所看到的，Python额外分配了24个字节(超额分配)，而不是一个元素所需的8个字节。将第5、第9和第17个元素追加到列表中时，也会发生同样的过度分配，依此类推。这个间隔由算法决定。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="3ef2" class="mx kx iu nu b gz ny nz l oa ob">No. of elements: 0, size: 56, Diff: 0<br/>No. of elements: 1, size: 88, Diff: 32<br/>No. of elements: 2, size: 88, Diff: 0<br/>No. of elements: 3, size: 88, Diff: 0<br/>No. of elements: 4, size: 88, Diff: 0<br/>No. of elements: 5, size: 120, Diff: 32<br/>No. of elements: 6, size: 120, Diff: 0<br/>No. of elements: 7, size: 120, Diff: 0<br/>No. of elements: 8, size: 120, Diff: 0<br/>No. of elements: 9, size: 184, Diff: 64<br/>No. of elements: 10, size: 184, Diff: 0<br/>No. of elements: 11, size: 184, Diff: 0<br/>No. of elements: 12, size: 184, Diff: 0<br/>No. of elements: 13, size: 184, Diff: 0<br/>No. of elements: 14, size: 184, Diff: 0<br/>No. of elements: 15, size: 184, Diff: 0<br/>No. of elements: 16, size: 184, Diff: 0<br/>No. of elements: 17, size: 256, Diff: 72<br/>No. of elements: 18, size: 256, Diff: 0<br/>No. of elements: 19, size: 256, Diff: 0<br/>No. of elements: 20, size: 256, Diff: 0</span></pre><p id="2fcf" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">另外，请注意，<em class="nn">一次创建一个包含20个元素</em>的列表和<em class="nn">一个接一个追加20个元素</em>是有区别的。有关内存分配的差异，请参考以下代码:</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="972a" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; sys.getsizeof(mylist_1)<br/>256</span><span id="61ff" class="mx kx iu nu b gz oc nz l oa ob">&gt;&gt;&gt; mylist_2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]<br/>&gt;&gt;&gt; sys.getsizeof(mylist_2)<br/>216</span></pre><p id="5216" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><strong class="lw je">元组:</strong>因为元组是不可变的，所以你不能改变它们的内容。但是，如果您通过一次增加一个元素来创建一个元组，并检查元组大小，您会注意到总有8个字节的差异。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="e3cb" class="mx kx iu nu b gz ny nz l oa ob">prev = 0<br/>mytuple = ()<br/>print(f”No. of elements: {0}, size: {sys.getsizeof(my_tuple)}, Diff: {0}”)</span><span id="121c" class="mx kx iu nu b gz oc nz l oa ob">for i in range(1, 11):<br/>    my_tuple = tuple(range(1, i+1))<br/>    tuple_size = sys.getsizeof(my_tuple)<br/>    diff, prev = tuple_size — prev, tuple_size<br/>    print(f”No. of elements: {i}, size: {tuple_size}, Diff: {diff}”)</span></pre><p id="8934" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">输出:</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="0884" class="mx kx iu nu b gz ny nz l oa ob">No. of elements: 0, size: 40, Diff: 0<br/>No. of elements: 1, size: 48, Diff: 48<br/>No. of elements: 2, size: 56, Diff: 8<br/>No. of elements: 3, size: 64, Diff: 8<br/>No. of elements: 4, size: 72, Diff: 8<br/>No. of elements: 5, size: 80, Diff: 8<br/>No. of elements: 6, size: 88, Diff: 8<br/>No. of elements: 7, size: 96, Diff: 8<br/>No. of elements: 8, size: 104, Diff: 8<br/>No. of elements: 9, size: 112, Diff: 8<br/>No. of elements: 10, size: 120, Diff: 8</span></pre><p id="a7d8" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">如果您要将上面的<strong class="lw je"> mylist_1 </strong>转换为<strong class="lw je"> tuple </strong>，大小将从<strong class="lw je"> 256字节</strong>减少到<strong class="lw je"> 200字节</strong>，如下图所示。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="f727" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; mytuple_1 = tuple(mylist_1)<br/>&gt;&gt;&gt; sys.getsizeof(mytuple_1)<br/>200</span></pre><h2 id="7fff" class="mx kx iu bd ky my mz dn lc na nb dp lg mf nc nd lk mj ne nf lo mn ng nh ls ja bi translated">时间效率</h2><p id="749a" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated"><strong class="lw je">创建列表&amp;元组:</strong>创建元组比创建列表快。在下面的例子中，我们使用了<strong class="lw je"> timeit </strong>模块来查看创建一个列表和一个元组1000万次需要多少时间。结果清楚地表明，元组是赢家。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="6668" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; timeit("(1,2,3,4,5,6,7,8,9,10)", number=10_000_000)<br/>0.20845220000046538</span><span id="bc10" class="mx kx iu nu b gz oc nz l oa ob">&gt;&gt;&gt; timeit("[1,2,3,4,5,6,7,8,9,10]", number=10_000_000)<br/>1.319473100000323</span></pre><p id="38e9" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><strong class="lw je">访问元素:</strong>甚至从元组中访问元素都比访问列表快。虽然不会有太大的差别，但元组仍然是赢家。这是因为元组有指向其元素的直接指针，而列表使用另一个包含指向列表元素的指针的中间数组。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="36ac" class="mx kx iu nu b gz ny nz l oa ob">&gt;&gt;&gt; my_tuple = tuple(range(100_000))<br/>&gt;&gt;&gt; my_list = list(my_tuple)</span><span id="9a31" class="mx kx iu nu b gz oc nz l oa ob">&gt;&gt;&gt; timeit("my_tuple[99_999]", globals=globals(), number=10_000_000)<br/>0.7667628999988665</span><span id="f605" class="mx kx iu nu b gz oc nz l oa ob">&gt;&gt;&gt; timeit("my_list[99_999]", globals=globals(), number=10_000_000)<br/>0.7837690000014845</span></pre><p id="f5cf" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><strong class="lw je">想知道为什么元组创建和访问元组元素比列表快吗？</strong>为了证明这一点，我们将使用<strong class="lw je"> dis </strong>模块。<strong class="lw je"> dis </strong>模块反汇编类、方法、函数和其他编译后的对象，并输出Python编译器使用的字节码。</p><p id="2331" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">在下面的例子中，我们将使用两个函数<strong class="lw je"> <em class="nn"> my_list </em> </strong>和<strong class="lw je"> <em class="nn"> my_tuple </em> </strong>。这两个函数都创建一个列表或元组，并访问一个元素。接下来，我们在两个函数上使用<strong class="lw je"> dis </strong>模块，看看需要多少字节码指令。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="c88f" class="mx kx iu nu b gz ny nz l oa ob">from dis import dis</span><span id="d908" class="mx kx iu nu b gz oc nz l oa ob">def my_list():<br/>    x = [10, 20, 30, 'abc']<br/>    y = x[0]</span><span id="78fd" class="mx kx iu nu b gz oc nz l oa ob">def my_tuple():<br/>    x = (10, 20, 30, 'abc')<br/>    y = x[0]</span><span id="3f02" class="mx kx iu nu b gz oc nz l oa ob">dis(my_list)<br/>dis(my_tuple)</span></pre><p id="e54e" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><strong class="lw je"> dis(my_list) </strong>的输出:列表创建和访问列表元素各生成6个字节码左右的指令。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="14c5" class="mx kx iu nu b gz ny nz l oa ob">2            0 LOAD_CONST              1 (10)<br/>             2 LOAD_CONST              2 (20)<br/>             4 LOAD_CONST              3 (30)<br/>             6 LOAD_CONST              4 ('abc')<br/>             8 BUILD_LIST              4<br/>            10 STORE_FAST              0 (x)<br/><br/>3           12 LOAD_FAST               0 (x)<br/>            14 LOAD_CONST              5 (0)<br/>            16 BINARY_SUBSCR<br/>            18 STORE_FAST              1 (y)<br/>            20 LOAD_CONST              0 (None)<br/>            22 RETURN_VALUE</span></pre><p id="9b68" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">dis(my_tuple) 的输出:创建元组只需要2条指令。这是因为Python的<a class="ae no" href="https://pythonsimplified.com/optimization-in-python-peephole/" rel="noopener ugc nofollow" target="_blank"> <strong class="lw je">窥视孔优化</strong> </a>。由于字节码指令的数量较少，显然元组创建比列表更快。但是访问元组元素会创建类似的指令。因此，基于其他因素，我们可以看到，访问元组元素可能比访问列表更快，正如我们在前面的示例中使用<strong class="lw je"> timeit </strong>函数所看到的那样。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="7128" class="mx kx iu nu b gz ny nz l oa ob">6            0 LOAD_CONST               1 ((10, 20, 30, 'abc'))<br/>             2 STORE_FAST               0 (x)<br/><br/>7            4 LOAD_FAST                0 (x)<br/>             6 LOAD_CONST               2 (0)<br/>             8 BINARY_SUBSCR<br/>            10 STORE_FAST               1 (y)<br/>            12 LOAD_CONST               0 (None)<br/>            14 RETURN_VALUE</span></pre><figure class="np nq nr ns gu ke gi gj paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="gi gj od"><img src="../Images/056aa8b3a2d679188b3c888a348618c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9w4mLAhD-76dizgNDOxKvQ.png"/></div></div><figcaption class="kl km gk gi gj kn ko bd b be z dk translated">列表与元组的差异</figcaption></figure><h1 id="f19b" class="kw kx iu bd ky kz ms lb lc ld mt lf lg lh mu lj lk ll mv ln lo lp mw lr ls lt bi translated">那么，谁是赢家？</h1><p id="01ea" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">基于你目前为止对list vs. tuple的理解，你怎么看？嗯，<strong class="lw je">看情况</strong>。</p><p id="0ca7" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">如果序列的内容(列表或元组)在程序的生命周期中没有改变，那么应该考虑使用元组，否则就考虑列表。另一种说法是，如果只是对序列进行迭代，应该使用元组。这提供了写保护<strong class="lw je">。</strong></p><h1 id="3966" class="kw kx iu bd ky kz ms lb lc ld mt lf lg lh mu lj lk ll mv ln lo lp mw lr ls lt bi translated">结论</h1><p id="ed24" class="pw-post-body-paragraph lu lv iu lw b lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr in bi translated">在本文中，我们讨论了Python开发人员的一个常见问题，即列表与元组。我们首先讨论了列表和元组之间的相似性，然后详细讨论了列表和元组之间的差异。最后我们得出结论，tuple在所有字体(速度、存储等方面都是赢家。).然而，列表和元组之间的选择取决于用例。</p><p id="52b1" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">希望你对这篇文章感兴趣，并从中有所收获。如果你有任何问题，请在下面的评论中告诉我们。</p><p id="5c5f" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated"><em class="nn">原载于2021年5月20日</em><a class="ae no" href="https://pythonsimplified.com/python-list-vs-tuple/" rel="noopener ugc nofollow" target="_blank"><strong class="lw je"><em class="nn"/></strong></a><em class="nn">。</em></p><h1 id="c88d" class="kw kx iu bd ky kz ms lb lc ld mt lf lg lh mu lj lk ll mv ln lo lp mw lr ls lt bi translated">进一步阅读</h1><ul class=""><li id="bdb6" class="oe of iu lw b lx ly mb mc mf og mj oh mn oi mr oj ok ol om bi translated"><a class="ae no" rel="noopener ugc nofollow" target="_blank" href="/the-difference-between-a-a-b-and-a-b-in-python-a7338d96e408">Python中a=a+b和a+=b的区别</a></li><li id="ebdb" class="oe of iu lw b lx on mb oo mf op mj oq mn or mr oj ok ol om bi translated"><a class="ae no" href="https://pythonsimplified.com/difference-between-sort-and-sorted-in-python/" rel="noopener ugc nofollow" target="_blank">Python中sort()和sorted()的区别</a></li><li id="6b1e" class="oe of iu lw b lx on mb oo mf op mj oq mn or mr oj ok ol om bi translated"><a class="ae no" href="https://pythonsimplified.com/the-most-controversial-python-walrus-operator/" rel="noopener ugc nofollow" target="_blank">最有争议的Python的海象算子</a></li><li id="c9dd" class="oe of iu lw b lx on mb oo mf op mj oq mn or mr oj ok ol om bi translated"><a class="ae no" href="https://pythonsimplified.com/understanding-indexing-and-slicing-in-python/" rel="noopener ugc nofollow" target="_blank">了解Python中的索引和切片</a></li><li id="3358" class="oe of iu lw b lx on mb oo mf op mj oq mn or mr oj ok ol om bi translated"><a class="ae no" href="https://pythonsimplified.com/making-sense-of-python-iterables-and-iterators/" rel="noopener ugc nofollow" target="_blank">理解Python中的可迭代项和迭代器</a></li></ul><p id="f1fc" class="pw-post-body-paragraph lu lv iu lw b lx ni lz ma mb nj md me mf nk mh mi mj nl ml mm mn nm mp mq mr in bi translated">我希望你喜欢阅读这篇文章。如果你喜欢我的文章并想订阅Medium，你可以在这里订阅:</p><div class="os ot gq gs ou ov"><a href="https://chetanambi.medium.com/membership" rel="noopener follow" target="_blank"><div class="ow ab fp"><div class="ox ab oy cl cj oz"><h2 class="bd je gz z fq pa fs ft pb fv fx jd bi translated">通过我的推荐链接加入媒体- Chetan Ambi</h2><div class="pc l"><h3 class="bd b gz z fq pa fs ft pb fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pd l"><p class="bd b dl z fq pa fs ft pb fv fx dk translated">chetanambi.medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kj ov"/></div></div></a></div></div></div>    
</body>
</html>