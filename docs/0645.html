<html>
<head>
<title>Malaria Detection using Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习的疟疾检测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/malaria-detection-using-deep-learning-8fa52839e801?source=collection_archive---------1-----------------------#2020-07-03">https://pub.towardsai.net/malaria-detection-using-deep-learning-8fa52839e801?source=collection_archive---------1-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="8717" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/4551944af14fd103eb1d9d0c535ca32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-hhfLFcKQPtOf8Co.jpeg"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">图片来源:<a class="ae kl" href="https://www.research.bayer.com/en/mosquitoes-zika-malaria-dengue.aspx" rel="noopener ugc nofollow" target="_blank">拜耳科学杂志</a></figcaption></figure><p id="8cd3" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">它们可能看起来又小又脆弱，但蚊子可能极其危险。众所周知，疟疾是一种由蚊子传播的疾病，威胁着所有年龄段的人的生命。更重要的是，在最初阶段，这些症状很容易被误认为是<em class="lk">热</em>、<em class="lk">流感、</em>或<em class="lk">普通感冒</em>。但是，在晚期阶段，它可能会通过感染和破坏细胞结构造成严重破坏，这可能会威胁到生命。如果不及时治疗，甚至会导致死亡。</p><p id="44d8" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">虽然大多数研究人员认为这种疾病起源于非洲大陆，但这种疾病的起源是有争议的。南美洲国家、非洲国家和印度次大陆因<em class="lk">疟疾</em>而处于高感染风险中，主要是因为它们的热带气候充当了受感染雌蚊的催化剂和繁殖地，这种受感染雌蚊携带<em class="lk">疟原虫</em>寄生虫，从而导致这种疾病。</p><p id="0ad0" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们这个项目的目标是开发一个可以检测这种致命疾病的系统，而不必完全依赖医学测试。</p><p id="084d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">本文是由<a class="ae kl" href="https://jovian.ml/" rel="noopener ugc nofollow" target="_blank"> Jovian.ml </a>和<a class="ae kl" href="https://www.freecodecamp.org/" rel="noopener ugc nofollow" target="_blank"> FreeCodeCamp </a>撰写的<a class="ae kl" href="http://zerotogans.com/" rel="noopener ugc nofollow" target="_blank">py torch Zero to GAN</a>认证项目最终项目工作的一部分。</p><p id="9286" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">所以，在进入主要部分之前，让我们先完成后勤工作。</p><p id="2c15" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">数据集最初取自美国国家卫生研究院网站，并上传至Kaggle。数据集包含<strong class="ko ja"> 27558 </strong>个细胞图像。其中，我们有被<strong class="ko ja"><em class="lk"/></strong>疟疾感染的<strong class="ko ja"> 13779 </strong>细胞图像和另一张<strong class="ko ja"> 13779 </strong>未感染的图像。我们正试图解决一个分类问题。正在使用的框架是Pytorch。</p><p id="89e5" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，让我们行动起来，创建一个检测疟疾的模型。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="951f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">导入库</h1><p id="6d04" class="pw-post-body-paragraph km kn iq ko b kp mq kr ks kt mr kv kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">现在让我们做一些数据探索:</p><ol class=""><li id="6d87" class="mv mw iq ko b kp kq kt ku kx mx lb my lf mz lj na nb nc nd bi translated">首先，我们将输入数据并对其应用各种转换。</li></ol><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1b7c" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">a)数据集包含不规则形状的图像。这样会妨碍模特训练。因此，我们将图像调整为128 x 128的形状。</p><p id="017b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">b)我们还将把我们的数据转换成张量，因为这是一种使用深度学习训练模型的有用格式。</p><p id="8b59" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">PyTorch的美妙之处在于，它允许我们使用很少几行代码来应用多种转换。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b37b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，我们将编写一个助手函数来可视化一些图像。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5b41" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们看看这两个类的一组图像。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f8f5" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了获得可重复的结果，我们需要设置种子。播种的原因可以在这里找到<a class="ae kl" href="https://medium.com/@ODSC/properly-setting-the-random-seed-in-ml-experiments-not-as-simple-as-you-might-imagine-219969c84752" rel="noopener">。</a></p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="47b1" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，让我们将整个图像集分为训练集、验证集和测试集。显然，训练集是用于训练模型的，而验证集是用于确保训练朝着正确的方向进行。测试集是为了在最后测试模型的性能。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f582" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将尝试通过使用批量图像来训练我们的模型。在这里，PyTorch的<a class="ae kl" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>实用程序就派上了用场。它在给定的数据集上提供了一个iterable。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="779e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将使用数据加载器来创建用于训练和验证的批次。我们需要确保在训练的时候批次是内部洗牌的。这只是在模型中引入了一些随机性。我们没有在内部对验证集进行洗牌，因为我们只是使用来验证每个时期的模型性能。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9bcc" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们试着想象一组图像。我们将为此编写一个助手函数。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1de2" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们设想一批图像。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b817" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">由于我们的数据是图像，我们将训练一个卷积神经网络。如果你被这些吓到了，那么你并不孤单。我第一次听说CNN的时候也很害怕。但是，坦率地说，由于Tensorflow和PyTorch等深度学习框架，它们很容易理解，有些实现起来更简单。</p><p id="1b48" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">阅读<a class="nk nl ep" href="https://medium.com/u/cb2327c63f48?source=post_page-----8fa52839e801--------------------------------" rel="noopener" target="_blank"> Irhum Shafkat </a>的这篇<a class="ae kl" href="https://towardsdatascience.com/intuitively-understanding-convolutions-for-deep-learning-1f6f42faee1" rel="noopener" target="_blank">文章</a>可以对卷积运算有一个大概的了解。CNN在初始层使用卷积运算来提取特征。最终图层是正常的线性图层。</p><p id="4f86" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将为包含各种助手方法的模型定义一个<strong class="ko ja">基类</strong>。如果我们将来试图解决类似的问题，这些方法可能会有所帮助。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7bbc" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们定义继承基类的主类。我们把它命名为<code class="fe nm nn no np b"><strong class="ko ja">Malaria2CnnModel</strong></code></p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5a80" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们使用CPU，训练深度学习模型是非常耗时和令人疲惫的。有许多平台，如Kaggle和谷歌的Colab，提供免费的GPU计算来训练模型。下面的帮助函数帮助我们找到我们的系统上是否有可用的GPU。如果是的话，我们可以将我们的数据和模型转移到GPU中进行更快的计算。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="593b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个项目是在Kaggle上完成的，它每周提供30小时的GPU计算时间。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4ef5" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们已经定义了一个<code class="fe nm nn no np b"><strong class="ko ja">DeviceDataLoader</strong></code>类来传输我们的模型、训练和验证数据。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5a4b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，我们将定义我们的<strong class="ko ja">拟合</strong>和<strong class="ko ja">评估</strong>函数。<strong class="ko ja"> fit() </strong>用于训练模型，而<strong class="ko ja"> evaluate() </strong>用于查看每个历元结束时的模型表现。一个历元可以理解为整个训练过程中的一个步骤，是一系列的步骤。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d2f3" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们将我们的模型转移到GPU设备上。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a757" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在训练之前，我们将评估该模型，看看它在验证集上的表现如何。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e0ef" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在训练之前，我们大约有50%的准确率。对于医疗保健领域的关键应用，这是非常低的。我们将设置要使用的时期和优化器(<code class="fe nm nn no np b">torch.optim.Adam</code>)的数量。我们还将学习率设定为<code class="fe nm nn no np b">0.001</code></p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="03e3" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将定义几个函数来绘制每个时期结束时的损耗和精度。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e3ca" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，让我们通过使用<strong class="ko ja">拟合</strong>函数来训练我们的模型。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1164" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在训练结束时，我们的模型已经从早期的50%准确率提高到大约95.54%</p><p id="e58e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们画出每个时期的精度和损耗，以便理解我们的模型。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7e7d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在将编写一个函数来预测单个图像的类别。然后，我们将对整个测试集进行预测，并检查整体准确性。</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="81ec" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对单个图像进行预测:</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0648" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们试着对整个测试集进行预测:</p><figure class="ne nf ng nh gt ka"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bac8" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们得到了一些很好的结果。96%是一个非常好的结果，但我认为这还可以通过改变超参数来改善。我们也可以使用更多的历元。</p><p id="8be8" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们就此打住。我们将在一个独立的博客中从我们停止的地方继续。我们将使用不同的技术，如数据扩充、正则化、批量标准化等。谢谢你陪我到最后。过几天继续找下一个帖子。</p><h1 id="227c" class="ls lt iq bd lu lv nq lx ly lz nr mb mc md ns mf mg mh nt mj mk ml nu mn mo mp bi translated">未来工作:</h1><ol class=""><li id="1546" class="mv mw iq ko b kp mq kt mr kx nv lb nw lf nx lj na nb nc nd bi translated">我们将尝试应用迁移学习技术，看看它是否能进一步提高准确性。</li><li id="c2eb" class="mv mw iq ko b kp ny kt nz kx oa lb ob lf oc lj na nb nc nd bi translated">我们将尝试图像分割技术和图像定位技术来群集红色球状结构，并分析它们的证据。</li><li id="8289" class="mv mw iq ko b kp ny kt nz kx oa lb ob lf oc lj na nb nc nd bi translated">我们将尝试使用数据扩充技术来限制我们的模型过度拟合。</li><li id="deb7" class="mv mw iq ko b kp ny kt nz kx oa lb ob lf oc lj na nb nc nd bi translated">我们将学习如何在生产中部署我们的模型，以便我们可以向不懂代码的人展示我们的工作。</li></ol><h1 id="72dc" class="ls lt iq bd lu lv nq lx ly lz nr mb mc md ns mf mg mh nt mj mk ml nu mn mo mp bi translated"><strong class="ak">参考文献</strong>:</h1><ol class=""><li id="6b43" class="mv mw iq ko b kp mq kt mr kx nv lb nw lf nx lj na nb nc nd bi translated"><a class="ae kl" href="https://pytorch.org/docs/stable/index.html" rel="noopener ugc nofollow" target="_blank"> PyTorch的文档</a></li><li id="b4e3" class="mv mw iq ko b kp ny kt nz kx oa lb ob lf oc lj na nb nc nd bi translated">尼提什·斯里瓦斯塔瓦和杰夫·辛顿的研究论文:<a class="ae kl" href="http://jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf" rel="noopener ugc nofollow" target="_blank">http://jmlr . org/papers/volume 15/Srivastava 14 a/Srivastava 14 a . pdf</a></li><li id="d6d9" class="mv mw iq ko b kp ny kt nz kx oa lb ob lf oc lj na nb nc nd bi translated">Jovian.ml的讲座系列。</li></ol></div></div>    
</body>
</html>