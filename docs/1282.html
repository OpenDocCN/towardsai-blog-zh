<html>
<head>
<title>Statistical Modeling of Time Series Data Part 2: Exploratory Data Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据的统计建模第2部分:探索性数据分析</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/statistical-modeling-of-time-series-data-part-2-exploratory-data-analysis-5c3aaedc04b7?source=collection_archive---------1-----------------------#2020-12-21">https://pub.towardsai.net/statistical-modeling-of-time-series-data-part-2-exploratory-data-analysis-5c3aaedc04b7?source=collection_archive---------1-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="dafe" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/73074a648cd7859f5cb93c7307897128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_b8ILLqf7AHy_Vce"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">克里斯·利维拉尼在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="eed3" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这一系列文章中，标准普尔500市场指数使用流行的统计模型进行分析:<strong class="ko ja"> SARIMA </strong>(季节性自回归综合移动平均线)和<strong class="ko ja"> GARCH </strong>(广义自回归条件异方差)。</p><p id="edd9" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在第一部分中，本系列文章中使用的数据标准普尔500价格(可互换地称为<code class="fe lk ll lm ln b">spx</code>)来自于<code class="fe lk ll lm ln b">yfinance</code> API。该系列捕捉了从<code class="fe lk ll lm ln b">1994–01–06</code>到<code class="fe lk ll lm ln b">2020–08–30</code>的每个工作日。它被清理出来，并被用来导出另外两个用于研究市场的序列:标准普尔500回报率(连续观察之间的价格变化百分比)和标准普尔500波动率(回报率的大小)。</p><p id="7bba" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在第二部分中，对预处理后的时间序列进行可视化和探索，以了解任何趋势、重复模式和/或其他特征，这些特征随后可用于对序列建模和预测未来值(在后续章节中介绍)。本文中使用的代码来自这个<a class="ae kl" href="https://github.com/yashveersinghsohi/Statistical_Modeling_for_Time_Series_Forecasting" rel="noopener ugc nofollow" target="_blank">资源库</a>中的<strong class="ko ja">可视化和EDA.ipynb </strong>笔记本。</p><h1 id="62f5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">目录</h1><ol class=""><li id="b78d" class="mm mn iq ko b kp mo kt mp kx mq lb mr lf ms lj mt mu mv mw bi translated">导入数据</li><li id="70d5" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">初步线图</li><li id="2b99" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">将时间序列数据拆分成训练测试集</li><li id="4d4f" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">使用箱线图探索年度趋势</li><li id="8ec2" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">数据分布</li><li id="5597" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">数据分解(加法和乘法)</li><li id="96c4" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">平滑时间序列(移动平均数)</li><li id="a347" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">相关图(ACF和PACF)</li><li id="fa4b" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">平稳性检查</li><li id="373e" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">结论</li><li id="b70e" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">链接到本系列的其他部分</li><li id="8811" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">参考</li></ol></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="a076" class="lo lp iq bd lq lr nj lt lu lv nk lx ly lz nl mb mc md nm mf mg mh nn mj mk ml bi translated">导入数据</h1><p id="611c" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">在开始探索之前，首先，让我们从最后一部分导入预处理数据。数据是从python中的<code class="fe lk ll lm ln b">yfinance</code> API中抓取的。它包含了从<code class="fe lk ll lm ln b">1994–01–06</code>到<code class="fe lk ll lm ln b">2020–08–30</code>的标准普尔500股票价格数据。然后对数据进行清理(填补缺失值)并用于创建两个新系列:回报和波动性。因此，最终数据集有以下3列:<code class="fe lk ll lm ln b">spx</code> (S &amp; P 500价格)、<code class="fe lk ll lm ln b">spx_ret</code> (S &amp; P 500收益)和<code class="fe lk ll lm ln b">spx_vol</code> (S &amp; P 500波动率)。参考第1部分准备好数据，或者从这个<a class="ae kl" href="https://github.com/yashveersinghsohi/Statistical_Modeling_for_Time_Series_Forecasting" rel="noopener ugc nofollow" target="_blank">库</a>下载<strong class="ko ja"> data.csv </strong>文件。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">从本系列的第1部分导入标准包和预处理数据集的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e8ada2238edf6ec641c1f7d8a8cdb4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Hs8ScyWxMhgqIkXjJIyQFQ.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示数据集前5行的前一个代码单元格的输出</figcaption></figure><p id="ff18" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们使用python导入几乎所有分析所用的所有标准库。<code class="fe lk ll lm ln b">sns.set()</code>功能只是给<code class="fe lk ll lm ln b">matplotlib.pyplot</code>制作的剧情增加一个主题。排除它只会导致一些样式上的改变。</p><p id="fa8c" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">read_csv()</code>函数接受文件路径作为参数(本例中为<code class="fe lk ll lm ln b">“data.csv”</code>)，并将结果存储为一个<code class="fe lk ll lm ln b">pandas</code> <code class="fe lk ll lm ln b">DataFrame</code>。由于<code class="fe lk ll lm ln b">Date</code>列存储为<code class="fe lk ll lm ln b">object</code>数据类型(或<code class="fe lk ll lm ln b">string</code>)，因此<code class="fe lk ll lm ln b">pandas</code>中的<code class="fe lk ll lm ln b">to_datetime()</code>函数用于将日期转换为<code class="fe lk ll lm ln b">datetime</code>格式。完成后，我们可以使用<code class="fe lk ll lm ln b">set_index()</code>函数将该数据帧的日期设置为其索引。这将使索引和切片更加直观。<code class="fe lk ll lm ln b">inplace = True</code>参数指示<code class="fe lk ll lm ln b">pandas</code>在同一数据帧上执行该操作，而不是在数据帧的复制版本上。如果没有此参数，更改将不会反映在原始的<code class="fe lk ll lm ln b">data</code>数据帧中。最后，<code class="fe lk ll lm ln b">data.head()</code>函数只显示数据帧的前5行(如上图所示)。</p><h1 id="86ce" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">初步线图</h1><p id="8158" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">简单的折线图是直观显示一段时间内序列趋势的好方法。通常，对于折线图(以及本文中的其他图)，x轴代表时间，y轴代表序列。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">用于为标准普尔500价格、回报和波动性生成折线图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ny"><img src="../Images/dabca259348a03a7c878e2a7c81eafb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbu5bM77AT_rhvSKDsq4dA.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">前一个代码单元格的输出显示了标准普尔500价格、回报和波动性的所有折线图</figcaption></figure><p id="0e21" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">plt.rcParams[“figure.figsize”]</code>用于设置图形的大小。它需要一个长度和高度如下的元组:(length，height)。<code class="fe lk ll lm ln b">plt.subplots()</code>用于在一个图形内构建多个地块。图形容器存储在该函数的第一个输出中(本例中为<code class="fe lk ll lm ln b">fig</code>)，图形的位置存储在第二个输出中(本例中为<code class="fe lk ll lm ln b">ax</code>)。参数<code class="fe lk ll lm ln b">(1, 3)</code>指定一行有3个支线剧情。3个支线剧情可以通过索引<code class="fe lk ll lm ln b">ax</code>变量来访问。因此，<code class="fe lk ll lm ln b">ax[0].plot()</code>将在第一个子情节中绘制在<code class="fe lk ll lm ln b">plot()</code>方法中指定的系列，对于<code class="fe lk ll lm ln b">ax[1]</code>和<code class="fe lk ll lm ln b">ax[2]</code>也是如此。<code class="fe lk ll lm ln b">set_title()</code>函数允许我们给一个支线剧情设置一个标题。<code class="fe lk ll lm ln b">legend()</code>功能使我们能够在图中显示标签。标签中的文本在<code class="fe lk ll lm ln b">plot()</code>函数中作为<code class="fe lk ll lm ln b">label</code>参数被提及。最后，<code class="fe lk ll lm ln b">plt.show()</code>显示没有任何附加Jupyter笔记本文本的输出。如果没有这个，在类似Jupyter笔记本的环境中，在情节之前可能会有一些可见的文本。</p><p id="068b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这些图表明，自1994年以来，标准普尔500价格总体上一直在上涨，在2004年和2008年出现了两次较大的下跌。回报率相当集中在0左右，在2004年和2008年左右表现出较高的偏差。类似地，波动性也表明市场在这两个时期相当不稳定。一段时期的较高波动性(回报率的大小)表明在此期间存在不稳定的市场。</p><h1 id="d144" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">将时间序列数据拆分成训练测试集</h1><p id="f377" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">在前面部分构建了初步的图表之后，我们最好将数据分成训练集和测试集。这是因为，在大多数现实世界的预测问题中，我们无法获得未来的观测数据。因此，为了模拟现实世界的问题，我们应该只探索我们的数据的一部分，并使用这些发现来建立模型以预测其余的数据。因此，在进行任何探索之前，让我们首先将数据分成<strong class="ko ja">训练</strong>和<strong class="ko ja">测试</strong>组。</p><p id="0da7" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">训练集将用于构建模型。然后，该模型将用于预测测试数据集中的值，测试数据集中的实际观察结果将用于评估模型的性能。一旦模型达到期望的准确度水平，它就被用于预测看不见的数据(即，训练集和测试集之外的数据)。</p><p id="6123" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">注意:</strong>因为我们使用测试集来评估和微调我们的模型，所以更好、更精确的术语是<strong class="ko ja">交叉验证集。</strong>需要为其生成预测的看不见的数据(在数据中观察到的时间段之后的时间段)将被称为测试集。然而，在这一系列文章中，我们的目标是构建模型，并仅在训练集和交叉验证集上查看它们的适用性。因此，为了简单起见，使用术语训练集和测试集。</p><p id="4ec9" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，我们需要选择如何将现有数据划分为训练集和测试集。在数据科学的其他问题中，如分类或回归，通常我们将数据分成80-20份(80%用于训练，20 %用于测试)，这是通过随机打乱数据来完成的。然而，在时间序列分析中，如果我们打乱数据，我们就消除了数据的时间依赖性。因此，首选方法是在某个时间点拆分数据。在这种情况下，我们将数据分成两部分:在<code class="fe lk ll lm ln b">2019–01–01</code>之前的所有数据都是训练集，在此日期之后的所有数据都是测试集。因此，我们根据截至<code class="fe lk ll lm ln b">2019–01–01</code>的数据建立模型，并尝试预测自<code class="fe lk ll lm ln b">2019–01–01</code>以来观察到的数据。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">将数据分成训练集和测试集的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1b832eb52c1ff3c20c710c687c274511.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*3tDWhR-cwVwh5dheM28IEg.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">前一个代码单元的输出显示了定型集和测试集的形状</figcaption></figure><p id="333d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用<code class="fe lk ll lm ln b">data</code>数据帧上的<code class="fe lk ll lm ln b">loc</code>索引操作符访问<code class="fe lk ll lm ln b">2019–01–01</code>之前的数据。因此，代码<code class="fe lk ll lm ln b">data.loc[:“2018–12–31”]</code>只提取从起始索引到标记为<code class="fe lk ll lm ln b">“2018–12–31”</code>的索引的<code class="fe lk ll lm ln b">data</code>的所有列，而代码<code class="fe lk ll lm ln b">data.loc[“2019–01–01”:]</code>提取从标记为<code class="fe lk ll lm ln b">“2019–01–01”</code>的索引到最后一个索引的所有列。<code class="fe lk ll lm ln b">train_df</code>和<code class="fe lk ll lm ln b">test_df</code>分别存储训练集和测试集。通过打印这两个数据帧的<code class="fe lk ll lm ln b">shape</code>,可以看到我们在训练集中有<code class="fe lk ll lm ln b">6518</code>个观察值，在测试集中有<code class="fe lk ll lm ln b">174</code>个观察值。</p><p id="6af0" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">随后，在列车组上完成所有探索:<code class="fe lk ll lm ln b">train_df</code></p><h1 id="103b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用箱线图探索年度趋势</h1><p id="92ed" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">根据<a class="ae kl" href="https://en.wikipedia.org/wiki/Box_plot" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="oa ob oc"><p id="dcd9" class="km kn od ko b kp kq kr ks kt ku kv kw oe ky kz la of lc ld le og lg lh li lj ij bi translated">在描述统计学中，<strong class="ko ja">箱线图</strong>或<strong class="ko ja">箱线图</strong>是一种通过四分位数图形化描述数字数据组的方法。</p></blockquote><p id="a020" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们通过实际观察箱线图来理解这个定义:</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ef50a2c928ce4b4ff5bbbda7f5d4f6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*utIxgPsEHTGLDfE3GBWq8A.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">箱形图的示例</figcaption></figure><p id="84d7" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一个箱形图由5条水平线组成，在上图中标记为<strong class="ko ja"> A </strong>、<strong class="ko ja"> B </strong>、<strong class="ko ja"> C </strong>、<strong class="ko ja"> D、</strong>E。</p><ul class=""><li id="d8a2" class="mm mn iq ko b kp kq kt ku kx oi lb oj lf ok lj ol mu mv mw bi translated"><strong class="ko ja">答:</strong>这条线代表数据集的最大值(排除离群值)</li><li id="2ca6" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated">B: 这条线代表第3个四分位数或第75个百分位数。这是数据集上半部分的中位数</li><li id="39ba" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><strong class="ko ja"> C: </strong>这条线代表数据集的第2个四分位数或第50个百分位数。换句话说，这是完整数据集的中间值</li><li id="f494" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><strong class="ko ja"> D: </strong>这条线代表第1个四分位数或第25个百分位数。这是数据集下半部分的中位数</li><li id="5410" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated">E: 这条线代表数据集的最小值(不包括离群值)</li><li id="8bb5" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated">数据的异常值被绘制为最大值和最小值线上方和下方的点(分别为<strong class="ko ja"> A </strong>和<strong class="ko ja">E</strong></li></ul><p id="0781" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，箱线图简洁地总结了数据的分布及其异常值。让我们在训练数据集中为每年的<code class="fe lk ll lm ln b">spx</code>、<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>构建箱线图:</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">为标准普尔500价格、回报和波动性创建年度箱线图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi om"><img src="../Images/39501a0e9bc4954a5f45eb81a07c2bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJdtDBXK_YwDAP7YAcooEg.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500价格的年度箱线图</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi on"><img src="../Images/8d180578d4b64c127cb15fc550d6044b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aeKQtlOHi-eJB8c3wuuciw.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500收益的年箱线图</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi oo"><img src="../Images/569c7cdc61d2d90bf5afb63931b7ee5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXIirBv8EA2v-y9yThH2ig.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500波动率的年度箱线图</figcaption></figure><p id="7069" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们向数据集添加一个新列，存储记录相应观察行的年份。这是使用定义了索引<code class="fe lk ll lm ln b">train_df</code>的<code class="fe lk ll lm ln b">datetime</code>对象的<code class="fe lk ll lm ln b">year</code>属性来完成的。年份列存储在<code class="fe lk ll lm ln b">train_df</code>中名为<code class="fe lk ll lm ln b">Year</code>的列中。然后我们设置了3个支线剧情，一个在另一个下面，并在其中绘制了<code class="fe lk ll lm ln b">spx</code> <code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>的方块剧情。<code class="fe lk ll lm ln b">pandas</code>的<code class="fe lk ll lm ln b">boxplot()</code>功能用于绘制这些图。该函数接受用于在<code class="fe lk ll lm ln b">column</code>参数中绘制数据的列和用于对在<code class="fe lk ll lm ln b">by</code>参数中绘制的数据进行分组的列。因此，在这种情况下，我们按年份分割数据(使用<code class="fe lk ll lm ln b">by = “Year”</code>)，然后为训练数据集中可用的每一年绘制单独的箱线图。</p><p id="3163" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">出现较宽的箱线图表明当年观察到的值分布很广。同样，大量异常值的存在也表明，在那一年，数据有较大的波动。基于这些，不难识别市场波动/不稳定程度较高的年份(如2004年和2008年左右)</p><h1 id="0e14" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">数据分布</h1><p id="307b" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">在本节中，我们试图使用<strong class="ko ja">密度曲线</strong>和<strong class="ko ja">直方图来理解标准普尔500价格、回报和波动性的分布。</strong>数据的分布将表明比其他值出现更频繁的值的范围，但它将消除时间因素。因此，当我们在数据集中遇到某个值时，仅仅通过查看分布图，我们将无法判断。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">生成标准普尔500价格、回报和波动性的密度曲线的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi om"><img src="../Images/330d95cee5b2d42f9f563cf60bf8078b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJsbfxfxYmy_3K9yMCVq_Q.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500价格的密度图</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi op"><img src="../Images/8d8d39187916956d990efbfe209fd733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sPwCdBhLpy5Lu4jBkRwJA.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500回报的密度图</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi oq"><img src="../Images/d46c736f97e7c6c88a0fbd6da9b13f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peDVPxd0yYQWuWhK0GKUDQ.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500波动率的密度图</figcaption></figure><p id="6d42" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">和之前所有的剧情一样，首先，我们设置人物的大小，定义支线剧情。然后，我们使用<code class="fe lk ll lm ln b">seaborn</code>的<code class="fe lk ll lm ln b">distplot()</code>函数在传递到函数中的系列直方图的顶部绘制一条密度曲线。然后我们为每个支线剧情设置标题(使用<code class="fe lk ll lm ln b">set_title()</code>)并显示它们(使用<code class="fe lk ll lm ln b">plt.show()</code>)。</p><p id="e37d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">标准普尔500价格的分布看起来有些正常，后缘有一些大的峰值。然而，标准普尔500回报的分布看起来完全正常，几乎与<code class="fe lk ll lm ln b">0</code>平均。最后，由于波动率永远不会是负的，而只是回报率的大小，标准普尔波动率的分布是严重右偏(长右尾)正态分布。</p><h1 id="bcfe" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">数据分解(加法和乘法)</h1><p id="6ee2" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">数据分解是将时间序列分解成3个分量的过程:<strong class="ko ja">趋势</strong>、<strong class="ko ja">季节性、</strong>和<strong class="ko ja">噪声</strong>。这样做可以让我们深入了解数据中的重复模式，这些模式可以在模型构建过程中使用。在python中，<code class="fe lk ll lm ln b">statsmodels</code>库用于完成这种分解。该库支持两种类型的分解:<strong class="ko ja">加法</strong>和<strong class="ko ja">乘法。</strong></p><p id="1c39" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在加法分解中，序列被表示为趋势、季节性和噪声的<strong class="ko ja">和</strong>，在乘法分解中，序列被表示为这三个分量的<strong class="ko ja">乘积</strong>。</p><p id="9617" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">从数学上讲，这两种类型的分解可以表示为:</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9d855cf212af03b85be1ed136c70847f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*CpZAH4WllMK9onziWquM4A.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">加法分解</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi os"><img src="../Images/e795b94904edfee7644df5bfc03c504e.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*H8ANs-galVfzQgs6SsLufA.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">乘法分解</figcaption></figure><p id="bff6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们来看看如何在python中实现这一点。具体来说，下一节将用于对标准普尔500价格进行加法分解。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">使用加法分解来分解标准普尔500价格的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ot"><img src="../Images/e7520b66aae51d35cd5fe794868b20d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dh3sbdnFbNd2q-X-6O4iQQ.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示标准普尔500价格相加分解的前一个代码单元的输出。</figcaption></figure><p id="11a0" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们从<code class="fe lk ll lm ln b">statsmodels.tsa.seasonal</code>包中导入<code class="fe lk ll lm ln b">seasonal_decompose()</code>方法。这个函数要求我们将时间序列作为参数传入。然后，我们需要将<code class="fe lk ll lm ln b">model</code>属性设置为<code class="fe lk ll lm ln b">“additive”</code>，以将系列分解为相加的组件。该函数的输出存储在<code class="fe lk ll lm ln b">result</code>变量中，该变量使用<code class="fe lk ll lm ln b">plot()</code>函数简单绘制。这将绘制4个图形:首先是系列本身。第二是趋势。接下来是季节成分，最后一个图是噪音。</p><p id="67b4" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在上面的图中，季节性因素看起来很奇怪。所以让我们进一步研究一下。让我们只绘制序列的前20个值，而不是绘制完整的季节分量。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">根据标准普尔500价格的季节性成分绘制前20个值的代码。</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ou"><img src="../Images/8fa80e7072cf8f9340295c23255dda1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPp9yR4_iDx_OUwmX3P4Wg.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示标准普尔500价格季节性成分的前一个代码单元格的输出</figcaption></figure><p id="1e36" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">marker = “o”</code>参数用于绘制数值，并为更加清晰起见分别标记每个观察值。通过使用<code class="fe lk ll lm ln b">result.seasonal</code>,我们可以访问分解数据的季节性成分。使用<code class="fe lk ll lm ln b">result.trend</code>(用于趋势)和<code class="fe lk ll lm ln b">result.resid</code>(用于噪声或残差)可以类似地访问其他组件。</p><p id="81cd" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">该图清楚地显示了每5个周期的重复循环。这是相当符合逻辑的，因为我们的数据是股票价格数据。我们在每周的每个工作日观察和收集股票价格数据。这意味着数据是每周季节性的，一周是商业周(每周5天)。然而，仔细观察，这些值可以忽略不计(从y轴的刻度可以看出)。因此，在我们的模型中使用5个周期的季节性可能不会产生很好的结果。</p><p id="1672" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了保持这篇文章简短，分解其他2个系列:<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>在这里没有显示。乘法分解也没有显示，但是可以使用上面注释中的代码绘制。</p><h1 id="deb3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">平滑时间序列(移动平均数)</h1><p id="9f6d" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">平滑是一种用于减少时间序列中不规则波动或尖峰的技术。这样做是为了抑制噪声对系列的影响。平滑时间序列的常用方法是使用<strong class="ko ja">移动平均线。</strong>在这种方法中，给定周期数的平均值(也称为<strong class="ko ja">窗口</strong>)是为系列中的每个时间步长计算的。对于时间步长，大小为n的窗口可以用两种方式定义:</p><ul class=""><li id="eb8f" class="mm mn iq ko b kp kq kt ku kx oi lb oj lf ok lj ol mu mv mw bi translated">当前时间步长可能在窗口的末尾。即n-1个过去的滞后和1个当前的时间步长组成大小为n的窗口</li><li id="1a22" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated">当前时间步长可以在窗口的中心。即大约一半的n-1个滞后是过去的滞后，剩余的是未来的滞后，并且当前时间步长在中心。</li></ul><p id="1880" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">注意:</strong>在这个例子中，我们使用选择窗口的第一种方法。因此，如果窗口大小为3，那么对于前2个值，我们没有足够的滞后来计算移动平均值。因此，对于大小为n的窗口，序列的前n-1个滞后将导致空值。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">为标准普尔500价格、回报和波动性生成移动平均图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ov"><img src="../Images/99141a9d2ff121c142653b2fcc2a03b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xmfaHghaiPE_XJPIlTCog.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示标准普尔500价格、回报和波动率的移动平均(窗口= 360个周期)图的前一个代码单元格的输出</figcaption></figure><p id="a226" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">像往常一样，我们从设定人物的大小和定义支线剧情开始。然而这一次，我们将参数<code class="fe lk ll lm ln b">sharex</code>设置为<code class="fe lk ll lm ln b">True</code>，这允许支线剧情有一个共同的x轴。在第一行，我们绘制了标准普尔500的实际价格和平滑版本。通过使用<code class="fe lk ll lm ln b">window=360</code>参数设置的窗口大小为360°的<code class="fe lk ll lm ln b">spx</code>系列使用<code class="fe lk ll lm ln b">rolling()</code>方法进行平滑。在调用<code class="fe lk ll lm ln b">rolling(window = 360)</code>函数上的<code class="fe lk ll lm ln b">mean()</code>函数时，我们得到期望的移动平均线。在接下来的2行中使用类似的函数来获得<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>系列的图。</p><p id="8faa" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在检查结果时，我们可以清楚地看到3个系列的趋势。价格和回报都显示出在2004年和2008年间的大幅下降。在这两个时间段内，波动性增加。所有这些都表明，在上述时间段内，市场不稳定。除了两次下跌，标准普尔500价格有明显的上升趋势。除了2004年和2008年左右，回报率和波动性基本保持不变。</p><p id="5931" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">通过改变<code class="fe lk ll lm ln b">rolling()</code>函数中的<code class="fe lk ll lm ln b">window</code>参数，我们也可以为其他窗口大小构建这样的图。</p><h1 id="bd90" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">相关图(ACF和PACF)</h1><p id="1b41" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">用于预测时间序列的模型利用序列本身的过去值来预测未来。因此，对于分析师来说，了解该系列对过去版本(或滞后版本)的依赖程度是很重要的。通过计算两个序列之间的<strong class="ko ja">相关性</strong>可以判断两个序列之间的相关性。然而，在这种情况下，2系列本质上是相同的。一个是另一个的滞后版本。因此，在这种情况下计算的相关性被称为<strong class="ko ja">自相关。</strong></p><p id="f0f5" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有两种类型的相关图常用于理解时间序列与其自身的相关性。这些是<strong class="ko ja"> ACF </strong>(自相关函数)和<strong class="ko ja"> PACF </strong>(部分自相关函数)图。</p><p id="b2af" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们已经讨论了什么是自相关。现在让我们理解部分自相关。根据本书<a class="ae kl" href="https://amzn.to/2XYS8DD" rel="noopener ugc nofollow" target="_blank">介绍R的时间序列</a>，</p><blockquote class="oa ob oc"><p id="d75d" class="km kn od ko b kp kq kr ks kt ku kv kw oe ky kz la of lc ld le og lg lh li lj ij bi translated">滞后k处的部分自相关是在去除了由较短滞后处的项引起的任何相关的影响之后得到的相关。</p></blockquote><p id="1742" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们通过一个例子来理解这一点。假设我们在某个星期三观察到标准普尔500价格的某个值。这个值取决于几天前(比如星期二和星期一)观察到的值。因此，周三的价格与周二和周一的价格之间的相关性是通过自相关来衡量的。然而，我们知道，就像周三一样，即使是周二的价格也取决于周一的价格。因此，当我们估计周三和周一价格之间的自相关时，我们估计了两种类型的相关性:一种是直接的(周三和周一之间)，另一种是间接的(周三和周二之间，以及周二和周一之间)。利用部分自相关，我们去除这种间接影响，只估计直接相关性。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">为标准普尔500价格、回报和波动性创建ACF和PACF图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ow"><img src="../Images/8d540f4a2822d93b393e1bffb7ee6e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKYazTycBXJdxugdVCKtCQ.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示标准普尔500价格、回报和波动性的ACF和PACF图的前一个代码单元格的输出</figcaption></figure><p id="4297" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们导入包含函数<code class="fe lk ll lm ln b">plot_acf()</code>和<code class="fe lk ll lm ln b">plot_pacf()</code>的包<code class="fe lk ll lm ln b">statsmodels.graphics.tsaplots</code>，用于绘制特定时间序列的ACF和PACF图。像本文中的其他情节一样，我们定义了人物大小和支线剧情(共享x轴)。然后，在该图的第一和第二列中，我们分别绘制了3个系列(<code class="fe lk ll lm ln b">spx</code>、<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>)的ACF和PACF。<code class="fe lk ll lm ln b">plot_acf()</code>和<code class="fe lk ll lm ln b">plot_pacf()</code>都将时间序列作为它们的自变量。此外，<code class="fe lk ll lm ln b">plot_acf()</code>(或<code class="fe lk ll lm ln b">plot_pacf()</code>)函数接受<code class="fe lk ll lm ln b">lags</code>参数，该参数指示该函数应计算ACF(或PACF)到多少滞后。在这种情况下，<code class="fe lk ll lm ln b">lags=40</code>表示该函数应计算ACF(或PACF ),直到历史中有40个滞后。<code class="fe lk ll lm ln b">plot_acf()</code>(或<code class="fe lk ll lm ln b">plot_pacf()</code>)中的<code class="fe lk ll lm ln b">zero</code>参数是一个布尔型参数，指示是否应该用其自身的非滞后版本计算系列的ACF(或PACF)。从数学上讲，这将始终是1，因为任何系列都与自身完全相关。因此绘制它并不提供任何额外的信息。</p><p id="fcd9" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">注意:</strong>作为输入传递给<code class="fe lk ll lm ln b">plot_acf()</code>和<code class="fe lk ll lm ln b">plot_pacf()</code>功能的序列中不应出现空值。</p><p id="10b9" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">图中x轴附近的蓝色条带表示显著性水平。高于该范围的滞后被认为是显著的。这些图说明了数据如何依赖于自身的滞后版本。在为这些系列构建模型时，这些信息至关重要。</p><h1 id="8bc5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">平稳性检查</h1><p id="2f14" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">根据Rob J Hyndman和George Athanasopoulos的《预测:原则和实践》一书，</p><blockquote class="oa ob oc"><p id="68ba" class="km kn od ko b kp kq kr ks kt ku kv kw oe ky kz la of lc ld le og lg lh li lj ij bi translated">平稳时间序列的性质不依赖于序列被观察的时间。因此，具有趋势或季节性的时间序列不是静止的，趋势和季节性会影响时间序列在不同时间的值。另一方面，白噪声序列是稳定的——当你观察它时，这并不重要，它在任何时间点看起来都应该差不多。</p></blockquote><p id="dd38" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这里的<strong class="ko ja">属性</strong>指的是<strong class="ko ja">均值、</strong>等统计属性。在建立统计模型来预测给定的时间序列时，确保作为输入给出的序列是平稳的是很重要的。这是因为，只有在平稳序列中，我们才能确定数据的基本分布在将来不会改变。然而，如果我们使用一个非平稳序列，我们永远无法确定基本分布。因此，模型将假设数据的分布在预测期内保持不变，由于在非平稳序列中，这一点没有保证，因此这种情况下的预测很可能很差。</p><p id="9f9e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有许多方法可以测试给定序列的平稳性。在本文中，我们来看以下3点:</p><ul class=""><li id="4752" class="mm mn iq ko b kp kq kt ku kx oi lb oj lf ok lj ol mu mv mw bi translated"><strong class="ko ja">目测:</strong>我们对序列进行绘图，检查序列是否有明显的趋势或季节周期。</li><li id="0006" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><strong class="ko ja">绘制汇总统计:</strong>我们绘制不同时间段数据的汇总统计(均值和方差)。</li><li id="c8f5" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><strong class="ko ja">统计检验:</strong>以上2种方法得出的结论都是定性的，而不是定量的。因此，为了获得更可靠的定量估计，使用了一种称为<strong class="ko ja">ADF</strong>(Augmented-Dickey Fuller)测试的强大统计测试。</li></ul><p id="8acb" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">目视检查:</strong>为此，我们使用本文开始时制作的初步图表。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">用于构建标准普尔500价格、回报和波动性的简单线图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ny"><img src="../Images/dabca259348a03a7c878e2a7c81eafb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbu5bM77AT_rhvSKDsq4dA.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">上述代码单元格的输出显示了标准普尔500价格、回报和波动性的折线图</figcaption></figure><p id="8468" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">本文的预备线图一节给出了代码的解释。从产量来看，很明显标准普尔500价格是非平稳的。这是因为，<code class="fe lk ll lm ln b">spx</code>系列有一个非常明显的趋势，大部分时间都是向上的(除了2004年和2008年左右)。另一方面，标准普尔500指数的回报率和波动性似乎没有显示出任何强劲的上升或下降趋势。<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>确实包含一些尖锐的尖峰信号，但它们不会以周期性周期出现。让我们用另一种方法来确定它们的平稳性。</p><p id="8e8b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">绘制汇总统计数据:</strong>在此方法中，我们将按年划分3个系列:<code class="fe lk ll lm ln b">spx</code>、<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>，并绘制这些数据，以查看汇总统计数据是否会随时间而变化。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">用于为标准普尔500价格、回报和波动性的年均值和方差生成折线图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ox"><img src="../Images/191676340a237fe5297c7278ba1b9dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCxugVEFJWzX6Zm8tMDGSA.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示标准普尔500价格、回报和波动性的年均值和方差的前一个代码单元格的输出</figcaption></figure><p id="5e40" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">groupby()</code>功能用于<code class="fe lk ll lm ln b">train_df</code>上，根据年份对3个系列进行分组。为了从<code class="fe lk ll lm ln b">train_df</code>的索引中提取年份，我们简单地使用<code class="fe lk ll lm ln b">train_df.index.year</code>并将其传递给<code class="fe lk ll lm ln b">groupby()</code>函数中的<code class="fe lk ll lm ln b">by</code>参数。<code class="fe lk ll lm ln b">mean()</code>和<code class="fe lk ll lm ln b">var()</code>功能用于<code class="fe lk ll lm ln b">groupby()</code>的输出，以获得包含每年3个系列的平均值和方差的数据帧。然后，我们绘制3个系列的平均值和方差的线图:<code class="fe lk ll lm ln b">spx</code>、<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>，首先设置图形的大小，然后定义子情节的数量(并且它们使用<code class="fe lk ll lm ln b">sharex = True</code>共享x轴)，然后用适当系列的图填充每个子情节。</p><p id="0615" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">像以前一样，标准普尔500价格的年均值显示出强劲的趋势。标准普尔500回报率和波动性的年均值显示出一些尖峰，但这些尖峰的幅度与序列本身相比非常小。所以这些可以认为是常数。标准普尔500价格的年方差不是常数，因此<code class="fe lk ll lm ln b">spx</code>是非平稳序列。与年均值相似，标准普尔500回报率和波动率的年方差显示峰值，但幅度较低，因此这两个序列:<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>看起来确实是平稳的。但是，为了得到更具体(或更定量)的平稳性证明，通常使用统计检验。</p><p id="20f5" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">统计检验(ADF): </strong>这里我们使用流行的<strong class="ko ja">增广的Dickey Fuller (ADF) </strong>检验来检查一个序列的平稳性。该测试有以下两个假设:</p><ul class=""><li id="4e41" class="mm mn iq ko b kp kq kt ku kx oi lb oj lf ok lj ol mu mv mw bi translated">零假设(<strong class="ko ja"> H0 </strong>):数列有单位根，或者是<strong class="ko ja">非平稳</strong>。</li><li id="d2a7" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated">交替假设(<strong class="ko ja"> H1 </strong>):数列没有单位根，或者是<strong class="ko ja">平稳</strong>。</li></ul><p id="829c" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">单位根的概念在<a class="ae kl" href="https://www.analyticsvidhya.com/blog/2018/09/non-stationary-time-series-python/" rel="noopener ugc nofollow" target="_blank">这篇来自Analytics Vidhya </a>的博客文章中有很好的解释。ADF测试输出测试统计数据以及统计数据的p值。如果统计的p值小于置信水平:1% (0.01)，5% (0.05)或10% (0.10)，那么我们可以拒绝零假设，并呼吁序列平稳。</p><p id="e57f" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们使用ADF测试来检查3系列的平稳性。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">对标准普尔500价格、回报和波动性运行ADF测试的代码单元</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/caacd2b384761bf4e6ac13c9f2f27a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*losVbJJS2RNhPtyT1dFRHA.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示标准普尔500价格的ADF测试结果的前一个代码单元的输出</figcaption></figure><p id="3922" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先我们从<code class="fe lk ll lm ln b">statsmodels.tsa.stattools</code>包中导入<code class="fe lk ll lm ln b">adfuller()</code>函数。然后，我们将应该执行ADF测试的系列作为输入参数传递给<code class="fe lk ll lm ln b">adfuller()</code>测试。在上面的单元格中，我们将<code class="fe lk ll lm ln b">train_df[“spx”]</code>系列作为输入传入。上面的输出显示了对<code class="fe lk ll lm ln b">spx</code>系列进行ADF测试的结果。第一个值是检验统计量，第二个值是p值。接下来的两个是使用的滞后次数和使用的观察次数。下一个字典是3个置信水平的统计值。如本例所示，统计的p值(~0.8或80%)大于所有3个置信区间。因此，我们不能拒绝零假设。所以<code class="fe lk ll lm ln b">spx</code>系列是非静止的。</p><p id="349f" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了对其他2个系列执行此测试，请取消注释上面代码单元格中的相应行。注意，作为输入传递给<code class="fe lk ll lm ln b">adfuller()</code>函数的序列应该没有任何空值。因此，对于<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>，我们在通过系列之前排除第一个观察值。下图分别显示了对标准普尔500回报率和波动率进行ADF测试的结果。</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/0fd227e83ca3b9ce9779f9304b75fb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*rEO4xfhKGMPdUB6gZllUjg.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500返回的ADF测试结果</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/617e900969b756d9e38dad94ae0ddcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*9SP99J60UMqbBrPVkRPclw.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500波动率的ADF测试结果</figcaption></figure><p id="68e0" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于这两个系列，p值(相应图像中的第二个值)非常接近于零，远小于上述3个置信水平。因此，对于这两个系列，我们可以拒绝零假设。因此，根据ADF检验，标准普尔500收益和标准普尔500波动率都是稳定的。</p><h1 id="6ab4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="1e00" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">对3个系列(<code class="fe lk ll lm ln b">spx</code>、<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>)的详尽研究揭示了数据的一些重要特征。以下几点总结了本文得出的主要见解:</p><ul class=""><li id="37bf" class="mm mn iq ko b kp kq kt ku kx oi lb oj lf ok lj ol mu mv mw bi translated"><strong class="ko ja">趋势:</strong> <code class="fe lk ll lm ln b">spx</code>除了围绕<code class="fe lk ll lm ln b">2004</code>和<code class="fe lk ll lm ln b">2008</code>的2个时间段外，总体呈上升趋势。另一方面，<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>，趋势不变。</li><li id="4bfd" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><strong class="ko ja">季节性:</strong>在分解数据和绘制相关函数时，数据可能具有5个周期的季节性。根据一般直觉，股票市场数据是在工作日观察到的，这也是有道理的。(即一周中的5天)。换句话说，我们的数据中可能存在每周的季节性。这应该在构建统计模型时进行探索。</li><li id="de1c" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><strong class="ko ja">平稳性:</strong><code class="fe lk ll lm ln b">spx</code>系列不是平稳的。这意味着在将序列用于建模和后续预测之前，需要执行额外的预处理。<code class="fe lk ll lm ln b">spx_ret</code>和<code class="fe lk ll lm ln b">spx_vol</code>都是固定的，因此，它们可以直接用于建模。</li></ul><p id="98e1" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在本系列的以下部分中，将建立各种统计模型来预测3个系列。</p><h1 id="a710" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">链接到本系列的其他部分</h1><ul class=""><li id="a6f7" class="mm mn iq ko b kp mo kt mp kx mq lb mr lf ms lj ol mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-1-data-preparation-and-preprocessing-b52f26f6213c" rel="noopener">时间序列数据的统计建模第1部分:预处理</a></li><li id="cede" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated">时间序列数据的统计建模第2部分:探索性数据分析</li><li id="be2b" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-3-forecasting-stationary-time-series-using-sarima-f0ff1284bebb" rel="noopener">时间序列数据的统计建模第三部分:利用SARIMA预测平稳时间序列</a></li><li id="48d7" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-of-time-series-data-part-4-forecasting-volatility-using-garch-1e9ff832f7e5" rel="noopener">时间序列数据的统计建模第四部分:利用GARCH预测波动率</a></li><li id="2944" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-for-time-series-data-part-5-arma-garch-model-for-time-series-forecasting-98beeedcfba8" rel="noopener">时间序列数据的统计建模第五部分:时间序列预测的ARMA+GARCH模型。</a></li><li id="02f3" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj ol mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-for-time-series-data-part-6-forecasting-non-stationary-time-series-using-9acc28c39db9" rel="noopener">时间序列数据的统计建模第六部分:用ARMA预测非平稳时间序列</a></li></ul><h1 id="6a7a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">参考</h1><p id="1a1f" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">[1]<a class="ae kl" href="https://365datascience.com/courses/time-series-analysis-in-python/" rel="noopener ugc nofollow" target="_blank">365数据科学</a>时间序列分析课程</p><p id="de85" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[2]<a class="ae kl" href="https://machinelearningmastery.com/time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">machine learning mastery</a>关于时序分析的博客</p><p id="4346" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[3] <a class="ae kl" href="https://en.wikipedia.org/wiki/Box_plot" rel="noopener ugc nofollow" target="_blank">维基百科</a>关于方框图的文章</p><p id="8876" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[4] <a class="ae kl" href="https://amzn.to/2XYS8DD" rel="noopener ugc nofollow" target="_blank">带R的介绍性时间序列</a></p><p id="f2ce" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[5] <a class="ae kl" href="https://www.youtube.com/watch?v=JntA9XaTebs" rel="noopener ugc nofollow" target="_blank"> Tamara Louie:应用统计建模&amp;机器学习进行时间序列预测</a></p><p id="11d6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">罗布·J·海曼和乔治·阿萨纳索普洛斯的《预测:原理与实践》</p><p id="f592" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[7] <a class="ae kl" href="https://www.analyticsvidhya.com/blog/2018/09/non-stationary-time-series-python/" rel="noopener ugc nofollow" target="_blank">用Python处理非平稳时间序列的温和介绍</a></p></div></div>    
</body>
</html>