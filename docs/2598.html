<html>
<head>
<title>Implementing Particle Swarm Optimization in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Tensorflow中实现粒子群优化</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/implementing-particle-swarm-optimization-in-tensorflow-b501ca4a3c17?source=collection_archive---------2-----------------------#2022-03-07">https://pub.towardsai.net/implementing-particle-swarm-optimization-in-tensorflow-b501ca4a3c17?source=collection_archive---------2-----------------------#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f4e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嘿，你们！！我在这里展示的是粒子群优化算法的TensorFlow实现。简述PSO(粒子群优化)及其在Tensorflow中的实现。</p><blockquote class="ko kp kq"><p id="a7df" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">TL/DR:使用tensorflow的PSO实现。<a class="ae kv" href="https://colab.research.google.com/drive/1sbjMwPR9L8gqopqawhsMMAgNvVjUEFIZ?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接到colab </a>。</p></blockquote><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/4dd38fa5bacf41a4c9b5063f780d004a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CtchhpRSbXwXmJRt"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mehdisepehri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈赫迪·塞佩赫里</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8e49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PSO有大量的资源，所以我将避免详细解释算法，并在这里留下<a class="ae kv" href="https://ieeexplore.ieee.org/abstract/document/488968?casa_token=nzrs9VtO2iQAAAAA:IO-ohAPG_GzEqF7SQ-G9Lriz4KTQprThJrh0MHFzbEJ5HdBI6Lri5vbk0bzUpbUVUYT-lX2gGg" rel="noopener ugc nofollow" target="_blank">原始论文</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Particle_swarm_optimization" rel="noopener ugc nofollow" target="_blank">维基百科文章的链接。</a>目前，可以说PSO是一种基于蜂群的元启发式优化。群体中的每个粒子将使用其个人信息加上群体信息，试图找到函数的最优值。那些信息分别被称为<em class="kr"> p-best </em> best和<em class="kr"> g-best </em>，它们基本上是粒子访问的最佳地点，也是所有蜂群看到的最佳地点。</p><blockquote class="lm"><p id="529d" class="ln lo it bd lp lq lr ls lt lu lv kn dk translated">使用tensorsflow进行PSO的一个好处是，你可以将所有的群体信息作为tensor来处理。然后，您可以一次性更新。所有的群体速度和位置可以一次更新。</p></blockquote><p id="654f" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">每个粒子都会有一个位置<strong class="js iu"> ( <em class="kr"> 𝜃 </em> </strong>)、一个速度(<strong class="js iu"> <em class="kr"> 𝑣 </em> </strong>)、一个个体最佳(<strong class="js iu"> <em class="kr"> 𝑝𝑏𝑒𝑠𝑡 </em> </strong>)。并且蜂群会有全局最优(<strong class="js iu"> <em class="kr"> 𝑔𝑏𝑒𝑠𝑡 </em> </strong>)，这是任何粒子曾经访问过的最优位置。因为我们正在使用<code class="fe mb mc md me b">tensorflow</code>，我们可能在一个张量中有这个信息，避免在群体上循环，所以我们将有:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/c710f627f4070af28d82434ffe8c5e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*L8rEBDIWCaC5C7zTLN2Zuw.png"/></div></figure><p id="1d70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以在一次操作中更新整个群体的速度:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mg"><img src="../Images/4894e9c8e18ea01f3ba9ef2bab4ed233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuVEspd6yiV203CF-sBrRw.png"/></div></div></figure><p id="cd36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">，其中<strong class="js iu"> <em class="kr"> 𝑐1 </em> </strong>和<strong class="js iu"> <em class="kr"> 𝑐 </em> 2 </strong>分别为认知和社会系数，<strong class="js iu"> <em class="kr"> 𝑟 </em> 1 </strong>和<strong class="js iu"> <em class="kr"> 𝑟 </em> 2 </strong>为[-1，1]范围内均匀分布的随机数。则粒子位置被更新为:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/998d446d7176b7d52b2dbacab7366897.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*2vnfLzv51TTxri2vQWH29A.png"/></div></figure><p id="e49b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我将所有这些步骤放在PSO算法中，右图帮助我们理解单个粒子的行为。请注意，合成向量<strong class="js iu"> <em class="kr"> v(t+1) </em> </strong>(红色)基本上是由给定迭代中粒子的三种运动组成的，即惯性(<strong class="js iu"> βv(t) </strong>，这是一个与上一次迭代指向相同方向的向量)、本能运动(<strong class="js iu"> <em class="kr"> vp </em> </strong>，这是一个指向<strong class="js iu"> <em class="kr"> pbest </em> </strong>的向量)和集体运动(<strong class="js iu">)</strong></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mi"><img src="../Images/5ea4d49dd370c893d7e7774c3646c6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoaitsZZr6E28YtS2GcTlA.png"/></div></div></figure><p id="2315" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有这个算法的<code class="fe mb mc md me b">tensorflow</code>实现(你也可以查看<a class="ae kv" href="https://colab.research.google.com/drive/1sbjMwPR9L8gqopqawhsMMAgNvVjUEFIZ?usp=sharing" rel="noopener ugc nofollow" target="_blank"> colab </a>):</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6ee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你注意到了吗？只有一个<code class="fe mb mc md me b">for</code>循环，用于迭代。因为我们处理的是张量，所以没有必要遍历群中的每个粒子。</p><p id="93d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们来举个例子。我们可以尝试在一个球面上找出最优解，这是一个简单的函数，有助于可视化群体的行为。所以我们的适应度函数将被定义为:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ml"><img src="../Images/91517d8920918010729abf1f9d32be9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUb4FFWh_kZYR3ORR_padQ.png"/></div></div></figure><p id="b267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以实例化上面定义的类来找到这个球体的中心:</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="da49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码将创建一个由100个均匀分布在[-1，1]之间的粒子组成的群体(因为它是用之前定义的类的默认参数来构建群体的)。优化过程可以在下一个动画中看到:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mm"><img src="../Images/9c87f027c8aac799cd877c274b8d14c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PgmU34oNVmoTKux4H0-JHA.gif"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">作者图片</figcaption></figure><p id="7c76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们比较不同大小的蜂群。贝娄，我们有一个仅由2个粒子组成的蜂群，另一个由100个粒子组成(我将轨迹留在顶部图中，因为很难跟踪只有2个粒子的运动)。请注意，对于较小的群体来说，找到收敛点有多难:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/5fbc85fa8ad1dc75e751d8daa18477f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*K3Pso5RVp2JTmmNzHapemA.gif"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">作者图片</figcaption></figure><p id="3d8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是所谓的香草粒子群算法，基本和最简单的版本。它是一个单峰优化器，这意味着它只能在不超过一个最优点的函数中找到最优。有许多不同版本的粒子群算法，其中许多提出了改变来处理这一问题。但是一个简单的解决方案是多个群体。下面，在左图中，我们只有一个100人的群体试图找到多个最佳点。在右边，我们把这个群体分成四组，每组25个个体，很容易注意到他们可以更容易地找到多个最优解。记住:那只是一个例子。有更好的方法来处理多模态优化。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi mm"><img src="../Images/367f2601bf29310428cc8fd77797af91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZMD24XJck8ixuyIT76HhYA.gif"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">作者图片</figcaption></figure><p id="cabd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！希望你喜欢这本书。如果您有任何问题或建议，请联系我！祝你愉快！</p></div></div>    
</body>
</html>