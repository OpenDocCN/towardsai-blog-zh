<html>
<head>
<title>A Basic Perceptron Model Using Least Squares Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于最小二乘法的基本感知器模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/basic-perceptron-model-using-least-squares-method-17900e0d1eff?source=collection_archive---------0-----------------------#2019-09-12">https://pub.towardsai.net/basic-perceptron-model-using-least-squares-method-17900e0d1eff?source=collection_archive---------0-----------------------#2019-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b4c6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">用Python | <a class="ae ep" href="https://towardsai.net" rel="noopener ugc nofollow" target="_blank">建立一个面向AI </a>的基本感知器模型</h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/d836c9b3fd058789be7251e47b858aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOTAw_CV2-_S5kWB7wbl9g.png"/></div></div></figure><p id="2134" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">就像组成人类神经系统的数十亿个神经元一样，感知器是人工智能的基本单元。我们做出的每一个想法、行动、情感或决定都反映了神经系统的活动，神经系统是一个控制和沟通你身体每一部分的主系统。生物智能依赖于这种由数十亿神经元组成的复杂机制，这些神经元组织在不同的层中，通过电信号和化学信号相互交流。</p><p id="1c10" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">为了理解生物智能是如何产生的，重要的是要理解被称为神经元的基本构件是如何工作的。</p><p id="d54a" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">生物神经元有3个主要功能:</p><ol class=""><li id="d96f" class="li lj it km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated"><strong class="km jd">感觉输入</strong>。神经元利用其树突(感受区域)来监控身体内外发生的变化。收集的信息被称为感官输入。</li><li id="fa10" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><strong class="km jd">整合</strong>:细胞体系统处理和解释感觉输入，并决定每个时刻应该做什么，这个过程叫做整合。如果感觉输入低于某个阈值，感觉信号就不会被激活。</li><li id="e362" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><strong class="km jd">电机输出</strong>。如果感觉输入信号高于某个阈值，神经元就会产生输出，由神经递质通过突触间隙传递。神经递质会刺激或抑制附近的神经元。</li></ol><p id="97d4" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">与生物智能类似，人工智能是由称为感知机的基本构建模块的复杂网络产生的。感知器的工作原理与神经元相同:</p><ol class=""><li id="b94c" class="li lj it km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated">投入</li><li id="e7e1" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">综合</li><li id="5862" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">输出</li></ol><p id="cb9f" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这里我们将重点讨论如何使用python构建一个基本的感知器模型。这一知识是理解更高级模型(如神经网络)的基础，神经网络是由成千上万亿个感知器组成的复杂系统，具有产生人工智能系统(如自动驾驶汽车)的能力。</p><h1 id="e946" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">基本感知机模型</h1><p id="2721" class="pw-post-body-paragraph kk kl it km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh im bi translated">Python的<em class="mz"> sklearn </em>包包含了几个分类器，比如<em class="mz">感知器</em>、<em class="mz">SupportVectorClassifier</em>、<em class="mz">logisticregressionclassifier</em>、<em class="mz"> DecisionTreeClassifier </em>、<em class="mz"> RandomForestClassifier </em>和<em class="mz"> KNN分类器</em>。虽然使用这些现成的机器学习算法很重要，但该领域的每个初学者都必须掌握这些算法如何工作的基础知识。开始进入神经网络和深度学习模型的旅程的一个好地方是考虑感知器。</p><p id="9269" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在这个例子中，我们构建了一个简单的感知器模型，其中学习权重是使用最小二乘法计算的。</p><p id="879f" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">感知器模型有以下四个主要步骤:</p><ol class=""><li id="24af" class="li lj it km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated"><strong class="km jd">训练</strong></li><li id="d33f" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><strong class="km jd">激活</strong></li><li id="7a0d" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><strong class="km jd">量子化</strong></li><li id="1fd1" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><strong class="km jd">预测</strong></li></ol><figure class="na nb nc nd gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/d836c9b3fd058789be7251e47b858aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOTAw_CV2-_S5kWB7wbl9g.png"/></div></div></figure><p id="33cc" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd"> X </strong>表示属性或预测矩阵，<strong class="km jd"> y </strong>表示类。我们将使用<a class="ae ne" href="https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a>来说明我们的模型。数据集包含以下属性信息:</p><ol class=""><li id="7efb" class="li lj it km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated">萼片长度，单位为厘米</li><li id="837b" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">萼片宽度，单位为厘米</li><li id="0b88" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">花瓣长度(厘米)</li><li id="38d4" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">花瓣宽度(厘米)</li></ol><p id="e5fe" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这三个类别是</p><ol class=""><li id="7c5c" class="li lj it km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated">刚毛鸢尾</li><li id="e898" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">杂色鸢尾</li><li id="f07d" class="li lj it km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">海滨鸢尾</li></ol><p id="fdf7" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">为简单起见，我们执行二元分类。出于实际原因，我们使用两个花类Setosa和Versicolor。然而，感知器算法可以扩展到多类分类，例如，通过一对一技术。</p><h1 id="db54" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使用Python实现模型</h1><p id="d9cb" class="pw-post-body-paragraph kk kl it km b kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld my lf lg lh im bi translated">这段代码将感知器分类算法应用于虹膜数据集。使用最小二乘法计算用于计算激活函数的权重。这种方法不同于Rosenblatt的原始感知器规则，在该规则中，权重是递归计算的。关于Rosenblatt感知器算法实现的更多信息，请参见以下书籍:《Python机器学习<em class="mz">》作者Sebastian Raschka。</em></p><p id="e823" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">导入必要的库</strong></p><pre class="na nb nc nd gt nf ng nh ni aw nj bi"><span id="8478" class="nk lx it ng b gy nl nm l nn no">import pandas as pd</span><span id="e244" class="nk lx it ng b gy np nm l nn no">import numpy as np</span><span id="3b1e" class="nk lx it ng b gy np nm l nn no">import matplotlib.pyplot as plt</span><span id="0c72" class="nk lx it ng b gy np nm l nn no">from sklearn.model_selection import train_test_split</span></pre><p id="2cbe" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">定义感知器分类器对象</strong></p><pre class="na nb nc nd gt nf ng nh ni aw nj bi"><span id="4c8b" class="nk lx it ng b gy nl nm l nn no">class Perceptron(object):<br/>    """Perceptron classifier using least-square method to calculate weights.<br/>      <br/>    Attributes<br/>    -----------<br/>    w : 1d-array<br/>        Weights after fitting.<br/>    """   <br/>    def fit(self, X, y):<br/>        """Fit training data.<br/>        <br/>        Parameters<br/>        ----------<br/>        X : {array-like}, shape = [n_samples, n_features]<br/>        Training vectors, where n_samples is the number of samples and n_features is the number of features.<br/>        y : array-like, shape = [n_samples]<br/>        Target values.<br/>        Returns<br/>        -------<br/>        self : object<br/>        """<br/>        self.w = np.dot(np.linalg.inv(np.dot(X.T,X)),np.dot(X.T,y))<br/>        return self<br/>    <br/>    def predict(self, X):<br/>        """Return class label after unit step"""<br/>        return np.where(np.dot(X,self.w) &gt;= 0.0, 1, -1)</span></pre><p id="4802" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">导入虹膜数据集</strong></p><pre class="na nb nc nd gt nf ng nh ni aw nj bi"><span id="0d82" class="nk lx it ng b gy nl nm l nn no">df = pd.read_csv('iris.data.csv', header=None)print(df.tail())<br/>y = df.iloc[0:100, 4].values<br/>y = np.where(y == 'Iris-setosa', -1, 1)<br/>X = df.iloc[0:100, 0:4].values</span><span id="b1dc" class="nk lx it ng b gy np nm l nn no">plt.scatter(X[:50, 0], X[:50, 2],color='red', marker='o', label='setosa')</span><span id="8f03" class="nk lx it ng b gy np nm l nn no">plt.scatter(X[50:100, 0], X[50:100, 2],color='blue', marker='x', label='versicolor')</span><span id="a2ed" class="nk lx it ng b gy np nm l nn no">plt.xlabel('sepal length (cm)')<br/>plt.ylabel('petal length (cm)')<br/>plt.legend(loc='upper left')<br/>plt.show()</span></pre><figure class="na nb nc nd gt kd gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dd88b4b5a1c9dcd3e1f752a54d414168.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*bSc1rC7RgApgWCd9VMycbQ.png"/></div></figure><p id="ac6c" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km jd">培训、测试和评估</strong></p><pre class="na nb nc nd gt nf ng nh ni aw nj bi"><span id="f5f7" class="nk lx it ng b gy nl nm l nn no">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=21, stratify=y)<br/>ppn = Perceptron()<br/>ppn.fit(X_train,y_train)<br/>y_pred=ppn.predict(X_test)<br/>accuracy = 100*np.sum(y_pred==y_test)/len(y_test)<br/>print("accuracy of the model:= " + str(accuracy))</span></pre><p id="8b6c" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">总之，我们已经演示了如何使用最小二乘法在python中构建一个基本的感知器模型，用于计算权重，然后用于计算激活函数。感知器模型是更高级的神经网络系统的基本构件。每个深度学习和人工智能领域的初学者都应该掌握感知机模型的基础知识。</p><p id="be6a" class="pw-post-body-paragraph kk kl it km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">本文的代码和数据集可以从这个Github资源库下载:<a class="ae ne" href="https://github.com/bot13956/perceptron_classifier" rel="noopener ugc nofollow" target="_blank">https://github.com/bot13956/perceptron_classifier</a>。</p></div></div>    
</body>
</html>