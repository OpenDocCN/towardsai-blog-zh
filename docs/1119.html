<html>
<head>
<title>Graphing The SIR Model With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python绘制SIR模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/graphing-the-sir-model-with-python-e3cd6edb20de?source=collection_archive---------0-----------------------#2020-11-05">https://pub.towardsai.net/graphing-the-sir-model-with-python-e3cd6edb20de?source=collection_archive---------0-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="66be" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="eb66" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">绘制和求解联立微分方程以模拟新冠肺炎扩展</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/8cb8d3d8885b732305aa84affd36f8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*yHWOHI0NYdRlSu-H"/></div></figure><p id="c7ee" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果说新冠肺炎疫情有什么好处的话，那就是我们获得了大量的数据。鉴于技术进步，我们可以获得更多的信息和计算能力，我们可以用这些来预测和遏制病毒的传播。最简单的方法之一是通过SIR模型。</p><p id="1e71" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SIR是一个房室模型，它将一个<em class="ls">常数</em>的人群分为三组，即易感人群、感染人群和康复人群。这些都可以表示为以时间为自变量的函数。</p><p id="c254" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">S(t) —易患该疾病的人数</p><p id="c463" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">I(t) —感染该疾病的人数</p><p id="914d" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">R(t) —不能感染他人的人；要么是康复的，要么是患病的(因此该组的更好名称可能是“移除的”)</p><p id="8151" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，在任一时刻t，S(t) + I(t) + R(t) = N，其中N是总人口。</p><h1 id="bc24" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">导入所需的Python库</h1><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="2b74" class="mq lu iq mm b gy mr ms l mt mu">from scipy.integrate import odeint</span><span id="c71d" class="mq lu iq mm b gy mv ms l mt mu">import numpy as np</span><span id="0890" class="mq lu iq mm b gy mv ms l mt mu">import matplotlib.pyplot as plt</span></pre><p id="9cb9" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用几个库来简化计算和绘图过程。SciPy库包含“用户友好且高效”的计算方法我们将在这个程序中使用他们的数值积分函数。我们还将使用Numpy表示浮点步长值，使用Matplotlib表示图形。</p><h1 id="7884" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">找出每个函数的变化率</h1><p id="b3ce" class="pw-post-body-paragraph kw kx iq ky b kz mw ka lb lc mx kd le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们不能直接为每个函数找到一个方程。但是我们可以推导出每个函数在t时刻的变化率，换句话说，这是一个导数。易感人群的数量通常从接近总人口开始。随着易感人群被感染，这个数字会随着时间的推移而减少。新感染人数是易感者和感染者之间可能相互作用的百分比。我们可以把这个感染率称为‘a’，而可能的相互作用是S(t)和I(t)的乘积。因此，易感人群的变化</p><p id="66fc" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">S'(t) = -a*S(t)*I(t)</p><p id="4da5" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">易感人数的减少和感染人数的增加是一样的。要求出I(t)的整导数，还必须考虑那些被感染后痊愈或死亡的人。这只是恢复率乘以当前感染人数。回收率为“b ”,则我们有</p><p id="a71d" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">I'(t) = a*S(t)*I(t) — b*I(t)</p><p id="90b9" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算R(t)的导数很简单，因为它只是I'(t)的第二项。在SIR模型中，恢复(或者更恰当地说是去除)只会随着时间的推移而增加。R(t)的增加是恢复率和感染人群的乘积:</p><p id="cef3" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">R'(t) = b*I(t)</p><p id="a9da" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以通过SciPy库使用这些导数来求解常微分方程组。</p><h1 id="8af6" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">定义必要的常数</h1><p id="8561" class="pw-post-body-paragraph kw kx iq ky b kz mw ka lb lc mx kd le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">从上面的等式中，我们看到有两个常数需要定义:传输速率和恢复速率。现在，我们将传输速率设置为100%，恢复速率设置为10%。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="2ec8" class="mq lu iq mm b gy mr ms l mt mu">a = 1 # infection rate<br/>b = 0.1 # recovery rate</span></pre><h1 id="a3dc" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">创建函数f(y，t)来计算导数</h1><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="1a40" class="mq lu iq mm b gy mr ms l mt mu"># FUNCTION TO RETURN DERIVATIVES AT T</span><span id="1f48" class="mq lu iq mm b gy mv ms l mt mu">def f(y,t):<br/>    S, I, R = y </span><span id="3c10" class="mq lu iq mm b gy mv ms l mt mu">    d0 = -a*S*I # derivative of S(t)</span><span id="a6b8" class="mq lu iq mm b gy mv ms l mt mu">    d1 = a*S*I — b*I # derivative of I(t)</span><span id="6ef0" class="mq lu iq mm b gy mv ms l mt mu">    d2 = b*I # derivative of R(t)</span><span id="6e4b" class="mq lu iq mm b gy mv ms l mt mu">    return [d0, d1, d2]</span></pre><p id="8a2d" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们必须定义一个函数来返回给定时间t的S(t)、I(t)和R(t)的导数，记住我们实际上已经求解过这些，只是将方程编码到一个函数中。在以下代码行中，d0、d1和d2分别是S、I和R的导数。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="563f" class="mq lu iq mm b gy mr ms l mt mu">d0 = -a*S*I # derivative of S(t)</span><span id="6527" class="mq lu iq mm b gy mv ms l mt mu">d1 = a*S*I — b*I # derivative of I(t)</span><span id="f6d8" class="mq lu iq mm b gy mv ms l mt mu">d2 = b*I # derivative of R(t)</span></pre><p id="aaec" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这里还没有定义S、I和R的值(尽管我们不需要R(t)来求它的导数)。由于这些函数相互依赖，我们将首先获得S(t)、I(t)和R(t)的先前值，以计算它们的导数。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="c441" class="mq lu iq mm b gy mr ms l mt mu">S, I, R = y</span><span id="9e3e" class="mq lu iq mm b gy mv ms l mt mu"># or</span><span id="b0e3" class="mq lu iq mm b gy mv ms l mt mu">S = y[0]<br/>I = y[1]<br/>R = y[2]</span></pre><p id="a1ea" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用下划线_代替变量R也是可以接受的，但是最好是明确的和描述性的。</p><h1 id="de3d" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">定义必要的初始值</h1><p id="5a49" class="pw-post-body-paragraph kw kx iq ky b kz mw ka lb lc mx kd le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在计算t时刻的函数值之前，我们必须先找到初始值。将菲律宾作为样本人群，2020年3月1日t=0。最初的易感人数是总人口，在109581078人左右。根据卫生部的新冠肺炎跟踪系统，2020年3月1日的初始病例为50人。当然，我们可以将恢复的总次数设为0。将值保持在0和1之间会使事情更清楚。这可以通过将所有值除以总体来实现。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="8dcf" class="mq lu iq mm b gy mr ms l mt mu">S_0 = 1<br/>I_0 = 50/109_581_078<br/>R_0 = 0</span></pre><p id="2a55" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将这些值存储在一个列表中会很有帮助，稍后我们会看到为什么这很重要。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="f1f1" class="mq lu iq mm b gy mr ms l mt mu">y_0 = [S_0,I_0,R_0]</span></pre><p id="8ccc" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也不要忘记定义域或时间范围。我们将使用Numpy的linspace来实现这一点，以便在需要时合并十进制值。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="ca8c" class="mq lu iq mm b gy mr ms l mt mu">t = np.linspace(start=1,stop=100,num=100)</span></pre><h1 id="4d78" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">用ODEInt解微分方程</h1><p id="f7d6" class="pw-post-body-paragraph kw kx iq ky b kz mw ka lb lc mx kd le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">既然我们已经定义了所有需要的变量、常数和函数，现在我们可以求解常微分方程组了。我们将按照时间范围中指定的100天的范围求解每个微分方程。通过设置所有参数，这样做实际上很简单；代码只有一行:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="78ce" class="mq lu iq mm b gy mr ms l mt mu">y = odeint(f,y_0,t)</span></pre><p id="27b8" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">f是我们前面定义的函数f(y，t)，y_0是我们初始值的列表，t是等距时间值的列表。</p><p id="e1cd" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量y实际上是一个Numpy ndarray，或者N维数组。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="5309" class="mq lu iq mm b gy mr ms l mt mu">&gt;&gt;&gt; print(type(y))<br/>&lt;class ‘numpy.ndarray’&gt;</span></pre><p id="d67f" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，odeint()函数返回一个二维数组。行是给定时间t的值的列表，而列表示S、I或R的值。S(t)的值在第一列中，I(t)在第二列中，R(t)在第三列中。因此，我们可以按如下方式访问它们:</p><p id="d7d6" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">位于第n行第m列的这种数组的元素可以被索引为</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="8ab1" class="mq lu iq mm b gy mr ms l mt mu">element = y[n,m]</span></pre><p id="2871" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用列表拼接来查看一列中的所有值。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="343f" class="mq lu iq mm b gy mr ms l mt mu">S = y[:,0]<br/>I = y[:,1]<br/>R = y[:,2]</span></pre><h1 id="9f63" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">绘制每个函数的值</h1><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="30a5" class="mq lu iq mm b gy mr ms l mt mu">plt.plot(t,S,’r’,label='S(t)')</span><span id="8013" class="mq lu iq mm b gy mv ms l mt mu">plt.plot(t,I,’b’,label='I(t)')</span><span id="3066" class="mq lu iq mm b gy mv ms l mt mu">plt.plot(t,R,’g’,label='R(t)')</span><span id="4544" class="mq lu iq mm b gy mv ms l mt mu">plt.legend()</span><span id="a0db" class="mq lu iq mm b gy mv ms l mt mu">plt.show()</span></pre><p id="5627" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">plot()函数中的前两个参数表示x和y值。然后我们可以指定每一行的颜色和标签。legend()函数在图表上放置一个图例，引用每一行的“label”关键字参数。</p><p id="a2c2" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用show()函数来实际生成图形。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/349e1dc53e69d515c487a98cd1e8a618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*BqK3Uvuxs8vCMpS2"/></div></figure><h1 id="9e4d" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">进一步探索</h1><p id="dab4" class="pw-post-body-paragraph kw kx iq ky b kz mw ka lb lc mx kd le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">值得指出的是，我们可以通过减小指定的步长值来提高图形的精度。(在这种情况下，通过增加“num”关键字参数)。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="f52f" class="mq lu iq mm b gy mr ms l mt mu">t = np.linspace(start=1,stop=100,num=200)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/c8b042ec53ddb10a6478e1879909e2b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*UxineIvAGrfEQ2Z_"/></div></figure><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="f30c" class="mq lu iq mm b gy mr ms l mt mu">t = np.linspace(start=1,stop=100,num=500)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/8992af60172ba0b20c6c09c90e25ffaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Le_nFqYVemNwtg1l"/></div></figure><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="cf47" class="mq lu iq mm b gy mr ms l mt mu">t = np.linspace(start=1,stop=100,num=1000)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/ffa6961ff01175831e187b7057ddd131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Hg-Sj45FcSH2djG2"/></div></figure><p id="ac0d" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，使传输和恢复率等参数更接近实际数据会使模型更准确。</p><p id="dbc1" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上所述，SIR模型展示了技术和数学在处理现实世界问题中的宝贵作用。</p><p id="e565" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在这里找到本文的代码:</p><p id="9e63" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae nb" href="https://github.com/JoaquindeCastro/SIR-Model/blob/main/SIR-ODE-Integrate.py" rel="noopener ugc nofollow" target="_blank">https://github . com/JoaquindeCastro/SIR-Model/blob/main/SIR-ODE-integrate . py</a></p><h1 id="189b" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">参考资料和资源</h1><div class="nc nd gp gr ne nf"><a href="https://www.maa.org/press/periodicals/loci/joma/the-sir-model-for-spread-of-disease-the-differential-equation-model" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ja gy z fp nk fr fs nl fu fw iz bi translated">疾病传播的SIR模型——微分方程模型</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">作为建模过程的第一步，我们确定自变量和因变量。独立报…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.maa.org</p></div></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://matplotlib.org/tutorials/introductory/pyplot.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ja gy z fp nk fr fs nl fu fw iz bi translated">Pyplot教程- Matplotlib 3.3.2文档</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">pyplot接口介绍。是使matplotlib像MATLAB一样工作的函数的集合。每个…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">matplotlib.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt ku nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://numpy.org/doc/stable/reference/arrays.ndarray.html#:~:text=An%20ndarray%20is%20a%20%28usually,the%20sizes%20of%20each%20dimension." rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ja gy z fp nk fr fs nl fu fw iz bi translated">N维数组(ndarray) - NumPy v1.19手册</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">是包含相同类型和大小的项的多维容器(通常大小固定)。维度的数量…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">numpy.org</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ku nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://www.doh.gov.ph/covid19tracker" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ja gy z fp nk fr fs nl fu fw iz bi translated">新冠肺炎追踪|卫生署网站</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">编辑描述</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.doh.gov.ph</p></div></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://www.sciencedirect.com/science/article/pii/S0960077920304549" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ja gy z fp nk fr fs nl fu fw iz bi translated">新冠肺炎在不同社区传播的SIR模型假设</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在这篇论文中，我们研究了由于小说《疫情》的传播而导致的建模方法的有效性</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.sciencedirect.com</p></div></div><div class="no l"><div class="nv l nq nr ns no nt ku nf"/></div></div></a></div></div></div>    
</body>
</html>