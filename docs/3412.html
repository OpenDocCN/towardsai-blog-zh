<html>
<head>
<title>Here Is Why You Probably Use numpy.std Incorrectly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是您可能不正确使用numpy.std的原因</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/here-is-why-you-probably-use-numpy-std-incorrectly-276c40aaf82e?source=collection_archive---------1-----------------------#2022-12-17">https://pub.towardsai.net/here-is-why-you-probably-use-numpy-std-incorrectly-276c40aaf82e?source=collection_archive---------1-----------------------#2022-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a07" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中如何正确估计标准差</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16c17fdf2b74fec3f6d86477f1ccb930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDzNrviLdJkdUIJ7fazM8g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">钟形正态分布。图片由<a class="ae ky" href="https://pixabay.com/users/openclipart-vectors-30363/" rel="noopener ugc nofollow" target="_blank">openclipbart-Vectors</a>在<a class="ae ky" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上生成</figcaption></figure><p id="a2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大小为<em class="lv"> N </em>的正态分布总体可以用其均值μ和标准差σ来描述。这种分布也被称为钟形曲线。</p><p id="4637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标准偏差(std)可以使用等式计算。1.</p><p id="1af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方差(var)就是标准差σ的平方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/c7310bf69e8402498113a1cdeb1c867f.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*IiWCSxyEyc3oUVGxZPFQ9g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">情商。1:大小为N且均值为μ的总体的标准差σ</figcaption></figure><p id="e136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">然而，如果我们用NumPy和pandas在Python中计算标准差，我们会得到不同的结果。</strong></p><p id="2d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，你会了解到为什么会这样。</p><h1 id="552f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">np.std vs熊猫std</h1><p id="e3de" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">下面是NumPy的std和pandas std对于一些随机数据点的输出<em class="lv"> X. </em></p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="d830" class="mz ly it mv b be na nb l nc nd">import numpy as np<br/>import pandas as pd<br/><br/>X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/><br/>df = pd.DataFrame({'X': X})<br/><br/>print(f"numpy std(X): {np.std(X)}")<br/>&gt;&gt; numpy std(X): 2.8722813232690143<br/><br/>print(f"pandas std(df): {df.std()}")<br/>&gt;&gt; pandas std(df): X    3.02765</span></pre><p id="e470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如你所见，NumPy给我们的标准差是2.87，pandas给我们的标准差是3.02。那么，哪个是真的呢？</strong></p><h1 id="896c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">贝塞尔校正</h1><p id="9860" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了理解这个问题，我们必须更深入地研究标准差这个话题。</p><p id="4d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为工程师或科学家，我们通常不知道真实的总体均值μ。然而，我们可以使用众所周知的等式从我们的数据点<em class="lv"> x </em>计算样本均值。2.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/cd3ca5aa912c49ac96db1de2390a4e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*rsUypVUeKMP7DK4rod-f5Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">情商。2:数据点x的样本平均值</figcaption></figure><p id="1f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过用样本均值<em class="lv"> m </em>代替总体均值μ，用样本大小<em class="lv"> n </em>代替总体大小<em class="lv"> N </em>，在等式。1、我们根据等式得到<strong class="lb iu">样本标准差</strong> <em class="lv"> s </em>。3.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/de1e8043e13f65f97260d412b9c7e9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*NOOTiJXqyho4PbjeptyK6w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">情商。3:样本标准偏差</figcaption></figure><p id="01ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定足够的数据点，我们希望样本标准差<em class="lv"> s </em>尽可能接近总体的真实标准差σ。数学上，这可以用期望值来表示。</p><p id="1ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，对于样本标准差来说，这是不成立的。情商。4表示样本标准差因附加项<em class="lv"> (n — 1)/n. </em>有偏<strong class="lb iu"/>，完整证明见参考文献[1]。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a44a683bc80dab616da25fd7af0d5d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*9Rjgcu5e0AjkyTDkqZ2mhQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">情商。4:样本标准差/方差有偏差[1]</figcaption></figure><p id="5b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过替换等式中的<em class="lv"> n </em>。3用<em class="lv">(n-1)</em>，我们得到方差的无偏估计和标准差的更好估计<em class="lv"> </em>。</p><p id="959e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这叫贝塞尔修正。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b2637b62600ca08e9f20676cd3f8bbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*68k2pbx-wuk30c6i1n1Egg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">情商。5:对总体标准差的更好估计(贝塞尔校正)</figcaption></figure><h1 id="677c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">解释np.std vs熊猫std</h1><p id="66cb" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">有了这些知识，我们现在可以解释np.std和pandas std函数之间的区别。</p><p id="e194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，NumPy使用<code class="fe ni nj nk mv b">1/n</code>(等式。3)，而pandas使用贝塞尔的校正与<code class="fe ni nj nk mv b">1/(n-1)</code>(等式。5).</p><p id="6dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过指定参数<code class="fe ni nj nk mv b">ddof</code>来改变NumPy的计算。</p><blockquote class="nl nm nn"><p id="0863" class="kz la lv lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu"> ddof: </strong> int，可选</p><p id="1fe5" class="kz la lv lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">意味着自由度增量。计算中使用的除数是<code class="fe ni nj nk mv b">N - ddof</code>，其中<code class="fe ni nj nk mv b">N</code>代表元素的个数。默认情况下<em class="it">的ddof </em>为零。</p></blockquote><p id="2d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们最初的Python例子，我们现在可以使用np.std中的参数<code class="fe ni nj nk mv b">ddof</code>来获得标准差的无偏估计。</p><pre class="kj kk kl km gt mu mv mw bn mx my bi"><span id="ffd3" class="mz ly it mv b be na nb l nc nd">import numpy as np<br/>import pandas as pd<br/><br/>X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/><br/>df = pd.DataFrame({'X': X})<br/><br/>print(f"pandas std(df): {df.std()}")<br/>&gt;&gt; pandas std(df): X    3.02765<br/><br/>print(f"numpy std (X, ddof=1): {np.std(X, ddof=1)}")<br/>&gt;&gt; numpy std (X, ddof=1): 3.0276503540974917</span></pre><p id="4854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ni nj nk mv b">np.std</code>中设置参数<code class="fe ni nj nk mv b">ddof = 1</code>现在给出了3.02的标准偏差。我们在熊猫身上得到了同样的结果。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3957" class="lx ly it bd lz ma ny mc md me nz mg mh jz oa ka mj kc ob kd ml kf oc kg mn mo bi translated">结论</h1><p id="03b3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">贝塞尔校正通过将<code class="fe ni nj nk mv b">n</code>替换为<code class="fe ni nj nk mv b">n — 1</code>来减少来自样本标准偏差<em class="lv"> s </em>的偏差。</p><p id="f5d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy的std函数使用公式<code class="fe ni nj nk mv b">n — ddof</code>。默认情况下，NumPy使用<code class="fe ni nj nk mv b">ddof = 0</code>，pandas使用<code class="fe ni nj nk mv b">ddof = 1</code>。</p><p id="b77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，如果你有一些来自总体的数据点，想用NumPy估计标准差，就用<code class="fe ni nj nk mv b">np.std(X, ddof = 1)</code>。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h2 id="33dd" class="od ly it bd lz oe of dn md og oh dp mh li oi oj mj lm ok ol ml lq om on mn oo bi translated">参考</h2><p id="dc89" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">[1]埃默里大学牛津学院——数学和计算机科学系，<a class="ae ky" href="http://mathcenter.oxford.emory.edu/site/math117/besselCorrection/" rel="noopener ugc nofollow" target="_blank">贝塞尔的修正</a>(访问日期:2022年12月14日)</p><p id="089d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">米（meter的缩写））霍利克，<a class="ae ky" href="https://doi.org/10.1007/978-3-642-38300-7_3" rel="noopener ugc nofollow" target="_blank">工程师概率统计导论</a> (2013)，施普林格，柏林，海德堡。</p><p id="5a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫。data frame . STD:<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.std.html" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas。DataFrame.std.html</a>(访问日期:2022年12月14日)</p><p id="1b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">numpy . STD:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.std.html" rel="noopener ugc nofollow" target="_blank">https://numpy . org/doc/stable/reference/generated/numpy . STD . html</a>(访问时间:2022年12月14日)</p></div></div>    
</body>
</html>