<html>
<head>
<title>Heart Disease Prediction with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于机器学习的心脏病预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/heart-disease-prediction-with-machine-learning-52eaf239cf05?source=collection_archive---------0-----------------------#2022-01-02">https://pub.towardsai.net/heart-disease-prediction-with-machine-learning-52eaf239cf05?source=collection_archive---------0-----------------------#2022-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2bc8" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div class="gh gi jz"><img src="../Images/a75deb66fc6151418c0cbcb1b370fed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*sYAEoKJBrjCyv_kmpV1h2w.png"/></div></figure><h2 id="bd27" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">I .下载数据集</h2><h2 id="e49c" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">二。Python处理</h2><h2 id="3783" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">三。Python应用ML算法</h2><h2 id="13ef" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">四。分析</h2></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h2 id="9e30" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">I .下载数据集</h2><p id="670b" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls kp lt lu lv kt lw lx ly kx lz ma mb mc im bi translated">去这里下载资料:<a class="ae md" href="https://www.kaggle.com/ronitf/heart-disease-uci" rel="noopener ugc nofollow" target="_blank">心脏病UCI | Kaggle </a></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h2 id="bc97" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">二。Python处理</h2><p id="a760" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls kp lt lu lv kt lw lx ly kx lz ma mb mc im bi translated">一旦你下载了。csv，打开你的python编辑器。使用这段代码导入pandas并引入CSV文件作为数据帧:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1dfe" class="kg kh it mj b gy mn mo l mp mq">import pandas as pd<br/>dfstack=pd.read_csv(r'C:\Users\...\HeartDiseaseTrain-Test.csv')</span></pre><p id="6aee" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">让我们来看看这些列:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="70f3" class="kg kh it mj b gy mn mo l mp mq">print(dfstack.columns)</span></pre><p id="df63" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">当您运行该行时，将得到以下内容:</p><blockquote class="mw mx my"><p id="c22f" class="li lj mz lk b ll mr ln lo lp ms lr ls na mt lu lv nb mu lx ly nc mv ma mb mc im bi translated">索引(['年龄'，'性别'，'胸痛_类型'，'静息_血压'，[T4 '，'胆固醇'，'空腹_血糖'，'静息_心电图'，'最大心率'，[T5 '，'运动_诱发_心绞痛'，'老年峰值'，'斜率'，[T6 '，'血管_着色_荧光检查'，'地中海贫血'，'目标']，<br/>dtype = '对象')</p></blockquote><p id="d55a" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">如果查看数据框，您会注意到许多列都有<strong class="lk jd"> <em class="mz">分类数据。</em> </strong>例如，“性别”列有两个值:男性/女性等。</p><p id="1ddb" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">此时，我们希望将这些分类列转换成数字数据。最快的方法如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a725" class="kg kh it mj b gy mn mo l mp mq">df_stack = pd.get_dummies(dfstack, prefix_sep=’_’)</span></pre><p id="402d" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">get_dummies函数将识别分类列并将它们转换为数字数据。为了说明这一点，下面是我们在使用get_dummies后刚刚创建的df_stack的数据框中的列名:</p><blockquote class="mw mx my"><p id="0f5b" class="li lj mz lk b ll mr ln lo lp ms lr ls na mt lu lv nb mu lx ly nc mv ma mb mc im bi translated">指数(['年龄'，'静息血压'，'胆汁淤积'，'最大心率'，<br/>'老年峰值'，'目标'，'性别_女性'，'性别_男性'，<br/>'胸痛_类型_无症状'，'胸痛_类型_非典型心绞痛'，<br/>'胸痛_类型_非心绞痛'，<br/>'空腹血糖_大于120 mg/ml '，<br/>'空腹血糖_非典型心绞痛')</p></blockquote><p id="7164" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">您将会注意到，分类列被拆分成若干个唯一的选项。例如，性别列现在是sex_Male，另一列称为sex_Female。新闻不会像最初的专栏中那样说“男性”或“女性”，而是看起来像这样:</p><figure class="me mf mg mh gt kd gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3923a07465ede34b559c5088fe089f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*yJw1zR10cnHCpBtsCCSudQ.png"/></div></figure><p id="5c08" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">正如您所看到的，当性别是男性时，在sex_Male列中的那一行有一个1，在sex_Female列中有一个0。当性别是女性时，这种情况就会发生变化。</p><p id="467f" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">接下来，为了应用该算法，我们必须拆分我们正在预测的类列(在本例中称为“target”)和数据集的其余部分，这些部分是该算法将用来预测该列的特征。</p><p id="94c7" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">我们可以用下面的代码做到这一点:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="235b" class="kg kh it mj b gy mn mo l mp mq">X = df_stack.drop('target', axis=1)<br/>y = df_stack['target']</span></pre><p id="b226" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">如我们所见，我们删除了“目标”列，并将数据帧的其余部分分配给x。然后，我们只将“目标”列分配给y。</p><p id="3dbe" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">接下来，让我们导入必要的包来创建测试序列分割:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3d35" class="kg kh it mj b gy mn mo l mp mq">from sklearn.model_selection import train_test_split</span></pre><p id="dc33" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">以下是创建拆分的标准代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ce67" class="kg kh it mj b gy mn mo l mp mq">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.30)</span></pre><p id="a71e" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">接下来，我们将使用sklearn的standardScaler进行一些特征缩放。这是标准代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="96fd" class="kg kh it mj b gy mn mo l mp mq">from sklearn.preprocessing import StandardScaler<br/>sc = StandardScaler()<br/>X_train = sc.fit_transform(X_train)<br/>X_test = sc.transform(X_test)</span></pre><h2 id="9659" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">三。Python应用ML算法</h2><p id="08da" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls kp lt lu lv kt lw lx ly kx lz ma mb mc im bi translated">现在是使用预测算法的时候了。在这种情况下，我们将使用支持向量机:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa8b" class="kg kh it mj b gy mn mo l mp mq">from sklearn.svm import SVC<br/>svclassifier = SVC()<br/>svclassifier.fit(X_train, y_train)</span></pre><p id="ef0d" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">如您所见，我们正在将svc分类器算法应用于训练集。</p><p id="12ed" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">现在，我们可以像这样将测试集传递给预测函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3327" class="kg kh it mj b gy mn mo l mp mq">y_pred = svclassifier.predict(X_test)</span></pre><p id="ce82" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">这预测了X_test的标签。</p><h2 id="2525" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la iz bi translated">四。分析</h2><p id="aa10" class="pw-post-body-paragraph li lj it lk b ll lm ln lo lp lq lr ls kp lt lu lv kt lw lx ly kx lz ma mb mc im bi translated">为了理解我们的算法是如何工作的，我们需要打印出混淆矩阵和其他指标:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bcd5" class="kg kh it mj b gy mn mo l mp mq">from sklearn.metrics import classification_report, confusion_matrix<br/>print(confusion_matrix(y_test,y_pred))<br/>print(classification_report(y_test,y_pred))</span></pre><p id="979c" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">当您运行整个程序时，您将得到以下输出:</p><figure class="me mf mg mh gt kd gh gi paragraph-image"><div class="gh gi jz"><img src="../Images/a75deb66fc6151418c0cbcb1b370fed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*sYAEoKJBrjCyv_kmpV1h2w.png"/></div></figure><p id="4746" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">在sklearn中，预测标签在顶部，实际标签在左侧:</p><figure class="me mf mg mh gt kd gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a6f337fe7d54d8de503ca0117804b00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*GcIeTb4kpn32dAr3kSsOCA.png"/></div></figure><p id="b3f6" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">让我们计算一些指标来分析这个混淆矩阵显示了什么。</p><p id="4a1e" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">首先，让我们计算准确度:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1395" class="kg kh it mj b gy mn mo l mp mq">Accuracy → Correctly predicted / overall <br/>Correctly predicted is this --&gt; 141 + 152 = 293<br/>Overall is this --&gt; 141+152+9+6 = 308</span><span id="0b2b" class="kg kh it mj b gy nf mo l mp mq">Therefore, the overall accuracy will be: <br/><strong class="mj jd">293/308 = 95.13%</strong></span></pre><p id="2db1" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">虽然准确性很高，但我们要记住，这是一个生物疾病数据集。这一点之所以重要，是因为疾病诊断有一些与准确性同样重要的指标。第一个这样的指标是灵敏度，另一个是特异性。让我们先了解这些是什么，然后计算它们。</p><blockquote class="mw mx my"><p id="5bc7" class="li lj mz lk b ll mr ln lo lp ms lr ls na mt lu lv nb mu lx ly nc mv ma mb mc im bi translated"><strong class="lk jd">第一个这样的指标是敏感性，另一个是特异性。</strong></p></blockquote><p id="bf8b" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">灵敏度的公式如下:</p><p id="715d" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated"><strong class="lk jd">灵敏度=真阳性数/(真阳性数+假阴性数)</strong></p><p id="31b9" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">让我们分解一下，来理解<strong class="lk jd">敏感度告诉我们什么。</strong></p><p id="6d36" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">公式的分母是真阳性和假阴性的总和。让我们逐一检查这些术语。</p><p id="4311" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated"><strong class="lk jd">真阳性</strong>是指该人在患病时被诊断为患病(即阳性诊断)，即做出正确的阳性诊断。</p><p id="3312" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated"><strong class="lk jd">假阴性</strong>表示该人被诊断为未患病(即阴性诊断)，但他们已患病。</p><blockquote class="mw mx my"><p id="48e5" class="li lj mz lk b ll mr ln lo lp ms lr ls na mt lu lv nb mu lx ly nc mv ma mb mc im bi translated">所以，如果加上<strong class="lk jd">真阳性和假阴性，得到的就是混淆矩阵中的患病总人数。</strong></p></blockquote><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c7ef" class="kg kh it mj b gy mn mo l mp mq">Sensitivity = number of true positives / (number of true positives + number of false negatives)<br/>Sensitivity = 152/(6+152) --&gt; 96.2%<br/></span></pre><p id="6814" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">因此，我们现在知道，在96.2%的情况下，该算法能够正确预测一个人实际上患有疾病。</p><p id="ce73" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">现在让我们看看特异性:</p><p id="398d" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated"><strong class="lk jd">特异性=真阴性数/(真阴性数+假阳性数)</strong></p><p id="fd81" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">真阴性意味着测试预测这个人没有疾病，而实际上他们并没有。</p><p id="05c3" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">假阳性意味着测试预测该人确实患有该疾病，但这是假的，即该人实际上并未患有该疾病。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="df06" class="kg kh it mj b gy mn mo l mp mq">Specificity =  number of true negatives / (number of true negatives + number of false positives)<br/>Specificity = 141/(141+9) --&gt; 94%</span></pre><p id="b322" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">因此，我们现在知道，在94%的情况下，该算法能够正确预测一个人没有患病，而他们实际上并没有患病。</p><p id="8d08" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">感谢阅读。</p><p id="9c3b" class="pw-post-body-paragraph li lj it lk b ll mr ln lo lp ms lr ls kp mt lu lv kt mu lx ly kx mv ma mb mc im bi translated">其他一些作品的链接:</p><div class="ng nh gp gr ni nj"><a rel="noopener  ugc nofollow" target="_blank" href="/machine-learning-cdbf0047af06"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jd gy z fp no fr fs np fu fw jc bi translated">机器学习</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">基于细胞图像的机器学习/生物统计学诊断急性淋巴细胞白血病</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">pub.towardsai.net</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ke nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-create-a-proximity-positioning-system-for-a-city-451ad19784d3"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jd gy z fp no fr fs np fu fw jc bi translated">如何为城市创建一个邻近定位系统</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">这里使用的距离算法来自以下链接中的代码:</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">pub.towardsai.net</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ke nj"/></div></div></a></div></div></div>    
</body>
</html>