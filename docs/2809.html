<html>
<head>
<title>The Guide To Data Analysis With Duck DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Duck DB数据分析指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-guide-to-data-analysis-with-duck-db-93a79950a08f?source=collection_archive---------0-----------------------#2022-06-01">https://pub.towardsai.net/the-guide-to-data-analysis-with-duck-db-93a79950a08f?source=collection_archive---------0-----------------------#2022-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cf0d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Duck DB将帮助您在数据分析职业生涯中更上一层楼。该指南将帮助您理解Python API和使用SQL脚本读取CSV文件的各种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f13900ef24703e6b79f8c530c82bc22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFBJcFL355Fccyb3LaA0Dw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="e5fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据分析师的生活围绕着通过SQL serve加载数据，使用各种Python包分析数据，并最终创建技术报告。有时这些SQL查询可能需要更长的时间来处理，因为您的数据是以TB为单位的。在这个快节奏的世界中，这种策略失败得很惨，大多数分析正在脱离传统的数据分析方式。<a class="ae lr" href="https://duckdb.org/" rel="noopener ugc nofollow" target="_blank"> DuckDB </a>解决了上面提到的所有问题，它与Python &amp; R集成。该数据库的工作方式类似于SQLite，专注于提供更快的分析查询。</p><p id="31f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本指南中，我们将深入学习运行DuckDB SQL查询的各种方式，并了解Deepnote集成。</p><h1 id="0a25" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">DuckDB</h1><p id="b511" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB是一个面向关系表的数据库管理系统，支持SQL查询来生成分析结果。它还附带了各种对数据分析有用的功能。</p><h2 id="354a" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">快速分析查询</h2><p id="a2ac" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB旨在运行更快的分析查询工作负载。它运行在一个列向量化的查询执行引擎上，该引擎可以一次性运行大量的流程。这使得运行<a class="ae lr" href="https://en.wikipedia.org/wiki/Online_analytical_processing" rel="noopener ugc nofollow" target="_blank">在线分析处理(OLAP) </a>比PostgreSQL等传统系统更快，后者按顺序处理每一行。</p><h2 id="c00b" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">简单操作</h2><p id="78c6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB采用简单性和嵌入式操作。</p><ul class=""><li id="71e1" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">没有外部依赖性的无服务器数据库</li><li id="39f9" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">处理查询时不导入或复制数据</li><li id="34a4" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">嵌入到宿主进程中</li><li id="9cc4" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">高速数据传输</li></ul><h2 id="fb5e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">功能丰富</h2><p id="e74c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB允许用户流畅地运行复杂的SQL查询。它还支持二级索引，以在单文件数据库中提供快速查询。DuckDB为Python和R提供了完全的集成，因此查询可以在同一个文件中执行。</p><h2 id="cfa2" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">免费和开源</h2><p id="ac93" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB可以免费使用，完整的代码可以在GitHub 上获得。它带有麻省理工学院的许可证，这意味着你可以将它用于商业目的。</p><h1 id="fafc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">正在创建数据库</h1><p id="9595" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB为您提供了连接数据库或使用类似命令<code class="fe np nq nr ns b">duckdb.connect(&lt;db name&gt;,read_only=False)</code>创建新数据库的box体验。正如您在下图中看到的，SampleDB文件已经在您的目录中创建。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="585c" class="mp lt iq ns b gy nx ny l nz oa">import duckdb<br/>conn = duckdb.connect(“SampleDB”,read_only=False)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2a5388c043bd685b1d2e6d083b9a2910.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*OxXl2ueTbWyfJXU4yrXHqg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="1747" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运筹学</p><p id="973b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">DuckDB还允许您使用<code class="fe np nq nr ns b">duckdb.connect()</code>创建内存中的临时数据库。<code class="fe np nq nr ns b">conn.execute()</code>运行数据库中的所有查询请求。在本例中，我们将创建一个名为<em class="oc"> test_table </em>的临时表，其中包含整数形式的<strong class="kx ir"> i </strong>和字符串形式的<strong class="kx ir"> j </strong>。如果你熟悉SQL，理解查询请求不会有问题，但是如果你是SQL新手，我建议你看看这个神奇的备忘单。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="8d34" class="mp lt iq ns b gy nx ny l nz oa">conn = duckdb.connect()</span><span id="c36f" class="mp lt iq ns b gy od ny l nz oa"># run arbitrary SQL commands<br/>conn.execute(“CREATE TABLE test_table (i INTEGER, j STRING)”)</span></pre><h2 id="839e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">插入值</h2><p id="6a46" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">您可以使用SQL命令插入单个或多个值。在这一部分，我们使用execute向<em class="oc"> test_table </em>添加两个值。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="c2fb" class="mp lt iq ns b gy nx ny l nz oa">conn.execute(“INSERT INTO test_table VALUES (1, ‘one’),(9,’nine’)”)</span></pre><p id="bfed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了检查我们是否已经成功添加了值，我们将运行SQL来读取<strong class="kx ir"> i. </strong>的所有值。为了在<a class="ae lr" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>数据框架中显示查询结果，我们将添加<code class="fe np nq nr ns b">.fetchdf()</code>，如下所示。<strong class="kx ir">干得好，</strong>我们已经成功地添加了我们的菲力两个值。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="9e71" class="mp lt iq ns b gy nx ny l nz oa">conn.execute(“SELECT i from test_table “).fetchdf()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d78be48f578eacf11d0ad4b4201f6a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*TBnkszt25Cow6USN7JT1rA.png"/></div></figure><p id="e491" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还可以使用占位符作为参数，然后向<em class="oc"> test_table </em>添加一个数组。如果您熟悉Python框架，您会发现这种方法很容易执行。我们也可以使用<code class="fe np nq nr ns b">.executemany()</code>一次执行多个值。正如您在下面看到的，我们已经成功地将值添加到了<em class="oc"> test_table </em>中。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="976b" class="mp lt iq ns b gy nx ny l nz oa">conn.execute(“INSERT INTO test_table VALUES (?, ?)”, [2, ‘two’])</span><span id="bdd2" class="mp lt iq ns b gy od ny l nz oa">conn.executemany(“INSERT INTO test_table VALUES (?, ?)”, [[3, ‘three’], [4, ‘four’]])</span><span id="2165" class="mp lt iq ns b gy od ny l nz oa">conn.execute(“SELECT * from test_table “).fetchdf()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/18b75d5e9f19c9d34dfc60d0cd5055ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*60AcJskB7xE3aChLy9_pjQ.png"/></div></figure><p id="0c28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">.fetchnumpy()</code>以一个<a class="ae lr" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>数组的形式显示你的结果。事情将变得非常有趣，因为我们将学习各种方法来执行复杂的SQL查询以进行数据分析</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="970d" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">conn.execute(“SELECT * FROM test_table”).fetchnumpy()</strong></span><span id="bd95" class="mp lt iq ns b gy od ny l nz oa">{'i': array([1, 9, 2, 3, 4, 1, 9, 2, 3, 4, 1, 9, 2, 3, 4, 1, 9, 2, 3, 4, 1, 9,<br/>        2, 3, 4, 1, 9, 2, 3, 4], dtype=int32),<br/> 'j': array(['one', 'nine', 'two', 'three', 'four', 'one', 'nine', 'two',<br/>        'three', 'four', 'one', 'nine', 'two', 'three', 'four', 'one',<br/>        'nine', 'two', 'three', 'four', 'one', 'nine', 'two', 'three',<br/>        'four', 'one', 'nine', 'two', 'three', 'four'], dtype=object)}</span></pre><h1 id="f36a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">熊猫数据框架和SQL</h1><p id="80a4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在这一节中，我们将使用pandas dataframe并学习读取<code class="fe np nq nr ns b">.csv</code>文件的各种方法。首先，我们将使用字典创建一个简单的熊猫数据帧，然后我们将它添加到一个名为<em class="oc"> test_df的新表中。</em></p><p id="5e58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用SQL脚本查找所有的值<strong class="kx ir"> j </strong>，其中<strong class="kx ir"> i </strong>大于1。查询结果显示三个样本符合我们的条件。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="cd8e" class="mp lt iq ns b gy nx ny l nz oa">import pandas as pd</span><span id="4aa3" class="mp lt iq ns b gy od ny l nz oa">test_df = pd.DataFrame.from_dict({“i”:[1, 2, 3, 4], “j”:[“one”, “two”, “three”, “four”]})</span><span id="7f67" class="mp lt iq ns b gy od ny l nz oa">conn.register(“test_df”, test_df)</span><span id="ea37" class="mp lt iq ns b gy od ny l nz oa">conn.execute(“SELECT j FROM test_df WHERE i &gt; 1”).fetchdf()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7b86b9c9b2c4afaefbdc920654f27dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/format:webp/1*h_6NnRcBqoDhtBVX4cUSBg.png"/></div></figure><p id="f57c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步，我们将把<code class="fe np nq nr ns b">.csv</code>导入到pandas dataframe中，然后把它添加到新表<em class="oc"> bank_df </em>中。本例中使用的数据集来自<a class="ae lr" href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html" rel="noopener ugc nofollow" target="_blank"> GPL2 </a>许可下的<a class="ae lr" href="https://www.kaggle.com/kingabzpro/bank-debt-data" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>。结果显示年龄大于27岁时的实际回收量。随着每一步的进行，我们复杂的查询变得越来越容易执行。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b279" class="mp lt iq ns b gy nx ny l nz oa">df = pd.read_csv(“bank_data.csv”)</span><span id="4d27" class="mp lt iq ns b gy od ny l nz oa">conn.register(“bank_df”, df)</span><span id="bd44" class="mp lt iq ns b gy od ny l nz oa">conn.execute(“SELECT actual_recovery_amount FROM bank_df WHERE age &gt; 27”).fetchdf()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b68a891f6893d54b3e3574b5b1642916.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*Utvze2lX6QrdHSCjTuLoBg.png"/></div></figure><h1 id="e4be" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关系</h1><p id="46d7" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">关系API使用编程查询来评估关系命令链。简而言之，您可以对关系运行python函数并显示结果。结果包含经验树、列中的结果和预览中的结果。如果你现在感到困惑，那也没关系，因为我们将深入研究关系以及如何使用它们来获得分析结果。</p><h2 id="b5f9" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">装载关系</h2><p id="b9a1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">conn.from_df(test_df)</code>从现有的Pandas数据帧<em class="oc"> test_df </em>创建关系。通过打印<code class="fe np nq nr ns b">rel</code>，我们可以可视化整个数据帧。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="f1da" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel = conn.from_df(test_df)</strong></span><span id="f440" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel</strong></span><span id="d751" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>pandas_scan(140194817412592)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- i (BIGINT)<br/>- j (VARCHAR)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>i	j	<br/>BIGINT	VARCHAR	<br/>[ Rows: 4]<br/>1	one	<br/>2	two	<br/>3	three	<br/>4	four</span></pre><p id="e7db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您也可以使用<code class="fe np nq nr ns b">duckdb.df()</code>获得类似的结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="6510" class="mp lt iq ns b gy nx ny l nz oa">rel = duckdb.df(test_df)</span></pre><p id="a8e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">conn.table</code>从现有表格创建一个关系。在我们的例子中，我们使用的是<em class="oc">测试_表</em>。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="6272" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel = conn.table(“test_table”)</strong></span><span id="bd29" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel</strong></span><span id="92f2" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Scan Table [test_table]<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- i (INTEGER)<br/>- j (VARCHAR)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>i	j	<br/>INTEGER	VARCHAR	<br/>[ Rows: 5]<br/>1	one	<br/>9	nine	<br/>2	two	<br/>3	three	<br/>4	four</span></pre><p id="8625" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">.from_csv_auto</code>直接从<code class="fe np nq nr ns b">.csv</code>文件创建关系。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="07da" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel = duckdb.from_csv_auto(“bank_data.csv”)</strong></span><span id="30d0" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel</strong></span><span id="c40b" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>read_csv_auto(bank_data.csv)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- id (INTEGER)<br/>- expected_recovery_amount (INTEGER)<br/>- actual_recovery_amount (DOUBLE)<br/>- recovery_strategy (VARCHAR)<br/>- age (INTEGER)<br/>- sex (VARCHAR)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>id	expected_recovery_amount	actual_recovery_amount	recovery_strategy	age	sex	<br/>INTEGER	INTEGER	DOUBLE	VARCHAR	INTEGER	VARCHAR	<br/>[ Rows: 10]<br/>2030	194	263.540000	Level 0 Recovery	19	Male	<br/>1150	486	416.090000	Level 0 Recovery	25	Female	<br/>380	527	429.350000	Level 0 Recovery	27	Male	<br/>1838	536	296.990000	Level 0 Recovery	25	Male	<br/>1995	541	346.385000	Level 0 Recovery	34	Male	<br/>731	548	520.710000	Level 0 Recovery	35	Male	<br/>221	549	221.585000	Level 0 Recovery	33	Male	<br/>1932	560	373.720000	Level 0 Recovery	19	Female	<br/>1828	562	201.865000	Level 0 Recovery	22	Female	<br/>2001	565	504.885000	Level 0 Recovery	27	Male</span></pre><h2 id="a9ef" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">关系信息</h2><p id="a96f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">rel.alias</code>检查赋予关系的名称。在我们的例子中，它是<em class="oc"> bank_data.csv. </em></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="97b1" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.alias</strong></span><span id="f271" class="mp lt iq ns b gy od ny l nz oa">'bank_data.csv'</span></pre><p id="98b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过使用<code class="fe np nq nr ns b">.set_alias</code>来改变当前的别名。这可能对加入类似的关系有用。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="6035" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel2 = rel.set_alias(‘bank_data’)</strong></span><span id="0af2" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel2.alias</strong></span><span id="439f" class="mp lt iq ns b gy od ny l nz oa">'bank_data'</span></pre><p id="c1c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在<em class="oc">子查询_关系中的关系类型。</em></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="5b84" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.type</strong></span><span id="3685" class="mp lt iq ns b gy od ny l nz oa">'SUBQUERY_RELATION'</span></pre><p id="cd81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要检查关系的列名，只需使用<code class="fe np nq nr ns b">.columns</code>。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b701" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.columns</strong></span><span id="20e2" class="mp lt iq ns b gy od ny l nz oa">['id',<br/> 'expected_recovery_amount',<br/> 'actual_recovery_amount',<br/> 'recovery_strategy',<br/> 'age',<br/> 'sex']</span></pre><p id="780d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">.types </code>检查色谱柱类型。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="0b8f" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.types</strong></span><span id="7dd4" class="mp lt iq ns b gy od ny l nz oa">['INTEGER', 'INTEGER', 'DOUBLE', 'VARCHAR', 'INTEGER', 'VARCHAR']</span></pre><h2 id="f305" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">应用类似python的函数(单一函数)</h2><p id="a1f5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在有趣的部分来了。您可以使用该关系添加任何函数，它将显示增强的结果。在我们的例子中，我们使用了<code class="fe np nq nr ns b">rel.filter</code>，它显示年龄大于18岁的结果。它还显示了关于表达式树的附加信息，如果要运行一个很长的复杂查询，这将非常有用。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="442b" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.filter(‘age &gt; 18’)</strong></span><span id="c799" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Filter [age&gt;18]<br/>  read_csv_auto(bank_data.csv)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- id (INTEGER)<br/>- expected_recovery_amount (INTEGER)<br/>- actual_recovery_amount (DOUBLE)<br/>- recovery_strategy (VARCHAR)<br/>- age (INTEGER)<br/>- sex (VARCHAR)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>id	expected_recovery_amount	actual_recovery_amount	recovery_strategy	age	sex	<br/>INTEGER	INTEGER	DOUBLE	VARCHAR	INTEGER	VARCHAR	<br/>[ Rows: 10]<br/>2030	194	263.540000	Level 0 Recovery	19	Male	<br/>1150	486	416.090000	Level 0 Recovery	25	Female	<br/>380	527	429.350000	Level 0 Recovery	27	Male	<br/>1838	536	296.990000	Level 0 Recovery	25	Male	<br/>1995	541	346.385000	Level 0 Recovery	34	Male	<br/>731	548	520.710000	Level 0 Recovery	35	Male	<br/>221	549	221.585000	Level 0 Recovery	33	Male	<br/>1932	560	373.720000	Level 0 Recovery	19	Female	<br/>1828	562	201.865000	Level 0 Recovery	22	Female	<br/>2001	565	504.885000	Level 0 Recovery	27	Male</span></pre><p id="641c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">.project </code>将显示提到的列，在我们的例子中显示的是<strong class="kx ir"> id </strong>和<strong class="kx ir">年龄。</strong></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="cd45" class="mp lt iq ns b gy nx ny l nz oa"># project the relation, get some columns</span><span id="08a4" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel.project(‘id, age’)</strong></span><span id="da04" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Projection [id, age]<br/>  read_csv_auto(bank_data.csv)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- id (INTEGER)<br/>- age (INTEGER)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>id	age	<br/>INTEGER	INTEGER	<br/>[ Rows: 10]<br/>2030	19	<br/>1150	25	<br/>380	27	<br/>1838	25	<br/>1995	34	<br/>731	35	<br/>221	33	<br/>1932	19	<br/>1828	22	<br/>2001	27</span></pre><p id="2298" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过添加数字或使用任何算术函数来转换列值。在我们的例子中，它用+1显示年龄。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="5845" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.project(‘age + 1’)</strong></span><span id="59f9" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Projection [age + 1]<br/>  read_csv_auto(bank_data.csv)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- age + 1 (INTEGER)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>age + 1	<br/>INTEGER	<br/>[ Rows: 10]<br/>20	<br/>26	<br/>28	<br/>26	<br/>35	<br/>36	<br/>34	<br/>20	<br/>23	<br/>28</span></pre><p id="b80d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺序类似于SQL脚本<code class="fe np nq nr ns b">ORDER</code>。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="419d" class="mp lt iq ns b gy nx ny l nz oa">rel.order(‘sex’)</span></pre><p id="bbce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe np nq nr ns b">.limit</code>显示表格中的顶级样本。在我们的例子中，它将只显示前2个值。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="02b8" class="mp lt iq ns b gy nx ny l nz oa">rel.limit(2)</span></pre><h2 id="bacc" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">将所有函数堆叠在一个链中</h2><p id="f325" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">就像在R中一样，您可以堆叠所有的函数来获得SQL输出。在我们的例子中，它显示了年龄<em class="oc">大于27岁的人的前两个<em class="oc"> actual_recovery_amount </em>，按<em class="oc">性别</em>排序。我们现在意识到表达式树的全部优势。</em></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="516f" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.filter(‘age &gt; 27’).project(‘actual_recovery_amount’).order(‘sex’).limit(2)<br/></strong>---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Limit 2<br/>  Order [sex DESC]<br/>    Projection [actual_recovery_amount]<br/>      Filter [age&gt;27]<br/>        read_csv_auto(bank_data.csv)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- actual_recovery_amount (DOUBLE)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>actual_recovery_amount	<br/>DOUBLE	<br/>[ Rows: 2]<br/>278.720000	<br/>245.000000</span></pre><h2 id="c7dc" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">聚合函数</h2><p id="cfc4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">聚合函数可以执行多个组任务。在这种情况下，它是所有实际回收金额的总和。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="2f55" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.aggregate(“sum(actual_recovery_amount)”)</strong></span><span id="32bf" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Result Preview  --<br/>---------------------<br/>sum(actual_recovery_amount)	<br/>DOUBLE	<br/>[ Rows: 1]<br/>7529821.469511</span></pre><p id="038a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下函数将显示每个年龄组的<em class="oc"> actual_recovery_amount </em>的总和。我们有年龄栏和总和栏。这太酷了，因为我们把两个功能简化成了一个。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="ab25" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.aggregate(“age, sum(actual_recovery_amount)”)</strong></span><span id="9b21" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Result Preview  --<br/>---------------------<br/>age	sum(actual_recovery_amount)	<br/>INTEGER	DOUBLE	<br/>[ Rows: 10]<br/>19	52787.712089	<br/>25	72769.342330	<br/>27	67569.292950	<br/>34	109902.427032	<br/>35	115424.466724	<br/>33	138755.807230	<br/>22	46662.153746	<br/>31	92225.534688	<br/>18	39969.573274	<br/>32	110627.466806</span></pre><p id="954a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您只想显示actual _recovery金额的总和，则添加group by列作为第二个输入。在我们的例子中，它只显示了每个年龄的实际恢复量的总和。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="3871" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.aggregate(“sum(actual_recovery_amount)”, “age”)</strong></span><span id="3839" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Result Preview  --<br/>---------------------<br/>sum(actual_recovery_amount)	<br/>DOUBLE	<br/>[ Rows: 10]<br/>52787.712089	<br/>72769.342330	<br/>67569.292950	<br/>109902.427032	<br/>115424.466724	<br/>138755.807230	<br/>46662.153746	<br/>92225.534688	<br/>39969.573274	<br/>110627.466806</span></pre><p id="5aec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe np nq nr ns b">distinct()</code>显示唯一值</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="63da" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.distinct()</strong></span><span id="e5e7" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Result Preview  --<br/>---------------------<br/>id	expected_recovery_amount	actual_recovery_amount	recovery_strategy	age	sex	<br/>INTEGER	INTEGER	DOUBLE	VARCHAR	INTEGER	VARCHAR	<br/>[ Rows: 10]<br/>2030	194	263.540000	Level 0 Recovery	19	Male	<br/>1150	486	416.090000	Level 0 Recovery	25	Female	<br/>380	527	429.350000	Level 0 Recovery	27	Male	<br/>1838	536	296.990000	Level 0 Recovery	25	Male	<br/>1995	541	346.385000	Level 0 Recovery	34	Male	<br/>731	548	520.710000	Level 0 Recovery	35	Male	<br/>221	549	221.585000	Level 0 Recovery	33	Male	<br/>1932	560	373.720000	Level 0 Recovery	19	Female	<br/>1828	562	201.865000	Level 0 Recovery	22	Female	<br/>2001	565	504.885000	Level 0 Recovery	27	Male</span></pre><h2 id="85db" class="mp lt iq bd lu mq mr dn ly ms mt dp mc le mu mv me li mw mx mg lm my mz mi na bi translated">多关系运算符</h2><p id="542f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们可以通过使用<code class="fe np nq nr ns b">.union</code>在两个关系之间创建<code class="fe np nq nr ns b">UNION</code>，这结合了两个关系的结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="2643" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel.union(rel)<br/></strong>---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Union<br/>  read_csv_auto(bank_data.csv)  read_csv_auto(bank_data.csv)</span></pre><p id="c702" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在id为的列上连接两个关系。我们已经创建了<em class="oc"> rel2 </em>，并基于<em class="oc"> id将其加入到<em class="oc"> rel </em>中。</em></p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="08ba" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">rel2 = duckdb.df(df)</strong></span><span id="a284" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel.join(rel2, ‘id’)</strong></span><span id="471a" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Join<br/>  read_csv_auto(bank_data.csv)  pandas_scan(139890483423984)</span></pre><p id="fa0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了连接类似的关系，我们将使用<code class="fe np nq nr ns b">alias()</code>来改变别名，然后连接它们，如下所示。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b585" class="mp lt iq ns b gy nx ny l nz oa">rel.set_alias(‘a’).join(rel.set_alias(‘b’), ‘a.id=b.id’)</span><span id="8479" class="mp lt iq ns b gy od ny l nz oa"> — — — — — — — — — — — — Expression Tree — — — — — — — — — — — — Join read_csv_auto(bank_data.csv) read_csv_auto(bank_data.csv)</span></pre><h1 id="f89a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据帧上的DuckDB函数。</h1><p id="ef1f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们可以跳过创建关系，直接使用<code class="fe np nq nr ns b">duckdb.&lt;fucntion&gt;(&lt;dataframe&gt;,&lt;script&gt;)</code>进行过滤和排序。示例显示了如何直接使用Pandas dataframe创建结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="c453" class="mp lt iq ns b gy nx ny l nz oa">print(duckdb.filter(df, ‘age &gt; 1’))</span><span id="6c3f" class="mp lt iq ns b gy od ny l nz oa">print(duckdb.project(df, ‘age +1’))</span><span id="d25b" class="mp lt iq ns b gy od ny l nz oa">print(duckdb.order(df, ‘sex’))</span><span id="3d06" class="mp lt iq ns b gy od ny l nz oa">print(duckdb.limit(df, 2))</span></pre><p id="a051" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，我们可以创建一个函数链并显示结果，如下所示。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="0ee8" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">duckdb.filter(df, ‘age &gt; 1’).project(‘age + 1’).order(‘sex’).limit(2)</strong></span><span id="2cc8" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Limit 2<br/>  Order [sex DESC]<br/>    Projection [age + 1]<br/>      Filter [age&gt;1]<br/>        pandas_scan(139890483423984)<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- age + 1 (BIGINT)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>age + 1	<br/>BIGINT	<br/>[ Rows: 2]<br/>26	<br/>20</span></pre><h1 id="38a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关系查询结果</h1><p id="9733" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">要显示关系的结果，请使用:</p><ul class=""><li id="337d" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated"><strong class="kx ir"> fetchone() </strong>:仅显示第一行，您可以重复此命令，直到您循环所有行。</li><li id="b6d4" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><strong class="kx ir"> fetchall() </strong>:显示结果中的所有值。</li><li id="0852" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><strong class="kx ir"> fetchdf() </strong>:以熊猫数据帧的形式显示结果。</li><li id="a279" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><strong class="kx ir"> fethnumpy() </strong>:以numpy数组的形式显示结果。</li></ul><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="3c76" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">res = rel.execute()</strong></span><span id="70e5" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir"># res is a query result, you can call fetchdf() or fetchnumpy() or fetchone() on it</strong></span><span id="f135" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">print(res.fetchone())<br/></strong>(2030, 194, 263.54, ‘Level 0 Recovery’, 19, ‘Male’)</span><span id="b937" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">print(res.fetchall())</strong></span><span id="f0dc" class="mp lt iq ns b gy od ny l nz oa">[(1150, 486, 416.09, ‘Level 0 Recovery’, 25, ‘Female’), (380, 527, 429.35, ‘Level 0 Recovery’, 27, ‘Male’).....</span></pre><ul class=""><li id="889d" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">我们也可以通过使用如下所示的<code class="fe np nq nr ns b">rel.df()</code>或<code class="fe np nq nr ns b">rel.to_df()</code>将结果转换成熊猫数据帧。</li></ul><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="1c98" class="mp lt iq ns b gy nx ny l nz oa">rel.to_df()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/4a92c731a378aa2650a1e44765cf36fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZU-KIDryHLMp9sFN8qhEpA.png"/></div></div></figure><h1 id="4064" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">表格和DuckDB</h1><p id="49ff" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们也可以通过使用<code class="fe np nq nr ns b">.create</code>创建关系表</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="bd37" class="mp lt iq ns b gy nx ny l nz oa">rel.create(“test_table2”)</span></pre><p id="9be5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下一部分中，我们将学习在关系中插入值的各种方法。</p><ul class=""><li id="5cb5" class="nb nc iq kx b ky kz lb lc le nd li ne lm nf lq ng nh ni nj bi translated">创建一个新表<em class="oc"> test_table3。</em></li><li id="8d3e" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><em class="oc">使用</em> <code class="fe np nq nr ns b"><em class="oc">values()</em></code> <em class="oc">和</em> <code class="fe np nq nr ns b">insert_into(&lt;tablename&gt;)</code>插入数值</li><li id="54e8" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">使用test_table3创建关系。</li><li id="2cfa" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">使用simple将值插入关系中。插入函数。</li></ul><p id="c1ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如我们所见，我们成功地为我们的关系增加了一个价值。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="fe4d" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir"># Inserting elements into table_3</strong></span><span id="ecc0" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">conn.execute(“CREATE TABLE test_table3 (i INTEGER, j STRING)”)</strong></span><span id="f73c" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">print(conn.values([5, ‘five’]).insert_into(“test_table3”))</strong></span><span id="b1be" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel_3 = conn.table(“test_table3”)</strong></span><span id="df07" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel_3.insert([6,’six’])</strong></span><span id="ac73" class="mp lt iq ns b gy od ny l nz oa"><strong class="ns ir">rel_3</strong></span><span id="16ad" class="mp lt iq ns b gy od ny l nz oa">---------------------<br/>-- Expression Tree --<br/>---------------------<br/>Scan Table [test_table3]<br/><br/>---------------------<br/>-- Result Columns  --<br/>---------------------<br/>- i (INTEGER)<br/>- j (VARCHAR)<br/><br/>---------------------<br/>-- Result Preview  --<br/>---------------------<br/>i	j	<br/>INTEGER	VARCHAR	<br/>[ Rows: 2]<br/>5	five	<br/>6	six</span></pre><h1 id="b696" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">DuckDB查询函数</h1><p id="73c1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">要直接运行SQL查询，您可以对您的关系使用<code class="fe np nq nr ns b">.query</code>。然后添加第一个输入作为查询的视图名，第二个输入作为使用视图名的SQL脚本，如下所示。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="b617" class="mp lt iq ns b gy nx ny l nz oa">res = rel.query(‘my_name_for_rel’, ‘SELECT * FROM my_name_for_rel LIMIT 5’)</span></pre><p id="2cce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了查看结果，让我们使用<code class="fe np nq nr ns b">fetchall()</code>来显示所有5个值。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="7679" class="mp lt iq ns b gy nx ny l nz oa"><strong class="ns ir">res.fetchall()</strong></span><span id="6dbc" class="mp lt iq ns b gy od ny l nz oa">[(2030, 194, 263.54, 'Level 0 Recovery', 19, 'Male'),<br/> (1150, 486, 416.09, 'Level 0 Recovery', 25, 'Female'),<br/> (380, 527, 429.35, 'Level 0 Recovery', 27, 'Male'),<br/> (1838, 536, 296.99, 'Level 0 Recovery', 25, 'Male'),<br/> (1995, 541, 346.385, 'Level 0 Recovery', 34, 'Male')]</span></pre><p id="490c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以直接使用<code class="fe np nq nr ns b">.query()</code>并在<em class="oc"> test_df </em>表上运行查询。结果显示了表中的所有四个值。查询功能可以对你的表、数据帧甚至<code class="fe np nq nr ns b">.csv</code>文件执行所有功能。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="89ca" class="mp lt iq ns b gy nx ny l nz oa">res = duckdb.query(‘SELECT * FROM test_df’)</span><span id="a456" class="mp lt iq ns b gy od ny l nz oa">res.df()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/026551ebaea693327e2ef9ed88b3335c.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*qLgzwEWGoVMTp07M4BuZQQ.png"/></div></figure><p id="3c24" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了在<code class="fe np nq nr ns b">.csv</code>文件上运行查询，我们将在SQL脚本中使用<code class="fe np nq nr ns b">read_csv_auto()</code>。在我们的例子中，我们直接从CSV文件中读取全部数据，并在Pandas dataframe中显示出来。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="202b" class="mp lt iq ns b gy nx ny l nz oa">res = duckdb.query(“SELECT * FROM read_csv_auto(‘bank_data.csv’)”)</span><span id="efe6" class="mp lt iq ns b gy od ny l nz oa">res.df()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/3a241690bec99cb252db2d8d5fb80e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFH8UYuYHjWcx_CyBN6ORw.png"/></div></div></figure><p id="df2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们运行一个复杂的脚本，以便充分发挥DuckDB的潜力。下面的结果表明，使用4级策略从雌性动物身上回收的量比预期的多。使用SQL查询进行数据分析既快速又有趣，而不是将您的数据加载到pandas并编写一堆代码来获得类似的结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="a48d" class="mp lt iq ns b gy nx ny l nz oa">res = duckdb.query(“SELECT sex, SUM(expected_recovery_amount) as Expected,\<br/> SUM(actual_recovery_amount) as Actual \<br/> FROM ‘bank_data.csv’\<br/> WHERE recovery_strategy LIKE ‘Level 4 Recovery’\<br/> GROUP BY sex\<br/> HAVING sex = ‘Female’”)<br/>res.df()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/1929df748789ace85f42a9852dc9cd2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*aBLQxyveMuJf251NY5c4hA.png"/></div></figure><h1 id="b75a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Deepnote SQL单元格</h1><p id="970c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> Deepnote </a>的<a class="ae lr" href="https://docs.deepnote.com/features/sql-cells/dataframe-sql" rel="noopener ugc nofollow" target="_blank"> Dataframe SQL cell </a>是使用DuckDB实现的，所以如果你想要一个简单的方法来使用DuckDB的所有功能，我推荐你使用Deepnote SQL cell。要运行您的SQL查询，首先从block选项添加一个SQL单元格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c45f35916bee309cdb61a37f59c50e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*rHhj1QiUyVDQ9FDzU6GqqQ.png"/></div></figure><p id="bd7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尝试编写一个简单的SQL脚本。我们可以看到，我们直接从<em class="oc"> bank_data.csv </em>读取数据，结果以熊猫数据帧<em class="oc">的形式存储在<em class="oc"> df_1 </em>中。我很喜欢这个功能，它甚至比通过Pandas加载你的数据还要好。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/f212cb8283b5e5a1239dcc3281e91a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwJQ8UGejE2YdSvdhbCQGg.png"/></div></div></figure><p id="8846" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在CSV文件上尝试一个更复杂的SQL查询。我们将显示三列<em class="oc">性别、预期</em>和<em class="oc">实际</em>。然后，我们将选择<em class="oc"> recovery_stretagy </em>为“4级恢复”的值，并按<em class="oc">性别</em>分组。最后，我们只展示<em class="oc">女性价值观</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/ce3fc37025183f9e8e327461478f868b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CEYvpdJFE4x-u_QG17KFQ.png"/></div></div></figure><h1 id="1bae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="b4f3" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">DuckDB可以解决传统SQL数据库中存在的大多数问题。这是一个无服务器的数据库管理系统，具有更快的分析查询，并与Python和r完全集成。如果您打算部署数据科学或机器学习应用程序，我建议您将DuckDB添加到您的堆栈中。</p><p id="b34a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本指南中，我们学习了创建数据库、添加表和运行查询的各种方法。我们还学习了关系，我们可以用它们来创建复杂的函数。最后，我们使用了各种方式直接与CSV文件交互，并运行了多个复杂的脚本。这个指南包括各种各样的例子，所以如果你陷入了你的项目，你也可以回来学习一些技巧。</p><blockquote class="op oq or"><p id="2e4a" class="kv kw oc kx b ky kz jr la lb lc ju ld os lf lg lh ot lj lk ll ou ln lo lp lq ij bi translated">最后，我会一直建议你通过实践来学习基础知识，并寻找其他资源来提高你对各种数据库系统的知识。</p></blockquote><h1 id="0c95" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">学习资源</h1><ul class=""><li id="80c0" class="nb nc iq kx b ky mk lb ml le ov li ow lm ox lq ng nh ni nj bi translated">DuckDB:用于数据辩论的嵌入式数据库——开发社区👩‍💻👨‍💻</li><li id="7a4b" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated">【SQL教程(w3schools.com)【T2 T3】</li><li id="7182" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><a class="ae lr" href="https://duckdb.org/docs/sql/introduction" rel="noopener ugc nofollow" target="_blank"> DuckDB — SQL简介</a></li><li id="c98d" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><a class="ae lr" href="https://deepnote.com/@allan-campopiano/Intro-to-SQL-Cells-HxtuNpQrSrOwmEkwb8qB8w" rel="noopener ugc nofollow" target="_blank">SQL单元格介绍(deepnote.com)</a></li><li id="f2c3" class="nb nc iq kx b ky nk lb nl le nm li nn lm no lq ng nh ni nj bi translated"><a class="ae lr" href="https://docs.deepnote.com/features/sql-cells/dataframe-sql" rel="noopener ugc nofollow" target="_blank">数据框架SQL — Deepnote文档</a></li></ul><p id="73cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">转帖:</strong><a class="ae lr" href="https://www.analyticsvidhya.com/blog/2021/12/the-guide-to-data-analysis-with-duckdb/" rel="noopener ugc nofollow" target="_blank">原文</a>发布在Analytics Vidhya上。</p></div></div>    
</body>
</html>