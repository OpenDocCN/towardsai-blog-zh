<html>
<head>
<title>Building a Quantize Aware Trained Deep Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建量化感知训练的深度学习模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/building-quantize-aware-trained-deep-learning-model-e056c44d9a52?source=collection_archive---------1-----------------------#2020-09-06">https://pub.towardsai.net/building-quantize-aware-trained-deep-learning-model-e056c44d9a52?source=collection_archive---------1-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6277" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="b455" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解什么是量化，不同类型的量化，以及如何使用Quantize Aware培训构建TFLite模型。</h2></div><p id="d66a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">在这篇文章中，你将学习什么是量化，我们为什么需要量化，不同类型的量化，然后在Tensorflow中构建一个量化的感知训练深度学习模型。</em> </strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/8257d01679f30cd7a096abf4d39a3673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bcNclq4-fyOLQNaJ_kca5Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae me" href="https://unsplash.com/@othentikisra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">以色列宫</a>在<a class="ae me" href="https://unsplash.com/s/photos/electronic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="218e" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">什么是量子化？</h2><p id="cce4" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">量化是将深度学习模型参数:权重、激活和偏差从较高的浮点精度转换为较低的位表示的过程。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5730627d21f17c192df8d2f8b084395c.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*Qinv5Ooy5FpWMQeWqH9lJA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">从float32到uint8的量化权重、偏差和激活</figcaption></figure><h2 id="6256" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">为什么我们需要量子化？</h2><blockquote class="nd"><p id="d824" class="ne nf it bd ng nh ni nj nk nl nm lm dk translated">量化有助于模型压缩和减少延迟。</p></blockquote><p id="3b04" class="pw-post-body-paragraph kr ks it kt b ku nn kd kw kx no kg kz la np lc ld le nq lg lh li nr lk ll lm im bi translated">模型大小可以压缩4倍。如果你的TF core深度学习模型大小是40MB，可以减到10MB <em class="ln">。</em>模型尺寸的减小使得模型重量更轻，这减少了计算量并需要更少的内存，从而减少了延迟。</p><p id="472d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">量化模型</p><ul class=""><li id="eec2" class="ns nt it kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated"><strong class="kt jd">占用更少的空间</strong></li><li id="cbce" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">在带宽较低的网络上有更快的下载时间</li><li id="01ba" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">模型占用<strong class="kt jd">更少的内存，以获得<strong class="kt jd">更快的推理</strong></strong></li><li id="d72e" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated"><strong class="kt jd">降低功耗</strong></li></ul><blockquote class="nd"><p id="bf7b" class="ne nf it bd ng nh og oh oi oj ok lm dk translated">量化模型减小了尺寸并改善了延迟，但是在精确度上有一点折衷</p></blockquote><h2 id="8374" class="mf mg it bd mh mi ol dn mk ml om dp mn la on mp mq le oo ms mt li op mv mw iz bi translated">有哪些不同类型的量化？</h2><p id="e42f" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">目前可以对深度学习模型应用两种类型的量化。</p><ul class=""><li id="41b4" class="ns nt it kt b ku kv kx ky la nu le nv li nw lm nx ny nz oa bi translated"><strong class="kt jd">量化感知训练</strong> : <strong class="kt jd">量化感知训练应用于预训练模型，产生量化感知模型</strong>。量化感知训练确保前向传递匹配训练和推理时间的精度。您可以为整个模型或仅部分模型生成量化感知。</li><li id="5aa7" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated"><strong class="kt jd">训练后量化:使用TensorFlow Lite格式</strong>对已经训练好的TensorFlow模型进行量化。您可以应用<strong class="kt jd">训练后动态范围量化、浮点16量化或全整数量化</strong>。在训练后量化中，<strong class="kt jd">权重在训练后被量化，</strong>和<strong class="kt jd">激活在推理时被动态量化。</strong></li></ul><h2 id="331b" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">我们如何建立量化感知模型？</h2><p id="ea94" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">简而言之，我们将遵循这些步骤来构建一个量化感知训练模型。</p><ol class=""><li id="2ecf" class="ns nt it kt b ku kv kx ky la nu le nv li nw lm oq ny nz oa bi translated"><strong class="kt jd">创建深度学习模型</strong></li><li id="8078" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">训练模型</strong></li><li id="094b" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">保存深度学习模型</strong></li><li id="c73c" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">为预训练模型创建量化感知模型</strong></li><li id="af93" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">将量化应用于量化感知模型</strong></li><li id="e674" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">将量化模型转换为Tflite </strong></li><li id="bb06" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">从量子化的TfLite模型中进行推论</strong></li></ol><p id="899f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">数据集是来自Kaggle的<a class="ae me" href="https://www.kaggle.com/puneet6060/intel-image-classification/version/2" rel="noopener ugc nofollow" target="_blank">英特尔图像分类</a></p><p id="3a48" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">数据集有六类:<strong class="kt jd">建筑、森林、冰川、山脉、海洋和街道</strong></p><h2 id="6082" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">创建深度学习模型</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="5ad9" class="mf mg it os b gy ow ox l oy oz"># setting the train, test and val directories<br/><strong class="os jd">train_dir = r'c:\data\Intel_Images\seg_train\seg_train'<br/>test_dir = r'c:\data\Intel_Images\seg_pred'<br/>val_dir = r'c:\data\Intel_Images\seg_test\seg_test'</strong></span><span id="d64b" class="mf mg it os b gy pa ox l oy oz">#setting basic parameters to the mdeol<br/><strong class="os jd">IMG_WIDTH=100<br/>IMG_HEIGHT=100<br/>IMG_DIM = (IMG_HEIGHT, IMG_WIDTH)<br/>input_shape = (IMG_HEIGHT, IMG_WIDTH ,3)<br/>batch_size = 16<br/>epochs = 25</strong></span><span id="25d4" class="mf mg it os b gy pa ox l oy oz"># creating Image Data generator<strong class="os jd"><br/>image_gen_train = ImageDataGenerator(rescale=1./255,                                     zoom_range=0.3, rotation_range=25,                         shear_range=0.1,featurewise_std_normalization=False)</strong></span><span id="fea2" class="mf mg it os b gy pa ox l oy oz">#Creating train data generator<br/><strong class="os jd">train_data_gen = image_gen_train.flow_from_directory(batch_size=batch_size,<br/>directory=train_dir,shuffle=True,target_size=IMG_DIM,class_mode='sparse')</strong></span><span id="1b42" class="mf mg it os b gy pa ox l oy oz">#Creating validation data generator<br/><strong class="os jd">image_gen_val = ImageDataGenerator(rescale=1./255)<br/>val_data_gen = image_gen_val.flow_from_directory(batch_size=batch_size,  directory=val_dir,target_size=IMG_DIM,                                              class_mode='sparse')</strong></span><span id="40c6" class="mf mg it os b gy pa ox l oy oz"># Define the model architecture.<br/><strong class="os jd">model = keras.Sequential([<br/>  keras.layers.InputLayer(input_shape=(IMG_HEIGHT, IMG_WIDTH ,3)),<br/>  keras.layers.Reshape(target_shape=(IMG_HEIGHT, IMG_WIDTH ,3)),<br/>  keras.layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu'),<br/>  keras.layers.MaxPooling2D(pool_size=(2, 2)),<br/>  keras.layers.Dropout(0.3),<br/>  keras.layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),<br/>  keras.layers.MaxPooling2D(pool_size=(2, 2)),<br/>  keras.layers.Dropout(0.3),<br/>  keras.layers.Conv2D(filters=128, kernel_size=(3, 3), activation='relu'),<br/>  keras.layers.MaxPooling2D(pool_size=(2, 2)),<br/>  keras.layers.Flatten(),<br/>  keras.layers.Dense(256, activation='relu'),<br/>  keras.layers.Dropout(0.4),<br/>  keras.layers.Dense(512, activation='relu'),<br/>  keras.layers.Dense(6, activation='softmax')<br/>])</strong></span></pre><h2 id="74c0" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">训练模型</h2><p id="a381" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">一旦深度学习模型被创建，我们就编译它并在100个时期上训练模型。</p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="1227" class="mf mg it os b gy ow ox l oy oz">#Compiling the model<br/><strong class="os jd">optimizer = optimizers.Adam(lr=0.0005)<br/>model.compile(optimizer=optimizer,<br/>              loss='sparse_categorical_crossentropy',<br/>              metrics=['accuracy'])</strong></span><span id="ec36" class="mf mg it os b gy pa ox l oy oz"># Training the model<br/><strong class="os jd">history = model.fit_generator(<br/>    train_data_gen,<br/>    steps_per_epoch=len(train_data_gen)/batch_size,<br/>    epochs=100,<br/>    validation_data=val_data_gen,<br/>    validation_steps=len(val_data_gen)/batch_size<br/>)</strong></span></pre><h2 id="409e" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">拯救深度学习模型</h2><p id="be8f" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">将训练好的模型保存到H5文件。</p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="2d2c" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">model.save('Intel_base_model.h5')</strong></span></pre><h2 id="ca0b" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">为预训练模型创建量化感知模型</h2><p id="9d6c" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated">要创建QAT模型，请确保您已经安装了<strong class="kt jd"><em class="ln">tensor flow-model-optimization</em></strong>库，如下所示。</p><p id="6ecb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe pb pc pd os b"><strong class="kt jd">pip install -q tensorflow-model-optimization</strong></code></p><p id="da60" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在下面的代码中，你会得到一个8位的量化，整个模型都会被量化。</p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="a20f" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">import tensorflow_model_optimization as tfmot</strong></span><span id="ce65" class="mf mg it os b gy pa ox l oy oz"><strong class="os jd">quantize_model = tfmot.quantization.keras.quantize_model</strong></span><span id="40dc" class="mf mg it os b gy pa ox l oy oz"># q_aware stands for for quantization aware.<br/><strong class="os jd">q_aware_model = quantize_model(model)</strong></span><span id="cdc7" class="mf mg it os b gy pa ox l oy oz"><strong class="os jd">optimizer = optimizers.Adam(lr=0.0001)</strong></span><span id="0cbf" class="mf mg it os b gy pa ox l oy oz"># `quantize_model` requires a recompile.<br/><strong class="os jd">q_aware_model.compile(optimizer=optimizer,              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),metrics=['accuracy'])</strong></span><span id="6343" class="mf mg it os b gy pa ox l oy oz"><strong class="os jd">q_aware_model.summary()</strong></span></pre><p id="05d5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面的模型是量子化感知的，但还没有量子化。</p><p id="2d68" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下图显示了张量流模型和量化感知模型之间的差异</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pe"><img src="../Images/0c211cb80b855a97944e74118a84dd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioBYK3IOPgRawpDQQsA6Ew.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">张量流和量化感知张量流模型的区别</figcaption></figure><h2 id="3944" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">将量化应用到量化感知模型</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="aafe" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">history = q_aware_model.fit_generator(<br/> train_data_gen,<br/> steps_per_epoch=len(train_data_gen)/batch_size,<br/> callbacks=[cp_callback],<br/> epochs=100,<br/> validation_data=val_data_gen,<br/> validation_steps=len(val_data_gen)/batch_size<br/>)</strong></span></pre><p id="4eb1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">比较张量流基本模型和量化感知模型的精度，</p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="26cf" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">_, model_accuracy = model.evaluate_generator(val_data_gen)<br/>_, qat_model_accuracy = q_aware_model.evaluate_generator(val_data_gen)<br/>print('TF Model accuracy:', model_accuracy)<br/>print('Quant Model accuracy:', qat_model_accuracy)</strong></span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/ffefaf704c0c8fd0821721c0e7233722.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*VDhu9aGllocfqdUsaGFcjw.png"/></div></figure><p id="7ffb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你会看到量子化感知模型的精确度略有下降。</p><p id="9a6f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">保存量化感知模型</strong></p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="223f" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">q_aware_model.save('Intel_quantize_aware_model.h5')</strong></span></pre><h2 id="4b79" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">将量化模型转换为Tflite</h2><p id="b700" class="pw-post-body-paragraph kr ks it kt b ku mx kd kw kx my kg kz la mz lc ld le na lg lh li nb lk ll lm im bi translated"><strong class="kt jd">这一步将创建一个量化模型。量化的模型将具有int8权重，并且激活将是uint8。</strong></p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="b4d3" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">converter = tf.lite.TFLiteConverter.from_keras_model(q_aware_model)<br/>converter.optimizations = [tf.lite.Optimize.DEFAULT]</strong></span><span id="86b7" class="mf mg it os b gy pa ox l oy oz"><strong class="os jd">quantized_tflite_model = converter.convert()</strong></span><span id="c8b0" class="mf mg it os b gy pa ox l oy oz"><strong class="os jd">with open('Intel_QAT.tflite', 'wb') as f:<br/>  f.write(quantized_tflite_model)</strong></span></pre><p id="47bf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以看到TFlite量化模型、量化感知模型和基本张量流模型之间的大小差异。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi pg"><img src="../Images/d99c309ebae4d46514e0e045afe2ce26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_T2lDgF0jACWhIZDD5MQCg.png"/></div></div></figure><h2 id="d87c" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">从量化的TFLite模型进行推断。</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="0de6" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">class_names = list(train_data_gen.class_indices.keys())</strong><br/>#Create the interpreter for the TfLite model<br/><strong class="os jd">interpreter = tf.lite.Interpreter(model_content=quantized_tflite_model)<br/>interpreter.allocate_tensors()</strong></span><span id="0201" class="mf mg it os b gy pa ox l oy oz">#Create input and output tensors from the interpreter<br/><strong class="os jd">input_index = interpreter.get_input_details()[0]["index"]<br/>output_index = interpreter.get_output_details()[0]["index"]</strong></span><span id="0643" class="mf mg it os b gy pa ox l oy oz"># Create the image data for prediction<br/><strong class="os jd">dataset_list = tf.data.Dataset.list_files(test_dir + '\\*')<br/>for i in range(10):<br/>    image = next(iter(dataset_list))<br/>    image = tf.io.read_file(image)<br/>    image = tf.io.decode_jpeg(image, channels=3)<br/>    image = tf.image.resize(image, (100,100))<br/>    image = tf.cast(image / 255., tf.float32)<br/>    image = tf.expand_dims(image, 0)<br/>    <br/>    </strong>#Set the tensor for image into input index<strong class="os jd">        <br/>    interpreter.set_tensor(input_index, image)</strong><br/>    <br/>    # Run inference.<br/>   <strong class="os jd"> interpreter.invoke()</strong></span><span id="d8da" class="mf mg it os b gy pa ox l oy oz"># find the prediction with highest probability.<br/>    <strong class="os jd">output = interpreter.tensor(output_index)<br/>    pred = np.argmax(output()[0])<br/>    <br/>    print(class_names[pred])</strong></span></pre><p id="d687" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">我可以只量化一个深度学习模型的几层吗？</em> </strong></p><p id="152e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你想量化深度学习模型的几层，那么<strong class="kt jd">尝试量化后面的层而不是第一层</strong>，并且总是<strong class="kt jd">避免量化关键层</strong>。</p><p id="09c3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">对深度学习模型的特定层进行量化</strong></p><ol class=""><li id="aa20" class="ns nt it kt b ku kv kx ky la nu le nv li nw lm oq ny nz oa bi translated"><strong class="kt jd">创建基础模型</strong></li><li id="13e2" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">加载预训练的砝码</strong></li><li id="9ba4" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">定义深度学习模型的哪些层需要量化</strong></li><li id="992c" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">使用<em class="ln">TF . keras . models . clone _ model()</em>量化具体的深度学习层</strong></li><li id="f872" class="ns nt it kt b ku ob kx oc la od le oe li of lm oq ny nz oa bi translated"><strong class="kt jd">使用<em class="ln"> quantize_apply() </em>创建量化感知模型</strong></li></ol><h2 id="d3e5" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">创建模型</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="8cde" class="mf mg it os b gy ow ox l oy oz"># Define the model architecture.<br/><strong class="os jd">base_model = keras.Sequential([<br/>  keras.layers.InputLayer(input_shape=(IMG_HEIGHT, IMG_WIDTH ,3)),<br/>  keras.layers.Reshape(target_shape=(IMG_HEIGHT, IMG_WIDTH ,3)),<br/>  keras.layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu'),<br/>  keras.layers.MaxPooling2D(pool_size=(2, 2)),<br/>  keras.layers.Dropout(0.3),<br/>  keras.layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),<br/>  keras.layers.MaxPooling2D(pool_size=(2, 2)),<br/>  keras.layers.Dropout(0.3),<br/>  keras.layers.Conv2D(filters=128, kernel_size=(3, 3), activation='relu'),<br/>  keras.layers.MaxPooling2D(pool_size=(2, 2)),<br/>  keras.layers.Flatten(),<br/>  keras.layers.Dense(256, activation='relu'),<br/>  keras.layers.Dropout(0.4),<br/>  keras.layers.Dense(512, activation='relu'),<br/>  keras.layers.Dense(6, activation='softmax')<br/>])</strong></span></pre><h2 id="60e2" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">加载预先训练的重量</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="e7f6" class="mf mg it os b gy ow ox l oy oz"><strong class="os jd">base_model.load_weights('Intel_base.h5')</strong></span></pre><h2 id="4c6a" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">定义要量化的深度学习层</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="5cc8" class="mf mg it os b gy ow ox l oy oz"># Create Helper function which uses `quantize_annotate_layer` to annotate the layers should be quantized.<br/><strong class="os jd">def apply_quantization_to_layer(layer):<br/>  if isinstance(layer, tf.keras.layers.MaxPool2D):<br/>    return tfmot.quantization.keras.quantize_annotate_layer(layer)<br/>  return layer</strong></span></pre><h2 id="2400" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">使用tf.keras.models.clone_model()对特定深度学习层进行量化</h2><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="b8ba" class="mf mg it os b gy ow ox l oy oz"># Use `tf.keras.models.clone_model` to apply #apply_quantization_to_layer` <br/># to the layers of the model.<br/><strong class="os jd">annotated_model = tf.keras.models.clone_model(<br/>    base_model,<br/>    clone_function=apply_quantization_to_layer,<br/>)</strong></span></pre><p id="cd21" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用<strong class="kt jd"><em class="ln">quantize _ apply()</em></strong>创建量化感知模型</p><pre class="lp lq lr ls gt or os ot ou aw ov bi"><span id="ef13" class="mf mg it os b gy ow ox l oy oz"># Now that the layers are annotated,<br/># `quantize_apply` actually makes the model quantization aware.<br/><strong class="os jd">quant_aware_model = tfmot.quantization.keras.quantize_apply(annotated_model)<br/>quant_aware_model.summary()</strong></span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/abd81f0de4369bc2ca5f33eabd10babc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*WEiSWbNppgxUutHmr5EOSw.png"/></div></figure><h2 id="7d13" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">结论:</h2><ul class=""><li id="4953" class="ns nt it kt b ku mx kx my la pi le pj li pk lm nx ny nz oa bi translated">深度学习模型的量化有助于减少模型的大小和延迟，这有助于将它们部署在边缘设备上。</li><li id="deb4" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">量化感知训练模型为整个模型或仅部分模型生成量化感知。</li><li id="4168" class="ns nt it kt b ku ob kx oc la od le oe li of lm nx ny nz oa bi translated">将训练后量化应用于已经训练的模型。</li></ul><h2 id="f408" class="mf mg it bd mh mi mj dn mk ml mm dp mn la mo mp mq le mr ms mt li mu mv mw iz bi translated">参考资料:</h2><div class="pl pm gp gr pn po"><a href="https://www.tensorflow.org/model_optimization/guide/quantization/training_comprehensive_guide" rel="noopener  ugc nofollow" target="_blank"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd jd gy z fp pt fr fs pu fu fw jc bi translated">量化感知训练综合指南</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">1/1[= = = = = = = = = = = = = = = = = = = = = = = = = = =]—0s 1 ms/step—损耗:16.1181 —精度:0.0000e+00警告:张量流:未解析…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">www.tensorflow.org</p></div></div><div class="px l"><div class="py l pz qa qb px qc ly po"/></div></div></a></div><p id="d715" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae me" href="https://arxiv.org/pdf/1712.05877.pdf" rel="noopener ugc nofollow" target="_blank">用于有效整数算术推理的神经网络的量化和训练</a></p></div></div>    
</body>
</html>