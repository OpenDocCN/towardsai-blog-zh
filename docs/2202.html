<html>
<head>
<title>U-Net Image Segmentation with Convolutional Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于卷积网络的U-Net图像分割</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/u-net-image-segmentation-with-convolutional-networks-90809950e0d3?source=collection_archive---------0-----------------------#2021-09-27">https://pub.towardsai.net/u-net-image-segmentation-with-convolutional-networks-90809950e0d3?source=collection_archive---------0-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/f6f00fb453b0af22bcc8c95abde913f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BbyzsDO3kMJmhnOy.png"/></div></figure><p id="0406" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们这个时代，图像数据的语义分割经常用于计算机视觉。U-Net是一个主干网络，包含用于屏蔽对象的卷积神经网络。</p><p id="6dc3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">🧶 <strong class="jz iu"> U-Net </strong>因其架构类似于图中所示的字母u而得名。输入图像在输出端作为分割的输出图获得。</p><p id="ab50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以在文章<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/image-segmentation-with-u-net-da8cc1cbeaeb">用U-Net进行图像分割</a>中了解U-Net网络的基本信息和工作架构。本文描述了用Python编程语言逐步编写U-Net的代码。</p><h2 id="f981" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">步骤1:获取数据集</h2><p id="4131" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">在此步骤中，如果您的数据集将从现有代码中提取，您可以按如下方式从文件中加载它。如果数据集位于正在工作的活动文件夹中，则可以通过从文件中加载数据来工作。如果您要像下面的代码行那样工作，数据在加载时需要经过一个准备阶段。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">get _ dataset . py</figcaption></figure><p id="8081" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们导入模块的Python文件的代码如下所示。这里的变量r向将要下载数据集的地址发出请求。为了从download_dataset文件中下载数据，您必须键入要下载的链接，而不是请求的默认域名。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">download_dataset.py</figcaption></figure><p id="f44b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">整个研究中使用的文库如下所示。应该用<strong class="jz iu"><em class="me">* pip install-r requirements . txt *</em></strong>命令将库安装在这个环境中。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="mf lz l"/></div></figure><p id="54b9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">📣<strong class="jz iu">注意！</strong><br/>download _ dataset文件的Python代码应位于Python文件夹中，以便主动工作。因此，稍后可以从该文件下载数据集。下一步是准备数据。</p><h2 id="efc3" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated"><strong class="ak">第二步:准备数据</strong></h2><p id="70f6" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">在这一步中，导入数据集的图像被缩小到512 x 512。因此，研究中使用的所有数据都采用了统一的数据大小。</p><p id="dc59" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">🪐As是已知的，在整个卷积神经网络模型中应用的高度和宽度的尺寸减小，即汇集层，可以与不同的方法结合，如最大值、平均值或中值，并在代码的后半部分实现。得益于这些图层，它旨在提高输出的分辨率。高分辨率特征和采样输出在整个模型中被组合用于定位。然后，顺序卷积层旨在基于此信息创建更精确的输出。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用images_prepare.py文件</figcaption></figure><p id="e11b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以在下面这行代码中找到导入的整个<strong class="jz iu"><em class="me">images _ prepare</em></strong>模块。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">images_prepare.py</figcaption></figure><h2 id="a014" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">步骤3:获取蒙版</h2><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">提取_masks.py</figcaption></figure><p id="e744" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上面提到的masks_prepare文件已经通过以下代码脚本保存。在该步骤中，首先，使用<strong class="jz iu"> <em class="me"> masks_prepare </em> </strong>函数将调整后的数据作为参数发送给该函数。</p><p id="fef7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">🧮Images被转换为1大小并被分配给NumPy数组。图像值到数组的转换对于处理像素值是必不可少的。从图像中提取的遮罩保存在一个文件夹中。简而言之，根据其他算法，U-Net不使用标签引用，而是使用数学推断的掩码。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="6af4" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">步骤4:缩放和转换数据</h2><p id="d686" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">在这一步中，数据被缩放到Float32，X和Y值称为图像和遮罩。在这一步中，数组被修改为NumPy数组，因为我将在训练和测试集中处理105。你可以根据自己的数据来改变这一点。您可以用<strong class="jz iu"> <em class="me"> plt.imshow. </em> </strong>控制一个随机图像数据</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">checkanalysisdata.py</figcaption></figure><h2 id="de6c" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">步骤5:创建U-Net模型</h2><p id="65f1" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">在此步骤中，将使用在文件夹中创建的UNET函数。导入模型所需的层CONV2D、MaxPooling2D、BatchNormalization、Conv2DTranspose、Dropout。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">unet_model.py</figcaption></figure><p id="e95e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为从工作文件夹中的<strong class="jz iu"> <em class="me"> model.py </em> </strong>文件中拉出的U-Net模型创建一个函数会加快工作速度。对于下一个模型，U-Net模型应该如上图所示。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0a3f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"><em class="me">model . summary()</em></strong>用于可视化代码中的图层。汇总各层后，输出如下。没有图片中看到的那么少的图层，我只添加了第一层，这样它们就不会占用空间。</p><figure class="lu lv lw lx gt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/633779d450ff6126fb0862f860dfcb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*STdX6G7nFmofAipU.png"/></div></figure><h2 id="ea65" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">步骤6:编译并拟合U-Net模型</h2><p id="115c" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">在这个阶段使用两个独立的函数。</p><ol class=""><li id="adc4" class="mg mh it jz b ka kb ke kf ki mi km mj kq mk ku ml mm mn mo bi translated"><strong class="jz iu"> model.compile: </strong>损失函数定义了优化器和指标。你需要一个编译好的模型来训练(因为训练用的是损失函数和优化器)。但是没有必要编译模型来进行预测。</li><li id="2827" class="mg mh it jz b ka mp ke mq ki mr km ms kq mt ku ml mm mn mo bi translated"><strong class="jz iu"> model.fit: </strong>为指定数量的时期训练模型。因为epochs参数在这里被给定为100，所以训练将在100个步骤中完成。由于这里选择的度量标准是<em class="me"> [“精确度”] </em>，因此在培训过程中将逐步遵循精确度值。</li></ol><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">compilefit_model.py</figcaption></figure><p id="bdd9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如代码中所述，编译时选择的指标、损失函数和优化器完全可以根据个人情况选择。您可以对此进行更改，并直观地看到精度的变化。结果，当开始模型训练时，观察到如下的周期变化。如果你已经走了这么远，恭喜你！</p><figure class="lu lv lw lx gt ju gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/5ab8cd2d73d5a22b6fbcf410bd700930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*28YAwPUvrvt3MjTH.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><strong class="bd ky">观察历元数的结果</strong></figcaption></figure><h2 id="2272" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">步骤7:模型的预测阶段</h2><p id="e19c" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">一旦训练结束，接下来就是猜测的步骤了。正如这里所看到的，我们作为x_test分离的数据被分配给一个具有predict函数的变量并被使用。您可以通过将<strong class="jz iu">预测</strong>值打印到屏幕上来查看预测结果。</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">预测. py</figcaption></figure><p id="be72" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">📑<em class="me">研究中使用的学术文章；</em></p><p id="b01d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><a class="ae kv" href="https://arxiv.org/pdf/1505.04597.pdf" rel="noopener ugc nofollow" target="_blank"> U-Net:用于生物医学图像分割的卷积网络</a></p><p id="b6ee" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">👁‍🗨 <em class="me">研究中使用的代码的主要来源；</em></p><div class="mv mw gp gr mx my"><a href="https://github.com/SerdarHelli/Segmentation-of-Teeth-in-Panoramic-X-ray-Image-Using-U-Net" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">GitHub-SerdarHelli/使用U-Net对全景X射线图像中的牙齿进行分割</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">本研究的目的是利用深度学习算法对一张全景x射线图像进行自动语义分割。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jv my"/></div></div></a></div><h1 id="4c15" class="nn kx it bd ky no np nq lb nr ns nt le nu nv nw lh nx ny nz lk oa ob oc ln od bi translated">参考</h1><ul class=""><li id="0c40" class="mg mh it jz b ka lp ke lq ki oe km of kq og ku oh mm mn mo bi translated">“语义分割”，王，机器学习小组，多伦多大学。</li></ul><div class="mv mw gp gr mx my"><a href="https://keras.io/api/models/model_training_apis/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Keras文档:模型训练API</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">为训练配置模型。示例参数优化器:字符串(优化器的名称)或优化器实例…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">keras.io</p></div></div><div class="nh l"><div class="oi l nj nk nl nh nm jv my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://stackoverflow.com/questions/47995324/does-model-compile-initialize-all-the-weights-and-biases-in-keras-tensorflow" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">model.compile()是否初始化了Keras (tensorflow backend)中的所有权重和偏差？</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">如果你使用的是compile，那么肯定是在load_model()之后。毕竟你需要一个模型来编译。(PS:load _ model……</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">stackoverflow.com</p></div></div><div class="nh l"><div class="oj l nj nk nl nh nm jv my"/></div></div></a></div></div></div>    
</body>
</html>