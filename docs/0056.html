<html>
<head>
<title>DiscoGANs Network, Generating Matching Bags From Shoe Images And Vice Versa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DiscoGANs网络，从鞋子图像生成匹配的包，反之亦然</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/generating-matching-bags-from-shoe-images-and-vice-versa-using-discogans-8149e2cbc02?source=collection_archive---------0-----------------------#2019-05-28">https://pub.towardsai.net/generating-matching-bags-from-shoe-images-and-vice-versa-using-discogans-8149e2cbc02?source=collection_archive---------0-----------------------#2019-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="47a5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">揭秘discodans |<a class="ae ep" href="https://towardsai.net" rel="noopener ugc nofollow" target="_blank">走向AI </a></h2><div class=""/><h1 id="116f" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">介绍</h1><p id="a9e2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">A<strong class="kw ja">Discovery GAN</strong>(<a class="ae ls" href="https://arxiv.org/pdf/1703.05192.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="kw ja">discover GAN</strong></a><strong class="kw ja">)</strong>是一个生成性对抗网络，给定一个<strong class="kw ja">域A </strong>的图像，生成<strong class="kw ja">域B </strong>中产品的图像。它将风格元素从一个图像转移到另一个图像，从而将纹理和装饰从一个时尚项目(如包)转移到另一个时尚项目(如一双鞋)。这种GAN在游戏和时尚行业有许多应用，值得感兴趣的读者进一步探索。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/081f67ff03c5057cab464c679b3938fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*_zq0tmsDCEXWmek7Sa7zVA.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><a class="ae ls" href="https://arxiv.org/pdf/1703.05192.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jy">标准GAN (Goodfellow等，2014) </strong> </a></figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/b121466e1e5f200a46bb1d8b611f5e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*oq3Xe8n5Fjnfs1jxpVtjHg.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><a class="ae ls" href="https://arxiv.org/pdf/1703.05192.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jy">甘带着重建的失落</strong> </a></figcaption></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/2223fe1139443994c69cb531f6e7cc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*GHPdt9_fxAcoM8-Jp-mQwQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated"><strong class="bd jy">提议的</strong> <a class="ae ls" href="https://arxiv.org/pdf/1703.05192.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jy">模型(DiscoGAN)旨在发现两个未配对、未标记数据集之间的关系</strong> </a></figcaption></figure><h1 id="4f4a" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">高层<strong class="ak"> DiscoGAN </strong>的架构图</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ml"><img src="../Images/0b9b322d1617b1f53178c752f755ecfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3mxWZSWz-JekBgK4e7BSw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">高层DiscoGAN的架构图</figcaption></figure><p id="f547" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja"> DiscoGAN </strong>将有两个<strong class="kw ja">生成器</strong>，一个用于从<strong class="kw ja">手袋</strong>(用<strong class="kw ja"> A </strong>表示)到<strong class="kw ja">鞋子</strong>(用<strong class="kw ja"> B </strong>表示)的映射，另一个用于反之亦然。</p><ul class=""><li id="ad38" class="mr ms iq kw b kx mm lb mn lf mt lj mu ln mv lr mw mx my mz bi translated">第一<strong class="kw ja">生成器</strong>将输入图像从<strong class="kw ja">域A </strong>映射到<strong class="kw ja">域B </strong>，</li><li id="cf04" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">第二<strong class="kw ja">生成器</strong>从<strong class="kw ja">域B </strong>到<strong class="kw ja">域A </strong>重构图像。</li><li id="c52b" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">在<strong class="kw ja">域B </strong>中生成的图像在风格和模式上都类似于<strong class="kw ja">域A </strong>中的图像。这种关系可以在训练期间无需明确地将来自两个域的图像配对来学习。</li><li id="5320" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="kw ja">发现者</strong>试图学习两个<strong class="kw ja">发电机</strong>功能<em class="nf"> G(ab) </em>和<em class="nf"> G(ba)。</em>当一幅图像<em class="nf"> xA </em>通过<strong class="kw ja">生成器</strong>G<em class="nf">ab时，它将</em>生成一幅图像<em class="nf"> xAB </em>，在<strong class="kw ja">域B </strong>中看起来很逼真。</li><li id="c316" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">当这个图像<em class="nf"> xAB，</em>通过另一个<strong class="kw ja">发生器</strong>网络<em class="nf"> G(ba) </em>馈入时，它应该产生一个图像<em class="nf"> xABA </em>，该图像应该理想地与原始图像<em class="nf"> xA </em>相同</li><li id="7431" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">在训练期间，无需明确配对来自两个<strong class="kw ja">域</strong>的图像，就可以学习这种关系。鉴于物品的配对是一项耗时的任务，这是一项非常强大的功能。</li></ul><p id="d721" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">在数学上，这可以表示如下</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c832cc03eac237bf83a45ad2c1274ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*t0NoohvdpWDN7NcvPtarEg.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f366e78cf30dc0eec7dfdad6726e3208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*8nHSBwkTToxGUFspHQMsVg.png"/></div></figure><p id="a25c" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">关于发电机功能，以下关系应成立</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ni"><img src="../Images/307dd996c109e58df414d0679685a50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIcXU3FJYiePEl4EPmND_A.png"/></div></div></figure><p id="e9e1" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">发生器</strong>函数<em class="nf"> G(ab) </em>和<em class="nf"> G(ba) </em>实际上不可能相互反转，所以我们必须使重建图像和原始图像之间的损失最小化。为此，我们可以使用<strong class="kw ja"> L1 </strong>或<strong class="kw ja"> L2 </strong>正规化。</p><ul class=""><li id="a531" class="mr ms iq kw b kx mm lb mn lf mt lj mu ln mv lr mw mx my mz bi translated">L1正则化是每个数据点的绝对误差之和。</li><li id="16e6" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">L2正则化是每个数据点的平方损失之和。</li><li id="a70e" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">我们可以如下示出单幅图像的L2正则化损失函数。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nj"><img src="../Images/08985f4ef41084a32f6897c642263a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDEuh6kE33I_8xsYkvWdiQ.png"/></div></div></figure><ul class=""><li id="6db4" class="mr ms iq kw b kx mm lb mn lf mt lj mu ln mv lr mw mx my mz bi translated">将L2损失最小化是不够的。我们必须确保创建的图像<em class="nf"> xB </em>在<strong class="kw ja">域B </strong>中看起来真实。例如，如果我们将域A<strong class="kw ja">中的包</strong>映射到域B 中的鞋，我们必须确保<em class="nf"> xB </em>看起来像一只鞋。</li><li id="5963" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="kw ja">域B </strong>上的<strong class="kw ja">鉴别器</strong> <em class="nf"> Db </em>会将<em class="nf"> xB </em>检测为假的如果图像作为鞋子不够逼真，则必须考虑这种损失。</li><li id="b26b" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">在训练中，生成的(<em class="nf"> xAB = G(ab)(xA)) </em>图像和<strong class="kw ja">域B </strong>中的原始(<em class="nf"> yB </em>)图像都将作为输入馈送给<strong class="kw ja">鉴别器</strong>，以便它学习将真实图像与虚假图像进行分类</li><li id="0a24" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated"><strong class="kw ja">生成器</strong>将<strong class="kw ja">域A </strong>中的一幅图像<em class="nf"> xA </em>映射到<strong class="kw ja">域B </strong>中的一幅图像的损失可以写成如下所示。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/344b187048b14009713522d0a7844c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*Ma0jKg9p8I8ef37KQQxjbw.png"/></div></figure><ul class=""><li id="7665" class="mr ms iq kw b kx mm lb mn lf mt lj mu ln mv lr mw mx my mz bi translated">并且在L2范数下的重建损失可以写成如下所示。</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3fcff1b1891aeeadb6b3f20ac5b2b2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*HrU5t-H-7IHoKJfVh91v7Q.png"/></div></figure><p id="5262" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">发生器</strong>试图将图像<em class="nf"> xAB </em>转换为对<strong class="kw ja">鉴别器</strong>来说看起来真实的图像。</p><p id="05e6" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">鉴别器</strong>试图将转换后的图像标记为假图像，因此<strong class="kw ja">生成器</strong> <em class="nf"> G(ab) </em>应该以尽可能小的假图像对数损失的方式生成图像<em class="nf"> xAB </em>。</p><p id="4a31" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果<strong class="kw ja">域B </strong>中的<strong class="kw ja">鉴别器</strong> <em class="nf"> D(b) </em>为真图像标记1，为假图像标记0。图像真实的概率由<em class="nf"> D(b)给出。)</em>。</p><p id="952d" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">然后<strong class="kw ja">生成器</strong>尝试使图像<em class="nf"> xAB </em>在<strong class="kw ja">鉴别器</strong>网络下极有可能被标记为真实，这意味着<strong class="kw ja">生成器</strong>尝试使<em class="nf">D(b)(xB)= D(b)(G(ab)(xA))</em>尽可能接近1。</p><p id="bbec" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">就对数损失而言，<strong class="kw ja">生成器</strong>应最小化概率的负对数，这给我们<em class="nf"> C(D(ab)) </em>，如下所示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9a6a32c956e2a8e6bbecb6cf0e55e438.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*tPMYuErjA4czV7c7zbI5yw.png"/></div></figure><p id="3dec" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">结合上面的函数，我们可以得到将一幅图像从<strong class="kw ja">域A </strong>映射到<strong class="kw ja">域b</strong>的总生成成本<em class="nf"> C_GAB </em></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6381854b8f20ef099fb1f3bbf8efac3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*ZxBH6hJPXqIYBsyEKnvmiA.png"/></div></figure><p id="4733" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">生成器</strong> <em class="nf"> G(ba) </em>映射从<strong class="kw ja">域B </strong>到<strong class="kw ja">域A </strong>的图像。由<strong class="kw ja">生成器</strong> <em class="nf"> G(ba) </em>将<strong class="kw ja">域B </strong>中的图像<em class="nf"> xB </em>变换成图像<em class="nf"> xBA </em>并且在<strong class="kw ja">域A </strong>处的<strong class="kw ja">鉴别器</strong>由<em class="nf"> D(a) </em>给出，那么与这样的变换相关联的代价函数由下面给出。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi no"><img src="../Images/1b666f0549b191f7433a36907868ba17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZUy5QICqBtITvn-TItUCw.png"/></div></div></figure><p id="b665" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">生成器</strong>两个域中所有图像的损失由下式给出。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi np"><img src="../Images/f06a0909e68248c9d5dfbeb1fb60aef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHIg5dLYpnZLMgQKPONs7A.png"/></div></div></figure><h1 id="76fc" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">鉴别器的成本函数</h1><p id="05b5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个域中的<strong class="kw ja">鉴别器</strong>都试图从伪图像中鉴别出真实图像，所以<strong class="kw ja">鉴别器</strong> <em class="nf"> G(b) </em>试图最小化代价<em class="nf"> C_D(b) </em>如下图所示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/34be8de0605ef1497a7c06cffa048175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*YoGJq-CT0JJq9IO_BgllzA.png"/></div></figure><p id="ab2d" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">同样的，<strong class="kw ja">鉴别器</strong> <em class="nf"> D(a) </em>尝试最小化成本<em class="nf"> C_DA </em>如下图。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nr"><img src="../Images/6831d4e90ce0cfb0c30973417248fa54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K06UQ_Dy3NPXnJYo9llL3A.png"/></div></div></figure><p id="eaff" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">总的<strong class="kw ja">鉴别器</strong>成本由<em class="nf"> C(d) </em>给出，如下所示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ns"><img src="../Images/6a07023fec897a6dc000eb374fc5d761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hu_Yiyu6MdOQ_kI9GHxphQ.png"/></div></div></figure><h1 id="24c8" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"> CycleGAN和DiscoGAN之间的相似性<em class="nt"/></h1><ul class=""><li id="7afe" class="mr ms iq kw b kx ky lb lc lf nu lj nv ln nw lr mw mx my mz bi translated"><strong class="kw ja"> CycleGAN </strong>和<strong class="kw ja"> DiscoGAN </strong>两者<strong class="kw ja"> </strong>几乎相似。<strong class="kw ja"> CycleGANs、</strong>中有一个变化，它有一个<strong class="kw ja"> </strong>附加超参数来调整重建/周期一致性损失在总损失函数中的贡献。这种灵活性决定了相对于GAN损失或归因于<strong class="kw ja">鉴别器</strong>的损失，分配给重建损失多少权重。</li><li id="4b9b" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">这个超参数平衡了损耗，帮助网络在训练时更快地收敛。</li><li id="03ac" class="mr ms iq kw b kx na lb nb lf nc lj nd ln ne lr mw mx my mz bi translated">一个<strong class="kw ja"> CycleGANs </strong>的其余实现与<strong class="kw ja"> DiscoGANs的相同。</strong></li></ul><p id="5daf" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja">为本帖所配的jupyter笔记本可以在</strong> <a class="ae ls" href="https://github.com/nitwmanish/Generating-Matching-Bags-From-Shoe-Images-And-Vice-Versa-Using-DiscoGANs" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ja"> G </strong> </a> <strong class="kw ja"> ithub上找到。</strong></p><h1 id="ef9a" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="ea8b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="kw ja"> DiscoGANs </strong>的一个很酷的应用是<strong class="kw ja"> </strong>将装饰从一个时尚单品比如包包转移到另一个时尚单品比如一双鞋。</p><p id="6fbc" class="pw-post-body-paragraph ku kv iq kw b kx mm kz la lb mn ld le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><strong class="kw ja"> <em class="nf">我希望这篇文章能帮助你开始建立自己的</em> DiscoGANs <em class="nf">。我想这至少会提供一个很好的解释和理解关于</em>发现者<em class="nf">。</em> </strong></p></div></div>    
</body>
</html>