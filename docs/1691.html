<html>
<head>
<title>Genetic Algorithm Optimization Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法优化算法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/genetic-algorithm-optimization-algorithm-f22234015113?source=collection_archive---------0-----------------------#2021-03-21">https://pub.towardsai.net/genetic-algorithm-optimization-algorithm-f22234015113?source=collection_archive---------0-----------------------#2021-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="867c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-science" rel="noopener ugc nofollow" target="_blank">计算机科学</a></h2><div class=""/><div class=""><h2 id="ebe6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一种受自然进化(如选择、变异和交叉)启发的优化算法</h2></div><p id="bba7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> <em class="ln">了解遗传算法，它在人工智能中扮演什么角色，它是如何工作的，最后，看一个实现。</em> </strong></p><blockquote class="lo"><p id="75f9" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">遗传算法(GA)是一种进化算法(EA)，受查尔斯·达尔文的自然选择理论的启发，该理论支持适者生存。</p></blockquote><p id="4c11" class="pw-post-body-paragraph kr ks it kt b ku ly kd kw kx lz kg kz la ma lc ld le mb lg lh li mc lk ll lm im bi translated">根据自然选择理论，最适合的个体被选择来产生后代。然后，最适合的父母的特征通过交叉和变异传递给他们的后代，以确保更好的生存机会。</p><p id="85df" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">遗传算法是一种随机搜索算法，通过模仿生物启发的自然选择过程，如选择、交叉和变异，生成高质量的优化解决方案。</strong></p><blockquote class="lo"><p id="f88b" class="lp lq it bd lr ls lt lu lv lw lx lm dk translated">遗传算法的目标是从搜索空间中找到最佳的<em class="md">解</em></p></blockquote><h2 id="892a" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated">遗传算法术语</h2><p id="29c2" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">在我们深入研究遗传算法的工作原理之前，我们将简要了解遗传算法中使用的术语。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7fb387049a9f5c71d6d907c7ec59c3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*JKw4Kx_rUknowfB045vvtg.png"/></div></figure><p id="6c56" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">世代或群体</strong>包含随机搜索过程开始的一组可能的解决方案。遗传算法将迭代多代，直到找到一个可接受的和优化的解决方案。第一代是随机生成的。</p><p id="4c3c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">染色体</strong>代表一代或群体中存在的一个候选解。染色体也被称为<strong class="kt jd">基因型</strong>。</p><p id="d299" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一条染色体由包含最优变量值的<strong class="kt jd">基因</strong>组成。</p><p id="38c0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">表现型</strong>是由遗传算法处理的基因型的解码参数列表。将作图应用于基因型以转化为表型。</p><p id="a049" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">适应度函数或目标函数</strong>评估每一代的个体解或表型，以识别最适合的成员。</p><h2 id="1e07" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">不同的遗传算子</h2><p id="4344" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated"><strong class="kt jd">选择是从一个种群中选择最适解的过程，然后最适解作为下一代解的父代</strong>。这使得下一代可以自然地继承强大的功能。可以使用基于适合度值的轮盘赌选择或等级选择来执行选择。</p><p id="011d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">当来自两个最适合的亲本的基因被随机交换以形成新的基因型或解决方案时，交换或重组就发生了</strong>。基于交换的亲本基因片段，交换可以是单点交换或多点交换。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi no"><img src="../Images/eb9d6554511cd535223605ba5a0a917f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*a4mJxjC0xiTfPU3PCqAaWw.png"/></div></figure><p id="de61" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在通过选择和交叉产生一个新群体后，它通过变异被随机修改。突变<strong class="kt jd">是使用随机过程修改基因型的过程，以促进群体的多样性，从而找到更好的优化解决方案。</strong></p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2a6e02d72c495834138c36f08c3c0706.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*bk6zF_rpgGi8IcPIY6fCWg.png"/></div></figure><h2 id="045d" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">遗传算法的工作原理</h2><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6c877a9ca87b2cb95bc14c1197926ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*TZ840m0DvghL80GodVGLeQ.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">遗传算法工作</figcaption></figure><p id="4018" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">为第0代</strong>初始化种群:GA从为一个问题创建一个随机产生的可能候选解的初始种群开始。</p><p id="4ecd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">基于目标函数或适应度函数评估这一代中的每个解决方案。</strong></p><p id="4d5f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">检查是否满足终止条件。终止条件可以是以下任何条件</p><ol class=""><li id="61e2" class="nv nw it kt b ku kv kx ky la nx le ny li nz lm oa ob oc od bi translated">当算法已经生成预定义的世代时</li><li id="3e59" class="nv nw it kt b ku oe kx of la og le oh li oi lm oa ob oc od bi translated">当我们的适应度函数达到预定的目标值时</li></ol><p id="2e2b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果不满足终止条件，则<strong class="kt jd">为下一代生成群体:</strong></p><p id="448f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最适合的群体成员被识别、排序并被选择作为下一代的父母。下一代的基因型是通过交叉和变异等遗传操作产生的。</p><p id="213d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">遗传算法传播成功的解决方案，并且应该产生越来越有能力的解决方案群体。</p><h2 id="fca2" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">遗传算法在人工智能中的应用</h2><p id="569b" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">遗传算法用于搜索和优化，使用迭代过程从多个解决方案中获得最佳解决方案。</p><ul class=""><li id="026c" class="nv nw it kt b ku kv kx ky la nx le ny li nz lm oj ob oc od bi translated">在深度学习中，遗传算法可以有效地为深度学习模型找到一组好的超参数及其值，以提高其性能。</li><li id="21c1" class="nv nw it kt b ku oe kx of la og le oh li oi lm oj ob oc od bi translated">还可以使用遗传算法来选择最佳数量的特征，用于构建对预测目标变量很重要的机器学习模型。</li></ul><h2 id="07b1" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">遗传算法的优势</h2><ul class=""><li id="89cc" class="nv nw it kt b ku mw kx mx la ok le ol li om lm oj ob oc od bi translated">求解复杂优化问题的通用框架。</li><li id="6760" class="nv nw it kt b ku oe kx of la og le oh li oi lm oj ob oc od bi translated">在相对较短的计算时间内探索搜索空间。</li><li id="d3e9" class="nv nw it kt b ku oe kx of la og le oh li oi lm oj ob oc od bi translated">可以很容易地包括多个复杂的优化目标</li><li id="3dd2" class="nv nw it kt b ku oe kx of la og le oh li oi lm oj ob oc od bi translated">对局部最小值和最大值具有鲁棒性，并且易于发现全局最优值</li><li id="c8ed" class="nv nw it kt b ku oe kx of la og le oh li oi lm oj ob oc od bi translated">GA可以很容易地并行化</li></ul><h2 id="4236" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">遗传算法的实现</h2><p id="6f90" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">在这里，我们将找到一个最佳解决方案来生成一个数组，该数组的数字范围在0到9之间，其和小于或等于11。</p><p id="9d01" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">导入所需的库并设置常量</strong></p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="be49" class="me mf it oo b gy os ot l ou ov"><strong class="oo jd">import numpy as np<br/>from random import randint, random, choice</strong><br/><strong class="oo jd">TARGET=11<br/>generations=1000<br/>NO_OF_BEST_SOLUTIONS=5<br/>NO_OF_SOLUTION_IN_A_GENERATION=10<br/>SIZE_OF_A_SOLUTION=10<br/>LOWER_RANGE=0<br/>UPPER_RANGE=10</strong></span></pre><p id="31a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">随机生成一个群体</strong></p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="7c6a" class="me mf it oo b gy os ot l ou ov"><strong class="oo jd">def generate_population(no_of_solution, size, lower, upper):<br/>    solution = []<br/>    population=[]<br/>    for i in range(no_of_solution):</strong><br/>        #Create a chromosome or solution for the population.        <br/>       <strong class="oo jd"> solution=[randint(lower,upper) for x in range(size) ]       <br/>        population.append(solution)<br/>    return population</strong></span></pre><p id="64c6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">定义适应度函数</strong></p><p id="8699" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">适应度函数将返回单个解决方案和预定义目标之间的绝对差值。</p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="1079" class="me mf it oo b gy os ot l ou ov"><strong class="oo jd">def fitness(individual):</strong><br/>   """<br/>   Determine the fitness of an individual. Lower is better.<br/>   individual: the individual to evaluate<br/>   """<br/>   <strong class="oo jd">total_list_sum = sum(individual)<br/>   return np.abs(total_list_sum - TARGET)</strong></span></pre><p id="423a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对群体进行排序，使具有最低绝对差异的单个解决方案位于列表顶部，因为它们是群体中的最佳解决方案</p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="5341" class="me mf it oo b gy os ot l ou ov"><strong class="oo jd">def sort_population_by_fitness(population):<br/>    return sorted(population, key=fitness, reverse=False)</strong></span></pre><p id="461f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">用两个最合适的双亲的杂交创造一个孩子</strong></p><p id="4447" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过随机选择第一个亲本的一部分和第二个亲本的一部分来组合来自两个最适合的亲本的基因，从而产生交叉</p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="b36f" class="me mf it oo b gy os ot l ou ov">#the most common technique is to pick a part of the bit string of A and a part of bit string of B<br/><strong class="oo jd">def crossover(individual_a, individual_b):<br/>    new_list=[]<br/>    first=randint(2,8)<br/>    new_list= individual_a[:first] + individual_b[first:]<br/>    return new_list</strong></span></pre><p id="5499" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">通过突变创造一个孩子</strong></p><p id="7863" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">突变是通过随机翻转群体中最适合的双亲之一的选定位来实现的。</p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="6449" class="me mf it oo b gy os ot l ou ov">#you can simply flip randomly selected bits of the individual string<br/>def mutate(individual):<br/>    new_list=[]<br/>    first=randint(0,9)<br/>    second=randint(0,9)<br/>    third=randint(0,9)<br/>    individual[first]=randint(0,9)<br/>    individual[second]=randint(0,9)<br/>    individual[third]=randint(0,9)<br/>    return individual</span></pre><p id="34cb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">创造新一代人口</strong></p><p id="6a5a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过从上一代中选择最合适的亲本，应用交叉和变异来产生新一代。</p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="614e" class="me mf it oo b gy os ot l ou ov"><strong class="oo jd">def make_next_generation(previous_population):<br/>    next_generation = []<br/>    sorted_by_fitness_population = sort_population_by_fitness(previous_population)<br/>    population_size = len(previous_population)<br/>   <br/>    for i in range(population_size):<br/>        # find the least loss in the fitness function among the population<br/>        for j in range(0,NO_OF_BEST_SOLUTIONS):<br/>            pick_best_parents= randint(0,NO_OF_BEST_SOLUTIONS-2)<br/>            parent_1=sorted_by_fitness_population[pick_best_parents]<br/>            parent_2=sorted_by_fitness_population[pick_best_parents+1]<br/>            best_parent_1=sorted_by_fitness_population[0]<br/>            best_parent_2=sorted_by_fitness_population[1]<br/>        draw = choice(["crossover", "mutate_parent1", "mutate_parent2", "Parent 1", "Parent 2","best 1", "best 2" ])<br/>        if draw=="crossover":<br/>            individual = crossover(parent_1, parent_2)<br/>        elif draw=="mutate_parent1":<br/>            individual = mutate(parent_1)<br/>        elif draw=="mutate_parent2":<br/>             individual = mutate(parent_2)<br/>        elif draw=="Parent 1":<br/>             individual =parent_1<br/>        elif draw=="Parent 2":<br/>             individual =parent_2<br/>        elif draw=="best 1":<br/>             individual =best_parent_1<br/>        elif draw=="best 2":<br/>             individual =best_parent_2<br/>        <br/>        next_generation.append(individual)<br/>    <br/>    return next_generation</strong></span></pre><p id="5184" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">遗传算法</strong></p><p id="1629" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，我们初始化第0代的解，然后基于适应度函数评估这一代中的每个解。</p><p id="4eea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">检查是否满足终止条件。如果不满足终止条件，则生成下一代解决方案。</p><pre class="nc nd ne nf gt on oo op oq aw or bi"><span id="5a30" class="me mf it oo b gy os ot l ou ov"># start with a population<br/><strong class="oo jd">best_solution=[]<br/>population_data=generate_population(NO_OF_SOLUTION_IN_A_GENERATION,SIZE_OF_A_SOLUTION,LOWER_RANGE, UPPER_RANGE)</strong></span><span id="e8ec" class="me mf it oo b gy ow ot l ou ov"># find the least loss in the fitness function among the population<br/><strong class="oo jd">best_individual = sort_population_by_fitness(population_data)</strong></span><span id="f9f2" class="me mf it oo b gy ow ot l ou ov"><strong class="oo jd">if fitness(best_individual[0])&lt;=1:<br/>    best_solution=best_individual[0]<br/>else:<br/>    for gen in range(generations):</strong><br/>        <br/>        <strong class="oo jd">population_data=make_next_generation(population_data)<br/>        best_individual = sort_population_by_fitness(population_data)<br/>        print(best_individual)<br/>        if fitness(best_individual[0])&lt;=1:<br/>            best_solution=best_individual[0]<br/>            print(best_solution)<br/>            break</strong></span><span id="1f63" class="me mf it oo b gy ow ot l ou ov"><strong class="oo jd">print("FINAL RESULT  ", best_solution,  " with fitness ", fitness(best_solution), "at generation ", gen)</strong></span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="oy oz di pa bf pb"><div class="gh gi ox"><img src="../Images/93a1eb8855b3e9f6d590bb5c1caf41b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXltcyxEpes0-YOYcSCmiw.png"/></div></div></figure><h2 id="6e35" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">结论:</h2><p id="8522" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">遗传算法是一种受生物启发的算法，用于解决优化和搜索问题。通过选择、交叉和变异，最适合的父母的特征被传递给下一代。</p><h2 id="5a11" class="me mf it bd mg mh nj dn mj mk nk dp mm la nl mo mp le nm mr ms li nn mu mv iz bi translated">参考资料:</h2><p id="4237" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated"><a class="ae pc" href="https://arxiv.org/pdf/2006.12703.pdf" rel="noopener ugc nofollow" target="_blank">使用可变长度遗传算法的深度学习中的高效超参数优化</a></p><div class="pd pe gp gr pf pg"><a href="https://www.sciencedirect.com/topics/engineering/genetic-algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jd gy z fp pl fr fs pm fu fw jc bi translated">遗传算法</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">遗传算法是一种随机搜索算法，被开发用来模仿…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">www.sciencedirect.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu nh pg"/></div></div></a></div><p id="5d37" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae pc" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Genetic_algorithm</a></p></div></div>    
</body>
</html>