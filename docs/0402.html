<html>
<head>
<title>Introduction to the Pandas Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫图书馆简介</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/introduction-to-the-pandas-library-4e00f07fc18?source=collection_archive---------0-----------------------#2020-04-14">https://pub.towardsai.net/introduction-to-the-pandas-library-4e00f07fc18?source=collection_archive---------0-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6f1f95818d551ee1488590204f23ec61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZX5HCGn94KVIDP7VClZQQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Source — Nimble编码</figcaption></figure><p id="df1f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在开始之前，我建议你阅读我之前关于NumPy <a class="ae ld" href="https://medium.com/datadriveninvestor/real-time-introduction-to-numpy-d556deb56f49" rel="noopener">的文章。尽管NumPy的数组比Python的数据结构好，但有几个限制阻碍了它的使用。<br/> 1。NumPy的<strong class="kh iu">高维数组</strong>每个数组只支持单一数据类型，这使得处理既有数字又有字符串的数据变得困难。<br/>一般来说实时数据是一种或多种数据类型的组合。<br/> 2。Numpy有硬件级的方法，但是没有为经常使用的分析模式预先构建的方法。</a></p><p id="8f2b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">熊猫库又称“Python数据分析库”解决了上述问题。Pandas是一个构建在Numpy之上的python库，它支持数据清理和数据操作。使用Pandas，我们可以高效地对<strong class="kh iu">多维和异构数据</strong>执行操作。熊猫还让我们能够灵活地处理来自更广泛资源类别的数据，如<code class="fe le lf lg lh b">.csv</code>、<code class="fe le lf lg lh b">.tsv</code>、<code class="fe le lf lg lh b">excel</code>和<code class="fe le lf lg lh b">webpages</code>。Pandas库主要由两种数据结构组成。(第三个数据结构<strong class="kh iu">“面板”</strong>这里不讨论。)</p><h1 id="4dad" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.系列</h1><p id="42a2" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">一个<strong class="kh iu">系列</strong>是一个一维数据结构，可以看作是Python的字典和Numpy的n-d数组数据结构的扩展。一个系列可以被想象成一个具有两列的数据结构，一列用于索引(类似于Python中字典的键)，另一列用于实际数据。这里要注意的一个要点是数据列也可以有自己的标签。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/76c26ecfbda9cc00bf7670ddc821ca58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_MCpDV9_iyzzRyAEfqzjQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">序列、数组和字典之间的区别</figcaption></figure><p id="056e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在内部，Pandas使用Numpy库将一个Series对象存储在一个类型化数组中。与传统的python列表相比，这提高了处理数据的速度和性能。</p><p id="098f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">创建系列</strong></p><p id="6fbf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可以通过多种方式创建系列。首先，要使用熊猫图书馆，我们需要—</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="7070" class="mu lj it lh b gy mv mw l mx my">import pandas as pd</span></pre><p id="c6c1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可以从Python列表、字典和Numpy数组创建Series对象。我们可以使用基本语法<code class="fe le lf lg lh b">pd.Series(data,index)</code>创建一个系列。index参数在这里是可选的。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/55f9b9ab2dbe88b5ef6f0f8142a00561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*IsAH-lnO_Iufmt6qSC4Rbw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">创建系列数据结构的不同方法</figcaption></figure><p id="74d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在前三个方法中，我们没有向Series方法传递任何索引参数，因此默认值0… n-1被视为索引。我们可以将自定义索引传递给数据值，如第四种方法所示。</p><p id="8a1a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">查询一个系列</strong></p><p id="64a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可以通过索引位置或索引标签来查询系列数据结构。当我们不传递index参数时，值的位置就变成了它的标签。为了通过数字位置进行查询，从零开始，我们使用了<em class="na"> iloc </em>属性。为了通过索引标签进行查询，我们可以使用<em class="na"> loc </em>属性。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3b9474ff2356766ca2d2c6971fa9884f.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*i6FRFUPsmhANIerarckadA.png"/></div></figure><p id="06f5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">让我们来回答一个问题！</strong></p><p id="ce86" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果indexes对象中的值列表与字典中的键不匹配，如下所示，该怎么办？</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5d0b141cd204c8d2242ea6b1e1e2cfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*fFQ-62VmeJ23c_AU5dHhIg.png"/></div></figure><p id="89b8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Pandas将忽略索引对象中不存在的键。它将为存在于索引对象中但不在字典中的键提供一个NaN值，如上所示。</p><h1 id="f2bd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.数据帧</h1><p id="9135" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">数据帧结构是熊猫图书馆的核心。这些是具有行和列的二维数据结构。我们同样可以认为数据帧是一系列对象的集合。与NumPy二维数组不同，DataFrame对象具有异构数据。组成数据帧的元素以及Pandas如何存储数据帧(每一列都是一个序列)可以在这里看到。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/cba5a85c9ff5b4ba3cccb759d11b1cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhSWB883eSovFnle_l3J3g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图像源— DataQuest</figcaption></figure><p id="50c6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">创建数据帧</strong></p><p id="1579" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">数据帧的创建方式与系列的创建方式相同，由— <code class="fe le lf lg lh b">pd.DataFrame(data,index)</code>创建。我们将创建一个数据帧，首先创建三个系列对象，然后将它们转换成一个数据帧。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/34f744ee9a4797c5776ae3007b3a0e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9ar4_Nl9IRI1PcpKf3Q9g.png"/></div></div></figure><p id="f831" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">探索数据帧</strong></p><p id="7da1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">df.info()</code>返回数据帧的行数、列数和每列的数据类型以及内存使用情况。</p><p id="1675" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">df.describe()</code>返回描述性统计数据，如数据框的中心性测量值和扩散性测量值。</p><p id="8c85" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">使用行和列</strong></p><p id="b4a1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">类似于系列对象，<br/> 1。如果我们想要查询数据帧的一行，我们可以通过使用<strong class="kh iu"> loc </strong> <em class="na"> </em>和<strong class="kh iu"> iloc </strong>属性来使用索引标签或索引位置。<br/> 2。如果我们想要查询列，我们可以直接使用<strong class="kh iu">括号符号[] </strong>和列名来检索整个列。<br/> 3。如果我们想要特定行和特定列的元素，我们使用<strong class="kh iu"> loc </strong>属性并传递行标签或索引位置以及列标签或索引位置。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/1376a29f5b9ac0d845bb050bf2b0f72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8olYaBNScqwYP5GWU-prIA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">查询数据框的各种方法</figcaption></figure><p id="ccdb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们注意到，如果我们的输出是一维数组，它将作为一个Series对象返回，如果我们的输出大于一维数组，它将作为DataFrame对象返回。</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="e7ea" class="mu lj it lh b gy mv mw l mx my"><strong class="lh iu"><em class="na"># Query a particular cell using the labels</em></strong><br/>df.loc["Person1","Name"]</span><span id="b170" class="mu lj it lh b gy ng mw l mx my"><strong class="lh iu"><em class="na"># Query a particular cell using the labels</em></strong><br/>df.iloc[0,1]</span></pre><p id="78a3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们来回答一个问题！</p><p id="5d86" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> df.iloc[[0，1]] </strong>和<strong class="kh iu"> df.iloc[0，1] </strong>有什么区别？看起来差不多，对吗？但是仔细看看。</p><p id="3e78" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在第一种情况下，我们向df.iloc[ ]属性传递一个由两个数字组成的列表，这意味着我们预期有2行，它们的索引位置分别为0和1。该查询返回DataFrame对象。</p><p id="a2aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在第二种情况下，我们将两个数字分别传递给df.iloc[ ]属性，第一个数字是行索引，第二个数字是列索引。<br/> <strong class="kh iu">注:</strong>我们也可以通过<strong class="kh iu"> ":" </strong>符号表示整行或整列。示例— df.iloc[:，7]将返回所有行，但仅返回第7列。</p><p id="c2ca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">向数据框架添加列</strong></p><p id="7c5f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这可以直接使用括号符号<code class="fe le lf lg lh b">[]</code>来完成，我们在其中传递新的列标签。如果我们向不存在的索引添加值，Pandas会自动添加<strong class="kh iu"> NaN </strong>值。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4f6438c28156699f9fcdf509350d5840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*Vihis9BE5Qzf6KDkUoYdJA.png"/></div></figure><p id="59e8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">删除行/列</strong></p><p id="9370" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这可以使用` drop()函数来完成。它有两个参数。<br/> 1) <strong class="kh iu">轴</strong>，以指示方向。(<code class="fe le lf lg lh b">axis=0</code>暗示行，<code class="fe le lf lg lh b">axis=1</code>暗示列。)<br/> 2) <strong class="kh iu">就地</strong>，如果设置为true，DataFrame将就地更新，而不是返回一个副本。</p><p id="b275" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一个用于删除列的函数是<strong class="kh iu"> del </strong>函数。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/1afbc85fba39c0d9722d6c3b4bb11de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7ZnG7jVGC2GDkXtXn1jRg.png"/></div></div></figure><p id="ff9f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">过滤数据</strong></p><p id="e1ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个有趣的概念<strong class="kh iu">布尔屏蔽</strong>可用于对数据帧进行高效过滤。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8f39e7f9a793abcef0f4f41b9a542e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*XHaoO8qBn5k0Wu_0xREL5g.png"/></div></figure><p id="9bfa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">分组依据</strong></p><p id="b460" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，让我们向表中添加职业和薪水列。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/aefd17f9a1046fb8c4d54ec8bfc29978.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*xUlj1R0NRhMQ3zDobTQE2g.png"/></div></figure><p id="67ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们想找出从事“IT”和“商业”的人的平均工资。</p><p id="6b9d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">常见的方法是遍历数据帧中的每一行，检查占用率并计算平均值。但我确实认为这种方法不太容易(熊猫的标准)。一种选择是使用<code class="fe le lf lg lh b">groupby()</code>功能。</p><p id="adec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">groupby()</code>允许我们根据列名对行进行分组，并执行求和、均值、标准差等聚合操作。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6b215aabb8dcf0791be88374dbbe104e.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*FrQVXdXn01ICoQtaWDfcuQ.png"/></div></figure><p id="5916" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们直接调用<strong class="kh iu"> mean() </strong>方法时，它对所有具有兼容数据类型的列进行操作。</p><p id="be2e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了仅对所需的列执行mean，我们需要使用<code class="fe le lf lg lh b">.agg()</code>方法，将列名和函数作为键值对传递给它。</p><p id="4772" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">熊猫使用的更多功能…</p><p id="57ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">sort_values</code>以列名为参数，默认按升序排序。示例<code class="fe le lf lg lh b">df.sort_values(“Age”,ascending=True)</code></p><p id="b2fe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">nlargest() </code>和<code class="fe le lf lg lh b">nsmallest()</code>返回给定列中“n”个最大和最小的元素。示例df.nlargest(3，" Age ")返回年龄最大的前3个人。</p><p id="2ac0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">idxmax()</code>和<code class="fe le lf lg lh b">idxmin()</code>返回第一个出现的最大值和最小值的索引。</p><p id="9ac6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">dropna()</code>用于删除包含空值/缺失值的列。</p><p id="b726" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">astype(x)</code>尝试遍历每一行，并将数据类型改为x。</p><p id="d654" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">apply()</code>用于在数据帧上调用<strong class="kh iu">用户自定义函数</strong>。语法如下所示。</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="fbc2" class="mu lj it lh b gy mv mw l mx my">def cube(x):<br/>    return x*x*x</span><span id="709b" class="mu lj it lh b gy ng mw l mx my">df['Salary'].apply(cube)</span></pre><p id="a855" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">合并数据帧</strong></p><p id="f617" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们想要将数据帧连接在一起时，我们不能直接跳到代码中。我们必须先做出选择。让我们创建两个数据帧student_df和staff_df。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/755d2ec3f31381026017bf873fed9c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*8z0sjeuvD4LUb-a1u6Kvzw.png"/></div></figure><p id="7d49" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，如果我们想获得每个人的信息，不管他们是学生还是职员，我们使用<strong class="kh iu">全外部连接。</strong> <br/>接下来，如果我们想获得职员和学生的信息，我们使用<strong class="kh iu">内部连接</strong>。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/8b6bad586cfc3c45c30d3b6a10583ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*E5VDyXzsDiuKud5dDxmYfQ.png"/></div></div></figure><p id="fb5e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要将连接的类型传递给<code class="fe le lf lg lh b">how</code>参数进行合并。我们还告诉merge函数，我们希望通过将left_index和right_index设置为<strong class="kh iu"> True </strong>来使用左索引和右索引作为连接列。在完全外部连接的情况下，詹姆斯·凯利没有学校，迈克也没有角色。因此，这些被NaN值替换。</p><p id="97c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">类似地，如果我们想知道所有职员的详细信息，不管他们是否是学生，但是如果他们是学生，我们也想得到他们的学生详细信息，我们可以使用<strong class="kh iu"> left join。</strong>我们可以用<strong class="kh iu">右连接</strong>反之亦然。</p><p id="7c7d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">从文件中读取</strong></p><p id="028d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">pd.read_csv()</code>用于将. csv文件转换为数据帧。</p><p id="6fdd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">pd.read_excel()</code>用于从Excel文件导入数据。</p><p id="bffe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">pd.read_html()</code>允许我们从HTML文件中读取表格。</p><p id="ba4a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">写入文件</strong></p><p id="767d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">.to_csv()</code>将我们的数据帧转换为. csv文件。</p><p id="8025" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">类似地，<code class="fe le lf lg lh b">to_excel()</code>将我们的数据框存储在一个Excel文件中。</p><h1 id="3f45" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="ec15" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">希望这篇文章能帮助你理解熊猫的重要性和它所提供的性能改进。对于有志于从事数据领域工作的人来说，Pandas是一个非常方便的图书馆。非常感谢您的阅读，如果您觉得这篇文章有用，请随意分享。</p></div></div>    
</body>
</html>