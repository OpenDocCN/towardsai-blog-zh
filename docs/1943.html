<html>
<head>
<title>A Very basic End-to-End Machine Learning Flask Model with Heroku Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个非常基本的端到端机器学习烧瓶模型，采用Heroku部署</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-very-basic-end-to-end-machine-learning-flask-model-with-heroku-deployment-d4ba6675f2f7?source=collection_archive---------1-----------------------#2021-06-25">https://pub.towardsai.net/a-very-basic-end-to-end-machine-learning-flask-model-with-heroku-deployment-d4ba6675f2f7?source=collection_archive---------1-----------------------#2021-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1416" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="1131" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">带部署的简单线性回归模型</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a6eb691d054a38412bfcda4119019815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAvybjs6W-EhFJnOWmMK2Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Flask和HTML5文件。作者的照片</figcaption></figure><p id="4e3b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">机器学习模型的部署在数据科学或机器学习之旅中非常重要。在本文中，我们将讨论和实现欺诈检测的不平衡数据，并试图通过过采样方法(即SMOTE)使其平衡，以避免过拟合问题。</p><p id="da51" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">什么是不平衡数据？</p><p id="232d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通常，我们在监督分类算法中看到这种类型的问题，其中目标变量具有不平衡的类。例如，类是“是”和“否”，其中一个类的数量比另一个类多90%。因此，这个问题使得该模型在真实场景中使用不可靠和不现实。</p><h2 id="785c" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">涵盖的主题:</h2><ul class=""><li id="8aef" class="mv mw it lj b lk mx ln my lq mz lu na ly nb mc nc nd ne nf bi translated"><strong class="lj jd">创造新环境</strong></li><li id="e736" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd">Jupyter上的欺诈检测机器学习建模</strong></li><li id="9d48" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd">需求文件和过程文件</strong></li><li id="6eb5" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd"> HTML文件</strong></li><li id="74a9" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd">烧瓶应用文件</strong></li><li id="6fa8" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd"> GitHub </strong></li><li id="7bae" class="mv mw it lj b lk ng ln nh lq ni lu nj ly nk mc nc nd ne nf bi translated"><strong class="lj jd"> Heroku部署</strong></li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="c83f" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">创建新环境</em> </strong></p></blockquote><p id="b33e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">创建一个新的环境总是有一个好处，即只获取我们在机器学习项目建模中使用的库，作为将在部署部分使用的需求文件。我们可以通过两种方法在anaconda中创建一个环境。</p><ul class=""><li id="14d5" class="mv mw it lj b lk ll ln lo lq nz lu oa ly ob mc nc nd ne nf bi translated"><strong class="lj jd">第一种方法:</strong>蟒蛇GUI导航器</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/1ca659b81d4325906b00ba1e4eb9e0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mSaCqk90L14wJL3ikG5Fg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="af06" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一步:打开Anaconda导航器</p><p id="ed9f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">第二步:</strong>点击创建按钮</p><p id="ffca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">步骤3: </strong>给出新环境的名称，然后单击create。</p><ul class=""><li id="0bc3" class="mv mw it lj b lk ll ln lo lq nz lu oa ly ob mc nc nd ne nf bi translated"><strong class="lj jd">第二种方法:</strong>用Anaconda提示</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/d833bc8a8e71cfacc604fed640c2655c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVopuWOpJZiVj_8VJKp_pA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="dd3e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">第一步:</strong>点击Anaconda提示符</p><p id="5c84" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">步骤2: </strong>我们将看到默认环境是基本环境，我们必须创建一个新环境。</p><p id="8d60" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">第三步:</strong>写下命令，然后按回车键，最后写下‘y’。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="81b2" class="md me it of b gy oj ok l ol om">conda create -n hello python=3.7</span></pre><p id="491b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">第四步:</strong>要激活新的环境，我们要写'<strong class="lj jd"> <em class="nv">激活你好</em> </strong>'我们会看到环境从基地变成'<strong class="lj jd"> <em class="nv">你好</em> </strong>'。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="a355" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">欺诈检测机器在Jupyter上学习建模</em> </strong></p></blockquote><p id="5bf3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将从kaggle和link中获取的不平衡数据在这里是<a class="ae on" href="https://www.kaggle.com/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c08b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在阅读了数据之后，很清楚地解释了总观察量是284，807次交易。目标变量被命名为包含两个类的类，即“0”和“1”。“0”或非欺诈类的计数是284315，“1”或非欺诈类的计数是492。目标变量的不平衡类观测值是显而易见的。</p><p id="0fcd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们用SMOTE做一个logistic模型，让它平衡。</p><p id="49a4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">导入库</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="b92f" class="md me it of b gy oj ok l ol om">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import seaborn as sns<br/>%matplotlib inline</span></pre><p id="b27c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">用熊猫图书馆读取数据</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="ba46" class="md me it of b gy oj ok l ol om">data = pd.read_csv("creditcard.csv")<br/>data.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/5714bdcd88ed7a3e64a52227f89544c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-kRW-Bg_i3AUwjWOvTbXQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="58aa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">用matplotlib库绘制目标变量计数。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="cdc2" class="md me it of b gy oj ok l ol om">count_classes = pd.value_counts(data['Class'], sort = True).sort_index()<br/>count_classes.plot(kind = 'bar')<br/>plt.title("Fraud class histogram")<br/>plt.xlabel("Class")<br/>plt.ylabel("Frequency")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/135e30115dad23be8cca024cb569cc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*Ln0Dhus1xqKqxsFu0SivRQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">目标变量的计数。作者的照片</figcaption></figure><p id="0cf8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们将计算目标变量中的两个类，以了解为“1”的少数类的百分比。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="62a9" class="md me it of b gy oj ok l ol om"># Count the number and finding the percentage of fraud cases<br/>fraud = data[data['Class'] == 1]<br/>valid = data[data['Class'] == 0]</span><span id="1edb" class="md me it of b gy oq ok l ol om">outlierFraction = len(fraud)/float(len(valid))</span><span id="dccf" class="md me it of b gy oq ok l ol om">print(outlierFraction)<br/>print('Fraud Cases: {}'.format(len(data[data['Class'] == 1])))</span><span id="e96e" class="md me it of b gy oq ok l ol om">print('Valid Transactions: {}'.format(len(data[data['Class'] ==<br/>                                                            0])))</span><span id="2ad7" class="md me it of b gy oq ok l ol om">#output:<br/>0.0017304750013189597<br/>Fraud Cases: 492<br/>Valid Transactions: 284315</span></pre><p id="7b64" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以从上面看到，欺诈交易的数量如此之少，以至于建模时数据是不平衡的。让我们使用SMOTE来平衡班级。SMOTE对少数类进行过采样。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="b877" class="md me it of b gy oj ok l ol om">import imblearn<br/>from imblearn.over_sampling import SMOTE<br/>import warnings<br/>warnings.filterwarnings('ignore')<br/>from sklearn.model_selection import train_test_split</span><span id="cf41" class="md me it of b gy oq ok l ol om">X_train,X_test,y_train,y_test = train_test_split(x, y, random_state=0, test_size=.20)</span></pre><p id="622c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在用SMOTE拟合训练数据。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="b8b6" class="md me it of b gy oj ok l ol om"># implement smote now<br/>smote = SMOTE(random_state=0)<br/>X_train,y_train = smote.fit_resample(X_train, y_train)</span><span id="f0b7" class="md me it of b gy oq ok l ol om">print("AFTER SMOTE")<br/>y_train.value_counts().plot.bar()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/afbfabce603d25bf9175ac1b18504e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*uq9CaiJHEUA7V3S90qoTRw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="8175" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用SMOTE后，这两个类是相同的，可以很好地对其进行预测。现在使用网格搜索CV来获得最佳参数以获得良好的精度。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="b2b2" class="md me it of b gy oj ok l ol om">#import Grid Search CV to find the parameters<br/>from sklearn.model_selection import GridSearchCV</span><span id="c09c" class="md me it of b gy oq ok l ol om"># Logistic Regression </span><span id="ebf7" class="md me it of b gy oq ok l ol om">log_reg_params = {"penalty": ['l1', 'l2'], 'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]}</span><span id="dd36" class="md me it of b gy oq ok l ol om">grid_log_reg = GridSearchCV(LogisticRegression(), log_reg_params)<br/>grid_log_reg.fit(X_train, y_train)</span><span id="3134" class="md me it of b gy oq ok l ol om">#Getting the best parameters for the model</span><span id="9685" class="md me it of b gy oq ok l ol om">log_reg = grid_log_reg.best_estimator_</span><span id="60ed" class="md me it of b gy oq ok l ol om">log_reg_score = cross_val_score(log_reg, X_train, y_train, cv=5)</span><span id="03aa" class="md me it of b gy oq ok l ol om">print('Logistic Regression Cross Validation Score: ',<br/>         round(log_reg_score.mean() * 100, 2).astype(str) + '%')</span><span id="15f9" class="md me it of b gy oq ok l ol om"><strong class="of jd">#output:</strong><br/>Logistic Regression Cross Validation Score:  97.19%</span></pre><p id="d947" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，用逻辑回归建立模型。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="c4a5" class="md me it of b gy oj ok l ol om">from sklearn.linear_model import LogisticRegression<br/>from sklearn import metrics</span><span id="72d9" class="md me it of b gy oq ok l ol om">lr = LogisticRegression()<br/>model = LogisticRegression()<br/>model.fit(X_train,y_train)</span><span id="38fc" class="md me it of b gy oq ok l ol om">y_pred = model.predict(X_test)</span><span id="1597" class="md me it of b gy oq ok l ol om">print('Logistic Regression accuracy = ',<br/>                           metrics.accuracy_score(y_pred,y_test))</span><span id="0463" class="md me it of b gy oq ok l ol om"><strong class="of jd">#output:</strong><br/>Logistic Regression accuracy =  0.9791264351673045</span></pre><p id="9c33" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，我们获得了97%的准确率。但我们必须在建模机器学习算法方面做很多事情，所以我们只是试图了解部署的所有步骤的基本步骤。</p><p id="0946" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，用joblib库保存模型。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="3c04" class="md me it of b gy oj ok l ol om">import joblib<br/>from joblib import dump,load</span><span id="8626" class="md me it of b gy oq ok l ol om">joblib.dump(model, 'creditcard_model.sav')</span><span id="6b82" class="md me it of b gy oq ok l ol om">#output:<br/>['creditcard_model.sav']</span></pre><p id="70f8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们的模型被保存，我们将在我们的flask模型中使用这个文件。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="554f" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">需求文件和</em>proc file</strong></p></blockquote><ul class=""><li id="3bbb" class="mv mw it lj b lk ll ln lo lq nz lu oa ly ob mc nc nd ne nf bi translated"><strong class="lj jd">需求</strong>文件包含了我们在jupyter模型和flask文件中使用过的所有库。</li></ul><p id="6b2c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了获得需求文件，我们需要在为模型创建的同一个工作环境中用anaconda提示符编写一个命令。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="22e9" class="md me it of b gy oj ok l ol om">pip freeze &gt; requirements.txt</span></pre><p id="572d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个命令之后，requirements.txt将被生成并保存在jupyter文件和模型文件被保存的同一个文件夹中。</p><ul class=""><li id="7e5f" class="mv mw it lj b lk ll ln lo lq nz lu oa ly ob mc nc nd ne nf bi translated">Procfile 是一个基本的需求文件，告诉我们应用程序的容器要运行什么命令。</li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="f26c" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it"> HTML5文件</em> </strong></p></blockquote><p id="706e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">需要HTML5文件来用flask检查我们的模型，在flask中，我们将给出输入并呈现HTML5文件，然后返回预测。HTML5代码的基本设计如下所示:</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="675e" class="md me it of b gy oj ok l ol om">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;title&gt;CreditCard&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;form action="{{ url_for('predict')}}" method="POST"&gt;<br/>        scaled_amount:  &lt;input type="number" name="scaled_amount"&gt;<br/>        scaled_time:  &lt;input type="number" name="scaled_time"&gt;<br/>        v1:  &lt;input type="number" name="v1"&gt;<br/>        v2:  &lt;input type="number" name="v2"&gt;&lt;br&gt;<br/>        v3:  &lt;input type="number" name="v3"&gt;<br/>        v4:  &lt;input type="number" name="v4"&gt;<br/>        v5:  &lt;input type="number" name="v5"&gt;<br/>        v6:  &lt;input type="number" name="v6"&gt;&lt;br&gt;<br/>        v7:  &lt;input type="number" name="v7"&gt;<br/>        v8:  &lt;input type="number" name="v8"&gt;<br/>        v9:  &lt;input type="number" name="v9"&gt;<br/>        v10:  &lt;input type="number" name="v10"&gt;&lt;br&gt;<br/>        v11:  &lt;input type="number" name="v11"&gt;<br/>        v12:  &lt;input type="number" name="v12"&gt;<br/>        v13:  &lt;input type="number" name="v13"&gt;<br/>        v14:  &lt;input type="number" name="v14"&gt;&lt;br&gt;<br/>        v15:  &lt;input type="number" name="v15"&gt;<br/>        v16:  &lt;input type="number" name="v16"&gt;<br/>        v17:  &lt;input type="number" name="v17"&gt;<br/>        v18:  &lt;input type="number" name="v18"&gt;&lt;br&gt;<br/>        v19:  &lt;input type="number" name="v19"&gt;<br/>        v20:  &lt;input type="number" name="v20"&gt;<br/>        v21:  &lt;input type="number" name="v21"&gt;<br/>        v22:  &lt;input type="number" name="v22"&gt;&lt;br&gt;<br/>        v23:  &lt;input type="number" name="v23"&gt;<br/>        v24:  &lt;input type="number" name="v24"&gt;<br/>        v25:  &lt;input type="number" name="v25"&gt;<br/>        v26:  &lt;input type="number" name="v26"&gt;&lt;br&gt;<br/>        v27:  &lt;input type="number" name="v27"&gt;<br/>        v28:  &lt;input type="number" name="v28"&gt;<br/>        &lt;input type=submit value=Submit&gt;<br/>   &lt;/form&gt;<br/>    My prediction: {{ predict }}<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="667e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上述代码的基本网站设计如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/b1a79d25fb35e6a5e9bf8f8e09d7f914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kI7NWx2ShU_Pn9M9SBofGQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="770c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们在一个HTML文件中创建一个表单时，我们应该添加action和method参数，这样我们输入的值就可以用flask文件来呈现。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="7963" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">烧瓶app文件</em> </strong></p></blockquote><p id="2fb9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个文件中，我们将使用我们保存的模型来渲染HTML5文件中的这些输入，并给出预测结果。</p><p id="1e23" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">烧瓶代码如下所示:</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="da41" class="md me it of b gy oj ok l ol om">from flask import Flask, render_template, request<br/>import numpy as np<br/>#import pickle<br/>import joblib</span><span id="9647" class="md me it of b gy oq ok l ol om">app = Flask(__name__)<br/>filename = 'creditcard_model.sav'<br/># model = pickle.load(open(filename, 'rb'))<br/>model = joblib.load(filename)<br/># model = joblib.load('filename.pkl')</span><span id="77bf" class="md me it of b gy oq ok l ol om"><a class="ae on" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def index():<br/>    <br/>    return render_template('index.html')</span><span id="e71c" class="md me it of b gy oq ok l ol om"><a class="ae on" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict', methods=['POST'])<br/>def predict():<br/>    scaled_amount = request.form['scaled_amount']<br/>    scaled_time = request.form['scaled_time']<br/>    v1 = request.form['v1']<br/>    v2 = request.form['v2']<br/>    v3 = request.form['v3']<br/>    v4 = request.form['v4']<br/>    v5 = request.form['v5']<br/>    v6 = request.form['v6']<br/>    v7 = request.form['v7']<br/>    v8 = request.form['v8']<br/>    v9 = request.form['v9']<br/>    v10 = request.form['v10']<br/>    v11 = request.form['v11']<br/>    v12 = request.form['v12']<br/>    v13 = request.form['v13']<br/>    v14 = request.form['v14']<br/>    v15 = request.form['v15']<br/>    v16 = request.form['v16']<br/>    v17 = request.form['v17']<br/>    v18 = request.form['v18']<br/>    v19 = request.form['v1']<br/>    v20 = request.form['v20']<br/>    v21 = request.form['v21']<br/>    v22 = request.form['v22']<br/>    v23 = request.form['v23']<br/>    v24 = request.form['v24']<br/>    v25 = request.form['v25']<br/>    v26 = request.form['v26']<br/>    v27 = request.form['v27']<br/>    v28 = request.form['v28']<br/>      <br/>    pred = model.predict(np.array([[scaled_amount, scaled_time, v1,<br/>                                                    ------, v28]]))</span><span id="f140" class="md me it of b gy oq ok l ol om">print(pred)<br/>    return render_template('index.html', predict=str(pred))</span><span id="4ed9" class="md me it of b gy oq ok l ol om">if __name__ == '__main__':<br/>    app.run(debug=True)</span></pre><p id="b7e2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们想使用我们的本地主机来查看我们通过flask用HTML制作的网页时，下面的代码行有助于呈现该页面。</p><pre class="ks kt ku kv gt oe of og oh aw oi bi"><span id="e12d" class="md me it of b gy oj ok l ol om"><a class="ae on" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')</span></pre><p id="6e26" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">flask文件中的predict函数用于收集我们在HTML文件中插入的所有输入，并使用它们进行预测。然后，我们用反映的预测值再次呈现我们的web页面。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="81f0" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it"> GitHub </em> </strong></p></blockquote><p id="6e6c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于部署，我们可以使用GitHub和直接Heroku CLI命令。这两种方法都适用于部署文件和制作应用程序。部署包含的文件应该包括模板文件夹中的<strong class="lj jd"> procfile、requirements.text文件、运行时文件、app.py文件</strong>，即<strong class="lj jd"> flask python文件</strong>和<strong class="lj jd"> HTML文件</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/ffc50ee528ddb332af615899f095e7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*5G0BAOKrosYPdkRbuAbj8w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">该文件夹包含用于部署的文件。作者的照片</figcaption></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="c8d3" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it"> Heroku部署</em> </strong></p></blockquote><p id="4fa5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将所有文件添加到GitHub后，我们可以将它连接到Heroku平台，并将我们保存的GitHub存储库部署到Heroku。</p><p id="90fa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一步:点击创建应用程序按钮，并给出你的应用程序的名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/44ef4c6794d446f0f212bb516e2a873b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*KuLP1FzXMpoCU-ojtlc2FQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在Heroku中创建应用程序的名称。作者的照片</figcaption></figure><p id="d383" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">步骤2:现在选择部署方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/9323e4c22a9a3a83cb2d668f7c6a32f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhSobmqzqw2kOlOLzbCveA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="a55a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第三步:然后连接GitHub并部署它。它将创建您的模型的应用程序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/449160a63f893550e378d3d4812adbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*IwscY2LprNCVeb2Jlt6hfA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者的照片</figcaption></figure><p id="a565" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第四步:打开应用程序，测试你的模型预测，并分享链接。</p><p id="e641" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本文模型链接是<a class="ae on" href="https://young-journey-20828.herokuapp.com" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="5e52" class="lh li nv lj b lk ll kd lm ln lo kg lp nw lr ls lt nx lv lw lx ny lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">结论</em> </strong></p></blockquote><p id="6e3c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇文章给出了一个非常基本的概念，如何在Heroku平台上部署这个模型。在所有这些过程中，会遇到许多需要学习的东西。</p><p id="79a0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae on" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae on" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="108b" class="ox me it bd mf oy oz pa mi pb pc pd ml ki pe kj mo kl pf km mr ko pg kp mu ph bi translated">推荐文章</h1><p id="a583" class="pw-post-body-paragraph lh li it lj b lk mx kd lm ln my kg lp lq pi ls lt lu pj lw lx ly pk ma mb mc im bi translated"><a class="ae on" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae on" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae on" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae on" rel="noopener ugc nofollow" target="_blank" href="/deep-learning-88e218b74a14?source=friends_link&amp;sk=540bf9088d31859d50dbddab7524ba35">为什么LSTM在深度学习方面比RNN更有用？</a> <br/> 5。<a class="ae on" rel="noopener ugc nofollow" target="_blank" href="/neural-networks-the-rise-of-recurrent-neural-networks-df740252da88?source=friends_link&amp;sk=6844935e3de14e478ce00f0b22e419eb">神经网络:递归神经网络的兴起</a> <br/> 6。<a class="ae on" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae on" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae on" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae on" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae on" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>