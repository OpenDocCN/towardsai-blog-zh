<html>
<head>
<title>Regular Expressions (RegEx) in Python: Advanced Concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的正则表达式(RegEx ):高级概念</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/regular-expressions-regex-in-python-advanced-concepts-69b25d0d023e?source=collection_archive---------0-----------------------#2022-06-13">https://pub.towardsai.net/regular-expressions-regex-in-python-advanced-concepts-69b25d0d023e?source=collection_archive---------0-----------------------#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4348" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Python系列中的正则表达式</h2><div class=""/><div class=""><h2 id="4234" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">向您的正则表达式技能集添加高级技能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/daea9b8fcfd626d5f76075385da9bc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7OyjR5eDdS-Zf6ySDXejA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><h1 id="9d52" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">动机</h1><p id="73c9" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">许多网站要求密码至少有八个字符和特殊要求。但是你有没有想过网站是如何根据这些要求来验证你的密码的？答案是正则表达式或者RegEx 。对于任何程序员和数据科学家来说，学习正则表达式是处理文本(字符串)的一项重要技能。<strong class="mb jd">你也可以用它来清洗自然语言处理中的文本数据！</strong></p><p id="606e" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在这个故事中，我将在基本正则表达式的基础上介绍一些高级正则表达式技巧，我在下面的故事中介绍了这些技巧。我强烈建议在深入研究高级正则表达式之前先温习一下基础知识。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/regular-expression-regex-in-python-the-basics-b8f2cd041bdb"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jd gy z fp ni fr fs nj fu fw jc bi translated">Python中的正则表达式:基础知识</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">正则表达式允许你从文本中提取重要信息。看看这个中等的故事，学习正则表达式的基础…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">pub.towardsai.net</p></div></div><div class="nm l"><div class="nn l no np nq nm nr lb nd"/></div></div></a></div></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="1c3d" class="lh li it bd lj lk nz lm ln lo oa lq lr ki ob kj lt kl oc km lv ko od kp lx ly bi translated">正则表达式元字符摘要</h1><p id="ca6b" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在上述介绍基本正则表达式的故事中，我介绍了单词、数字和空格字符的元字符。下表介绍了其他重要的元字符。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/9b0a9f55d4642bfdbcb85be923b27083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YRqW_9V6UplYmGF4EKPcQ.png"/></div></div></figure><h1 id="aab5" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">1.匹配任意字符。(句号)</h1><p id="eda9" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">regex模式中的句点<code class="fe of og oh oi b">.</code>可用于匹配除换行符<code class="fe of og oh oi b">\n</code>之外的任何字符。如下图所示，<code class="fe of og oh oi b">.</code>和量词<code class="fe of og oh oi b">+</code>一起用于匹配<code class="fe of og oh oi b">https://</code>之后的任何事物。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/c8ef41dea020ed9d75504d60ee9aef29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cyEpZ8IoHMe7TkR9pmHHw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明的用法。匹配任何字符(图片由作者提供)</figcaption></figure><h1 id="700b" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">2.使用^(脱字符号)和$(美元)指定搜索位置</h1><p id="0e61" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在下图中，我们提取了蜘蛛侠电影的续集。但是，它给出了整个文本的结果。如果我们希望模式只在文本的开头或结尾匹配呢？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/e8772e6bfa948c40a1e0bf7aa8ff27dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvezW3RD-ruHpcXXuqz3lw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明文本中的位置独立搜索(图片由作者提供)</figcaption></figure><p id="7274" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在模式前指定<code class="fe of og oh oi b">^</code>将在文本的开头查找潜在的匹配，如下图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/74abdfcb45636bba52bf8ca5aa570096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92DcsE-jnnpLLUxaCX70Hg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用^在正文的开头举例说明搜索(图片由作者提供)</figcaption></figure><p id="7eae" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">类似地，在模式末尾指定<code class="fe of og oh oi b">$</code>将在文本末尾查找潜在的匹配，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/7d30ce5cb3110bebba0f111682e75456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MK-gVvurZV700Uz2pTbrsg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用$(图片由作者提供)在文本末尾说明搜索</figcaption></figure><h1 id="028d" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">3.OR运算符|(管道)</h1><p id="d397" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">让我们考虑我们有两种模式——A和B；我们想匹配其中一种模式。这可以通过使用<code class="fe of og oh oi b">A|B</code>来完成。换句话说，<code class="fe of og oh oi b">A|B</code>表示匹配A或b中的任何内容。这也可以扩展到两个以上的模式，例如<code class="fe of og oh oi b">A|B|C|D|E</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/7b1af0fca9c978a9337ae9d08b144763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFMyjjwXuo-SK2KED1vNuw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明|作为OR运算符的用法(图片由作者提供)</figcaption></figure><h1 id="80b3" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">4.使用[ ](方括号)指定字符范围</h1><p id="2946" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">提取一个单词字符，我们可以用<code class="fe of og oh oi b">\w</code>。但是如果我们只想匹配大写字母呢？我们可以在<code class="fe of og oh oi b">[]</code>中指定这样的字符范围。例如，<code class="fe of og oh oi b">[A-Z]</code>表示匹配任何单个大写字母。通过使用类似<code class="fe of og oh oi b">[A-Z]+</code>的加号进行量化，可以匹配多个大写字母。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/c8da7721eec7c87af52c3d5b67362dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW-hqXGlFdCurlf4eEoLGw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明使用<code class="fe of og oh oi b">[ ]</code>来指定字符范围(图片由作者提供)</figcaption></figure><p id="75d6" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb jd">字符范围的几个例子<br/> 1。【A-Z】:</strong>匹配任意单个大写字母<br/> <strong class="mb jd"> 2。</strong><strong class="mb jd">【A-Za-z】:</strong>匹配任意单个大写或小写字母<br/> <strong class="mb jd"> 3 .[0–9]:</strong>匹配0到9<br/>T25】4之间的任意一个数字。[!@#]: 匹配任意单个字符！、@或#</p><p id="c463" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">点击阅读更多关于角色范围<a class="ae ok" href="https://docstore.mik.ua/orelly/unix3/upt/ch32_08.htm" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="8569" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb jd"> <em class="ol">注:</em> </strong> <em class="ol">中的</em> <code class="fe of og oh oi b"><em class="ol">[]</em></code> <em class="ol">，元字符如</em> <code class="fe of og oh oi b"><em class="ol">.*+?</em></code> <em class="ol">等。没有特别的含义。他们将被严格对待。虽然特殊字符</em> <code class="fe of og oh oi b"><em class="ol">^</em></code> <em class="ol">在</em> <code class="fe of og oh oi b"><em class="ol">[]</em></code> <em class="ol">里面有不同的意思。</em></p><h1 id="d862" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">5.在[ ]中使用^(插入符号)指定相反的字符范围</h1><p id="5257" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我们看到使用<code class="fe of og oh oi b">[A-Z]</code>，任何大写字符都可以匹配。但是如果我们想要匹配除了大写字母以外的任何东西呢？这里，我们可以在字符范围内使用<code class="fe of og oh oi b">^</code>来指定范围的反义词，例如<code class="fe of og oh oi b">[^A-Z]</code>将匹配除大写字母之外的任何内容。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/d92f93c76e7413ca04f3b33710d2b669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxWREs5AdDQlsSgwG8Xw2g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明在[ ]中使用^来指定相反的字符范围(图片由作者提供)</figcaption></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="b5b1" class="lh li it bd lj lk nz lm ln lo oa lq lr ki ob kj lt kl oc km lv ko od kp lx ly bi translated"><strong class="ak">动机</strong>为分组</h1><p id="f8b5" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">让我们使用正则表达式模式从给定的文本中提取一个网站。如下图所示，这很简单。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/8f281160f313f3a11e8a1de87e4d8c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjgQTeFezIw-bUpwR7UojA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明不使用分组的搜索(作者图片)</figcaption></figure><p id="91e4" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">但有时，我们可能希望从匹配的模式中提取出单独的部分，例如，单独的网站组件，如网站名称、网站域名等。为了实现这一点，我们可以在regex模式中指定组。</p><h1 id="8e2d" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">1.使用()(括号)分组</h1><p id="8f21" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">可以使用<code class="fe of og oh oi b">()</code>指定组。在下面的例子中，我们使用分组提取网站的片段。听起来很有用，不是吗？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/d844d2d55c44c62f4b08bc88d21d282f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3usAjVGtpqw5tsKwQV9bCA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明如何使用( )来指定组(图片由作者提供)</figcaption></figure><h1 id="f276" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">2.使用(？:)</h1><p id="2a29" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">但是，有时我们希望匹配特定的组，但不想将它们包含在结果中。在下面的例子中，我们想要匹配一个组<code class="fe of og oh oi b">(www)</code>，但是不希望它出现在输出中。通过在分组模式前添加<code class="fe of og oh oi b">?:</code>，例如<code class="fe of og oh oi b">(?:www)</code>，我们可以使其成为非捕获组。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/d1ed7af910ee5463403df5b3b56a9089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I37EoOGMFL1ksci02URjZQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明...的用法。:指定非捕获组(按作者分类的图像)</figcaption></figure><h1 id="d7dd" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">3.反向引用组</h1><p id="8417" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">您使用正则表达式匹配了一个组。现在，您希望以相同的模式再次重用匹配的部分。我们如何做到这一点？反向引用允许重用来自<strong class="mb jd">捕获</strong>组的匹配部分。如下图所示，<code class="fe of og oh oi b">\1</code>可以指一组比赛，<code class="fe of og oh oi b">\2</code>可以指二组比赛。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/de36c6066c7d6bcbfbb5294b379436ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mQI-GQNTyBCF6P9St1pXg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">\1和\2分别指代组1和组2(图片由作者提供)</figcaption></figure><p id="75e0" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">让我们看看反向引用的实际应用。在下面的例子中，我们将通过使用<code class="fe of og oh oi b">\2</code>重用第二组的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/ee0c8b707b177fb338e9f9b402ce3ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NvFVWkVnDC1UIazWFp44g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明了反向引用的应用，用Mr .替换名字，并通过\2重用第二个组中的第二个名字。(图片由作者提供)</figcaption></figure><h1 id="7928" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">4.环视断言</h1><p id="3612" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">regex激动人心的部分开始了！让我们考虑你只想要匹配一个模式，如果它是成功的或者是在一个特定的模式之前。换句话说，我们希望只有当一个模式的左半部分或右半部分与一个特定的子模式匹配时，才匹配这个模式。理论太多！该举例了。</p><h2 id="1cdf" class="on li it bd lj oo op dn ln oq or dp lr mi os ot lt mm ou ov lv mq ow ox lx iz bi translated">4.1使用(？=)</h2><p id="3dbd" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">假设您有五个测试，其结果如图所示。您只想检索那些通过的测试。换句话说，我们需要在<code class="fe of og oh oi b">Test\d</code>之前检查文本<code class="fe of og oh oi b">Passed</code>是否成功，然后只匹配文本<code class="fe of og oh oi b">Test\d</code>。</p><p id="26e0" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这被称为积极的前瞻，因为我们想得到匹配，只有当它是由一个给定的子模式。通过在子模式前添加<code class="fe of og oh oi b">?=</code>，可以将其转换为正向前瞻断言。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/ea81a1d35961feaf1b3776fe33170a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zd4SIDjUtolJKio_8JG2_Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明...的用法。=指定正向前瞻(作者图像)</figcaption></figure><p id="b722" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb jd">积极前瞻可用于检查任何预期密码是否满足最少字符、特殊字符等条件。</strong></p><h2 id="824d" class="on li it bd lj oo op dn ln oq or dp lr mi os ot lt mm ou ov lv mq ow ox lx iz bi translated">4.2使用(？！)</h2><p id="9f0f" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">现在我们想要检索那些后面没有文本<code class="fe of og oh oi b">Passed</code>的测试。这是一个消极前瞻的例子，因为我们不希望一个特定的子模式(这里是<code class="fe of og oh oi b">Passed</code>)后面跟随着某个东西(这里是<code class="fe of og oh oi b">Test\d</code>)。</p><p id="22ec" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">负前视的构造包括子模式前的<code class="fe of og oh oi b">?!</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/f807819df80e0e7197e736939ef5770f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXbqnrsV4JaO-DeRGnJNFQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">说明...的用法。！要指定负前瞻(按作者排列的图像)</figcaption></figure><h2 id="0298" class="on li it bd lj oo op dn ln oq or dp lr mi os ot lt mm ou ov lv mq ow ox lx iz bi translated">4.3使用(？&lt;=)</h2><p id="78b1" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">This is the flip side of positive lookahead. Here we want to match something only if it is preceded by a specific sub-pattern. In the following example, we only want to retrieve a number if it starts with the pound ( 【T0】 ).</p><p id="4721" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">The positive lookahead construct includes  【T1】  before the sub-pattern.</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/805efae9b999c8deb97fcb068415fc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*381LRPT5_Nqpp0zhFrCNuw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Illustrating usage of ?&lt;= to specify positive lookbehind (image by author)</figcaption></figure><h2 id="fd57" class="on li it bd lj oo op dn ln oq or dp lr mi os ot lt mm ou ov lv mq ow ox lx iz bi translated">4.4 Negative lookbehind using (?</h2><p id="c0ea" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">This is the complete opposite of negative lookahead. Here we want to match something only if it is NOT preceded by a specific sub-pattern. In the following example, we want to retrieve a number only if it DOES NOT start with the pound ( 【T2】 ).</p><p id="a5ed" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">The negative lookahead construct includes  【T3】  before the sub-pattern.</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/72abd885f835e8396eefbfaf7641389a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCKBt3dF9kUxeSr5RvEMNw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Illustrating usage of ?</figcaption></figure><h1 id="3c91" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">Closing remarks</h1><p id="b0e3" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">Thanks for reading the story! I hope it has strengthened your regex muscles. Let me close with an exercise question.</p><p id="4103" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb jd">问题:</strong>如何使用正则表达式验证满足以下条件的密码？<strong class="mb jd"> <br/>条件1 — </strong>它必须至少有8个字符<strong class="mb jd"> <br/>条件2— </strong>它必须至少有一个大写字母和一个小写字母<strong class="mb jd"> <br/>条件3— </strong>它必须至少有一个数字<br/>符合上述条件的密码示例是q1w2eR3T。</p><p id="22f5" class="pw-post-body-paragraph lz ma it mb b mc mv kd me mf mw kg mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">欢迎在评论中分享你的答案。如果你想知道更多这样的故事，请关注我。</p></div></div>    
</body>
</html>