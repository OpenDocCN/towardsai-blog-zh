<html>
<head>
<title>Time Series Prediction using Adaptive Filtering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用自适应滤波的时间序列预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/time-series-prediction-using-adaptive-filtering-491a43d8fa93?source=collection_archive---------2-----------------------#2020-07-23">https://pub.towardsai.net/time-series-prediction-using-adaptive-filtering-491a43d8fa93?source=collection_archive---------2-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f467" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="1c5c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python中使用自适应滤波预测未来时间序列值</h2></div><h1 id="c782" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">什么是自适应滤波？</h1><p id="643f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">自适应滤波是一种计算设备，它试图模拟两个信号之间的关系，这两个信号的系数随着使滤波器收敛到最佳状态的目标而变化。优化标准是成本函数，最常见的是自适应滤波器的输出和期望信号之间的误差的均方值。当滤波器调整其系数时，均方误差(MSE)将收敛到其最小值。下图演示了简单的自适应滤波器。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/10857aa49f8694520947dd21ee60e1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VacVVgi8MHA1Zhh-MhcWA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">简单的自适应滤波器工具箱</figcaption></figure><p id="584f" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">自适应滤波器将尝试使滤波器输出<em class="na"> y(k) </em>与期望信号<em class="na"> d(k) </em>相匹配。自适应滤波器还将利用误差<em class="na"> e(k) </em>进行学习，并调整系数。于是，它适应了新的环境，输入<em class="na"> x(k) </em>。</p><p id="d3e6" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">这为我们带来了自适应滤波的主要特性，即它具有<strong class="ll jd">实时调整响应的能力，以提高其性能</strong>(听起来像是自学，有人知道吗？).自适应算法通过两种方法实现；梯度法和最小二乘法(LMS，RLS算法)。</p><h1 id="5222" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">这是为了什么？</h1><p id="0135" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您学习过任何数字信号和处理课程，您会看到自适应滤波器的大部分应用是识别未知通信信道、消除噪声或干扰，或者预测周期信号的未来值。</p><h1 id="87a3" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">那么我们如何在商业环境中使用它呢？</h1><p id="b21c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基于数字用例的最后一个例子，我们可以应用这个概念来预测实时设置中的未来值，例如；股价预测。然而，使用这种方法预测未来需要几个<em class="na">关键假设；数据要么是稳定的，要么是随时间缓慢变化的，以及周期性的超时</em>。</p><p id="7901" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">接受这些假设，自适应滤波器必须根据过去的输入值预测期望输出的未来值。因此，我们需要构建输入信号的延迟，并将其馈入自适应滤波器系统。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nb"><img src="../Images/58619842cddccd3f64840433873fd6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Es8yu9rn-QeOTxqzL2F09w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使用自适应滤波器预测未来值</figcaption></figure><p id="9932" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">如前所述，自适应滤波器用于识别和理解未知系统，我们可以用它来识别和预测时间序列行为。</p><h1 id="3214" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">Python实现</h1><p id="20ec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Python中有一个名为<strong class="ll jd"> <em class="na"> padasip </em> </strong>的库，你可以用它来实现自适应滤波。在下面的<a class="ae nc" href="https://pypi.org/project/padasip/" rel="noopener ugc nofollow" target="_blank">链接</a>处检查库。</p><h2 id="0f20" class="nd ks it bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh iz bi translated">简单的实现示例</h2><p id="5fb7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在对时间序列数据使用自适应滤波器之前，让我们看一个简单的例子。假设我们有以下等式:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi no"><img src="../Images/a45dbf8bf11dc3e9100e61e54c675089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_deTZOXiFS_9xrBqD1ysQ.png"/></div></div></figure><p id="e19a" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">然后，我们可以准备输入、目标并运行过滤器(在本例中使用LMS)。关于滤波算法的其他来源，请访问<a class="ae nc" href="https://matousc89.github.io/padasip/sources/filters.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c36c" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">在我们运行<code class="fe nr ns nt nu b">f.run(d, x)</code>之后，我们将得到预测(y)、误差(e)和每次迭代的权重(w)。我们可以看到，在前几次迭代中，滤波器无法准确预测目标值，但随着迭代次数的增加，滤波器开始适应并预测接近目标值的值。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nv"><img src="../Images/f86f72ef8428228f1c398db9910065f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NURNDGTqLUzWAVKYq2v6iw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">实际值和预测值之间的比较(上图)，每次迭代的误差(下图)</figcaption></figure><h2 id="f1a1" class="nd ks it bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh iz bi translated">对股票价格数据使用NLMS的实现</h2><p id="312b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们试着预测优衣库的收盘价(从2012年到2016年)。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nw"><img src="../Images/c78d27afa298d7a1370c416672e231b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APOMviLEKYyjXIW8ADNzng.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">给定时间序列数据(优衣库的收盘价)</figcaption></figure><p id="8969" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">我们将开始使用前1000个数据点构建过滤器，每个预测迭代有5个滞后数据点。已经测试了<code class="fe nr ns nt nu b">mu</code>的三个值，具有最佳mu(最小误差)的样本代码如下所示。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">部分代码</figcaption></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nv"><img src="../Images/01c0b96fe55538b226ecc189e0aa7be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gllh48njncsaiz-PCBBjTQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">NLMS滤波结果以及第一次和最后300次迭代的可视化</figcaption></figure><p id="9ef1" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">我们可以看到过滤器如何需要几次(大约60次)迭代来调整权重以适应数据。在此阶段，我们还将获得过滤器以供进一步使用。下面的代码片段展示了我们如何在生产环境中使用它们。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1876" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">从代码中，我们获得上一步的最佳过滤器，并使用它来预测新的数据点(第18行)。在预测完成后，我们使用适应滤波器的方法来调整权重(第20行)。输出和错误如下所示。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nx"><img src="../Images/f6b4954296972a0561eac93b256cd421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njs4YJHq560c8RCBOss6_w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">模拟实时数据的自适应滤波结果</figcaption></figure><h2 id="66de" class="nd ks it bd kt ne nf dn kx ng nh dp lb ls ni nj ld lw nk nl lf ma nm nn lh iz bi translated">尾注</h2><p id="c4a7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个例子中，我演示了如何对时间序列数据使用自适应滤波器来预测未来值。对于自适应滤波器，有许多滤波器和算法可供尝试。对于您遇到的特定问题，可能需要查看和选择适当的过滤器类型。希望本文向您介绍了自适应滤波器及其在现实世界中的基本实现。</p><p id="a07b" class="pw-post-body-paragraph lj lk it ll b lm mv kd lo lp mw kg lr ls mx lu lv lw my ly lz ma mz mc md me im bi translated">你可以在我的Github上查看完整的笔记本和样本数据集(或者点击<a class="ae nc" href="https://nbviewer.jupyter.org/github/netsatsawat/Adaptive-Filter-NLMS-Introduction/blob/master/code/NLMS%20Adaptive%20filter%20Tutorial.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>直接查看笔记本)，也可以随时在LinkedIn上与我联系。</p><div class="ny nz gp gr oa ob"><a href="https://github.com/netsatsawat/Adaptive-Filter-NLMS-Introduction" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">netsatsawat/自适应滤波器NLMS-简介</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op mp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://www.linkedin.com/in/satsawat/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">沙特瓦特·纳塔卡·恩基特库尔- AVP，渣打银行-暹罗商业银行| LinkedIn高级数据科学家</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">我是一名数据爱好者，利用技术和业务知识来推动和传递对…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.linkedin.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op mp ob"/></div></div></a></div></div></div>    
</body>
</html>