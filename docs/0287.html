<html>
<head>
<title>Efficient Pandas: Using Chunksize for Large Data Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效的熊猫:对大型数据集使用Chunksize</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/efficient-pandas-using-chunksize-for-large-data-sets-c66bf3037f93?source=collection_archive---------0-----------------------#2020-01-27">https://pub.towardsai.net/efficient-pandas-using-chunksize-for-large-data-sets-c66bf3037f93?source=collection_archive---------0-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="37c0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><div class=""><h2 id="fca1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Pandas高效地探索大型数据集</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/847b1015f0bcfcee6ef35dfa7a40463e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SI0RX2SDvgyYTFrzkaZ7dw.jpeg"/></div></div></figure><p id="084d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">数据科学专业人员经常会遇到具有数百个维度和数百万个观察值的非常大的数据集。有多种方法可以处理大型数据集。我们都知道像<a class="ae lz" href="https://hadoop.apache.org/" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> Hadoop </em> </a>和<a class="ae lz" href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#overview" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> Spark </em> </a>这样的分布式文件系统，它们通过在集群中的多个工作节点上并行化来处理大数据。但是对于本文，我们将使用pandas<strong class="lf jd"><em class="ma">chunksize</em></strong>属性或<strong class="lf jd"> get_ <em class="ma"> chunk() </em> </strong>函数。</p><p id="7fea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">想象一下，你正在制作一部新电影，你想知道</p><blockquote class="mb mc md"><p id="4fe7" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated"><strong class="lf jd"> 1。从0.5到5.0最常见的电影评分是多少</strong></p><p id="a04a" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated"><strong class="lf jd"> 2。大多数制作的电影的平均电影评级是多少？</strong></p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mh"><img src="../Images/2e302498abdf5a4723383b21ff97571e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxqF816LPV1VABRAb0T4yg.jpeg"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated"><a class="ae lz" href="https://d26oc3sg82pgk3.cloudfront.net/files/media/edit/image/3372/article_full%401x.jpg" rel="noopener ugc nofollow" target="_blank"> img_credit </a></figcaption></figure><p id="357e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要回答这些问题，首先，我们需要找到一个包含数万部电影的电影评分的数据集。感谢<a class="ae lz" href="https://grouplens.org/about/what-is-grouplens/" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd"><em class="ma">group lens</em></strong></a><strong class="lf jd"><em class="ma"/></strong>提供<a class="ae lz" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd"><em class="ma">movie lens</em></strong></a>数据集，包含超过13.8万用户超过2000万的电影评分，涵盖超过2.7万部不同电影。</p><p id="f8cc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是一个庞大的数据集，用于构建推荐系统，这正是我们所需要的。所以我们用wget提取一下。我在Colab工作，但是任何笔记本或者IDE都可以。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="664a" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">!wget -O moviedataset.zip </strong><a class="ae lz" href="https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/ML0101ENv3/labs/moviedataset.zip" rel="noopener ugc nofollow" target="_blank"><strong class="mn jd">https://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/ML0101ENv3/labs/moviedataset.zip</strong></a></span><span id="5dae" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">print('unziping ...')</strong></span><span id="e9df" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">!unzip -o -j moviedataset.zip</strong></span></pre><p id="4736" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">解压缩文件夹会显示4个CSV文件:</p><p id="e45b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">links.csv</p><p id="8451" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">电影. csv</p><p id="d5f9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">评级. csv</p><p id="a8ce" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">tags.csv</p><p id="a751" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们感兴趣的是ratings.csv数据集，其中包含27，000多部电影的2000多万个电影评级。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="5975" class="mr ms it mn b gy mt mu l mv mw"># First let's import a few libraries<br/><strong class="mn jd">import pandas as pd<br/>import matplotlib.pyplot as plt</strong></span></pre><p id="0d01" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们看一下ratings.csv文件</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="ad78" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">ratings_df = pd.read_csv('ratings.csv')<br/>print(ratings_df.shape)<br/></strong>&gt;&gt;<br/>  <strong class="mn jd">(22884377, 4)</strong></span></pre><p id="3103" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如所料，ratings_df数据帧有超过2200万行。这对我们的计算机内存来说是一个很大的数据处理量。为了对这个数据集进行计算，一个接一个地分块处理数据集是很有效的。以一种懒惰的方式，使用迭代器对象。</p><blockquote class="mb mc md"><p id="91ae" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">请注意，我们不需要读取整个文件。我们可以简单地使用head()函数查看前五行，如下所示:</p></blockquote><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="868d" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">pd.read_csv('ratings.csv').head()</strong></span></pre><p id="fbe9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这一点上，讨论可迭代对象和迭代器是很重要的…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f797ad372108385b28f547587f9673c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*rRQvgdnsf1TgtBahqCNDbw.png"/></div></figure><p id="b3c3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">iterable是一个有关联的<em class="ma"> iter() </em>方法的对象。一旦这个<em class="ma"> iter() </em>方法被应用于iterable，迭代器对象就被创建了。在引擎盖下，这就是循环的<em class="ma">正在做的事情，它接受一个类似于<em class="ma">列表</em>、<em class="ma">字符串</em>或<em class="ma">元组</em>的可迭代对象，并应用一个<em class="ma"> iter() </em>方法，创建一个迭代器并遍历它。iterable还有一个<em class="ma"> __get_item__() </em>方法，可以使用方括号从iterable中提取元素。</em></p><p id="8bc3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请看下面的例子，将iterable转换为iterator对象。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="9cc4" class="mr ms it mn b gy mt mu l mv mw"># x below is a list. Which is an iterable object.<br/><strong class="mn jd">x = [1, 2, 3, 'hello', 5, 7]</strong></span><span id="b746" class="mr ms it mn b gy mx mu l mv mw"># passing x to the iter() method converts it to an iterator.<br/><strong class="mn jd">y = iter(x)</strong></span><span id="885e" class="mr ms it mn b gy mx mu l mv mw"># Checking type(y)<br/><strong class="mn jd">print(type(y))</strong><br/>&gt;&gt;<br/><strong class="mn jd">&lt;class 'list_iterator'&gt;</strong></span></pre><p id="a1cb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在文件上调用<em class="ma"> pd.read_csv() </em>函数返回的对象是可迭代对象。意思是它有<em class="ma"> __get_item__() </em>方法和关联的<em class="ma"> iter() </em>方法。然而，将数据帧传递给<em class="ma"> iter() </em>方法会创建一个地图对象。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="ec1c" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">df = pd.read_csv('movies.csv').head()</strong></span><span id="1602" class="mr ms it mn b gy mx mu l mv mw"># Let's pass the data frame df, to the iter() method<strong class="mn jd"><br/>df1 = iter(df)</strong></span><span id="889a" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">print(type(df1))</strong><br/>&gt;&gt;<br/><strong class="mn jd">&lt;class 'map'&gt;</strong></span></pre><p id="a49e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">迭代器被定义为一个对象，它有一个关联的<em class="ma"> next() </em>方法来产生连续的值。</p><p id="8339" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要从一个iterable创建一个迭代器，我们需要做的就是使用函数<em class="ma"> iter() </em>并将iterable传递给它。然后，一旦我们定义了迭代器，我们将它传递给<em class="ma"> next() </em>方法，这将返回第一个值。再次调用<em class="ma"> next() </em>返回下一个值，依此类推…直到没有更多的值要返回，然后抛出一个<strong class="lf jd"><em class="ma">stopiterionerror。</em> </strong></p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="c41d" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">x = [1, 2, 3]</strong></span><span id="2f64" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">x = iter(x)  </strong># Converting to an iterator object</span><span id="4c63" class="mr ms it mn b gy mx mu l mv mw"># Let’s call the next function on x using a for loop<br/><strong class="mn jd">for i in range(4): print(next(x))<br/>&gt;&gt;<br/>1<br/>2<br/>3<br/><em class="ma">StopIterationError<br/></em></strong># Error is displayed if next is called after all items have been printed out from an iterator object</span></pre><blockquote class="mb mc md"><p id="0511" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">请注意，术语“函数”和“方法”在这里可以互换使用。一般来说，它们的意思是一样的。只是方法通常应用于对象，如数据框上的head()方法，而函数通常接受参数，如print()函数。</p></blockquote><p id="b297" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你想了解python的理解和生成器，请看这个<a class="ae lz" href="https://github.com/Blackman9t/Effective_Python/blob/master/list_comprehensions_and_generators.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> <em class="ma">链接</em> </strong> </a>到我在Github上的笔记本。这篇文章没必要。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/03ed8cb02c930736953f64139791e5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*O0_ZaLefBljQjS9JkpvNPQ.png"/></div></figure><p id="0291" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">好的。让我们回到<em class="ma">收视率_df </em>数据框。我们想回答两个问题:</p><blockquote class="mb mc md"><p id="14da" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated"><strong class="lf jd"> 1。0.5到5.0最常见的电影评分是多少</strong></p><p id="bd62" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated"><strong class="lf jd"> 2。大多数电影的平均电影评分是多少？</strong></p></blockquote><p id="87b3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们检查ratings_df数据帧的内存消耗</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="5b79" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">ratings_memory = ratings_df.memory_usage().sum()</strong></span><span id="c9b6" class="mr ms it mn b gy mx mu l mv mw"># Let's print out the memory consumption<br/><strong class="mn jd">print('Total Current memory is-', ratings_memory,'Bytes.')</strong></span><span id="9786" class="mr ms it mn b gy mx mu l mv mw"># Finally, let's see the memory usage of each dimension.<br/><strong class="mn jd">ratings_df.memory_usage()<br/></strong>&gt;&gt;<br/><strong class="mn jd">Total Current memory is- 732300192 Bytes.</strong></span><span id="221e" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">Index              128<br/>userId       183075016<br/>movieId      183075016<br/>rating       183075016<br/>timestamp    183075016<br/>dtype: int64</strong></span></pre><p id="3a26" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以看到这个数据集的总内存消耗超过了<strong class="lf jd"> <em class="ma"> 732.3百万字节</em> </strong> …哇。</p><p id="a390" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因为我们对评级感兴趣，所以让我们从0.5到5.0获得不同的评级键</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="08c5" class="mr ms it mn b gy mt mu l mv mw"># Let's get a list of the rating scale or keys<strong class="mn jd"><br/>rate_keys = list(ratings_df['rating'].unique())</strong></span><span id="bae2" class="mr ms it mn b gy mx mu l mv mw"># let's sort the ratings keys from highest to lowest.<br/><strong class="mn jd">rate_keys = sorted(rate_keys, reverse=True)</strong> <br/> <br/><strong class="mn jd">print(rate_keys)<br/></strong>&gt;&gt;<strong class="mn jd"><br/></strong>  <strong class="mn jd">[5.0, 4.5, 4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5]</strong></span></pre><p id="bfe8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们现在知道了我们的评级尺度。接下来，要找到一种方法来获得量表上每个键的评分数。然而，由于内存大小的原因，我们应该分块读取数据集，并对每个块执行矢量化操作。除非必要，否则避免循环。</p><p id="99ec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的第一个目标是统计每个分级键的电影分级数。在2200多万的收视率中，每把钥匙有多少收视率？回答这个问题就自动回答了我们的第一个问题:-</p><h2 id="29c3" class="mr ms it bd na nb nc dn nd ne nf dp ng lm nh ni nj lq nk nl nm lu nn no np iz bi translated">问题一:</h2><blockquote class="nq"><p id="a04d" class="nr ns it bd nt nu nv nw nx ny nz ly dk translated"><strong class="ak"> 1。0.5到5.0最常见的电影评分是多少</strong></p></blockquote><p id="78f4" class="pw-post-body-paragraph ld le it lf b lg oa kd li lj ob kg ll lm oc lo lp lq od ls lt lu oe lw lx ly im bi translated">让我们使用一个简单的for循环来创建一个字典，它的键是惟一的评级键。然后我们把每个键赋值为零。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="b45c" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">ratings_dict = {}<br/>for i in rate_keys: ratings_dict[i] = 0</strong></span><span id="61c4" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">ratings_dict<br/></strong>&gt;&gt;</span><span id="459c" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">{0.5: 0,  1.0: 0,  1.5: 0,  2.0: 0,  2.5: 0,  3.0: 0,  3.5: 0,  4.0: 0,  4.5: 0,  5.0: 0}</strong></span></pre><p id="eb6c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来，我们使用python <em class="ma"> enumerate() </em>函数，传递<em class="ma"> pd.read_csv() </em>函数作为其第一个参数，然后在<em class="ma"> read_csv() </em>函数中，我们指定<em class="ma"> chunksize = 1000000 </em>，一次读取一百万行数据的块。</p><p id="3d76" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们从1开始<em class="ma"> enumerate() </em>函数索引，传递<strong class="lf jd"><em class="ma">start = 1</em></strong><em class="ma"/>作为它的第二个参数<em class="ma">。这样我们就可以使用索引计算每个块处理的平均字节数。然后，我们对评分键使用一个简单的for循环，提取每个组块每个键的评分数，并在<em class="ma"> ratings_dict </em>中对每个键的评分数求和</em></p><p id="03f3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最终的<em class="ma"> ratings_dict </em>将包含作为关键字的每个评级关键字和作为值的每个关键字的总评级。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9ed3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用chunksize属性我们可以看到:<br/> <strong class="lf jd">总块数:23 <br/>每个块的平均字节数:3180万字节</strong></p><p id="b2b4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这意味着如果我们一次处理完整的数据帧，我们每块处理大约<strong class="lf jd"><em class="ma">3200万字节的数据</em> </strong>而不是<strong class="lf jd"> <em class="ma"> 732万字节的数据</em> </strong>。这是计算和内存高效的，尽管通过数据帧的懒惰迭代。</p><p id="5bc1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有23个块，因为我们一次从数据集中取出100万行，有2280万行。这意味着第23块有最后的80万行数据。</p><p id="765d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们还可以在下面看到我们的ratings_dict，包括每个评分键和每个键的评分总数</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="6dd5" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">{5.0: 3358218, 4.5: 1813922, 4.0: 6265623, 3.5: 2592375, 3.0: 4783899, 2.5: 1044176, 2.0: 1603254, 1.5: 337605, 1.0: 769654, 0.5: 315651}</strong></span></pre><p id="a5e7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，通过在<code class="fe oh oi oj mn b">r<strong class="lf jd">ead_csv</strong></code>中指定<code class="fe oh oi oj mn b"><strong class="lf jd">chunksize</strong></code>，返回值将是一个<code class="fe oh oi oj mn b"><strong class="lf jd">TextFileReader</strong> .</code>类型的可迭代对象，指定<code class="fe oh oi oj mn b"><strong class="lf jd">iterator=True</strong></code>也将返回<code class="fe oh oi oj mn b"><strong class="lf jd">TextFileReader</strong></code>对象:</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="255a" class="mr ms it mn b gy mt mu l mv mw"># Example of passing chunksize to read_csv<br/><strong class="mn jd">reader = pd.read_csv(’some_data.csv’, chunksize=100)</strong><br/># Above code reads first 100 rows, if you run it in a loop, it reads the next 100 and so on</span><span id="bee8" class="mr ms it mn b gy mx mu l mv mw"># Example of iterator=True. Note iterator=False by default.<br/><strong class="mn jd">reader = pd.read_csv('some_data.csv', iterator=True)<br/>reader.get_chunk(100)<br/></strong>This gets the first 100 rows, running through a loop gets the next 100 rows and so on.</span><span id="42a7" class="mr ms it mn b gy mx mu l mv mw"># Both chunksize=100 and reader.get_chunk(100) return same TextFileReader object.</span></pre><p id="1b13" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这表明<em class="ma"> chunksize </em>的行为就像迭代器的next()函数，迭代器使用<em class="ma"> next() </em>函数来获取它的下一个元素，而<em class="ma">get _ chunksize()</em><strong class="lf jd"><em class="ma"/></strong>函数从数据帧中抓取下一个指定数量的数据行，这类似于迭代器。</p><p id="1bfc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在继续之前，让我们确认我们从上面的练习中获得了完整的评级。总评分应等于ratings_df中的行数。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="0232" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">sum(list(ratings_dict.values())) == len(ratings_df)</strong><br/>&gt;&gt;<br/><strong class="mn jd">True</strong></span></pre><p id="d91c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们通过从<em class="ma"> ratings_dict </em>中选择具有最大值的键/值对来最终回答<strong class="lf jd">问题一 </strong>。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="38f2" class="mr ms it mn b gy mt mu l mv mw"># We use the operator module to easily get the max and min values<strong class="mn jd"><br/>import operator<br/>max(ratings_dict.items(), key=operator.itemgetter(1))</strong></span><span id="2c62" class="mr ms it mn b gy mx mu l mv mw">&gt;&gt;<br/>  <strong class="mn jd">(4.0, 6265623)</strong></span></pre><p id="b842" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以看到评分值最高的评分键是<strong class="lf jd"> 4.0 </strong>，值为<strong class="lf jd">6265623</strong>电影评分。</p><blockquote class="mb mc md"><p id="8484" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">因此，从0.5到5.0最常见的电影评级是4.0 </p></blockquote><p id="7986" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们从最大值到最小值来可视化评级键和值的图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/ae6e4fd16b41c902f71fa17556860db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F52xjTpE6jnwPpJ_QhxhEw.jpeg"/></div></div></figure><p id="b436" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们从<em class="ma"> ratings_dict </em>创建一个数据帧(<em class="ma"> ratings_dict_df </em>)，只需将每个值转换为一个列表，并将<em class="ma"> ratings_dict </em>传递给pandas <em class="ma"> DataFrame() </em>函数。然后，我们按照降序对数据帧进行排序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/f8630c0bcd17cce0da008bf1f7b7c17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*Na4OXrKdJBVPfC_865hc-g.jpeg"/></div></div></figure><h2 id="930d" class="mr ms it bd na nb nc dn nd ne nf dp ng lm nh ni nj lq nk nl nm lu nn no np iz bi translated">问题二:</h2><blockquote class="nq"><p id="0d1b" class="nr ns it bd nt nu nv nw nx ny nz ly dk translated"><strong class="ak"> 2。大多数电影的平均电影评分是多少？</strong></p></blockquote><p id="6d5d" class="pw-post-body-paragraph ld le it lf b lg oa kd li lj ob kg ll lm oc lo lp lq od ls lt lu oe lw lx ly im bi translated">为了回答这个问题，我们需要计算分布的加权平均值。</p><blockquote class="mb mc md"><p id="3c03" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">这仅仅意味着我们将每个评分键乘以其被评分的次数，然后将它们相加，再除以总评分数。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/baba847a9cd3cb25d5f6c6c30ab6bbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLkYLsR_rjRNwVb-utLCvQ.jpeg"/></div></div></figure><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="62a2" class="mr ms it mn b gy mt mu l mv mw"># First we find the sum of the product of rate keys and corresponding values.<br/><strong class="mn jd">product = sum((ratings_dict_df.Rating_Keys * ratings_dict_df.Count))</strong></span><span id="fa35" class="mr ms it mn b gy mx mu l mv mw"># Let's divide product by total ratings.<br/><strong class="mn jd">weighted_average = product / len(ratings_df)</strong></span><span id="b92c" class="mr ms it mn b gy mx mu l mv mw"># Then we display the weighted-average below.<br/><strong class="mn jd">weighted_average</strong><br/>&gt;&gt;<br/><strong class="mn jd">  3.5260770044122243</strong></span></pre><p id="ba50" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了回答第二个问题，我们可以说</p><blockquote class="mb mc md"><p id="5637" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated"><strong class="lf jd">0.5到5.0的电影平均评分为3.5。</strong></p></blockquote><p id="b1fe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">相当鼓舞人心的是，在<strong class="lf jd"> <em class="ma"> 5.0 </em> </strong>的评分尺度上，大多数电影的评分都是<strong class="lf jd"><em class="ma"/></strong>4.0，平均评分<strong class="lf jd"><em class="ma"/></strong>3.5……嗯，有人在考虑电影制作吗？</p><p id="7cec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你像我认识的大多数人一样，那么下一个合乎逻辑的问题是:-</p><blockquote class="nq"><p id="a6ad" class="nr ns it bd nt nu nv nw nx ny nz ly dk translated">嘿，劳伦斯，我的电影至少被评为一般的可能性有多大？</p></blockquote><p id="1c10" class="pw-post-body-paragraph ld le it lf b lg oa kd li lj ob kg ll lm oc lo lp lq od ls lt lu oe lw lx ly im bi translated">为了找出多少百分比的电影至少被评为平均水平，我们将计算<strong class="lf jd"> <em class="ma">相对频率</em> </strong>的评级百分比分布。</p><blockquote class="mb mc md"><p id="0e2b" class="ld le ma lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">这仅仅意味着每个分级键占电影分级的百分比是多少？</p></blockquote><p id="351d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们使用<em class="ma">应用</em>和<em class="ma">λ</em>向ratings_dict_df添加一个百分比列。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="9010" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">ratings_dict_df['Percent'] = ratings_dict_df['Count'].apply(lambda x: (x / (len(ratings_df)) * 100))</strong></span><span id="f0a7" class="mr ms it mn b gy mx mu l mv mw"><strong class="mn jd">ratings_dict_df</strong><br/>&gt;&gt;</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2087b9c608c9c63b573a19ed1426d786.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*OO-8D7TQ-DIMrAIRQcm1QQ.jpeg"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">每个键的电影分级百分比。</figcaption></figure><p id="5141" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，为了找到至少被评为平均水平的电影的百分比(<strong class="lf jd"><em class="ma"/></strong>)3.5，我们简单地将电影关键点<strong class="lf jd"> <em class="ma"> 3.5 </em> </strong>到<strong class="lf jd"> <em class="ma"> 5.0 </em>的百分比相加。</strong></p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="a151" class="mr ms it mn b gy mt mu l mv mw"><strong class="mn jd">sum(ratings_dict_df[ratings_dict_df.Rating_Keys &gt;= 3.5]['Percent'])</strong><br/>&gt;&gt;<br/>  <strong class="mn jd">61.308804692389046</strong></span></pre><h2 id="77a9" class="mr ms it bd na nb nc dn nd ne nf dp ng lm nh ni nj lq nk nl nm lu nn no np iz bi translated">调查结果:</h2><p id="552c" class="pw-post-body-paragraph ld le it lf b lg oo kd li lj op kg ll lm oq lo lp lq or ls lt lu os lw lx ly im bi translated">从这些练习中，我们可以推断，在<strong class="lf jd"><em class="ma"/></strong>5.0的评分范围内，大多数电影的评分为<strong class="lf jd"><em class="ma"/></strong>4.0，电影的平均评分为<strong class="lf jd"><em class="ma"/></strong>3.5，最后，超过<strong class="lf jd"> <em class="ma"> 61.3% </em> </strong>的所有电影的评分至少为<strong class="lf jd"> <em class="ma"> 3.5。</em> </strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/e9d3d57886b61963b7872292aa828317.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*JnB3hQLnMudx4nQQb6AszQ.jpeg"/></div></div></figure><h2 id="b81a" class="mr ms it bd na nb nc dn nd ne nf dp ng lm nh ni nj lq nk nl nm lu nn no np iz bi translated">结论:</h2><p id="e241" class="pw-post-body-paragraph ld le it lf b lg oo kd li lj op kg ll lm oq lo lp lq or ls lt lu os lw lx ly im bi translated">我们已经看到了如何使用pandas chunksize属性处理大型数据集，尽管是以一种懒散的方式一个块接一个块地处理。</p><p id="eb94" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">优点可以说是有效的内存使用和计算效率。缺点包括计算时间和可能使用for循环。重要的是要说明，对每个块应用矢量化运算可以大大加快计算时间。</p><p id="dd6a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">谢谢你的时间。</p><p id="e2cc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">页（page的缩写）在Github的<a class="ae lz" href="https://github.com/Lawrence-Krukrubo/exploring_python_iterables-iterators" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a>中可以看到这篇文章的笔记本链接。</p><p id="a463" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">干杯！</strong></p><h2 id="b307" class="mr ms it bd na nb nc dn nd ne nf dp ng lm nh ni nj lq nk nl nm lu nn no np iz bi translated">关于我:</h2><p id="2a6d" class="pw-post-body-paragraph ld le it lf b lg oo kd li lj op kg ll lm oq lo lp lq or ls lt lu os lw lx ly im bi translated">劳伦斯是技术层的数据专家，对公平和可解释的人工智能和数据科学充满热情。我持有IBM的 <strong class="lf jd"> <em class="ma">数据科学专业</em> </strong> <em class="ma">和</em> <strong class="lf jd"> <em class="ma">高级数据科学专业</em> </strong> <em class="ma">证书。我已经使用ML和DL库进行了几个项目，我喜欢尽可能多地编写函数代码，即使现有的库比比皆是。最后，我从未停止学习和实验，是的，我拥有几个数据科学和人工智能认证，并且我已经写了几篇强烈推荐的文章。</em></p><p id="2aed" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请随时在以下网址找到我</p><p id="31dd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://github.com/Lawrence-Krukrubo" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> Github </strong> </a></p><p id="f239" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://www.linkedin.com/in/lawrencekrukrubo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">领英</strong> </a></p><p id="4257" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://twitter.com/LKrukrubo" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">推特</strong> </a></p></div></div>    
</body>
</html>