<html>
<head>
<title>Machine Learning Model Stacking in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的机器学习模型堆栈</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/machine-learning-model-stacking-in-python-f7c7068efe3f?source=collection_archive---------1-----------------------#2022-01-21">https://pub.towardsai.net/machine-learning-model-stacking-in-python-f7c7068efe3f?source=collection_archive---------1-----------------------#2022-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="cb5e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="b0ad" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">了解如何使用堆叠来提高模型性能</h2></div><blockquote class="ko kp kq"><p id="0948" class="kr ks kt ku b kv kw ka kx ky kz kd la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">堆叠是一种集成学习，其中多层模型用于最终预测。更具体地说，我们使用一些第一级模型预测训练集(以类似CV方式)和测试集，然后使用这些预测作为第二级模型的特征。</p></blockquote><p id="00d1" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">我们可以在python中使用一个名为“Vecstack”的库来实现。该库由Igor Ivanov开发，于2016年发布。在这篇文章中，我们将看看这个库对于一个分类问题的基本实现。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/30d0a166146c31280bb02b08b4239898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcGmOuMTARvshOY5bDN81Q.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">将多个模型的输出合并为一个</figcaption></figure><p id="8ca5" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">可以使用以下方式安装该库:</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="8109" class="mm mn iq mi b gy mo mp l mq mr">pip install vecstack</span></pre><p id="c9bb" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">接下来，我们导入它:</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="5a07" class="mm mn iq mi b gy mo mp l mq mr">from vecstack import stacking</span></pre><p id="e0b2" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">首先，我们将创建单独的模型并执行超参数调整，以找出所有模型的最佳参数。为了避免过度拟合，我们应用交叉验证将数据分成5份，并计算roc_auc得分的平均值。</p><ol class=""><li id="dd11" class="ms mt iq ku b kv kw ky kz lo mu lp mv lq mw ln mx my mz na bi translated">决策树分类器:</li></ol><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="0f7d" class="mm mn iq mi b gy mo mp l mq mr">#Hyperparameter tuning for decision tree classifier</span><span id="3f9c" class="mm mn iq mi b gy nb mp l mq mr">clf = DecisionTreeClassifier()<br/>parameters={'min_samples_split' : np.arange(10,100,10),'max_depth': np.arange(1,20,2)}<br/>clf_random = RandomizedSearchCV(clf,parameters,n_iter=15 , scoring = 'roc_auc' , cv =5 , verbose = True)<br/>clf_random.fit(x_train, y_train)</span><span id="f25f" class="mm mn iq mi b gy nb mp l mq mr">#Best parameters <br/>{'min_samples_split': 70, 'max_depth': 9}</span><span id="6060" class="mm mn iq mi b gy nb mp l mq mr">#mean roc_auc score<br/>0.8142247920534071</span></pre><p id="c016" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated"><em class="kt">同样，</em></p><p id="54b0" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">2.随机森林分类器:</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="ca87" class="mm mn iq mi b gy mo mp l mq mr">#Best parameters<br/>{'min_samples_split': 90, 'max_depth': 9}</span><span id="c029" class="mm mn iq mi b gy nb mp l mq mr">#mean roc_auc score<br/>0.8051500705643935</span></pre><p id="1db8" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">3.多层感知器分类器；</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="b111" class="mm mn iq mi b gy mo mp l mq mr">#Best parameters<br/>{'max_iter': 100, 'learning_rate': 'constant', 'hidden_layer_sizes': (20, 7, 3), 'activation': 'tanh'}</span><span id="2aac" class="mm mn iq mi b gy nb mp l mq mr">#mean roc_auc score<strong class="mi ja"><br/></strong>0.8017714839042659</span></pre><p id="6132" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">4.KNeighbours分类器:</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="f947" class="mm mn iq mi b gy mo mp l mq mr">#Best parameters<br/>{'weights': 'distance', 'n_neighbors': 7}</span><span id="2802" class="mm mn iq mi b gy nb mp l mq mr">#mean roc_auc score<br/>0.7013120709379057</span></pre><p id="e359" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">5.支持向量机分类器；</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="d217" class="mm mn iq mi b gy mo mp l mq mr">#Best parameters<br/>{'max_iter': 700}</span><span id="c0c1" class="mm mn iq mi b gy nb mp l mq mr">#mean roc_auc score<br/>0.8672302452275072</span></pre><p id="6ff4" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">接下来，我们为堆叠模型创建一个基础层，绕过上面提到的所有模型。我们希望用一些第一级模型预测训练集和测试集，然后使用这些预测作为第二级模型的特征。任何模型都可以用作一级模型或二级模型。</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="2aa9" class="mm mn iq mi b gy mo mp l mq mr"># 1st level models</span><span id="6bf5" class="mm mn iq mi b gy nb mp l mq mr">models = [KNeighborsClassifier(n_neighbors= 3) ,  <br/>          DecisionTreeClassifier(min_samples_split= 70,max_depth=9), <br/>          RandomForestClassifier(min_samples_split= 90,max_depth=9),<br/>          MLPClassifier(max_iter= 100, learning_rate='constant',hidden_layer_sizes= (20, 7, 3), activation= 'tanh') , <br/>          LinearSVC(max_iter= 700) ]<br/>      <br/>S_Train, S_Test = stacking(models,                   <br/>                           x_train, y_train ,x_test ,   <br/>                           regression=False, <br/>  <br/>                           mode='oof_pred_bag', <br/>       <br/>                           needs_proba=False,<br/>         <br/>                           save_dir=None, <br/>            <br/>                           metric= roc_auc_score, <br/>    <br/>                           n_folds=4, <br/>                 <br/>                           stratified=True,<br/>            <br/>                           shuffle=True,  <br/>            <br/>                           random_state=0,    <br/>         <br/>                           verbose=2)</span></pre><p id="b024" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">接下来，我们将这些模型的预测作为输入传递给我们的第2层模型，在这种情况下是MLP分类器。我们还对这个模型进行了超参数调整和交叉验证。</p><pre class="ls lt lu lv gt mh mi mj mk aw ml bi"><span id="f33e" class="mm mn iq mi b gy mo mp l mq mr">mlp = MLPClassifier()<br/>parameters = {'hidden_layer_sizes':[(10,5,3), (20,7,3)], 'activation':['tanh', 'relu'], 'learning_rate':['constant', 'adaptive'], 'max_iter' :[100, 150]}<br/>mlp_random = RandomizedSearchCV(mlp,parameters,n_iter=15 , scoring = 'roc_auc' , cv =5 , verbose = True)<br/>mlp_random.fit(S_Train , y_train)<br/>grid_parm=mlp_random.best_params_<br/>print(grid_parm)<br/>print(mlp_random.best_score_)</span></pre><p id="008e" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">最终模型的Roc_Auc得分的平均值是<strong class="ku ja">0.93065863861</strong></p><p id="f50c" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated"><strong class="ku ja">结论:</strong></p><p id="29a5" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la lo lc ld le lp lg lh li lq lk ll lm ln ij bi translated">因此，使用堆叠，我们能够将模型的性能提高至少7%！堆叠是一种将多个模型的优势结合成一个强大模型的方法。话虽如此，堆叠可能并不总是最好的做法，因为它涉及大量使用计算资源，并且必须根据业务案例、时间和资金来决定是否使用它。对这个库的开发者伊戈尔·伊万诺夫来说，这是一个非常棒的工作。</p></div></div>    
</body>
</html>