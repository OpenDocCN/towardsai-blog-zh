<html>
<head>
<title>A Beginner’s Guide To Configuring Haystack To Work With Weaviate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">配置Haystack以使用Weaviate的初学者指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-beginners-guide-to-configuring-haystack-to-work-with-weaviate-6f90dc903175?source=collection_archive---------0-----------------------#2022-12-07">https://pub.towardsai.net/a-beginners-guide-to-configuring-haystack-to-work-with-weaviate-6f90dc903175?source=collection_archive---------0-----------------------#2022-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f31c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用VS代码和Docker编写</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9056a4cb5ab9a13b9241f419860eda2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73KZOxH2YzCTRFVHDldhsg.png"/></div></div></figure><h1 id="3c9b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="9282" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这篇博文将解释如何创建一个简单的docker-compose <a class="ae mi" href="https://github.com/deepset-ai/haystack" rel="noopener ugc nofollow" target="_blank"> Haystack </a>部署，该部署使用<a class="ae mi" href="https://github.com/semi-technologies/weaviate" rel="noopener ugc nofollow" target="_blank"> Weaviate </a>作为其文档存储。我们将使用Haystack repo中可用的<a class="ae mi" href="https://github.com/deepset-ai/haystack/blob/main/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose文件</a>作为起点，并讨论所需的更改。</p><p id="c23b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">重现本报告中描述的部署的代码是<a class="ae mi" href="https://github.com/hsm207/haystack-weaviate-docker-compose" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h1 id="f3aa" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">问题陈述</h1><p id="8d64" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Haystack的<a class="ae mi" href="https://docs.haystack.deepset.ai/v1.4.0/docs/document_store" rel="noopener ugc nofollow" target="_blank">文档</a>声明该框架支持许多开箱即用的文档存储。然而，只有Elasticsearch有docker-compose部署。对其他文档存储的支持仅通过代码示例来演示。即使是Weaviate团队也在代码片段方面讨论与Haystack的集成(例如，观看这个<a class="ae mi" href="https://www.youtube.com/watch?v=BkozaOnZpJI" rel="noopener ugc nofollow" target="_blank">视频</a>)。</p><p id="3d34" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这使得很难全面了解将一个使用其他文档存储的工作的Haystack解决方案部署到生产环境中需要做些什么。这可能会影响开发人员的体验，尤其是对于一个刚刚开始构建由vector search支持的解决方案的人来说，如果这些更改不是微不足道或显而易见的话。</p><h1 id="4dd3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">解决方案</h1><p id="db2f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">创建一个使用Weaviate作为其文档存储的Haystack docker-compose部署可以分为七个步骤，即:</p><ol class=""><li id="155d" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">拿些文件</li><li id="151f" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">克隆干草堆回购协议</li><li id="5e79" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">在容器中构建干草堆回购</li><li id="9b2d" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">定义管道配置</li><li id="8ba8" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">创建<code class="fe nc nd ne nf b">docker-compose.yml</code>文件</li><li id="7cd7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">调出部署</li><li id="3a1f" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">上传数据</li></ol><h2 id="8225" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">第一步:拿一些文件</h2><p id="835c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了简单起见，我们将只使用lingua.com的几篇英语短文来测试部署。你可以在这里看到这些段落<a class="ae mi" href="https://github.com/hsm207/haystack-weaviate-docker-compose/tree/master/data" rel="noopener ugc nofollow" target="_blank">的内容和出处。</a></p><h2 id="4035" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">第二步:克隆干草堆回购协议</h2><p id="922a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以使用来自deepset的预构建映像之一，例如<a class="ae mi" href="https://hub.docker.com/r/deepset/haystack-cpu" rel="noopener ugc nofollow" target="_blank"> deepset/haystack-cpu </a>来运行haystack框架。然而，在本地构建框架将有助于调试和探索解决方案如何在幕后工作。所以，让我们开始吧。</p><p id="72e9" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">该命令将克隆特定版本的Haystack:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="5747" class="nw kv it nf b be nx ny l nz oa">git clone --depth 1 --branch HAYSTACK_VERSION https://github.com/deepset-ai/haystack.git</span></pre><h2 id="a1dd" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">步骤3:在容器中构建干草堆回购</h2><p id="23c1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">创建一个名为<code class="fe nc nd ne nf b">haystack.Dockerfile</code>的文件来构建我们在上一步中克隆的Haystack repo:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="0757" class="nw kv it nf b be nx ny l nz oa">FROM deepset/haystack-cpu:latest<br/>        <br/>WORKDIR /app<br/>COPY haystack /app<br/>RUN pip install -e '.[dev,ocr,weaviate]'</span></pre><p id="0106" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">请注意以下几点:</p><ol class=""><li id="f654" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">我们使用deepset中的一个映像作为基础映像，以避免自己处理构建依赖关系</li><li id="e880" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">回购安装在容器内的<code class="fe nc nd ne nf b">/app</code>文件夹中</li><li id="3122" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">我们只构建我们实际需要的依赖集，即<code class="fe nc nd ne nf b">dev, ocr</code>和<code class="fe nc nd ne nf b">weaviate</code>(你可以参考项目的<a class="ae mi" href="https://github.com/deepset-ai/haystack/blob/main/pyproject.toml" rel="noopener ugc nofollow" target="_blank"> toml文件</a>来了解这些组下的依赖集)</li></ol><h2 id="87f8" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">步骤4:定义管道配置</h2><p id="21de" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以采用<code class="fe nc nd ne nf b"><a class="ae mi" href="https://github.com/deepset-ai/haystack/blob/v1.11.x/rest_api/rest_api/pipeline/pipelines.haystack-pipeline.yml" rel="noopener ugc nofollow" target="_blank">pipelines.haystack-pipeline.yml</a></code>配置并修改<code class="fe nc nd ne nf b">DocumentStore</code>组件，使其看起来像:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="2d6c" class="nw kv it nf b be nx ny l nz oa">- name: DocumentStore<br/>    type: WeaviateDocumentStore<br/>    params:<br/>      host: http://weaviate<br/>      similarity: "dot_product"<br/>      custom_schema:<br/>        classes:<br/>          - class: "Document"<br/>            invertedIndexConfig:<br/>              cleanupIntervalSeconds: 60<br/>            vectorizer: text2vec-transformers<br/>            properties:<br/>              - name: "name"<br/>                dataType:<br/>                  - string<br/>              - name: "content"<br/>                dataType:<br/>                  - text<br/>            vectorIndexConfig:<br/>              distance: "dot"</span></pre><p id="d431" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">注意，我们必须指定自己的模式。这是因为Haystack创建的默认Weaviate模式没有指定任何。<code class="fe nc nd ne nf b">vectorizer</code>(见此处<a class="ae mi" href="https://github.com/deepset-ai/haystack/blob/05ea711c72f94c6d7bbbbd59cb7f6ef086cbfa6e/haystack/document_stores/weaviate.py#L187" rel="noopener ugc nofollow" target="_blank"/>)。这意味着当我们上传一个文档到Weaviate时，我们将不得不自己手动提供向量表示。这实际上是不必要的，因为我们可以使用Weaviate的<code class="fe nc nd ne nf b"><a class="ae mi" href="https://weaviate.io/developers/weaviate/current/retriever-vectorizer-modules/text2vec-transformers.html" rel="noopener ugc nofollow" target="_blank">text2vec-transformers</a></code>模块来自动计算向量表示。</p><p id="d59d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们还需要更新<code class="fe nc nd ne nf b">Retriever</code>组件，因为<a class="ae mi" href="https://weaviate.io/developers/weaviate/current/modules/index.html#dense-retrievers-vs-sparse-retrievers" rel="noopener ugc nofollow" target="_blank"> Weaviate不支持BM25检索</a>(在撰写本文时)。因此，我们需要告诉Haystack使用一个<code class="fe nc nd ne nf b"><a class="ae mi" href="https://docs.haystack.deepset.ai/v1.4.0/docs/retriever#embedding-retrieval-recommended" rel="noopener ugc nofollow" target="_blank">EmbeddingRetriever</a></code>来代替:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="a337" class="nw kv it nf b be nx ny l nz oa">  - name: Retriever<br/>    type: EmbeddingRetriever<br/>    params:<br/>      embedding_model: sentence-transformers/paraphrase-MiniLM-L6-v2 # from huggingface's model hub<br/>      document_store: DocumentStore<br/>      top_k: 5</span></pre><h2 id="2846" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">第五步:创建<code class="fe nc nd ne nf b">docker-compose.yml</code>文件</h2><p id="9f87" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这些是我们在Haystack中将Weaviate用作文档存储时需要的服务:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="154c" class="nw kv it nf b be nx ny l nz oa">  weaviate:<br/>    image: semitechnologies/weaviate:1.16.6<br/>    ports:<br/>      - 8080:8080<br/>    environment:<br/>      - AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED=true<br/>      - PERSISTENCE_DATA_PATH=/var/lib/weaviate<br/>      - QUERY_DEFAULTS_LIMIT=20<br/>      - DEFAULT_VECTORIZER_MODULE=text2vec-transformers<br/>      - ENABLE_MODULES=text2vec-transformers<br/>      - TRANSFORMERS_INFERENCE_API=http://t2v-transformers:8080<br/><br/>  t2v-transformers:<br/>    image: semitechnologies/transformers-inference:sentence-transformers-paraphrase-MiniLM-L6-v2<br/>    environment:<br/>      ENABLE_CUDA: 0</span></pre><p id="5a5d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">当一个文档上传到这里时，<code class="fe nc nd ne nf b">weaviate</code>服务将使用<code class="fe nc nd ne nf b">t2v-transformers</code>服务对其进行矢量化处理。</p><p id="7f6b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">下面是实际运行Haystack框架的服务:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="1dc9" class="nw kv it nf b be nx ny l nz oa">  haystack-api:<br/>    build:<br/>      context: .<br/>      dockerfile: ./haystack.Dockerfile<br/>    ports:<br/>      - 8000:8000<br/>    restart: on-failure<br/>    environment:<br/>      # See rest_api/pipeline/pipelines.haystack-pipeline.yml for configurations of Search &amp; Indexing Pipeline.<br/>      - PIPELINE_YAML_PATH=/app/rest_api/rest_api/pipeline/pipelines.haystack-pipeline.yml<br/>      - QUERY_PIPELINE_NAME=query<br/>      - TOKENIZERS_PARALLELISM=false<br/>    working_dir: /app/rest_api<br/>    volumes:<br/>      - ./haystack:/app<br/>      - ./pipelines.haystack-pipeline.yml:/app/rest_api/rest_api/pipeline/pipelines.haystack-pipeline.yml<br/>    command: "/bin/bash -c 'gunicorn rest_api.application:app -b 0.0.0.0 -k uvicorn.workers.UvicornWorker --workers 1 --timeout 3600'"<br/>    depends_on:<br/>      - weaviate</span></pre><p id="e39d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">请注意:</p><ol class=""><li id="2964" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">我们将克隆的haystack repo挂载到容器的<code class="fe nc nd ne nf b">/app</code>文件夹中，以防我们想要从容器内部进行代码更改</li><li id="f74a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">我们还将<code class="fe nc nd ne nf b">pipelines.haystack-pipeline.yml</code>配置挂载到容器中，以便它可以被<code class="fe nc nd ne nf b">PIPELINE_YAML_PATH</code>环境变量引用</li><li id="d495" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">我们公开端口8000，这样我们就可以从部署外部调用Haystack的REST API</li></ol><h2 id="b7af" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">步骤6:启动部署</h2><p id="98cf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用VS代码很容易做到这一点:只需从命令面板中调用<code class="fe nc nd ne nf b">Docker: Compose Up</code>命令，然后等待直到所有容器都在运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b20d17d75e1e84461d3bb7da7ee1150b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DFO84tj6kcEK2dW6TymJw.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">图1:从命令面板运行“docker-compose up”</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/027dbda0693827dff9241edd20205e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLUG9-NHcFMGdi2RZrFnMw.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">图2:终端中显示所有容器都已打开的消息</figcaption></figure><p id="ef25" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们还可以通过检查分别调用Haystack和Weaviate的<code class="fe nc nd ne nf b">health</code>和<code class="fe nc nd ne nf b">nodes</code>端点的结果来获得部署成功的额外保证，这在使用<a class="ae mi" href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" rel="noopener ugc nofollow" target="_blank"> REST客户端</a>扩展的VS代码中非常容易做到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/34d86c889a7f8da54c0b614e672036ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSztOGDbR3gSV8QRdJe6CA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">图3:检查haystack部署是否顺利</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a3798f387af9f452054228fc7335b296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SkzHjtu1WSikwUDvbqIjhQ.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">图4:检查weaviate部署是否顺利</figcaption></figure><h2 id="e4eb" class="ng kv it bd kw nh ni dn la nj nk dp le lv nl nm lg lz nn no li md np nq lk nr bi translated">步骤7:上传数据</h2><p id="dfa7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以使用Haystack的<code class="fe nc nd ne nf b">file-upload</code>端点告诉它预处理步骤1中的文档并上传到Weaviate:</p><pre class="kj kk kl km gt ns nf nt bn nu nv bi"><span id="c031" class="nw kv it nf b be nx ny l nz oa"> curl -X 'POST' \<br/>  'http://localhost:8000/file-upload' \<br/>  -H 'accept: application/json' \<br/>  -H 'Content-Type: multipart/form-data' \<br/>  -F 'split_length=200' \<br/>  -F 'split_overlap=10' \<br/>  -F 'files=@data/seasons.txt;type=application/txt'<br/><br/> curl -X 'POST' \<br/>  'http://localhost:8000/file-upload' \<br/>  -H 'accept: application/json' \<br/>  -H 'Content-Type: multipart/form-data' \<br/>  -F 'split_length=200' \<br/>  -F 'split_overlap=10' \<br/>  -F 'files=@data/days.txt;type=application/txt'</span></pre><h1 id="c679" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用</h1><p id="abea" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此时，您可以在web浏览器中导航到<code class="fe nc nd ne nf b"><a class="ae mi" href="http://localhost:8000/docs" rel="noopener ugc nofollow" target="_blank">localhost:8000</a></code>，通过其Swagger UI与Haystack进行交互。例如，要问一个问题，滚动到<code class="fe nc nd ne nf b">query</code>端点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/22eb8e4dd1e4b06e51dd02a48874c069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPgmEdAYMBrHaakypVdznQ.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">图5:使用Swagger UI玩Haystack</figcaption></figure><p id="fa6e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">当然，你也可以通过VS代码中的REST客户端扩展实现同样的事情，类似于我们在步骤6中所做的。</p><h1 id="be4d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="2d0b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这篇博文描述了如何配置和创建一个docker-compose部署的Haystack，它使用Weaviate作为它的文档存储。希望您现在已经更清楚地了解了如何将它带到下一个级别，例如，在Ray、K8s或Docker Swarm集群上部署。</p></div></div>    
</body>
</html>