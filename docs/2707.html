<html>
<head>
<title>How to Filter Pandas DataFrame By Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何按时间筛选熊猫数据帧</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-to-filter-pandas-dataframe-by-time-81509d3adee9?source=collection_archive---------0-----------------------#2022-04-27">https://pub.towardsai.net/how-to-filter-pandas-dataframe-by-time-81509d3adee9?source=collection_archive---------0-----------------------#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">按时间过滤数据帧的简单熊猫方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/608b423fc4194015c1efa35ae92fc771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WvszXRhXmHFn-v_-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·博尔曼斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7166" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ecec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">带有时间戳的数据集很常见，我们可能需要按时间过滤数据帧。在本文中，我们研究了如何使用Pandas版本1.4.1中的<code class="fe mn mo mp mq b">.between_time()</code>、<code class="fe mn mo mp mq b">.at_time()</code>和<code class="fe mn mo mp mq b">.loc</code>方法按时间过滤Pandas数据帧。</p><p id="d74b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们创建了两个数据帧，<code class="fe mn mo mp mq b">df_row</code>和<code class="fe mn mo mp mq b">df_col</code>，用于说明如何跨不同的轴按时间进行过滤。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="dc58" class="na la it mq b gy nb nc l nd ne">ts = pd.date_range('2022-03-04', periods=10, freq='12h20min')<br/>df_row = pd.DataFrame({'ts': ts, 'qty': [np.random.randint(10, 100) for i in range(10)]})<br/>df_col = pd.DataFrame(np.random.randint(0,100,size=(5, 10)), columns = ts)</span></pre><p id="4414" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">df_row</code>有一个名为<code class="fe mn mo mp mq b">ts</code>的时间戳列</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1f07364ee66139dec7a644c429cab98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/0*vY1Epa8YGxObWz2W"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="7f72" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">而<code class="fe mn mo mp mq b">df_col</code>将列标题作为时间戳</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d6a15ca621d0a822c662deaf2dd93a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M5mACAfr1voWJBB1"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><h1 id="bff3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在时间之间</h1><p id="9f8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">.between_time()</code>是一个Pandas DataFrame方法，用于过滤Pandas DataFrame中开始和结束时间之间的行。这些参数是:</p><ul class=""><li id="14cd" class="nh ni it lt b lu mr lx ms ma nj me nk mi nl mm nm nn no np bi translated"><code class="fe mn mo mp mq b">start_time</code> : datetime.time或str</li><li id="2bba" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><code class="fe mn mo mp mq b">end_time</code> : datetime.time或str</li><li id="e7fd" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><code class="fe mn mo mp mq b">inclusive</code> : { "两者"、"两者都不是"、"左"、"右" }，默认为"两者"。包括边界；将每个绑定设置为封闭还是开放。</li><li id="7199" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><code class="fe mn mo mp mq b">axis</code> : {0或'索引'，1或'列' }，默认为0</li></ul><p id="20d4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">该方法用于过滤<code class="fe mn mo mp mq b">DateTimeIndex</code>，因此我们必须确保使用<code class="fe mn mo mp mq b">set_index()</code>方法将<code class="fe mn mo mp mq b">ts</code>列设置为索引。<code class="fe mn mo mp mq b">start_time</code>和<code class="fe mn mo mp mq b">end_time</code>参数排除24小时和12小时时间格式。注意<code class="fe mn mo mp mq b">.between_time()</code>仅过滤<strong class="lt iu">时间</strong>而不考虑日期。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="2fb3" class="na la it mq b gy nb nc l nd ne"># 24 hour format<br/>df_row.set_index('ts').between_time('14:20', '16:00').reset_index()</span><span id="f50d" class="na la it mq b gy nv nc l nd ne"># 12 hour format<br/>df_row.set_index('ts').between_time('2:20PM', '4:00PM').reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6c9759d318ef4a9528def09b6e51655f.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/0*F96PNHCgXJHRoXQ5"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="2592" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">默认情况下，<code class="fe mn mo mp mq b">start_time</code>和<code class="fe mn mo mp mq b">end_time</code>是包含的。我们可以通过定义<code class="fe mn mo mp mq b">inclusive</code>参数将左右边界设置为开放或封闭。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="fc54" class="na la it mq b gy nb nc l nd ne">df_row.set_index('ts').between_time('2:20PM', '4:00PM', inclusive = 'right').reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/91ff5fda289920931064f3de05a1c7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/0*W2hgSc1GO0IoKB-t"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="b17d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">时间为14:20:00的行被删除，因为不包括左边界。</p><p id="8566" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果我们希望得到不在和<code class="fe mn mo mp mq b">start_time</code>之间的所有时间<strong class="lt iu">，我们只需将<code class="fe mn mo mp mq b">start_time</code>设置为晚于<code class="fe mn mo mp mq b">end_time</code>。</strong></p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="569c" class="na la it mq b gy nb nc l nd ne"># swap the start_time and end_time<br/>df_row.set_index('ts').between_time('16:00', '14:20').reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c3c34df812edbd750f4cd813db578e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/0*Unf7Pa85vOki6ZWc"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="a716" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">.between_time()</code>也允许我们跨列按时间过滤数据帧。我们可以通过将<code class="fe mn mo mp mq b">axis</code>参数定义为<code class="fe mn mo mp mq b">1</code>来实现。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="6593" class="na la it mq b gy nb nc l nd ne">df_col.between_time('14:20', '16:00', axis = 1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/49a511557dcb806d4c9c13793269086f.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/0*Fo12f4rASjUmkJdZ"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><h1 id="7082" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">有时</h1><p id="9374" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">.at_time()</code>是一个Pandas DataFrame方法，它选择具有确切时间而不是时间范围的行。这些参数是:</p><ul class=""><li id="7b6e" class="nh ni it lt b lu mr lx ms ma nj me nk mi nl mm nm nn no np bi translated"><code class="fe mn mo mp mq b">time</code> : timedatetime.time或str</li><li id="16fe" class="nh ni it lt b lu nq lx nr ma ns me nt mi nu mm nm nn no np bi translated"><code class="fe mn mo mp mq b">axis</code> : {0或'索引'，1或'列' }，默认为0</li></ul><p id="3785" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">该方法用于过滤一个<code class="fe mn mo mp mq b">DateTimeIndex</code>，因此我们必须确保通过使用<code class="fe mn mo mp mq b">set_index()</code>方法将<code class="fe mn mo mp mq b">ts</code>列设置为索引。参数<code class="fe mn mo mp mq b">time</code>接受24小时和12小时时间格式。注意<code class="fe mn mo mp mq b">.at_time()</code>仅过滤<strong class="lt iu">时间</strong>而不考虑日期。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="9dda" class="na la it mq b gy nb nc l nd ne"># 24 hour format<br/>df_row.set_index('ts').at_time('02:40').reset_index()</span><span id="a760" class="na la it mq b gy nv nc l nd ne"># 12 hour format<br/>df_row.set_index('ts').at_time('2:40 AM').reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/69e6e3532461838625612bfb8aa9f81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/0*6MyXLnWFSCIyTfwp"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="ce11" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">.at_time()</code>还允许我们按时间跨列而不是行过滤数据帧。我们可以通过简单地将轴参数定义为<code class="fe mn mo mp mq b">1</code>来实现。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="7cd3" class="na la it mq b gy nb nc l nd ne">df_col.at_time('02:40', axis = 1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1f4379d389a6786bdeea86f4a227fcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/0*Pl-VpF1K2EvMw9vE"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><h1 id="b123" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在日期和时间之间筛选</h1><p id="16b6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上面的例子演示了如何按时间过滤，而不考虑日期。以下示例显示了如何在两个时间戳之间进行过滤，同时考虑日期和时间，例如在<code class="fe mn mo mp mq b">2022-03-04 12:00</code>和<code class="fe mn mo mp mq b">2022-03-06 15:00</code>之间。让我们将开始和结束日期时间定义为<code class="fe mn mo mp mq b">datetime.datetime</code>类型。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="e07b" class="na la it mq b gy nb nc l nd ne">from datetime import datetime</span><span id="bd60" class="na la it mq b gy nv nc l nd ne">start_datetime = datetime.strptime('2022-03-04 12:00:00', '%Y-%m-%d %H:%M:%S')<br/>end_datetime = datetime.strptime('2022-03-06 15:00:00', '%Y-%m-%d %H:%M:%S')</span></pre><p id="3ad4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">筛选行</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="2f48" class="na la it mq b gy nb nc l nd ne">df_row.loc[(df_row['ts'] &gt;= start_datetime) &amp; (df_row['ts'] &lt;= end_datetime)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/56c41b9633b607c52aae9ddc7c3d106d.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/0*SalN8iE06V9cCCQa"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="c8de" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">要筛选列</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="40af" class="na la it mq b gy nb nc l nd ne">df_col.loc[:, [i for i in df_col.columns if i &gt;= start_datetime and i &lt;= end_datetime]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/7c94c0c94e3a885f6cc5438106c94a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yOJqHHLcLS2W4fie"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><h1 id="5ef1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="389a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我们研究了3种方法来过滤熊猫数据帧的时间和日期和时间的组合。<code class="fe mn mo mp mq b">.between_time()</code>和<code class="fe mn mo mp mq b">.at_time</code>是应用在<code class="fe mn mo mp mq b">DateTimeIndex</code>上的简单优雅的方法，只过滤时间，不过滤日期。要过滤日期和时间组合，我们可以使用<code class="fe mn mo mp mq b">.loc</code>并将开始和结束范围定义为<code class="fe mn mo mp mq b">datetime.datetime</code>类型。</p></div></div>    
</body>
</html>