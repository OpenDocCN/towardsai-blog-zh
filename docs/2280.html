<html>
<head>
<title>Text Similarity using K-Shingling, Minhashing, and LSH(Locality Sensitive Hashing)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用K-Shingling、最小散列和LSH(位置敏感散列)的文本相似性</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/text-similarity-using-k-shingling-minhashing-and-lsh-locality-sensitive-hashing-8a60a7aaa9d9?source=collection_archive---------0-----------------------#2021-10-29">https://pub.towardsai.net/text-similarity-using-k-shingling-minhashing-and-lsh-locality-sensitive-hashing-8a60a7aaa9d9?source=collection_archive---------0-----------------------#2021-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9921" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div class="gh gi jw"><img src="../Images/45d6403426f5318376863c6fe78d4e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*iQU569HGBmkMKJGGrdKcXA.png"/></div></figure><p id="ae32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文本相似性在自然语言处理(NLP)中起着重要的作用，并且在许多领域得到了广泛的应用。一些应用包括信息检索、文本分类、主题检测、机器翻译、文本摘要、文档聚类、剽窃检测、新闻推荐等。几乎涵盖了所有领域。</p><p id="af70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有时，理解文本相似性算法背后的概念变得很困难。这篇文章将展示文本相似性的实现以及对所需概念的解释。</p><p id="afba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但在我开始之前，让我告诉你，可能有几种方法和几种算法来执行相同的任务。我将使用K-Shingling、最小散列和LSH(局部敏感散列)中的一种方法进行描绘。</p><p id="944f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑的数据集是从手头问题的3个文档中提取的文本。</p><p id="23d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用n个文档，每个文档都很长。但是为了简化和避免繁重的计算，我考虑从每个文档中抽取一小块。</p><p id="6bb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一步一步地执行实现。</p><p id="1c49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第一步:</strong></p><p id="2f63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将您的工作目录设置为文件所在的文件夹，以便R可以读取它。然后使用下面的代码从工作目录中读取所有的输入文件。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7fa4" class="lk ll iq lg b gy lm ln l lo lp"># Libraries used<br/>library(dplyr)<br/>library(proxy)<br/>library(stringr)<br/>library(data.table)<br/># Set the working directory<br/>setwd(".\")</span><span id="0bee" class="lk ll iq lg b gy lq ln l lo lp"># Read the original text file <br/>files &lt;- list.files(path=".", pattern='*.txt', all.files=FALSE,<br/>           full.names=FALSE)</span><span id="fcf1" class="lk ll iq lg b gy lq ln l lo lp">( doc &lt;- lapply( files, readLines ) )</span></pre><p id="dd62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">R Studio输入显示</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/f80002508549b453715683509df48b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*uliib7g22LCriUHEJ4wDuA.png"/></div></figure><p id="c8a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第二步:</strong></p><p id="081b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对文本进行预处理以删除标点符号，将其转换为小写，并逐字拆分文本。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="280a" class="lk ll iq lg b gy lm ln l lo lp"># Preprocess text<br/>documents &lt;- lapply(doc, function(x) {<br/>  text &lt;- gsub("[[:punct:]]", "", x) %&gt;% tolower()<br/>  text &lt;- gsub("\\s+", " ", text) %&gt;% str_trim()  <br/>  word &lt;- strsplit(text, " ") %&gt;% unlist()<br/>  return(word)<br/>})<br/># Print the texts in files<br/>documents[[1]]<br/>documents[[2]]<br/>documents[[3]]</span></pre><p id="e095" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/011c2e57dc4d2f33ebee499c20ba5ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*jTA6UpLOqa2alCmtBGAppA.png"/></div></figure><p id="46ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第三步:</strong></p><p id="e31d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">介绍一种表示文档资产的技术。我们将进一步理解K收缩的重要性，但是现在，我们可以试着熟悉这些步骤。</p><p id="1c0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">手头文档的k-瓦片区被认为是在其中找到的所有可能的长度为k的连续子串。</p><p id="e7a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一个k = 3的例子来说明。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="55d5" class="lk ll iq lg b gy lm ln l lo lp">Shingling &lt;- function(document, k) {<br/>  shingles &lt;- character( length = length(document) - k + 1 )<br/>  <br/>  for( i in 1:( length(document) - k + 1 ) ) {<br/>    shingles[i] &lt;- paste( document[ i:(i + k - 1) ], collapse = " " )<br/>  }<br/>  <br/>  return( unique(shingles) )  <br/>}</span><span id="839f" class="lk ll iq lg b gy lq ln l lo lp"># "shingle" the example document, with k = 3<br/>documents &lt;- lapply(documents, function(x) {<br/>  Shingling(x, k = 3)<br/>})<br/>list( Original = doc[[1]], Shingled = documents[[1]] )</span></pre><p id="d5b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/950bd80bafaab25ca18395b48af4a41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*ROBzkSXd9TF0jUf6ipY6pA.png"/></div></figure><p id="303e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在k = 3的情况下，打印出来的第一个文档的k个瓦片区由长度为3的子串组成。</p><p id="e7e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个K字是:<strong class="kf ja">《夜是》</strong></p><p id="820d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个带状疱疹是:<strong class="kf ja">《夜色深沉》</strong>以此类推。</p><p id="8797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的重要一点是，文档的k-shingle集应该是惟一的。例如，如果上面的第一个文档包含不止一个<strong class="kf ja">“the night is”</strong>，那么它将只作为该文档的k-瓦片区集合出现一次。</p><p id="c36a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第四步:</strong></p><p id="84ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建一个<strong class="kf ja">“特征”矩阵</strong>，将三个文档之间的关系可视化。“特征”矩阵将是布尔矩阵，具有:</p><p id="bc78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">rows =所有文档中瓦片区集合的每个唯一可能组合的元素。</p><p id="68c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">columns =每个文档一列。</p><p id="5a0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当且仅当文档j包含瓦片区I时，矩阵将在行I和列j中填充1，否则将填充0。</p><p id="dca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过下面的描述来理解这一点。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8dc3" class="lk ll iq lg b gy lm ln l lo lp"># Unique shingles sets across all documents<br/>doc_dict &lt;- unlist(documents) %&gt;% unique()</span><span id="6ec9" class="lk ll iq lg b gy lq ln l lo lp"># "Characteristic" matrix<br/>Char_Mat &lt;- lapply(documents, function(set, dict) {<br/>  as.integer(dict %in% set)<br/>}, dict = doc_dict) %&gt;% data.frame()</span><span id="818a" class="lk ll iq lg b gy lq ln l lo lp"># set the names for both rows and columns<br/>setnames( Char_Mat, paste( "doc", 1:length(documents), sep = "_" ) )<br/>rownames(Char_Mat) &lt;- doc_dict<br/>Char_Mat</span></pre><p id="bceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/509fb5700932030f0f84d7be0202bbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*WXp7bWvePvLvtbw7_vwQlw.png"/></div></figure><p id="9153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述矩阵的第一行所有三列都为1。这是因为所有三个文档都包含3个字母“黑夜是”。</p><p id="5556" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于第二列，值是[1，0，1]，这意味着文档2没有3-瓦片区“黑夜是黑暗的”，而文档1和3有。</p><p id="65ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里要注意的重要一点是，大多数时候这些“特征矩阵”几乎是稀疏的。所以我们通常尽量只用1出现的位置来表示这些矩阵，这样更节省空间。</p><p id="5d6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第五步:</strong></p><p id="4112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建了瓦片集和特征矩阵之后，我们现在需要测量文档之间的相似性。</p><p id="82ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将利用<strong class="kf ja"> Jaccard相似性</strong>。</p><p id="afdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，对于作为集合1和集合2的两个瓦片区集合，Jaccard相似性将是:</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/b159c616280192a0b7a7584f617886ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*yUcfvUawWOe1U0-H3DxY2A.png"/></div></figure><p id="efa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们将计算所有三个文档的成对Jaccard相似性。“R”中的“dist”函数快速计算并返回距离/相似性矩阵。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ccb3" class="lk ll iq lg b gy lm ln l lo lp"># how similar is two given document, Jaccard similarity <br/>JaccardSimilarity &lt;- function(x, y) {<br/>  non_zero &lt;- which(x | y)<br/>  set_intersect &lt;- sum( x[non_zero] &amp; y[non_zero] )<br/>  set_union &lt;- length(non_zero)<br/>  return(set_intersect / set_union)<br/>}</span><span id="2ecf" class="lk ll iq lg b gy lq ln l lo lp"># create a new entry in the registry<br/>pr_DB$set_entry( FUN = JaccardSimilarity, names = c("JaccardSimilarity") )</span><span id="2397" class="lk ll iq lg b gy lq ln l lo lp"># Jaccard similarity distance matrix <br/>d1 &lt;- dist( t(Char_Mat), method = "JaccardSimilarity" )</span><span id="c3e1" class="lk ll iq lg b gy lq ln l lo lp"># delete the new entry<br/>pr_DB$delete_entry("JaccardSimilarity")<br/>d1</span><span id="db52" class="lk ll iq lg b gy lq ln l lo lp">doc</span></pre><p id="9e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/8e22e3a792883469a19bc87dabf9758c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*dBkxn7KUbahbx4MHOsp1Sw.png"/></div></figure><p id="c42e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相似性矩阵d1告诉我们，文档1和3是三个文档中最相似的。</p><p id="f424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于小数据集，上面的方法工作得非常好，但是想象一下，如果我们有大量的文档要比较，而不是只有三个具有明显更大长度的文档，那么上面的方法可能不能很好地扩展，并且我们可能会有大量的计算和性能问题，因为具有一组跨所有文档的唯一瓦片区的稀疏矩阵将相当大，使得文档之间的Jaccard相似性的计算成为负担。</p><p id="1e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们采用一种不同的技术来帮助我们节省计算，并可以有效地大规模比较文档的相似性。这种技术被称为<strong class="kf ja">最小化。</strong></p><p id="f42d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第六步:</strong></p><p id="8cb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最小散列涉及将大量独特的瓦片区压缩成一个更小的表示，称为“签名”。</p><p id="514e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用这些签名来衡量文档之间的相似性。</p><p id="a88e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这些签名不可能给出精确的相似性度量，但是估计值非常接近。</p><p id="b49e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择的签名数量越多，估计就越准确。</p><p id="3780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了说明，让我们考虑一个例子。</p><p id="1234" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们采用上述例子将16行的minhash特征矩阵分成4个签名。然后，第一步是生成4列相互独立的随机置换行。我们可以自己看到，这个简单的散列函数实际上确实生成了随机置换的行。为了得出这个结果，我们使用公式:</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/23de612287080c6cde8453a94c43b4ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*DjkpG9ukVPw6arSGcVY-NQ.png"/></div></figure><p id="4f96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中:</p><p id="565d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">x是原始特征矩阵的行数。</p><p id="1975" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a和b是小于或等于最大数x的任意随机数，并且它们在每个签名中必须是唯一的。</p><p id="a7b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，对于签名1，如果生成5作为a系数，则必须确保该值不会在签名1内多次作为a系数，尽管它仍然可以用作</p><p id="7c99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">签名1中的b系数。并且该限制对于下一个签名也是刷新的，也就是说，5可以用作签名2的a或b系数，但是签名2的a或b系数同样没有倍数5，依此类推。</p><p id="cf62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">c是一个素数，略大于瓦片区集合的总数。</p><p id="299f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于上面的示例集，由于总行数是16，因此素数17就可以了。</p><p id="1a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们通过“R”代码来生成它。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="380e" class="lk ll iq lg b gy lm ln l lo lp"># number of hash functions (signature number)<br/>signature_num &lt;- 4</span><span id="7a21" class="lk ll iq lg b gy lq ln l lo lp"># prime number<br/>prime &lt;- 17</span><span id="22e0" class="lk ll iq lg b gy lq ln l lo lp"># generate the unique coefficients  <br/>set.seed(12345)<br/>coeff_a &lt;- sample( nrow(Char_Mat), signature_num )<br/>coeff_b &lt;- sample( nrow(Char_Mat), signature_num )</span><span id="0d27" class="lk ll iq lg b gy lq ln l lo lp"># see if the hash function does generate permutations<br/>permute &lt;- lapply(1:signature_num, function(s) {<br/>  hash &lt;- numeric( length = length(nrow(Char_Mat)) )<br/>  for( i in 1:nrow(Char_Mat) ) {<br/>    hash[i] &lt;- ( coeff_a[s] * i + coeff_b[s] ) %% prime<br/>  }<br/>  return(hash)<br/>})<br/># # convert to data frame <br/>permute_df &lt;- structure( permute, names = paste0( "hash_", 1:length(permute) ) ) %&gt;%<br/>  data.frame()<br/>permute_df</span></pre><p id="180f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/35df1338391a870061dadf96a9acaedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*DOS2vGqjSA3iFlV2d-vtPQ.png"/></div></figure><p id="7232" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的输出中，我们看到生成了4列随机置换的行。也有0，但这不会影响我们的计算，我们稍后会看到。</p><p id="c0d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ja">第七步:</strong></p><p id="60a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用随机置换的行，现在将进一步计算签名。任何列(文档)的签名值都是通过使用由每个哈希函数生成的置换顺序获得的，其中该列的第一行的编号为1。</p><p id="d181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们接下来要做的是将随机置换的行(由哈希函数生成)与原始特征矩阵相结合，并将矩阵的行名更改为其行号，以说明计算过程。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1b30" class="lk ll iq lg b gy lm ln l lo lp"># use the first two signature as an example<br/># bind with the original characteristic matrix<br/>Char_Mat1 &lt;- cbind( Char_Mat, permute_df[1:2] )<br/>rownames(Char_Mat1) &lt;- 1:nrow(Char_Mat1)<br/>Char_Mat1</span></pre><p id="65ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/50bc9418ea39592b11c614fc74ce6547.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*ajCxGewJD-Glq1tfpdEhYQ.png"/></div></figure><p id="f2c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在考虑上面生成的矩阵，我们将从第一个哈希函数(hash_1)开始。</p><p id="7e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我们的第一个散列函数的置换行顺序，第一行是第14行(为什么是第14行？因为0是我们随机生成的排列的最小值，并且它在第14行有一个0，使其成为第一行)。然后，我们将查看所有三个文档的第14行的条目，并试图找到“第14行的哪个文档的条目是1？”。文档3的(doc_3)行14是1，因此由我们的第一个散列函数生成的文档3的签名值是0。但是文档2和3在第14行的条目都是0，因此我们必须继续寻找。</p><p id="9cc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我们的第一个哈希函数的置换行顺序，第二行是第8行(1是我们随机生成的置换的第二个最小值，它在第8行的值为1)。我们应用与上面相同的概念，发现第8行的文档2的(doc_2)条目是1，因此由我们的第一个散列函数生成的文档2的签名值是1。注意，我们已经完成了文档3，我们不再需要检查它是否包含1。但是我们还没有完成，文档1在第8行的条目仍然是0。因此，我们必须看得更远。</p><p id="a25a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次检查我们的第一个散列函数的置换行顺序，第三行是第2行。文档1的第2行的条目是1。因此，我们已经使用第一个散列函数计算完了所有三列的签名值！！也就是[2，1，0]。</p><p id="5a39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以应用相同的概念，使用第二个散列函数计算每一列(文档)的签名值，第三列、第四列等等也是如此。快速查看签名第二散列函数显示，根据其置换的行顺序，第一行是第8行，doc_2在行3中具有1。类似地，第二行是doc_3为1的第14行，第三行是doc_1为1的第3行。因此，我们的第二个散列函数为所有三个文档生成的签名值是[2，0，1]。</p><p id="9dd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至于这些计算出来的签名值，我们会沿途存储到一个签名矩阵中，这个矩阵以后会代替原来的特征矩阵。以下部分将使用所有4个哈希函数计算所有3列的签名值，并打印出签名矩阵。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4093" class="lk ll iq lg b gy lm ln l lo lp"># obtain the non zero rows' index for all columns<br/>non_zero_rows &lt;- lapply(1:ncol(Char_Mat), function(j) {<br/>  return( which( Char_Mat[, j] != 0 ) )<br/>})</span><span id="509f" class="lk ll iq lg b gy lq ln l lo lp"># initialize signature matrix<br/>SM &lt;- matrix( data = NA, nrow = signature_num, ncol = ncol(Char_Mat) )</span><span id="c0d0" class="lk ll iq lg b gy lq ln l lo lp"># for each column (document)<br/>for( i in 1:ncol(Char_Mat) ) {<br/>  # for each hash function (signature)'s value <br/>  for( s in 1:signature_num ) {<br/>    SM[ s, i ] &lt;- min( permute_df[, s][ non_zero_rows[[i]] ] )<br/>  }<br/>}</span><span id="a949" class="lk ll iq lg b gy lq ln l lo lp"># set names for clarity<br/>colnames(SM) &lt;- paste( "doc", 1:length(doc), sep = "_" )<br/>rownames(SM) &lt;- paste( "minhash", 1:signature_num, sep = "_" )  <br/>SM</span></pre><p id="85ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/35ebea14f1cca21ce83020bc6082c9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*bHVU0yC49UAPkKHO2W2MGw.png"/></div></figure><p id="5c25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的签名矩阵具有与原始特征矩阵相同的列数，但是它只有n行，其中n是我们希望生成的散列函数的数量(在本例中是4)。</p><p id="1c6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我详细说明我们如何解释上述结果？</p><p id="132a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，对于文档1和3(列1和3)，其相似度将是0.25，因为它们仅在总共4行中的1行一致(两列的行4都是1)。</p><p id="c756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过代码来计算同样的解释。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fad4" class="lk ll iq lg b gy lm ln l lo lp"># signature similarity<br/>SigSimilarity &lt;- function(x, y) mean( x == y )</span><span id="8655" class="lk ll iq lg b gy lq ln l lo lp"># same trick to calculate the pairwise similarity <br/>pr_DB$set_entry( FUN = SigSimilarity, names = c("SigSimilarity") )<br/>d2 &lt;- dist( t(SM), method = "SigSimilarity" )<br/>pr_DB$delete_entry("SigSimilarity")</span><span id="55ab" class="lk ll iq lg b gy lq ln l lo lp">list(SigSimilarity = d2, JaccardSimilarity = d1)</span></pre><p id="a4ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/1f2eba0dee5d2d010ecb0f784a169cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*vJrmDBsjz6zSHgeXpHisnA.png"/></div></figure><p id="52ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据原始Jaccard相似性和使用签名相似性获得的新相似性之间的结果差异，我们可能会怀疑这是否是一个准确的估计？但是如前所述，Minhash的目的是提供一个对真正Jaccard相似性的快速“近似”,估计可以更接近，但不是100%准确，因此存在差异。此外，这里考虑的例子太小，无法使用大数定律来描述更接近的精度。大型数据集有望获得更准确、更接近的结果。</p><p id="dd96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在主要要求是计算每个可能的对的相似性的情况下，可能是为了文本聚类或类似的目的，那么LSH(位置敏感散列法)不能达到目的，但是如果要求是找到最可能相似的对，那么可以进一步使用一种称为位置敏感散列法的技术，这将在下面讨论。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="e461" class="lk ll iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my iw bi translated">位置敏感散列法</h2><p id="bf6a" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">虽然计算文档之间的相似性所需的信息已经从原始的<em class="ne">稀疏</em>特征矩阵压缩成更小的签名矩阵，但是潜在的问题或对所有文档执行成对比较的需要仍然存在。</p><p id="118e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">位置敏感散列(LSH)的概念是，给定大小为n(行数)的签名矩阵，我们将把它分成b个带，结果每个带有r行。这相当于一个简单的数学公式——n = br，因此，当我们进行划分时，我们必须确保我们选择的b可以被n整除。使用上面的签名矩阵并选择频带大小为2，上面的示例将变成:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="88e6" class="lk ll iq lg b gy lm ln l lo lp"># number of bands and rows<br/>bands &lt;- 2<br/>rows &lt;- nrow(SM) / bands</span><span id="fa52" class="lk ll iq lg b gy lq ln l lo lp">data.frame(SM) %&gt;% <br/>  mutate( band = rep( 1:bands, each = rows ) ) %&gt;%<br/>  select( band, everything() )</span></pre><p id="6aa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">r工作室显示器</p><figure class="lb lc ld le gt ka gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cab482de9f86de9d915fb25507a7c63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*MsfsaAYxXUfj8uUvVcp22A.png"/></div></figure><p id="ca1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">位置敏感哈希告诉我们的是:如果两个文档的签名值在至少一个带的所有行中一致，那么这两个文档很可能是相似的，应该进行比较(将其列为候选对)。使用这一小组文档可能是一个不好的例子，因为可能会发生没有一个文档被选为我们的候选对的情况。例如，如果波段1的文档2的签名值变为[ 0，1 ]而不是当前的[ 1，0 ]，那么文档2和文档3将成为候选对，因为它们在波段1中的两行都取相同的值[ 0，1 ]。</p><p id="a54a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意——在执行上述这组R代码时，我的计算和你的计算可能会有所不同，因为签名是随机生成的。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="c5a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后的想法</p><p id="ac93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述使用雅克卡相似性、最小散列法和LSH的技术是计算文档相似性所使用的技术之一，尽管还存在更多的技术。文本相似性是一个活跃的研究领域，技术在不断发展。因此，使用哪种方法在很大程度上取决于用例以及我们想要实现的需求。</p><p id="45d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！！！</p><p id="682c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在媒体上跟踪我</p><p id="2401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">领英:<a class="ae ng" href="https://www.linkedin.com/in/supriya-ghosh" rel="noopener ugc nofollow" target="_blank">苏普里亚·戈什</a></p><p id="9cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推特:<a class="ae ng" href="https://twitter.com/isupriyaghosh" rel="noopener ugc nofollow" target="_blank"> @isupriyaghosh </a></p></div></div>    
</body>
</html>