<html>
<head>
<title>How To Call a Python Function With A String?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用字符串调用Python函数？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/python-trick-how-to-call-a-function-by-its-name-f35309469c66?source=collection_archive---------0-----------------------#2022-07-31">https://pub.towardsai.net/python-trick-how-to-call-a-function-by-its-name-f35309469c66?source=collection_archive---------0-----------------------#2022-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5085c07df1f8c35224cafdfe7f289b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3S8Wzywh0K9vsFfd"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">詹姆斯·哈里森在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="ce71" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Methodcaller、Get属性、名称空间等等</h2></div><p id="bfec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎阅读一系列短文，每篇都有可以帮助你提高游戏水平的Python技巧。在这篇博客中，我们将研究如何通过名字调用一个函数。</p><h2 id="4245" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">情况</h2><p id="2553" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设你有一个函数<code class="fe ms mt mu mv b">def f(): pass</code>。</p><p id="adca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以只用<code class="fe ms mt mu mv b">"f"</code>调用函数吗？</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h2 id="69b4" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">解决方案1:本地和全球</h2><p id="2aaf" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在我们深入研究<code class="fe ms mt mu mv b">locals</code>和<code class="fe ms mt mu mv b">globals</code>之前，了解一下什么是名称空间是很重要的。在Python运行时，所有定义的对象(类、函数、变量等。)被映射并存储在一个字典中，也称为命名空间。</p><p id="bd89" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">locals()</code>返回局部级别的名称空间——比如，函数中定义的局部变量，这些变量将成为函数中局部名称空间的一部分。</p><p id="1dbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">globals()</code>返回全局级别的名称空间——比如，全局导入的模块或全局定义的对象，它们将成为全局名称空间的一部分，无论它在函数内部还是外部。</p><p id="225f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设有一个函数名为<code class="fe ms mt mu mv b">my_function</code>。</p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="5c74" class="lu lv jj mv b gy nl nm l nn no">def my_function(a, b, c):<br/>  pass</span></pre><p id="fd25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe ms mt mu mv b">locals</code>和<code class="fe ms mt mu mv b">globals</code>调用带有<code class="fe ms mt mu mv b">"my_function"</code>的功能:</p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="05a4" class="lu lv jj mv b gy nl nm l nn no">s = "my_function"</span><span id="7497" class="lu lv jj mv b gy np nm l nn no"># calling the function from local namespace<br/>function = locals()[s]<br/>function(a=1, b=2, c=3)</span><span id="9c3d" class="lu lv jj mv b gy np nm l nn no"># calling the function from global namespace<br/>function = globals()[s]<br/>function(a=1, b=2, c=3)</span></pre><h2 id="c577" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">解决方案2:评估</h2><p id="8121" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">下一个选项是众所周知的<code class="fe ms mt mu mv b">eval</code>，这是一个内置的python函数，它计算任意字符串表达式/编译后的代码，如果它是一个<strong class="la jk">合法的</strong> Python表达式就执行。</p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="fdb7" class="lu lv jj mv b gy nl nm l nn no">eval(expression[, globals[, locals]])</span></pre><p id="ab24" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用<code class="fe ms mt mu mv b">eval</code>，您最多只需要三个参数:</p><ul class=""><li id="9e67" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">Expression:要计算的字符串表达式/编译代码</li><li id="5254" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">Globals:为<code class="fe ms mt mu mv b">eval</code>提供全局名称空间的可选字典</li><li id="0669" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">Locals:为<code class="fe ms mt mu mv b">eval</code>提供本地名称空间的可选字典</li></ul><blockquote class="oe of og"><p id="a17e" class="ky kz oh la b lb lc kk ld le lf kn lg oi li lj lk oj lm ln lo ok lq lr ls lt im bi translated">当提供全局变量和局部变量时，它们就是<code class="fe ms mt mu mv b">eval</code>运行所基于的名称空间。否则，<code class="fe ms mt mu mv b">eval</code>将使用当前代码所基于的全局和局部名称空间。</p></blockquote><h2 id="8387" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">解决方案3:方法调用方</h2><p id="8007" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">另一种方法(没有双关语)是在Python的一个标准库中— <code class="fe ms mt mu mv b">operator.methodcaller</code>。与上面的选项不同，<code class="fe ms mt mu mv b">methodcaller</code>从提供的对象中获取一个可调用的<strong class="la jk">。因此，以下内容将不起作用:</strong></p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="6720" class="lu lv jj mv b gy nl nm l nn no">from operator import methodcaller</span><span id="d225" class="lu lv jj mv b gy np nm l nn no"># This would not work!!<br/>bar = methodcaller("myfunction")<br/>bar()</span></pre><p id="dc83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，可调用的需要是对象的一部分:</p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="261e" class="lu lv jj mv b gy nl nm l nn no">from operator import methodcaller<br/>foo = "bar"</span><span id="d2ce" class="lu lv jj mv b gy np nm l nn no"># upper is a method of a string object<br/>foo_method = methodcaller("upper")<br/>foo_method(foo)</span><span id="6278" class="lu lv jj mv b gy np nm l nn no">&gt;&gt;&gt; 'BAR'</span></pre><p id="1b43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">methodcaller</code>和其他选项的另一个关键区别是，任何论据都需要提前提供。例如:</p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="c02c" class="lu lv jj mv b gy nl nm l nn no">from operator import methodcaller<br/>import random</span><span id="7c36" class="lu lv jj mv b gy np nm l nn no"># This doesn't work<br/>foo_method = methodcaller("randint")<br/>foo_method(random)</span><span id="d3db" class="lu lv jj mv b gy np nm l nn no">&gt;&gt;&gt; TypeError: randint() missing 2 required positional arguments: 'a' and 'b'</span><span id="d714" class="lu lv jj mv b gy np nm l nn no"># This doesn't work either<br/>foo_method = methodcaller("randint")<br/>foo_method(random, a=1, b=2)</span><span id="84b8" class="lu lv jj mv b gy np nm l nn no">&gt;&gt;&gt; TypeError: methodcaller() takes no keyword arguments</span><span id="3a84" class="lu lv jj mv b gy np nm l nn no"># This works!<br/>foo_method = methodcaller("randint", a=1, b=2)<br/>foo_method(random)</span><span id="eb9d" class="lu lv jj mv b gy np nm l nn no">&gt;&gt;&gt; 1</span></pre><p id="2dd3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，要使用<code class="fe ms mt mu mv b">methodcaller</code>，您首先需要注意:</p><ul class=""><li id="3c80" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">方法的位置(例如，该方法在哪个模块/类下)</li><li id="598e" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">使用该方法是否需要参数</li></ul><h2 id="5aeb" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">解决方案4:获取属性</h2><p id="d0e0" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">就像<code class="fe ms mt mu mv b">operator.methodcaller</code>，<code class="fe ms mt mu mv b">getattr</code>是另一个选项，需要预先知道方法所在的位置。也就是说，两个选项有两个主要区别:<br/> 1。<code class="fe ms mt mu mv b">getattr</code>不限于获取可调用的。使用它时，一定要注意返回的对象是否可调用。<br/> 2。<code class="fe ms mt mu mv b">getattr</code>允许您将参数传递给返回的方法，而<code class="fe ms mt mu mv b">methodcaller</code>要求您事先提供参数。</p><pre class="nd ne nf ng gt nh mv ni nj aw nk bi"><span id="b0c7" class="lu lv jj mv b gy nl nm l nn no">import random</span><span id="fdfa" class="lu lv jj mv b gy np nm l nn no">bar = getattr(random, 'randint')<br/>result = bar(1, 2)<br/>&gt;&gt;&gt; 2</span></pre><h2 id="f5fe" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结束语</h2><p id="27b6" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你能做并不意味着你应该做。</p><p id="cba1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">允许脚本的用户使用用户提供的字符串来指定它的行为会导致一些不良的安全漏洞。其他一些臭名昭著的安全漏洞源于将非参数化数据视为代码，包括XSS和SQL注入。也就是说，Python本身是一种解释型语言，这意味着可以说，人们可以做出更低级的改变，从而产生更大的漏洞。</p><p id="d009" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，在本教程中，我们已经走过了使用字符串调用方法的四种方式。作为快速修订，以下表格总结了他们的行为:</p><figure class="nd ne nf ng gt iv"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4e5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博文就讲到这里吧！我希望你已经发现这是有用的。如果你喜欢这本书，别忘了留下一些掌声，甚至使用我的推荐链接加入媒体(不需要额外付费)。</p><div class="is it gp gr iu on"><a href="https://louis-chan.medium.com/membership" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jk gy z fp os fr fs ot fu fw ji bi translated">通过我的推荐链接加入灵媒&amp;路易·陈</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">阅读路易·陈的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接支持…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">louis-chan.medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ja on"/></div></div></a></div></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="9531" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="6952" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/python-tricks-unpacking-iterables-a1acf8a658a6"> Python技巧:解包Iterables </a></li><li id="89d0" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-flattening-lists-75aeb1102337" rel="noopener" target="_blank"> Python技巧:拉平列表</a></li><li id="e400" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540" rel="noopener" target="_blank"> Python技巧:如何检查与熊猫的表格合并</a></li><li id="0326" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71" rel="noopener" target="_blank"> Python技巧:简化If语句&amp;布尔求值</a></li><li id="cf70" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4" rel="noopener" target="_blank"> Python技巧:对照单个值检查多个变量</a></li></ul><p id="208e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="5293" class="nq nr jj la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d">Python中用于交易策略优化的遗传算法</a></li><li id="4c19" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="3e5d" class="nq nr jj la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/ann-recommendation-system-for-stock-selection-c9751a3a0520">人工神经网络选股推荐系统</a></li></ul></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><div class="nd ne nf ng gt on"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jk gy z fp os fr fs ot fu fw ji bi translated">Louis Chan -数据和分析副总监-毕马威英国| LinkedIn</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">www.linkedin.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ja on"/></div></div></a></div></div></div>    
</body>
</html>