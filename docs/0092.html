<html>
<head>
<title>Comparing Neural Network Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较神经网络架构</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/comparing-neural-network-architectures-through-language-classifier-using-google-colab-63167c18b919?source=collection_archive---------2-----------------------#2019-06-28">https://pub.towardsai.net/comparing-neural-network-architectures-through-language-classifier-using-google-colab-63167c18b919?source=collection_archive---------2-----------------------#2019-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5af6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">使用Google Colab比较NN架构| <a class="ae ep" href="https://towardsai.net" rel="noopener ugc nofollow" target="_blank">和AI </a></h2><div class=""/><div class=""><h2 id="482d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Google Colab，通过语言分类器比较神经网络架构</h2></div><p id="9c1b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在阅读了弗朗索瓦·乔莱的精彩书籍<em class="ln">用Python进行深度学习</em>之后，我对不同的神经网络架构以及哪一种最适合各种任务感到好奇。我已经想到用单词数据进行一些练习，所以我决定承担对写单词的语言进行分类的项目。当处理文字时，我想到的第一个方向是使用递归神经网络。Chollet的书还建议，一系列1D卷积可能是合适的。最后，我发现了一篇不错的<a class="ae lo" href="https://medium.com/coinmonks/language-prediction-using-deep-neural-networks-42eb131444a5" rel="noopener">博文</a>，它使用一个简单的全连接网络完成了类似的任务。这是在同一个项目中尝试这些优秀网络的最佳机会！我自己收集数据，用Keras做机器学习。完整的Python代码可以在我的<a class="ae lo" href="https://github.com/yangobeil/language-identifier" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h1 id="8e20" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">设置数据收集</h1><p id="feff" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">项目的第一步是收集数据。我想收集不同语言的单词，以便对它们进行分类，所以我在网上搜寻文本。一个简单的策略是使用Wikipedia Python包在Wikipedia上搜索单词，并获取文章中的所有文本。我需要定义的第一个函数是<em class="ln"> get_words </em>来收集所有的单词。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="96eb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">它以{language: [query1，query2，...]，…}形式的字典作为输入，该字典包含要搜索的每种语言的所有单词。对于每种语言，该函数搜索单词列表以收集文章的文本。然后，它将文本拆分成单词(在空格上),使用定义的函数对单词进行清理。然后，所有单词都被添加到一个列表中，根据输入的内容删除或保留重复的单词。输出是一个{language: [word1，word2，…]，…}形式的字典，其中所有收集到的单词都按语言进行了组织。</p><p id="aedc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要定义的下一个函数是<em class="ln"> clean_word </em>将单词转换成一种好的格式。这在<em class="ln"> get_words </em>函数中使用。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="96b0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这需要一根绳子，并按摩它，使它成为一个更加统一的形状。它首先把所有的东西都变成小写，然后去掉所有的标点符号或数字。最后，带重音的字母被不带重音的字母代替。所有这些清理并不是完全必要的，但是如果不这样做，将会导致单词的更多特征，因为我需要对所有这些不同的字符分别进行编码。</p><p id="5f31" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在收集和清理单词之后，下一步是定义函数<em class="ln"> word_to_array </em>将每个单词转换成可以作为神经网络输入的格式。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9980" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些单词被转换成从a到z的一系列字符，这些字符被一次性编码。每个单词对应一个形状为(26，max_len)的矩阵(Numpy数组)。每一列都是编码为零向量的字符之一，在字符的位置有一个1。所有的单词都被限制在max_len字符以内，所以较长的单词被删除，较短的单词在末尾包含零列。例如，单词“cat”将是一个在位置(0，2)、(1，0)和(2，19)处为1的零数组。</p><p id="23dc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后将这些函数合并成一个函数，从查询词的字典中创建数据。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6c2a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个函数首先使用<em class="ln"> get_words搜索所有的单词。</em>然后使用<em class="ln"> word_to_array </em>将所有介于min_len和max_len字符之间的字转换成数组，并将它们堆叠在一起，形成一个更大的数组(num_words，26，max_len)。还有一个为单词标签创建的数组。语言按照字符的形式进行一次性编码，并放入shape (num_words，num_languages)数组中。</p><p id="7941" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">函数<em class="ln"> create_data </em>是继续分析部分的最后一个必要步骤，但是我也创建了一些有用的函数。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e0ed" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个函数的作用与<em class="ln"> word_to_array </em>相反:它接收一个编码后的字，并将其转换回字符串。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="178f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个函数接收完整的编码数据，并打印出每种语言有多少单词。它还打印数据中的总字数。</p><h1 id="e3cc" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">收集数据</h1><p id="d441" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">现在一切都设置正确了，是时候实际获取数据了。我选择关注三种北美语言:英语、法语和西班牙语。我使用以下关键词进行搜索。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0653" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些词背后的想法是找到维基百科上最大的文章，并在主题上有很好的变化。同样重要的是，每种语言要有相同数量的单词。然后，我使用这个字典的函数<em class="ln"> create_data </em>来获取编码的单词，并将它们保存在我的计算机上。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b881" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我选择取min_len=2来得到很多单词但没有单个字母。我还选择了max_len=12，因为没有太多的单词比这个长，选择一个更大的数字会导致更大的数据，因此计算时间更长。一个棘手的步骤是决定我是否想要使用副本。两种情况下的字数都有很大不同。</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="f51d" class="my lq it mu b gy mz na l nb nc">Keeping duplicates:</span><span id="3a35" class="my lq it mu b gy nd na l nb nc">Number of words in language  0 :  158916<br/>Number of words in language  1 :  155235<br/>Number of words in language  2 :  145862<br/>Total number of words:  460013</span><span id="d0a8" class="my lq it mu b gy nd na l nb nc">Removing duplicates:</span><span id="b546" class="my lq it mu b gy nd na l nb nc">Number of words in language  0 :  19636<br/>Number of words in language  1 :  17027<br/>Number of words in language  2 :  18729<br/>Total number of words:  55392</span></pre><p id="3405" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当使用较小的数据集时，使用神经网络进行分类的结果非常糟糕，所以我决定保留重复的数据集。更大的数据也代表了更真实的世界，模型应该更加关注最常用的词。</p><h1 id="7075" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">设置Google Colab</h1><p id="b5cf" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">收集完数据后，是时候用它来训练一个模型，以完成将单词分类成三种可能语言的任务了。如上所述，我决定使用各种不同的架构来比较它们在准确性和运行时间上的效率。因为我的桌面上没有GPU，所以我用谷歌的Colab来运行计算。我将保存的数据上传到我的驱动器，我必须运行下面的代码来允许Colab访问它。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="41e9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第一部分允许我上传处理数据所需的<em class="ln"> generate_data.py </em>文件。第二部分是将Colab笔记本链接到我的驱动器。</p><p id="9ed0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">完成后，我加载数据并使用SciKit-learn的<em class="ln"> train_test_split </em>函数将数据分成训练集和测试集。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5694" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里非常重要的一点是要理解，我迄今为止使用的数据格式适合CNN和RNNs，但不适合完全连接的网络，因此我必须将每个单词的矩阵展平为一个数组。作为一个小细节:我还必须在Colab上安装维基百科模块。我选择将数据拆分，只有1%进入测试集，因为数据太多，仍然有超过4500个单词。</p><h1 id="4f72" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">神经网络训练</h1><p id="31d8" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">我决定训练四种类型的神经网络:全连接，两种卷积和递归。训练是使用TensorFlow后端在Keras上完成的。我使用检查点回调来保存在训练时测试数据上获得最佳准确性的模型。每个模型都需要一个检查点，所以用xxx的四个不同值重复第7行。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="22a9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我使用的第一个模型是一个简单的全连接神经网络，有4个隐藏层和一个输出层，输出层有3个softmax单元，对应于3种语言。我尝试使用辍学层来调整训练，但它没有帮助，很可能是因为没有足够的数据量涉及过度拟合。在考虑了层和单元的数量之后，我决定使用下面的架构。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3707" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我想尝试的第二个网络是一个RNN，它具有一个LSTM单位的图层和一个具有3个softmax单位的密集图层用于分类。我尝试添加第二个LSTM，但它并没有更好。我认为这是因为我们训练的序列不够大。我发现的最好的架构如下。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2848" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，我想在CNN上尝试一下1D卷积，看看它们与我更熟悉的其他模型相比如何。我基本上只是为内核一个接一个地添加了不同大小的多个Conv1D层。我必须指定数据是第一种格式的通道，因为默认情况下Keras使用最后一种格式的通道。在这种情况下，通道对应于独热编码字符。当然，我在模型中加入了通常的输出层。我试图使用流行的池层，但它没有帮助，很可能是因为数据不够大(只有12个字符)，所以平均/最大化区域使模型丢失有用的信息。选择了以下架构。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bc95" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我使用的最终架构与之前的架构相同，但具有可分离的卷积层。Chollet在他的书中写道，这些可以使训练更快，效果更好。</p><p id="0bac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我在Google Colab上训练了所有这些模型。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4d06" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我使用了Adam optimizer，因为由于分类问题的性质，它是作为损失函数的最频繁和最分类的交叉熵。我对所有的模型进行了100个时期的训练，从结果来看，似乎所有的模型都达到了一个稳定期。我使用大小为1028的批次，因为有很多数据，较小的批次导致训练速度较慢，结果较差。最后，我对每次训练进行计时，以便在结束时进行比较。对于完全连接的网络，请注意使用扁平化数据。</p><p id="78ae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我不知道如何让Tensorboard在Google Colab上工作，所以我只是保存了模型的历史，然后离线分析它们。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="9d72" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">结果</h1><p id="0b70" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">训练完所有网络并保存模型后，我们可以看看结果。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7e05" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下表列出了每个模型的参数数量、运行时间以及测试集的最佳精度。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="39f1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第一个观察结果是，它们都有非常接近的精度，所以我真的不能说其中一个明显比其他的更好或更差。结合运行时间来看，RNN似乎不是最好的，因为它需要很多时间来运行，并且它的准确性最差。这可能是因为我正在研究的序列很短，而rnn(尤其是LSTMs)是用来模拟长序列的。具有可分离卷积的CNN确实比通常的CNN快，但是它没有给出更好的结果。这可能是因为可分离的层假设通道之间不存在依赖性，而在这里它们是相互依赖的。CNN和全连接网络给出了非常相似的结果和运行时间，所以两者都是上帝的选择。然而，CNN有更少的参数，所以这个模型更容易保存和使用。</p><p id="bd78" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些模型的训练历史可以被绘制出来，长时间的训练似乎不会有太大的改善。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/33d265ec3d4c03de0947270b709db5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AkX8rfdurtb7SMH0ybaAQ.png"/></div></div></figure><h1 id="f1c4" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">做预测</h1><p id="edfa" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">当然，这样做的目的是有一个模型可以预测一个单词是用哪种语言写的。该项目的最后一部分是制作一个脚本，使用经过训练的模型进行预测。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0a0c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我使用argparse包从命令行获取输入。输入是要分类的单词，并且有选择使用哪个模型的选项。如果没有指定模型，脚本将使用最准确的模型:CNN。然后，代码将这个单词转换成一个可以给模型的数组，加载模型，并使用正确的模型预测结果。它最终打印出每种语言的概率。该代码是用三种语言为这个特定示例编写的，但是很容易修改以适应给定的数据。要使用该代码，只需在命令行中编写(简单的修改)下面一行。</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="6db3" class="my lq it mu b gy mz na l nb nc">python predict.py word -m RNN</span></pre><p id="1f6a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">查看一些结果示例来分析性能可能会很有趣。我专注于使用CNN模型的预测。</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="d247" class="my lq it mu b gy mz na l nb nc">Word: banane<br/>Francais: 95.25%, English: 1.84%, Espanol: 2.81%</span><span id="e291" class="my lq it mu b gy nd na l nb nc">Word: will<br/>Francais:  4.26%, English:  94.09%, Espanol:  1.64%</span><span id="6efa" class="my lq it mu b gy nd na l nb nc">Word: plane<br/>Francais:  65.13%, English:  32.47%, Espanol:  2.4%</span><span id="628d" class="my lq it mu b gy nd na l nb nc">Word: gracias<br/>Francais:  0.0%, English:  0.02%, Espanol:  99.98%</span><span id="2f9c" class="my lq it mu b gy nd na l nb nc">Word: class<br/>Francais:  0.18%, English:  99.03%, Espanol:  0.79%</span><span id="bff8" class="my lq it mu b gy nd na l nb nc">Word: classe<br/>Francais:  99.67%, English:  0.21%, Espanol:  0.12%</span></pre><p id="e4be" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看起来这个模型对只存在于一种语言中的单词做得很好。有迹象表明，它理解像“plane”这样的词在法语和英语中都存在，因为两者都有不可忽略的概率。我努力尝试，但我找不到一个词，显然是错误的分类。训练数据中的大多数错误似乎都出现在出现在多种语言中的单词上。一个令人印象深刻的单词是“class(e)”,它被明确归类为不带e的英语和带e的法语。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="15ab" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">非常感谢你阅读我的第一篇博文！我是一名试图转向数据科学的物理学家，我做了许多个人项目，我将尝试与感兴趣的人分享。让我知道你对我工作的看法:)</p></div></div>    
</body>
</html>