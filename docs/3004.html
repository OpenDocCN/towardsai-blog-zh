<html>
<head>
<title>Time Series Clustering for Stock Market Prediction in Python- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中用于股市预测的时间序列聚类-第1部分</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/time-series-clustering-for-stock-market-prediction-in-python-part-1-738ab6462f0e?source=collection_archive---------0-----------------------#2022-08-01">https://pub.towardsai.net/time-series-clustering-for-stock-market-prediction-in-python-part-1-738ab6462f0e?source=collection_archive---------0-----------------------#2022-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b64" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尝试识别股票模式以进行聚类和预测。N的第1部分</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/9acae9e1cdfe499807045dbecf8c8b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*DcEl_iWzXMbu6kn-Zoqliw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@vedranafilipovic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">韦德拉纳·菲利波维奇</a>在<a class="ae kv" href="https://unsplash.com/s/photos/sequence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="be25" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你是一名分析师，不管你的工作部门，你肯定知道有许多不同的方法来预测股市。目前最相关的方法大多使用应用于序列数据的神经网络，如LSTMs，或者涉及情感分析和信号检测。</p><p id="5c26" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这些方法肯定很有趣，而且有一个很好的理由——互联网上有大量的资源处理提到的主题。这不是一件坏事，因为分析师可以遵循一个共享的基线来启动他们的项目，然后用他们自己的方法来扩展。</p><p id="a7ee" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">今天，我想提出一个不同的方法，一个我几周前梦寐以求的方法，它让我一直在思考，因为有意想不到的机会。我说的是应用于股票市场的<strong class="ky iu">时间序列聚类。</strong></p><p id="253d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我的主要想法是</p><blockquote class="ls lt lu"><p id="df4e" class="kw kx lv ky b kz la ju lb lc ld jx le lw lg lh li lx lk ll lm ly lo lp lq lr im bi translated">如果我可以识别数据中的模式，找到相似的模式，将它们组合在一起，并为每个模式分配投资机会，会怎么样？</p></blockquote><p id="52f5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这将允许我以概率的方式找出可以预测特定趋势的相关序列。</p><p id="1fe3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我已经花了几个小时在这个项目上，我想和你分享这个系列的第一部分。随着我继续从事这个项目，我将在另一篇文章中分享我的发现。</p><p id="5503" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">请记住，这是我的方法——如果你喜欢整体推理，但你会做一些不同的事情，请告诉我👌</p><p id="52b9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我希望你和我一样对这个项目感到兴奋。我们开始吧！</p><h1 id="29fe" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">潜在的直觉</h1><p id="7cf7" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这个想法是，如果我们选取一个时间序列，不管它的性质和背景(不管是股票还是其他什么)，我们可以把它分成块，并孤立地研究每个块。</p><p id="2360" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这让我们可以对这些词块做出假设，并相互检验。</p><p id="cdd4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">说到这里——这是这个问题的假设</p><blockquote class="ls lt lu"><p id="e1c3" class="kw kx lv ky b kz la ju lb lc ld jx le lw lg lh li lx lk ll lm ly lo lp lq lr im bi translated">如果我把一个时间序列分成特定长度的块，我就可以把这些块分成两部分，我称之为A和B。</p><p id="88c7" class="kw kx lv ky b kz la ju lb lc ld jx le lw lg lh li lx lk ll lm ly lo lp lq lr im bi translated">通过研究A，我能够找到以相似方式运行的模式和分组元素。这让我可以计算B跟随某个A有相似趋势的概率。</p></blockquote><p id="cbd8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在我看来，概率方法是最合适的方法。一会儿你就会明白为什么了。</p><p id="ceb9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">总而言之，<strong class="ky iu">我想找到在整个时间序列中具有一定相似度的趋势部分。我想对这些相似的部分进行分组，并查看之后的<em class="lv">部分在趋势方面的表现，趋势是使用斜率计算的。</em></strong></p><p id="6c06" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是我如何想象解决这个问题的图表</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/97f0d35f89d78dc5ada5b5f79cdd727b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxCyKIVPexck55oCdjp4Jw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">聚类算法的工作原理。图片由作者提供。</figcaption></figure><p id="2e43" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果我们发现一些a具有高度的相似性，那么我们可以将它们分组在一起，并通过计算多少个B具有正斜率或负斜率来找到B上升或下降的概率。</p><h1 id="711b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">该算法</h1><p id="34f9" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">根据上面的解释，我是这样设计算法的</p><ol class=""><li id="f1e7" class="nb nc it ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">将时间序列分割成长度为<code class="fe nk nl nm nn b">N</code>的序列</li><li id="9337" class="nb nc it ky b kz no lc np lf nq lj nr ln ns lr ng nh ni nj bi translated">根据大小<code class="fe nk nl nm nn b">K</code>将每个序列分成两部分，以创建<code class="fe nk nl nm nn b">A</code>和<code class="fe nk nl nm nn b">B</code>序列。</li><li id="22e1" class="nb nc it ky b kz no lc np lf nq lj nr ln ns lr ng nh ni nj bi translated">计算<code class="fe nk nl nm nn b">A</code>的所有序列之间的相似度<code class="fe nk nl nm nn b">S</code></li><li id="f6b1" class="nb nc it ky b kz no lc np lf nq lj nr ln ns lr ng nh ni nj bi translated">基于阈值对所有相似的<code class="fe nk nl nm nn b">A</code>序列进行分组</li><li id="4bf8" class="nb nc it ky b kz no lc np lf nq lj nr ln ns lr ng nh ni nj bi translated">对于每组<code class="fe nk nl nm nn b">G</code>,计算序列<code class="fe nk nl nm nn b">B</code>中正、负或稳定趋势的概率<code class="fe nk nl nm nn b">P</code></li><li id="2f7d" class="nb nc it ky b kz no lc np lf nq lj nr ln ns lr ng nh ni nj bi translated">在一个新的、看不见的时间序列中，识别分组序列<code class="fe nk nl nm nn b">A</code>以获得后续部分<code class="fe nk nl nm nn b">B</code>的概率</li></ol><p id="9fb2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果这些步骤现在对你来说还不是非常清楚，不要担心。我将用详细的论证和代码来解释每一步。</p><p id="4984" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们马上开始编码。</p><h1 id="a8c7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">要求</h1><p id="def6" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们将从头开始编写逻辑代码，所以我们将只依赖少量的Python库。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f863" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这里唯一值得一提的是，我们将使用<em class="lv"> pandas_datareader </em>作为股票市场数据的提供者。我们将在几个tickers上测试这个算法的部分。</p><h1 id="3bdb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">时间序列</h1><p id="e2aa" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们将使用pandas_datareader获取1000天前的苹果股票数据。这将包括689个数据点。这是因为排除了周末和其他节假日。</p><p id="9f68" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我选择这个数字并没有什么特别的原因，它看起来就像足够的数据。让我们定义一个助手函数来完成这个任务。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nv"><img src="../Images/f54d22c97c3bc49985f349de765ac2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyhA7JMaJaEaH0vJ0G-_TQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们时间序列的第一行。图片作者。</figcaption></figure><p id="3ba3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将使用<em class="lv">收盘</em>列作为我们的时间序列。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nw"><img src="../Images/7a6c46c03a4658471846dc7ccc38fc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7aRcSlVJnfdd0sYfkj3CA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">本文中使用的时间序列。图片由作者提供。</figcaption></figure><p id="1c3d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在让我们根据上面提到的逻辑继续拆分时间序列。</p><h1 id="23bc" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">拆分时间序列</h1><p id="b748" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们将定义两个函数，首先将时间序列分割成序列，然后分割成<em class="lv">分割序列。让我给你看一个例子:</em></p><p id="121e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">假设我们有一个20个数字的Numpy数组</p><p id="e93e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">s = np.array([i for i in range(30)])</code></p><p id="d11a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们想把这个系列分成大小相等的N个片段。我们可以这样实现它</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cf3e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果我们用<code class="fe nk nl nm nn b">n = 6</code>将这个函数应用于<code class="fe nk nl nm nn b">s</code>，我们将获得一个没有丢弃元素的完整的分割序列(因为当30除以6时没有余数)。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/128ad3058a178c860c334c9b7ca50379.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*lupnXvJyddt69t_fE9q0OQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">分裂序列法的应用。图片由作者提供。</figcaption></figure><p id="c7d8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我们需要根据大小<code class="fe nk nl nm nn b">K</code>将每个序列分成两部分，以创建<code class="fe nk nl nm nn b">A</code>和<code class="fe nk nl nm nn b">B</code>序列。让我们为此定义两个新函数，称为<em class="lv"> split_sequence和split_sequences </em>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8e55" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在<em class="lv"> split_sequence </em>中，参数<code class="fe nk nl nm nn b">K</code>允许我们如何控制第一个序列的大小。将其视为Sklearn的<em class="lv"> train_test_split中的<em class="lv"> test_size </em>参数。</em></p><p id="410b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><em class="lv"> split_sequences </em>只是负责将逻辑应用于数组。</p><p id="c9d3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们将它应用到我们的例子中来理解它是如何工作的</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c0efdec6b7c9ccda6a0dd299b4c94f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*lcIGxCx0_t-w-ZmQzqvIyQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">分割序列法。图片由作者提供。</figcaption></figure><p id="4ae8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">A</code>和<code class="fe nk nl nm nn b">B</code>序列定义如下</p><p id="815e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">[seq[0] for seq in sss], [seq[1] for seq in sss]</code></p><p id="c2a3" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此Numpy数组中第一个和第二个列表中的成对元素。</p><p id="b8e6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们将所有这些应用到我们的时间序列中。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">实现算法前两步的代码</figcaption></figure><p id="7f0a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果我们看一下<code class="fe nk nl nm nn b">A[0]</code>和<code class="fe nk nl nm nn b">B[0]</code>，我们会得到苹果收盘数据的第一部分，显示预处理是成功的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nz"><img src="../Images/d8215a7597aee73d1f297d762c7a226d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIFmGDnMYl2vy3pNsH3cow.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们预处理产生的第一个序列。图片作者。</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oa"><img src="../Images/76ecb5baf064d90612d12529e6e67cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGw-OyBfZoeGD_cUNPGs7g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">原始数据与预处理数据的对比。图片由作者提供。</figcaption></figure><p id="f2b6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我们准备通过相似性来比较序列。</p><h1 id="9f30" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">相似度计算</h1><p id="915c" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这是算法的第三步。为了计算相似性，我们将结合使用<strong class="ky iu">皮尔森相关性和动态时间扭曲。相关性帮助我们匹配趋势的大致方向，而DTW帮助我们计算两点之间的距离。关于这两个话题，网上有很多资源，如果你有兴趣的话，建议你去看看。</strong></p><p id="c87c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">公式如下，它是相关性和DWT的加权乘积</p><p id="7b64" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe nk nl nm nn b">DWT * (1 — correlation)</code></p><p id="a863" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">虽然可能不是最佳的(帮我找到一个更好的解决方案！)，它似乎是有效的，正如您将简要看到的。</p><p id="6fc5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这里的想法是创建一个相似性矩阵<code class="fe nk nl nm nn b">S</code>来存储属于<code class="fe nk nl nm nn b">A</code>的所有序列的成对得分。请记住，我们希望在A中找到相似的元素，以计算在趋势中找到某个B的概率。</p><p id="108c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">具有高于某个任意阈值的相似性的元素将被分组在一起。不过，我们以后会看到的。现在，让我们编写相似性计算的代码。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3269" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了清楚起见，我只打印矩阵的前两行</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/099e8615a2ab2b62a11ff4cd42f394b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*9MBXGbOjhooD-v6rESIgfA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">相似性矩阵的前两行由作者绘制。</figcaption></figure><p id="c111" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如你所见，相同系列的分数为0。所以，相似序列越来越相似，就越趋向于0。让我们用热图来描绘一下。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6acd8bdc405ca3d76101649ce1024a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*dCOxOzYoUgsezqRpwec0xQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">序列相似性热图。图片由作者提供。</figcaption></figure><p id="5a9b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">热图揭示了一条重要信息:最相似的序列大多出现在我们时间序列的开头和结尾。</p><p id="c19b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">不知道为什么会这样——我很想听听你对此的看法。我们继续吧。</p><h1 id="317a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">相似序列分组</h1><p id="d9ed" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">下一步是将<code class="fe nk nl nm nn b">A</code>中相似的序列分组在一起。这里的想法很简单:如果序列的相似性得分低于某个阈值，那么将它们分组到一个名为。<code class="fe nk nl nm nn b">G</code>。<code class="fe nk nl nm nn b">G</code>将为这个项目举办所有有意义的集群。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e5ea" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">关于阈值的说明:我通过反复试验使用了值6，因为它似乎在相似性分组方面产生了最好的结果(参见下文)。你可能想使用其他的价值观——尝试其他的价值观，让我知道它是如何为你工作的。</p><p id="6f66" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们通过打印字典的一部分来看看<code class="fe nk nl nm nn b">G</code>是什么样子的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c3fd34038a87d709b41016804d402778.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*wsj_6dmQq6pWHNU9fu57sg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">聚类A序列的一部分。图片作者。</figcaption></figure><p id="a5fc" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">酷…但没那么酷！字典并不能真正有效地传达信息。我们看到一些序列被组合在一起，但是它们看起来像什么呢？</p><h1 id="0283" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将小组形象化</h1><p id="d25e" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">现在最激动人心的部分来了…让我们来想象一下各组吧！</p><p id="8e3a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">对于<code class="fe nk nl nm nn b">G</code>字典中引用种子序列的每个键，让我们绘制所有相似序列的专用图表。</p><p id="cc71" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">记住:所有相似的序列都有一个低的动态时间弯曲值和一个相似的趋势。用于实现这种分组的参数是</p><p id="0927" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">N = 15 <br/> K = 0.70 <br/>阈值= 6</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oe"><img src="../Images/4acf4dfdfcb9c9bb905e88a60c065062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lc9ZQqZiG0a9j4ncsSX0FQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">这些团体形象化了。在每个图表中，种子序列是黑色的，相似的是几种颜色的—图片由作者提供。</figcaption></figure><p id="6348" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">逻辑似乎工作得很好，因为黑线，也就是种子序列，<strong class="ky iu">被在解剖和方向上相似的序列所包围。</strong></p><p id="814f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们检查另一个参数组合。</p><p id="0c33" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">n = 25<em class="lv"><br/></em>K = 0.6<em class="lv"><br/></em>阈值= 25</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi of"><img src="../Images/4a6e783e1a7d384a83ca80c1b9f3fffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GLTWo1Zlu5xHSDznYolcA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">基于新参数的新序列分组。图片由作者提供。</figcaption></figure><p id="f31f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">根据输入参数</strong>，结果可能会发生剧烈变化。这是意料之中的，因为窗口大小、A/B序列分割大小和阈值都会影响聚类算法的逻辑。</p><p id="0da6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">有些模式非常突出，比如第22组中的这个</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi og"><img src="../Images/13d8ef10729384c12e87e5d3604ee76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*kN9nwvFNr-8ggpFo7eNiaA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">第22组。图片由作者提供。</figcaption></figure><p id="7df7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">和第26组</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ada97cca82371039f2b28ee740207236.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*Ym75ipsWJLKDY4ILS5y1oA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">第26组。图片由作者提供。</figcaption></figure><p id="b4f9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">种子序列周围的大多数序列确实是相似的，并且在视觉上与种子共享几个特征。我认为需要更精确的方法来评估这些属性。</p><p id="b9db" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">虽然我确信有更好的方法来计算分数，但这些结果对我来说似乎很有希望。</p><h1 id="d247" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">计算概率</h1><p id="5416" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们将讨论本文的最后一部分。我们现在将计算B序列出现上升趋势、下降趋势或稳定趋势<em class="lv">的概率。</em>回想一下<code class="fe nk nl nm nn b">B</code>总是跟在<code class="fe nk nl nm nn b">A</code>后面——这意味着B_i的<em class="lv">第一个元素跟在A_i的最后一个元素后面。</em></p><p id="b121" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们将定义另一个名为<em class="lv"> classify_trend </em>的辅助函数，它负责计算斜率并理解B序列的大致方向。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1e07" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这些是结果。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/34467c7267b31ba91d8159951e2a21bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*a2SAX8kwXh3ZUYA9Xkz9_A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">概率被放在一个数据框架中。图片由作者提供。</figcaption></figure><p id="b7f5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们画出概率分布图。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/90a2b834e79a536edf8876b885fadfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*7nlgYJcwL9_tFX1UY2gtmQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">B序列的方向分布。图片作者。</figcaption></figure><p id="c3ed" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我选择按<em class="lv"> n_elements </em>对项目进行排序，因为越多的序列组合在一起，聚类就越相关。其实1组和14组分别有8个和7个元素，相似的模式还挺多的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f53508a93fca2e38cecb790c45a37cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*mcY0lKgA7j8pKZVU5Huasw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">第一组和第十四组。图片由作者提供。</figcaption></figure><p id="0fb0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这并不奇怪，因为两个A序列基本上是平的。这里肯定有优化的空间，例如，删除所有的扁平线。但是我们将来会看到这一点。</p><p id="30e9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在任何情况下，组1中75%的B序列具有向上的方向，而组14中57%的B序列具有向下的方向。也许两条线在某些方面确实不同，或者这种影响只是随机的。让我们画出B序列。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/592d7afa1356d0473784e41e65f7b0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*W8P3IIQIBR3wyNtwm_VkWw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">A看同组的A和B序列。图片由作者提供。</figcaption></figure><p id="0272" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这些B序列中的大多数确实上升了。有一些工作要做，以确保这不只是噪音。</p><p id="2bfe" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们检查第14组</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c6ffcb5349a1c58274ceb3dde501a57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*RFf07sqTtP8qRHA0D8M4dg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">A看同组的A和B序列。图片由作者提供。</figcaption></figure><p id="89b5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">事实上，他们中的大部分都走下坡路了。虽然逻辑似乎是正确的，但也许斜率计算需要一些改进:也许我们可以从默认的0.05增加阈值…但我们将在下一篇文章中讨论这个问题。</p><p id="9996" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">纯粹出于好奇，让我们绘制第22组，从视觉角度来看，这似乎也很有趣。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/53255f5ae7999dc1e34f194e2ecf06c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*nTeUThGxnBTEL_oXbcORSg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">A看同组的A和B序列。图片由作者提供。</figcaption></figure><p id="05e8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">哇哦。仅仅是我，还是B序列<em class="lv">实际上看起来彼此相似？</em>虽然这需要深入的分析，但如果这被证明是真的，那么A真的可以预测B，因此，这将解释为什么我们会看到类似的B。</p><h1 id="7512" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">第一部分结束</h1><p id="47f8" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">这很有趣。在第1部分中，我们看到了算法是如何工作的，以及它在预测股票市场趋势方面的潜力。</p><p id="75d0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">实际上，如果这可行，它可能是一个通用的方法…适用于任何时间序列。太令人兴奋了！在不久的将来，随着我对这个想法的继续研究，我将扩展这个分析。</p><p id="1e1a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">请分享您对该方法的意见、疑问和想法。我喜欢整合反馈和贡献！😊</p><p id="f3f6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><strong class="ky iu">如果你想支持我的内容创作活动，欢迎点击我下面的推荐链接，加入Medium的会员计划</strong>。我将获得你投资的一部分，你将能够以无缝的方式访问Medium的大量数据科学文章。</p><div class="om on gp gr oo op"><a href="https://medium.com/@theDrewDag/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">通过我的推荐链接加入Medium-Andrew D # data science</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">阅读Andrew D #datascience(以及媒体上成千上万的其他作者)的每一个故事。您的会员费直接…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kp op"/></div></div></a></div><p id="dd6b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">下一篇文章再见👋</p></div></div>    
</body>
</html>