<html>
<head>
<title>Writing TFRecord Files the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以正确的方式编写TFRecord文件</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/writing-tfrecord-files-the-right-way-7c3cee3d7b12?source=collection_archive---------2-----------------------#2021-03-31">https://pub.towardsai.net/writing-tfrecord-files-the-right-way-7c3cee3d7b12?source=collection_archive---------2-----------------------#2021-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f93c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="54f2" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何正确地从数据集生成TFRecord文件</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/27e4f49a2ff08771f032c1fe1a373f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jZnw-WizS_sVsFuA97CIg.png"/></div></div></figure><p id="6339" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi lw translated">TFRecord格式是一种用于存储二进制记录序列的简单格式。</p><blockquote class="mf mg mh"><p id="9798" class="la lb mi lc b ld le ka lf lg lh kd li mj lk ll lm mk lo lp lq ml ls lt lu lv ij bi translated">在这篇文章中，你将了解为什么以及何时应该使用TFRecords格式，以及使用它所必需的代码。</p><p id="bf24" class="la lb mi lc b ld le ka lf lg lh kd li mj lk ll lm mk lo lp lq ml ls lt lu lv ij bi translated">这篇文章是我为官方Keras.io代码示例页面写的教程的更详细版本。</p></blockquote><p id="7e80" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">将您的数据转换为TFRecord有许多优点，例如:</p><ul class=""><li id="d359" class="mn mo iq lc b ld le lg lh lj mp ln mq lr mr lv ms mt mu mv bi translated"><strong class="lc ja">更高效的存储</strong>:TF record数据可以比原始数据占用更少的空间；它也可以被分割成多个文件。</li><li id="5726" class="mn mo iq lc b ld mw lg mx lj my ln mz lr na lv ms mt mu mv bi translated"><strong class="lc ja">快速I/O</strong>:TF record格式可以通过并行I/O操作读取，这对于<a class="ae mm" href="https://www.tensorflow.org/guide/tpu" rel="noopener ugc nofollow" target="_blank">TPU</a>或多个主机很有用。</li><li id="74a5" class="mn mo iq lc b ld mw lg mx lj my ln mz lr na lv ms mt mu mv bi translated"><strong class="lc ja">自包含文件</strong>:TF record数据可以从单一来源读取——例如，<a class="ae mm" href="https://cocodataset.org/" rel="noopener ugc nofollow" target="_blank"> COCO2017 </a>数据集最初将数据存储在两个文件夹中(“图像”和“注释”)。</li></ul><p id="ae61" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">TFRecord数据格式的一个重要用例是TPU上的培训。首先，TPU足够快，可以从优化的I/O操作中受益。此外，TPU需要远程存储数据(例如在谷歌云存储上)，使用TFRecord格式可以更容易地加载数据，而无需批量下载。</p><p id="f49e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果您还将TFRecord格式与<a class="ae mm" href="https://www.tensorflow.org/guide/data" rel="noopener ugc nofollow" target="_blank"> tf.data </a> API一起使用，那么使用TF record格式的性能可以得到进一步提高。</p><p id="250b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这里，您将学习如何将不同类型的数据(图像、文本和数字)转换成TFRecord。</p><h2 id="1913" class="nb nc iq bd nd ne nf dn ng nh ni dp nj lj nk nl nm ln nn no np lr nq nr ns iw bi translated">COCO 2017数据集</h2><p id="d425" class="pw-post-body-paragraph la lb iq lc b ld nt ka lf lg nu kd li lj nv ll lm ln nw lp lq lr nx lt lu lv ij bi translated">我们将使用<a class="ae mm" href="https://cocodataset.org/" rel="noopener ugc nofollow" target="_blank"> COCO2017 </a>数据集，因为它有许多不同类型的特性，包括图像、浮点数据和列表。它将作为一个很好的例子，说明如何将不同的特性编码成TFRecord格式。</p><p id="3345" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该数据集有两组字段:<strong class="lc ja">图像</strong>和<strong class="lc ja">注释元数据</strong>。</p><p id="f8a6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些图像是JPG文件的集合，元数据存储在一个JSON文件中，根据<a class="ae mm" href="https://cocodataset.org/#format-data" rel="noopener ugc nofollow" target="_blank">官方网站</a>，该文件包含以下属性:</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="0186" class="nb nc iq nz b gy od oe l of og">id: int,<br/>image_id: int,<br/>category_id: int,<br/>segmentation: RLE or [polygon], object segmentation mask<br/>bbox: [x,y,width,height], object bounding box coordinates<br/>area: float, area of the bounding box<br/>iscrowd: 0 or 1, is single object or a collection</span></pre><h2 id="32d3" class="nb nc iq bd nd ne nf dn ng nh ni dp nj lj nk nl nm ln nn no np lr nq nr ns iw bi translated">让我们看看数据集中的一个样本</h2><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="ac68" class="nb nc iq nz b gy od oe l of og">{'area': 367.89710000000014,<br/> 'bbox': [265.67, 222.31, 26.48, 14.71],<br/> 'category_id': 72,<br/> 'id': 34096,<br/> 'image_id': 525083,<br/> 'iscrowd': 0,<br/> 'segmentation': [[267.51,<br/>                   222.31,<br/>                   292.15,<br/>                   222.31,<br/>                   291.05,<br/>                   237.02,<br/>                   265.67,<br/>                   237.02]]}</span></pre><h1 id="64b1" class="oh nc iq bd nd oi oj ok ng ol om on nj kf oo kg nm ki op kj np kl oq km ns or bi translated">开始数据转换</h1><p id="3040" class="pw-post-body-paragraph la lb iq lc b ld nt ka lf lg nu kd li lj nv ll lm ln nw lp lq lr nx lt lu lv ij bi translated">要开始数据转换过程，首先，我们需要定义几个函数。<br/>从原始数据到张量流类型的转换开始:</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="6137" class="nb nc iq nz b gy od oe l of og">def image_feature(value):<br/>    """Returns a bytes_list from a string / byte."""<br/>    return tf.train.Feature(<br/>        bytes_list=tf.train.BytesList(value=[tf.io.encode_jpeg(value).numpy()])<br/>    )<br/><br/>def bytes_feature(value):<br/>    """Returns a bytes_list from a string / byte."""<br/>    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value.encode()]))<br/><br/>def float_feature(value):<br/>    """Returns a float_list from a float / double."""<br/>    return tf.train.Feature(float_list=tf.train.FloatList(value=[value]))<br/><br/>def int64_feature(value):<br/>    """Returns an int64_list from a bool / enum / int / uint."""<br/>    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))<br/><br/>def float_feature_list(value):<br/>    """Returns a list of float_list from a float / double."""<br/>    return tf.train.Feature(float_list=tf.train.FloatList(value=value))</span><span id="3fec" class="nb nc iq nz b gy os oe l of og">def create_example(image, path, example):<br/>    feature = {<br/>        "image": image_feature(image),<br/>        "path": bytes_feature(path),<br/>        "area": float_feature(example["area"]),<br/>        "bbox": float_feature_list(example["bbox"]),<br/>        "category_id": int64_feature(example["category_id"]),<br/>        "id": int64_feature(example["id"]),<br/>        "image_id": int64_feature(example["image_id"]),<br/>    }<br/>    return tf.train.Example(features=tf.train.Features(feature=feature))</span></pre><p id="73b3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些函数非常直观，但让我们更好地理解它们的用法。</p><p id="bc38" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">基本函数是<code class="fe ot ou ov nz b">bytes_feature</code>、<code class="fe ot ou ov nz b">float_feature</code>和<code class="fe ot ou ov nz b">int64_feature</code>，它们将把基本数据如字符串和数字数据(整数和浮点数)转换成等价的TensorFlow数据类型，<code class="fe ot ou ov nz b">float_feature</code>和<code class="fe ot ou ov nz b">float_feature_list</code>的区别在于<code class="fe ot ou ov nz b">float_feature_list</code>用于转换一列浮点数，而不仅仅是单个值。<br/>接下来，我们将使用<code class="fe ot ou ov nz b">image_feature</code>来转换图像，也可以使用常规字符串或浮动列表来转换图像，但是使用像<code class="fe ot ou ov nz b">encode_jpeg</code>这样的函数更有效。<br/>最后，我们有<code class="fe ot ou ov nz b">create_example</code>将所有这些集合在一起，它接收所有必要的数据，并将其转换为适当的TensorFlow格式，创建一个字典，后者将被序列化并写成TFRecord文件。</p><p id="566b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，我们可以定义一些参数来启动这个过程。</p><p id="edb8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ot ou ov nz b">num_samples</code>是每个TFRecord文件上的数据样本数。</p><p id="b20d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ot ou ov nz b">num_tfrecods</code>是我们将要创建的TFRecord文件的总数。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="c4d0" class="nb nc iq nz b gy od oe l of og">root_dir = "datasets" # input data root folder<br/>tfrecords_dir = "tfrecords" # output data folder<br/>images_dir = os.path.join(root_dir, "val2017") # input images folder</span><span id="8e07" class="nb nc iq nz b gy os oe l of og"># input annotations folder and filepath<br/>annotations_dir = os.path.join(root_dir, "annotations") <br/>annotation_file = os.path.join(annotations_dir, "instances_val2017.json")</span><span id="952d" class="nb nc iq nz b gy os oe l of og">num_samples = 4096<br/>num_tfrecods = len(annotations) // num_samples</span><span id="0b38" class="nb nc iq nz b gy os oe l of og">with open(annotation_file, "r") as f: # load annotation data as list<br/>    annotations = json.load(f)["annotations"]<br/><br/>if not os.path.exists(tfrecords_dir):<br/>    os.makedirs(tfrecords_dir)  # creating TFRecords output folder</span></pre><h2 id="65e1" class="nb nc iq bd nd ne nf dn ng nh ni dp nj lj nk nl nm ln nn no np lr nq nr ns iw bi translated">生成TFRecord格式的数据</h2><p id="21fd" class="pw-post-body-paragraph la lb iq lc b ld nt ka lf lg nu kd li lj nv ll lm ln nw lp lq lr nx lt lu lv ij bi translated">现在我们可以迭代COCO2017数据并创建TFRecord文件。文件名格式将是<code class="fe ot ou ov nz b">file_{number}.tfrec</code>(这是可选的，但是在文件名中包含数字序列可以使计数更容易)。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="9ec8" class="nb nc iq nz b gy od oe l of og">for tfrec_num in range(num_tfrecods):<br/>    samples = annotations[(tfrec_num * num_samples) : <br/>                          ((tfrec_num + 1) * num_samples)]<br/><br/>    with tf.io.TFRecordWriter(<br/>        tfrecords_dir+"/file_%.2i-%i.tfrec"%(tfrec_num,len(samples))<br/>    ) as writer:<br/>        for sample in samples:<br/>            image_path=f"{images_dir}/{sample['image_id']:012d}.jpg"<br/>            image = tf.io.decode_jpeg(tf.io.read_file(image_path))<br/>            example = create_example(image, image_path, sample)<br/>            writer.write(example.SerializeToString())</span></pre><p id="f3f7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是这个循环中发生的情况:</p><p id="86f7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先，我们对注释列表进行切片，只获取将在该迭代中写入的样本，切片大小基于我们之前为每个TFRecord文件定义的样本数量<code class="fe ot ou ov nz b">num_samples</code>。</p><p id="dd7c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我们使用<code class="fe ot ou ov nz b">tf.io.TFRecordWriter</code>来创建将要写入的TFRecord文件，并且我们使用另一个循环来迭代第一步中切片的样本。</p><p id="c885" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于最后一个循环，我们首先构建图像文件路径，并使用它通过<code class="fe ot ou ov nz b">tf.io.decode_jpeg</code>读取图像，然后我们可以使用这些属性调用<code class="fe ot ou ov nz b">create_example </code>函数，该函数将返回一个TensorFlow示例，我们将使用<code class="fe ot ou ov nz b">example.SerializeToString()</code>序列化该示例，最后，将该示例写入第二步中创建的TFRecord文件。</p><h1 id="72c1" class="oh nc iq bd nd oi oj ok ng ol om on nj kf oo kg nm ki op kj np kl oq km ns or bi translated">从生成的TFRecord中探索一个样本</h1><p id="5ddd" class="pw-post-body-paragraph la lb iq lc b ld nt ka lf lg nu kd li lj nv ll lm ln nw lp lq lr nx lt lu lv ij bi translated">要打开新创建的TFRecord文件，我们需要一个parse函数，该函数会将二进制记录序列转换回适当的TensorFlow数据类型。</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="6223" class="nb nc iq nz b gy od oe l of og">def parse_tfrecord_fn(example):<br/>    feature_description = {<br/>        "image": tf.io.FixedLenFeature([], tf.string),<br/>        "path": tf.io.FixedLenFeature([], tf.string),<br/>        "area": tf.io.FixedLenFeature([], tf.float32),<br/>        "bbox": tf.io.VarLenFeature(tf.float32),<br/>        "category_id": tf.io.FixedLenFeature([], tf.int64),<br/>        "id": tf.io.FixedLenFeature([], tf.int64),<br/>        "image_id": tf.io.FixedLenFeature([], tf.int64),<br/>    }<br/>    example = tf.io.parse_single_example(example, feature_description)<br/>    example["image"] = tf.io.decode_jpeg(example["image"], channels=3)<br/>    example["bbox"] = tf.sparse.to_dense(example["bbox"])<br/>    return example</span></pre><p id="0ab0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">读取图像并显示</p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="e35b" class="nb nc iq nz b gy od oe l of og">raw_dataset = tf.data.TFRecordDataset(f"{tfrecords_dir}/file_00-{num_samples}.tfrec")<br/>parsed_dataset = raw_dataset.map(parse_tfrecord_fn)<br/><br/>for features in parsed_dataset.take(1):<br/>    for key in features.keys():<br/>        if key != "image":<br/>            print(f"{key}: {features[key]}")<br/><br/>    print(f"Image shape: {features['image'].shape}")<br/>    plt.figure(figsize=(7, 7))<br/>    plt.imshow(features["image"].numpy())<br/>    plt.show()</span></pre><p id="2a22" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mi">输出:</em></p><pre class="kp kq kr ks gt ny nz oa ob aw oc bi"><span id="b971" class="nb nc iq nz b gy od oe l of og">bbox: [473.07 395.93  38.65  28.67]<br/>area: 702.1057739257812<br/>category_id: 18<br/>id: 1768<br/>image_id: 289343<br/>path: b'datasets/val2017/000000289343.jpg'<br/>Image shape: (640, 529, 3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7eae34dff7258f891887163f999dc48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*M3mgyEjHHhqe79DFyBtprA.png"/></div></figure><p id="4333" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">TFRecord的另一个优点是，您可以向它添加许多功能，以后只使用其中的一部分，在这种情况下。</p><p id="008f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在你可以使用新生成的TFRecord文件训练一个模型，查看我写的<a class="ae mm" href="https://keras.io/examples/keras_recipes/creating_tfrecords/" rel="noopener ugc nofollow" target="_blank"> Keras.io教程</a>中的例子。</p><h1 id="dc7d" class="oh nc iq bd nd oi oj ok ng ol om on nj kf oo kg nm ki op kj np kl oq km ns or bi translated">结论</h1><p id="c864" class="pw-post-body-paragraph la lb iq lc b ld nt ka lf lg nu kd li lj nv ll lm ln nw lp lq lr nx lt lu lv ij bi translated">本文演示了使用TFRecord，您可以从单一来源获得数据，而不是从不同来源读取图像和注释。这个过程可以使存储和读取数据更简单、更高效。更多信息可以去<a class="ae mm" href="https://www.tensorflow.org/tutorials/load_data/tfrecord" rel="noopener ugc nofollow" target="_blank"> TFRecord和tf.train.Example </a>教程。</p><h2 id="965b" class="nb nc iq bd nd ne nf dn ng nh ni dp nj lj nk nl nm ln nn no np lr nq nr ns iw bi translated">参考</h2><p id="cf0f" class="pw-post-body-paragraph la lb iq lc b ld nt ka lf lg nu kd li lj nv ll lm ln nw lp lq lr nx lt lu lv ij bi translated">- <a class="ae mm" href="https://www.tensorflow.org/tutorials/load_data/tfrecord" rel="noopener ugc nofollow" target="_blank"> TFRecord和TF . train . example</a>(tensor flow)<br/>-<a class="ae mm" href="https://keras.io/examples/keras_recipes/creating_tfrecords/" rel="noopener ugc nofollow" target="_blank">创建TF records</a>(keras . io)<br/>-<a class="ae mm" href="https://www.kaggle.com/ryanholbrook/tfrecords-basics" rel="noopener ugc nofollow" target="_blank">TF records基础</a> (Kaggle)</p></div></div>    
</body>
</html>