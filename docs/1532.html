<html>
<head>
<title>Procedural OCHL Stock Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序OCHL股票生成器</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/procedural-ochl-stock-generator-54ce041931be?source=collection_archive---------3-----------------------#2021-02-13">https://pub.towardsai.net/procedural-ochl-stock-generator-54ce041931be?source=collection_archive---------3-----------------------#2021-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4225" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">量化金融，</a>数据可视化，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="7c9b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">程序化地生成用于模拟目的的合成股票数据。完整的代码可在我的回购<a class="ae kr" href="https://github.com/arditoibryan/Projects/blob/master/20210203_OCHL_Stock_Generator/v2.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></h2></div><p id="855d" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">点击这里了解我、我的项目和我的最新文章。T9】</p><p id="67fb" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">技术分析最困难的部分之一是找到数据。持续下载历史股票数据并不像听起来那么容易:你需要从提供数据的公司获得一个API密匙，然后必须下载、解析、清理数据，只有这样你才能处理一些数据。事实上，简单地使用两三只股票作为样本是有趣的，但当你在尝试量化金融中的全部算法时，这有点限制性。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/1f15085ac659ca90fb215ece1bf48c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdJW6gzo_-o5PtSrMaHCIw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">程序生成的OCHL股票价格</figcaption></figure><p id="ef95" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">作为一个解决方案，我可以从零开始创建我的数据:这被称为<strong class="ku jd">合成数据</strong>。我在本文中发布的算法直接生成了一个包含随机股票价格的pandas数据框架，包括高、低、收盘和开盘价。我也包括这些指标的原因是，许多技术分析算法不仅基于数据的接近部分，而且需要更多。</p><h2 id="9ade" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">算法构造</h2><p id="a565" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我构建这个模型的方式非常简单:我在一整年内每小时生成随机数据，然后通过查看一天中的24小时，提取当天的最高价和最低价，以及开盘和收盘时的价格，来获得OCHL指标。因此，我将有4个单独的列。</p><h2 id="a496" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">构建算法的步骤如下:</h2><ol class=""><li id="a9e2" class="nb nc it ku b kv mw ky mx lb nd lf ne lj nf ln ng nh ni nj bi translated">安装依赖项</li><li id="ce92" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">导入库</li><li id="0651" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">定义函数</li><li id="5b85" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">Groupby函数</li><li id="a9d1" class="nb nc it ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated">OHCL模拟器</li></ol><h2 id="6c04" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">1.安装依赖项</h2><p id="ec42" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">对于这个算法，我将使用图形库Plotly。因为，有时候，库会因为新的更新而变得不稳定，所以我使用一个稳定的版本来避免错误。对于更高级和适应性更强的代码，您可能需要将Plotly升级到最新版本。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="b0df" class="me mf it nq b gy nu nv l nw nx">!pip install plotly==4.8</span></pre><h2 id="d58e" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">2.导入库</h2><p id="0346" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">至于每一个算法，我会在开始的时候导入基本库。我将使用pandas，NumPy和random来执行模拟，并Plotly来绘制结果。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="50aa" class="me mf it nq b gy nu nv l nw nx">import plotly.express as px<br/>import pandas as pd<br/>import numpy as np<br/>import random<br/>from scipy.stats import skewnorm<br/>import plotly.graph_objects as go</span></pre><h2 id="fd6f" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">3.定义函数</h2><p id="a035" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">为了以结构化的方式组织我的算法，我需要定义几个函数来保存部分代码。这些功能将有助于模拟。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="d9a0" class="me mf it nq b gy nu nv l nw nx">#graphs all columns for x, uses df.index as y<br/>def graph_stock(df, title):<br/>  #time_column is a string</span><span id="af83" class="me mf it nq b gy ny nv l nw nx">pd.options.plotting.backend = "plotly"<br/>  #fig = px.line(df, x='time', y=['price', 'price_2'])<br/>  fig = px.line(df, x=df.index, y=df.columns, title=title)<br/>  fig.show()</span><span id="64ae" class="me mf it nq b gy ny nv l nw nx">def graph_OCHL(df_OCHL, title):<br/>  #fig_1 = px.line(df, x=df.index, y=df.columns, title=title)<br/>  fig_2 = go.Figure(data=go.Ohlc(x=df_OCHL.index,<br/>                      open=df_OCHL['open'],<br/>                      high=df_OCHL['high'],<br/>                      low=df_OCHL['low'],<br/>                      close=df_OCHL['close']))<br/>  fig_2.update(layout_xaxis_rangeslider_visible=False)<br/>  fig_2.show()</span></pre><p id="be9b" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">现在是创建主函数的时候了:一个在被调用时可以执行整个模拟的代码。我将使用8760作为长度参数来使用这个函数，这意味着我将为一年中的每个小时生成随机值。因为结果很容易与最初的1000作为基础价格有所不同(1年后，我可能会有100，000，不太现实)，所以我将大幅减少我的随机分布值，使其接近0。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="cda2" class="me mf it nq b gy nu nv l nw nx">def simulate_stock(initial_price, drift, volatility, trend, days):</span><span id="656b" class="me mf it nq b gy ny nv l nw nx">  def create_pdf(sd, mean, alfa):<br/>    #invertire il segno di alfa<br/>    x = skewnorm.rvs(alfa, size=1000000) <br/>    def calc(k, sd, mean):<br/>      return (k*sd)+mean<br/>    x = calc(x, sd, mean) #standard distribution</span><span id="3839" class="me mf it nq b gy ny nv l nw nx">    #graph pdf<br/>    #pd.DataFrame(x).hist(bins=100)</span><span id="85d4" class="me mf it nq b gy ny nv l nw nx">    #pick one random number from the distribution<br/>    #formally I would use cdf, but I just have to pick randomly from  the 1000000 samples<br/>    #np.random.choice(x)<br/>    return x</span><span id="2c26" class="me mf it nq b gy ny nv l nw nx">  def create_empty_df(days):<br/>    #creare un empty DataFrame con le date<br/>    empty = pd.DatetimeIndex(<br/>        pd.date_range("2020-01-01", periods=days, freq="D")<br/>    )<br/>    empty = pd.DataFrame(empty)<br/>    #si tagliano ore, minuti, secondi<br/>    empty</span><span id="9676" class="me mf it nq b gy ny nv l nw nx">    #si tagliano ore, minuti, secondi<br/>    empty.index = [str(x)[0:empty.shape[0]] for x in   list(empty.pop(0))]<br/>    empty</span><span id="eac9" class="me mf it nq b gy ny nv l nw nx">    #final dataset con values<br/>    stock = pd.DataFrame([x for x in range(0, empty.shape[0])])<br/>    stock.index = empty.index<br/>    return stock</span><span id="ce28" class="me mf it nq b gy ny nv l nw nx">  #skeleton<br/>  stock = create_empty_df(days)</span><span id="9e28" class="me mf it nq b gy ny nv l nw nx">  #initial price<br/>  stock[0][0] = initial_price</span><span id="0bdc" class="me mf it nq b gy ny nv l nw nx">  #create entire stock DataFrame<br/>  x = create_pdf(volatility, drift, trend)<br/>  for _ in range(1, stock.shape[0]):<br/>    stock.iloc[_] = stock.iloc[_-1]*(1+np.random.choice(x))<br/>  <br/>  stock.index = pd.DatetimeIndex(stock.index)<br/>  return stock</span></pre><p id="2c1d" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我将使用OCHL转换器提取一部分24小时股票价格的最高价、最低价、开盘价和收盘价。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="3b28" class="me mf it nq b gy nu nv l nw nx">def OCHL(group_values):<br/>  min_ = min(group_values)<br/>  max_ = max(group_values)<br/>  range = max_ - min_<br/>  open = min_+range*random.random()<br/>  close = min_+range*random.random()<br/>  return min_, max_, open, close</span></pre><p id="90db" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我现在可以进行整个模拟。这将生成存储在df变量中的一年的每小时数据。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="6cd6" class="me mf it nq b gy nu nv l nw nx">df = simulate_stock(1000, 0, 0.01, 0, 8760)</span></pre><h2 id="ea00" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">4.Groupby函数</h2><p id="8a81" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">一旦我模拟了一年的数据，我就可以最终提取OCHL。为此，我将把数据按24份分组，然后使用OCHL转换器。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="dc97" class="me mf it nq b gy nu nv l nw nx">df_ = list()<br/>#df.groupby(np.arange(len(df))//24).apply(OCHL) non funziona<br/>#sarebbe il modo corretto, ma devo creare un nuovo df da 0<br/>for a, b in df.groupby(np.arange(len(df))//24):<br/>  group_values = np.array(b.values).flatten()<br/>  low, high, open, close = OCHL(group_values)<br/>  df_.append([low, high, open, close])</span><span id="ab8c" class="me mf it nq b gy ny nv l nw nx">#<br/>df_OCHL = pd.DataFrame(df_, index=pd.Series(pd.date_range("2020-01-01", periods=365, freq="D")), columns=['low', 'high', 'open', 'close'])</span></pre><h2 id="1f9a" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">5.执行模拟</h2><p id="9826" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">最后，让我用图表显示结果:</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="10fd" class="me mf it nq b gy nu nv l nw nx">#graph<br/>graph_stock(df, "")<br/>fig = go.Figure(data=go.Ohlc(x=df_OCHL.index,<br/>                    open=df_OCHL['open'],<br/>                    high=df_OCHL['high'],<br/>                    low=df_OCHL['low'],<br/>                    close=df_OCHL['close']))<br/>fig.update(layout_xaxis_rangeslider_visible=False)<br/>fig.show()</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nz"><img src="../Images/f6d11a7cc1bd00f2c07ea0fc276e9bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WaSgDI4OubxxFZC3-AR5Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">1年内每小时变动的股票</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/ec9bd23f7f5864e870881f8df7a0d359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcO3Rq6qkN3jizc074hZgg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">一年内每日变动的股票，OCHL格式</figcaption></figure><p id="e2c5" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">每次运行该算法时，都会生成一个新的随机OCHL作为变量df_OCHL。您可以使用pandas导出它，用它执行分析，甚至决定生成数千个并连接它们。</p></div></div>    
</body>
</html>