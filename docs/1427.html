<html>
<head>
<title>Movie Proximity in the N-Dimensional Space, Using PCA for Data Visualization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PCA进行数据可视化的N维空间中的电影邻近性</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/movie-proximity-in-the-n-dimensional-space-using-pca-for-data-visualization-1148296169ec?source=collection_archive---------3-----------------------#2021-01-23">https://pub.towardsai.net/movie-proximity-in-the-n-dimensional-space-using-pca-for-data-visualization-1148296169ec?source=collection_archive---------3-----------------------#2021-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fae5" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a></h2><div class=""/><div class=""><h2 id="b2f2" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">将21维的数值数据压缩为3维，然后将结果绘制成3D图形</h2></div><p id="e6d3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">数据已经从<a class="ae ln" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank">这个网站</a>下载，这是一个开源的电影评级和标签数据集。出于可视化目的，我将编辑数据集中的数据，将所有标记编码为one_hot编码，并将它们放入多维空间。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/1b9190f34d0b455a13e3e804a7b7f06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XM7NUONKPIfES7Nvm5Tgtg.jpeg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><a class="ae ln" href="https://www.artstation.com/artwork/VEG9N" rel="noopener ugc nofollow" target="_blank">https://www.artstation.com/artwork/VEG9N</a>，来自奥利维尔普龙地形象</figcaption></figure><p id="bb6e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因为一个超过3维的空间不能使用图像来绘制，我将需要使用PCA技术来压缩数据，并使用Plotly在3D空间中可视化它。</p><h2 id="4290" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated">下载数据</h2><p id="5f98" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">因为数据可视化是GPU密集型任务，在3D空间中有几个限制，所以我可以简单地使用2MB数据集。如果你真的想建立庞大的网络或进行其他实验，你要知道，在这个源头上，你可以访问一个3.1GB的电影数据集。</p><p id="24cf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将从数据中收集以下变量，这些变量存储在两个独立的excel文件中(原因是每部电影都有多个评级)。</p><ul class=""><li id="6f34" class="nb nc it kt b ku kv kx ky la nd le ne li nf lm ng nh ni nj bi translated">电影分级</li><li id="c217" class="nb nc it kt b ku nk kx nl la nm le nn li no lm ng nh ni nj bi translated">影片标签</li></ul><p id="8d4a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后，我将继续合并这两个数据集，对标记进行one_hot编码，将它们转换为数字数据，最后，对这个多维数据集执行PCA。</p><h2 id="8303" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated">导入包含熊猫的数据</h2><p id="08c0" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">从网站下载文件后，我将使用熊猫导入它们。您必须将路径更改为。以正确导入数据集。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="80e7" class="me mf it nq b gy nu nv l nw nx">import pandas as pd<br/>X_1= pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Projects/20210103_Movie_PCA/movies.csv')<br/>X_1.index = X_1.pop('movieId')<br/>X_1</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ny"><img src="../Images/fbed8f8beb4fa7c3e8527aa32d99ab87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYyJeFw1fN9qIlfU6IYRBw.png"/></div></div></figure><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="2fd0" class="me mf it nq b gy nu nv l nw nx">X_2 = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Projects/20210103_Movie_PCA/ratings.csv')<br/>X_2.index = X_2.pop('movieId')<br/>X_2</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c3154b033c0d96e2402b84b10e7f8530.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*A7X9DwloqoCifhdivsj6KA.png"/></div></figure><p id="e930" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从这两个数据集可以看出，行数是不相等的，这就是为什么它们存储在不同的文件中。我需要把它们合并到同一个<strong class="kt jd"> movieId </strong>中，然后把评级压缩成一个数字，代表它们的平均值。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="4492" class="me mf it nq b gy nu nv l nw nx">X = X_1.join(X_2, on='movieId', rsuffix='_')<br/>X</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oa"><img src="../Images/4ddc18c13a8b8da3007c4ebbe1271f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0JrIpT1-6qGjj8ymAE5ZQ.png"/></div></div></figure><h2 id="5657" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated"><strong class="ak">平均评级</strong></h2><p id="a24e" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">现在，我将根据影片的标题创建不同的组，然后通过对评级执行平均来压缩同一影片的所有行。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="f80f" class="me mf it nq b gy nu nv l nw nx">#making a copy to not import everything over again<br/>df = X.copy()</span><span id="1e02" class="me mf it nq b gy ob nv l nw nx">#separate groups<br/>dataframe_list = list()<br/>for region, df_region in df.groupby('title'):<br/>  dataframe_list.append(df_region)</span><span id="920e" class="me mf it nq b gy ob nv l nw nx">#average ratings<br/>final_list=list()<br/>for movie in dataframe_list:<br/>  movie_df = pd.DataFrame(movie.iloc[0]).transpose()<br/>  movie_df['rating'] = movie.mean()[1]<br/>  final_list.append(movie_df)</span><span id="85a8" class="me mf it nq b gy ob nv l nw nx">final_list</span></pre><p id="35a2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我已经将每个影片作为final_list的一个元素进行了存储，我将通过将它们连接为行来创建一个唯一的数据集，然后删除无用的列以供out分析:</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="3082" class="me mf it nq b gy nu nv l nw nx">df = pd.concat(final_list, axis=0)<br/>df = df.reset_index()<br/>df.pop('index')<br/>df.pop('userId')<br/>df.pop('timestamp')<br/>df</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oc"><img src="../Images/d8cda1c4388bea64e820f979089a9264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zArmQtrIjDPrl7tqQPJvqQ.png"/></div></div></figure><h2 id="ac81" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated"><strong class="ak"> One_Hot编码</strong></h2><p id="4351" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">要执行one_hot编码，我将首先创建一组所有可能的标记:</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="a2c3" class="me mf it nq b gy nu nv l nw nx">#creating set of tags<br/>set1 = set()<br/>for row in range(df.shape[0]):<br/>  df.iloc[row]</span><span id="a993" class="me mf it nq b gy ob nv l nw nx">for _ in df.iloc[row]['genres'].split('|'):<br/>    set1.add(_)</span><span id="54ba" class="me mf it nq b gy ob nv l nw nx">set1<br/>{'(no genres listed)',<br/> 'Action',<br/> 'Adventure',<br/> 'Animation',<br/> 'Children',<br/> 'Comedy',<br/> 'Crime',<br/> 'Documentary',<br/> 'Drama',<br/> 'Fantasy',<br/> 'Film-Noir',<br/> 'Horror',<br/> 'IMAX',<br/> 'Musical',<br/> 'Mystery',<br/> 'Romance',<br/> 'Sci-Fi',<br/> 'Thriller',<br/> 'War',<br/> 'Western'}</span></pre><p id="e1e7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后我需要一部字典，它会为每个标签关联一个数字，这就是<strong class="kt jd">固定基数编码</strong>:</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="372e" class="me mf it nq b gy nu nv l nw nx">tag_dict = {list(set1)[i]:i for i in [x for x in range(len(set1))]}<br/>tag_dict<br/>\<br/>{'(no genres listed)': 13,  <br/>'Action': 19,  <br/>'Adventure': 17,  <br/>'Animation': 14,  <br/>'Children': 18,  <br/>'Comedy': 2,  <br/>'Crime': 15,  <br/>'Documentary': 7,  <br/>'Drama': 12,  <br/>'Fantasy': 5,  <br/>'Film-Noir': 0,  <br/>'Horror': 8,  <br/>'IMAX': 10,  <br/>'Musical': 16,  <br/>'Mystery': 1,  <br/>'Romance': 3,  <br/>'Sci-Fi': 9,  <br/>'Thriller': 4,  <br/>'War': 6,  <br/>'Western': 11}</span></pre><p id="6599" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我有了一个将每个标签与其编号相关联的字典，我需要用空白来填充数据集。我将创建20列，可以容纳二进制编码数据:</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="f659" class="me mf it nq b gy nu nv l nw nx">#creating empty columns from 0 to 20<br/>df[[x for x in range(20)]] = 0</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi od"><img src="../Images/9a30698d578625e7ddf629672f0acd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOs3lozchbpurFofAV_c7Q.png"/></div></div></figure><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="7872" class="me mf it nq b gy nu nv l nw nx">#fill the zeroes<br/>for row in range(df.shape[0]):<br/>  #print(df.iloc[row]['genres'].split('|'))<br/>  for zero in [tag_dict[x] for x in df.iloc[row]['genres'].split('|')]:<br/>    #print(row, zero)<br/>    #iloc won't change values, I am using at for this purpose<br/>    df.at[row, zero] = 1<br/>df</span></pre><p id="4d6b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过将每个标签除以|，假设<strong class="kt jd">动作|犯罪|惊悚</strong>将变成<strong class="kt jd"> ['动作'，'犯罪'，'惊悚'] </strong>，我将使用<strong class="kt jd"> tag_dict </strong>将每个标签转换成其对应的数字。然后，对于每个数字，我将把数据集中右边的0变成1:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oe"><img src="../Images/4da23e8f64d57307199c9395cd1a2290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0tWBtR7eWVmZQEj_x6i4Q.png"/></div></div></figure><p id="37ec" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了执行PCA，我只需要存储数字数据。我将把电影的标题保存在另一个名为movie_index的列表中，以后我可以用它来制作图表。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="1eed" class="me mf it nq b gy nu nv l nw nx">k = df.copy()<br/>k.pop('genres')<br/>k = k.dropna()<br/>movie_index = k.pop('title')<br/>k</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi of"><img src="../Images/2ecd5d66ec7907d98410a3441b95b7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDMJyVOkkJJYJONQz2j4Xw.png"/></div></div></figure><h2 id="4c42" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated">执行PCA</h2><p id="d244" class="pw-post-body-paragraph kr ks it kt b ku mw kd kw kx mx kg kz la my lc ld le mz lg lh li na lk ll lm im bi translated">现在我只有数字数据，假设我将标签分类数据转换为数字数据，我将所有数据压缩到一个我可以绘制的3D空间中。</p><p id="4ee4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *我将只使用500个样本，9719个样本很长，绘制起来会减慢实验速度:请随意删除此限制并查看结果</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="c6db" class="me mf it nq b gy nu nv l nw nx">from sklearn.decomposition import PCA<br/>import matplotlib.pyplot as plt</span><span id="f84e" class="me mf it nq b gy ob nv l nw nx">pca = PCA(n_components=3)<br/>pca_result = pca.fit_transform(k[0:500])<br/>pca_result<br/>\<br/>array([[-0.73554249, -0.913036 , 0.04851076],<br/> [-0.61063851, 0.57240558, -1.05159588],<br/> [-0.36358865, -0.26951576, 0.50582827],<br/> …,<br/> [-0.33447108, 0.72195369, 0.76125547],<br/> [-0.18515421, -0.32207719, 0.55323268],<br/> [-0.08170257, -0.95603453, 0.50899355]])</span></pre><h2 id="833b" class="me mf it bd mg mh mi dn mj mk ml dp mm la mn mo mp le mq mr ms li mt mu mv iz bi translated">绘制结果图表</h2><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="ebdd" class="me mf it nq b gy nu nv l nw nx">import plotly.express as px<br/>fig = plt.figure(figsize=(14, 8))</span><span id="1360" class="me mf it nq b gy ob nv l nw nx">x = list(pca_result[:,0])<br/>y = list(pca_result[:,1])<br/>z = list(pca_result[:,2])</span><span id="7270" class="me mf it nq b gy ob nv l nw nx">#fig = px.scatter_3d(k, x=x, y=y, z=z, text=k.index[0:500])<br/>fig = px.scatter_3d(k, x=x, y=y, z=z)<br/>fig.show()</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi og"><img src="../Images/8dac0999c207cdd2be18e6737b349b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jM3tgsR9E9sYhVC6gyBqfg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">绘制不带标签的数据集</figcaption></figure></div></div>    
</body>
</html>