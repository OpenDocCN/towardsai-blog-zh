<html>
<head>
<title>Automatic Movie Review System Using Sentimental Analysis For Positive or Negative Reviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用正面或负面评论的情感分析的自动电影评论系统</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/automatic-movie-review-system-using-sentimental-analysis-for-positive-or-negative-review-1667ea3041d4?source=collection_archive---------1-----------------------#2020-05-25">https://pub.towardsai.net/automatic-movie-review-system-using-sentimental-analysis-for-positive-or-negative-review-1667ea3041d4?source=collection_archive---------1-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9f15" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a></h2><div class=""/><div class=""><h2 id="8996" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一篇很好的文章，通过回顾电影来理解情感分析和数据搜集的基础。</h2></div><blockquote class="ko kp kq"><p id="f4c1" class="kr ks kt ku b kv kw ka kx ky kz kd la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在本文中，我们将使用<strong class="ku ja">机器学习对IMDB网站上任何给定电影的评论</strong>进行情感分析，然后决定是否观看该电影。理解<strong class="ku ja"> NLP </strong>以及<strong class="ku ja">数据抓取</strong>的基础知识是一个很好的项目。如果你在机器学习领域工作了相当长的时间，那么很可能你可以跳过这个教程。</p></blockquote><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/b568dd3bd18025d87ee47e43cfec667e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OwNg5FWOHspgMx0VRG4nKQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">基于网页抓取的情感分析</figcaption></figure><p id="0f89" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">我们将使用的工作流程或方法由四个主要部分组成:</p><ul class=""><li id="8448" class="mh mi iq ku b kv kw ky kz me mj mf mk mg ml ln mm mn mo mp bi translated">安装所有依赖项和必需的文件</li><li id="185f" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated">模型开发(朴素贝叶斯)</li><li id="2d6f" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated">搜集对某部电影的评论</li><li id="b26b" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated">预测每条评论的情绪，决定看不看。</li></ul><h2 id="cd09" class="mv mw iq bd mx my mz dn na nb nc dp nd me ne nf ng mf nh ni nj mg nk nl nm iw bi translated">先决条件</h2><p id="e0c4" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">我假设您熟悉python编程语言<strong class="ku ja"><em class="kt"/></strong>，并且您的系统中已经安装了python 3。</p><h2 id="e113" class="mv mw iq bd mx my mz dn na nb nc dp nd me ne nf ng mf nh ni nj mg nk nl nm iw bi translated">安装所需的软件包</h2><p id="bcaa" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">对于给定的包，您可以简单地使用<code class="fe ns nt nu nv b">pip install pakage_name</code>。在开始编码之前需要安装的包有:</p><ul class=""><li id="a899" class="mh mi iq ku b kv kw ky kz me mj mf mk mg ml ln mm mn mo mp bi translated"><strong class="ku ja"> selenium </strong> —用于网页抓取和自动滚动网站。在selenium中，你还需要下载<a class="ae nw" href="https://sites.google.com/a/chromium.org/chromedriver/downloads" rel="noopener ugc nofollow" target="_blank">chomedriver.exe</a>来自动使用chrome。</li><li id="a3ca" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated"><strong class="ku ja"> nltk </strong> —用于执行自然语言处理任务和模型训练。</li><li id="2ef7" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated"><strong class="ku ja"> bs4 </strong> —用于解析Html页面的BeautifulSoup。</li><li id="f071" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated"><strong class="ku ja"> lxml </strong> —它是用来用python处理Html和xml的包。</li><li id="0244" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated"><strong class="ku ja"> urllib </strong> —用于请求网页。</li><li id="c138" class="mh mi iq ku b kv mq ky mr me ms mf mt mg mu ln mm mn mo mp bi translated"><strong class="ku ja"> sklearn(可选)</strong> —用于保存训练好的模型。</li></ul><h1 id="a5e8" class="nx mw iq bd mx ny nz oa na ob oc od nd kf oe kg ng ki of kj nj kl og km nm oh bi translated">让我们开始编码吧</h1><p id="bb71" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">创建用于训练和预测评论的python文件。别担心，我们稍后会在不同的文件中删除这些评论。</p><h2 id="d56f" class="mv mw iq bd mx my mz dn na nb nc dp nd me ne nf ng mf nh ni nj mg nk nl nm iw bi translated">模型开发</h2><p id="df6f" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">首先，我们必须下载所有必要的数据，比如我们的模型将要训练的<strong class="ku ja"><em class="kt">movie _ reviews</em></strong>以及nltk在我们的代码中使用的一些其他数据，比如停用词、punkt。如果nltk需要更多的数据，它会通知您错误。下面几行将下载数据。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="f54c" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">import </strong>nltk<br/>nltk.download(<strong class="nv ja">"punkt"</strong>)<br/>nltk.download(<strong class="nv ja">"movie_reviews"</strong>)<br/>nltk.download(<strong class="nv ja">"stopwords"</strong>)</span></pre><p id="6838" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">现在我们将导入所有需要的包和文件。这里，<strong class="ku ja"> <em class="kt"> movie_reviews </em> </strong>是我们的训练和测试数据，<strong class="ku ja"> <em class="kt"> stopwords </em> </strong>是像<code class="fe ns nt nu nv b">is,the,of</code>这样对训练没有贡献的词。我们用<strong class="ku ja"> <em class="kt">洗牌</em> </strong>洗牌训练和测试数据。<strong class="ku ja"> <em class="kt"> NaiveBayes </em> </strong>是最常用于NLP(自然语言处理)的分类器。<strong class="ku ja"><em class="kt">word _ tokenizer</em></strong>用来把文本分成更小的部分称为记号。</p><p id="3e4e" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">MAIN_scrap_movies_reviews是我们抓取数据的python文件，<strong class="ku ja"><em class="kt">reviews _ extract</em></strong>是执行该任务的函数。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="cc85" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">from </strong>nltk.corpus <strong class="nv ja">import </strong>movie_reviews<br/><strong class="nv ja">from </strong>nltk.corpus <strong class="nv ja">import </strong>stopwords<br/><strong class="nv ja">from </strong>random <strong class="nv ja">import </strong>shuffle<br/><strong class="nv ja">import </strong>string<br/><strong class="nv ja">from </strong>nltk <strong class="nv ja">import </strong>NaiveBayesClassifier<br/><strong class="nv ja">from </strong>nltk <strong class="nv ja">import </strong>classify<br/><strong class="nv ja">from </strong>nltk <strong class="nv ja">import </strong>word_tokenize<br/><strong class="nv ja">from </strong>MAIN_scrap_movies_reviews <strong class="nv ja">import </strong>reviews_extract<br/><strong class="nv ja">from </strong>sklearn.externals <strong class="nv ja">import </strong>joblib</span></pre><p id="69e2" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated"><strong class="ku ja"/></p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="2c2b" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">def </strong>bag_words(words):<br/>    <strong class="nv ja">global </strong>stop_words<br/>    stop_words = stopwords.words(<strong class="nv ja">'english'</strong>)<br/>    clean = []<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>words:<br/>        <strong class="nv ja">if </strong>i <strong class="nv ja">not in </strong>stop_words <strong class="nv ja">and </strong>i <strong class="nv ja">not in </strong>string.punctuation:<br/>            clean.append(i)<br/>    dictionary = dict([word, <strong class="nv ja">True</strong>] <strong class="nv ja">for </strong>word <strong class="nv ja">in </strong>clean)<br/>    <strong class="nv ja">return </strong>dictionary</span></pre><p id="88f0" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">我们已经创建了函数<strong class="ku ja"><em class="kt">training and testing()</em></strong>来训练和检查模型的准确性。有两个空列表用于存储正面和负面评论。然后，我们在movie_reviews列<code class="fe ns nt nu nv b">fileids</code>中迭代，如果它包含<code class="fe ns nt nu nv b">pos</code>，那么该行或评论被存储在正面评论列表中，反之亦然。之后，我们遍历存储在<em class="kt"> pos_reviews </em>中的每个评论，并调用<strong class="ku ja"> <em class="kt"> bag_words </em> </strong>函数，该函数依次给出包含评论词(删除了停用词和标点符号)的字典，并将<code class="fe ns nt nu nv b">pos</code>与其相关联，表示这是正面评论。负面评价也是一样。然后，我们对数据进行洗牌和分割，以进行训练和测试。我们简单地使用了<a class="ae nw" href="https://www.geeksforgeeks.org/naive-bayes-classifiers/" rel="noopener ugc nofollow" target="_blank">朴素贝叶斯分类器</a>进行情感分析。nltk的内置功能使训练和测试变得简单。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cad0a9ed58313f68061644a995802970.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*W8tQVubf5_dXAY7KqKS4aA.gif"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">用nltk训练就像魔术一样</figcaption></figure><p id="18a5" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">这里最后一行用来存储训练好的模型，这样就不需要每次回顾电影的时候都训练模型了。此外，您可以简单地返回分类器，并在预测阶段使用它。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="324f" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">def </strong>TrainingAndTesting():<br/>    pos_review = []<br/>    neg_review = []<br/>    <br/>    <strong class="nv ja">for </strong>fileid <strong class="nv ja">in </strong>movie_reviews.fileids(<strong class="nv ja">'pos'</strong>):<br/>        pos_review.append(movie_reviews.words(fileid))</span><span id="37da" class="mv mw iq nv b gy or on l oo op">    <strong class="nv ja">for </strong>fileid <strong class="nv ja">in </strong>movie_reviews.fileids(<strong class="nv ja">'neg'</strong>):<br/>        neg_review.append(movie_reviews.words(fileid))</span><span id="3b93" class="mv mw iq nv b gy or on l oo op">    pos_set = []<br/>    <strong class="nv ja">for </strong>word<strong class="nv ja"> in </strong>pos_review:<br/>        pos_set.append((bag_words(word),<strong class="nv ja">'pos'</strong>))</span><span id="70e6" class="mv mw iq nv b gy or on l oo op">    neg_set = []<br/>    <strong class="nv ja">for </strong>word <strong class="nv ja">in </strong>neg_review:<br/>        neg_set.append((bag_words(word),<strong class="nv ja">'neg'</strong>))</span><span id="b8d9" class="mv mw iq nv b gy or on l oo op">    shuffle(pos_set)<br/>    shuffle(neg_set)<br/>    test_set = pos_set[:200]+neg_set[:200]<br/>    train_set = pos_set[200:]+neg_set[200:]</span><span id="3399" class="mv mw iq nv b gy or on l oo op">    classifier = NaiveBayesClassifier.train(train_set)<br/>    acc = classify.accuracy(classifier,test_set)<br/>    print(acc)<br/>    joblib.dump(classifier,<strong class="nv ja">'imdb_movies_reviews.pkl'</strong>)</span></pre><p id="b1e3" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">现在，我们将创建另一个文件，从IMDB抓取评论，或者您也可以在同一个文件中定义函数。</p><h2 id="2e4e" class="mv mw iq bd mx my mz dn na nb nc dp nd me ne nf ng mf nh ni nj mg nk nl nm iw bi translated">搜集对某部电影的评论</h2><p id="56a3" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">导入所需的包。所有这些的用途在开始时都有定义。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="b113" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">from </strong>selenium <strong class="nv ja">import </strong>webdriver<br/><strong class="nv ja">import </strong>urllib.request <strong class="nv ja">as </strong>url<br/><strong class="nv ja">import </strong>bs4<br/><strong class="nv ja">import </strong>time</span></pre><p id="2c73" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">在这个函数中，我们将电影名称作为用户的输入，然后使用<code class="fe ns nt nu nv b">urlopen</code>获取特定网页的内容。现在，我们将使用<code class="fe ns nt nu nv b">BeautifulSoup</code>解析内容，并找到页面上第一个电影结果的链接，移动到该链接，然后进入评论部分，单击加载更多评论。这是使用<strong class="ku ja"> <em class="kt">硒</em> </strong>的主要原因，否则我们将坚持只有5或6个预载注释。在我们的例子中，点击特定次数(20次)后，我们将找到每个评论的文本，并将其添加到列表中，然后返回该列表。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="3e15" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">def </strong>reviews_extract():<br/>    movie = input(<strong class="nv ja">'Enter name of movie:'</strong>)<br/>    movie = movie.lower()</span><span id="c7ba" class="mv mw iq nv b gy or on l oo op">    web = url.urlopen(<strong class="nv ja">"https://www.imdb.com/find?ref_=nv_sr_fn&amp;q="</strong>+movie)<br/>    page1 = bs4.BeautifulSoup(web,<strong class="nv ja">'lxml'</strong>)<br/>    b = page1.find(<strong class="nv ja">'td'</strong>,class_=<strong class="nv ja">'result_text'</strong>)<br/>    href = b.a[<strong class="nv ja">'href'</strong>]<br/>    web2 = url.urlopen(<strong class="nv ja">"https://www.imdb.com"</strong>+href)<br/>    page2 = bs4.BeautifulSoup(web2,<strong class="nv ja">'lxml'</strong>)<br/>    c = page2.find(<strong class="nv ja">'div'</strong>,class_=<strong class="nv ja">'user-comments'</strong>)<br/>    temp = []<br/>    <strong class="nv ja">for </strong>a <strong class="nv ja">in </strong>c.find_all(<strong class="nv ja">'a'</strong>,href =<strong class="nv ja">True</strong>):<br/>        g =(a[<strong class="nv ja">'href'</strong>])<br/>        temp.append(g)<br/>    d = temp[-1]<br/>    driver = webdriver.Chrome(<strong class="nv ja">'C:\\Users\\dell\\Desktop\\chromedriver.exe'</strong>)<br/>    driver.get(<strong class="nv ja">"https://www.imdb.com"</strong>+d)<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>range(20):<br/>        <strong class="nv ja">try</strong>:<br/>            loadMoreButton = driver.find_element_by_class_name(<strong class="nv ja">'load-more-data'</strong>)<br/>            loadMoreButton.click()<br/>            time.sleep(1)<br/>        <strong class="nv ja">except </strong>Exception <strong class="nv ja">as </strong>e:<br/>            print(e)<br/>            <strong class="nv ja">break<br/>    </strong>web3 = driver.page_source<br/>    page3 = bs4.BeautifulSoup(web3,<strong class="nv ja">'lxml'</strong>)</span><span id="185d" class="mv mw iq nv b gy or on l oo op">    e = page3.find(<strong class="nv ja">'div'</strong>,class_=<strong class="nv ja">'lister-list'</strong>)</span><span id="9bf6" class="mv mw iq nv b gy or on l oo op">    e1 = e.find_all(<strong class="nv ja">'a'</strong>,class_=<strong class="nv ja">'title'</strong>)</span><span id="59dc" class="mv mw iq nv b gy or on l oo op">    user_reviews = []<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>e1:<br/>        raw = (i.text)<br/>        user_reviews.append(raw.replace(<strong class="nv ja">'\n'</strong>,<strong class="nv ja">''</strong>))<br/>    driver.quit()<br/>    print(user_reviews)<br/>    print(len(user_reviews))<br/>    <strong class="nv ja">return </strong>user_reviews,movie</span></pre><h2 id="cc38" class="mv mw iq bd mx my mz dn na nb nc dp nd me ne nf ng mf nh ni nj mg nk nl nm iw bi translated">预测每个评论的情绪</h2><p id="61c5" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">抓取之后，我们回到之前的python文件。现在，我们将使用已经训练好的模型来预测每个刮掉的评论的情绪。在代码中，首先我们加载了之前保存的模型，并调用上面定义的reviews_extract函数来获取评论。之后，我们处理每个评论，即标记化，删除停用词，并将评论转换为所需的格式。然后，如果<code class="fe ns nt nu nv b">neg</code>增加n的计数，如果<code class="fe ns nt nu nv b">pos</code>增加p，我们预测它的情绪，并计算正面评论的百分比。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="9da7" class="mv mw iq nv b gy om on l oo op"><strong class="nv ja">def </strong>predicting():<br/>    classifier = joblib.load(<strong class="nv ja">'imdb_movies_reviews.pkl'</strong>)<br/>    reviews_film, movie = reviews_extract()<br/>    testing = reviews_film</span><span id="45ee" class="mv mw iq nv b gy or on l oo op">    tokens = []<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>testing:<br/>        tokens.append(word_tokenize(i))</span><span id="698f" class="mv mw iq nv b gy or on l oo op">    set_testing = []<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>tokens:<br/>        set_testing.append(bag_words(i))</span><span id="eddd" class="mv mw iq nv b gy or on l oo op">    final = []<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>set_testing:<br/>        final.append(classifier.classify(i))</span><span id="d7e9" class="mv mw iq nv b gy or on l oo op">    n = 0<br/>    p = 0<br/>    <strong class="nv ja">for </strong>i <strong class="nv ja">in </strong>final:<br/>        <strong class="nv ja">if </strong>i == <strong class="nv ja">'neg'</strong>:<br/>            n+= 1<br/>        <strong class="nv ja">else</strong>:<br/>            p+= 1<br/>    pos_per = (p / len(final)) * 100</span><span id="4fc7" class="mv mw iq nv b gy or on l oo op">    <strong class="nv ja">return </strong>movie,pos_per,len(final)</span></pre><p id="edc1" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">然后，在最后，我们调用所需的函数，如果正面百分比大于60%，我们就向我们的朋友推荐这部电影。</p><pre class="lp lq lr ls gt oi nv oj ok aw ol bi"><span id="883c" class="mv mw iq nv b gy om on l oo op">TrainingAndTesting()<br/>movie,positive_per,total_reviews = predicting()<br/>print(<strong class="nv ja">'The film {} has got {} percent positive reviews'</strong>.format(movie, round(positive_per)))<br/><strong class="nv ja">if </strong>positive_per &gt; 60:<br/>    print(<strong class="nv ja">'overall impression of movie is good  '</strong>)<br/><strong class="nv ja">else</strong>:<br/>    print(<strong class="nv ja">'overall impression of movie is bad '</strong>)</span></pre><h1 id="d0b1" class="nx mw iq bd mx ny nz oa na ob oc od nd kf oe kg ng ki of kj nj kl og km nm oh bi translated">我的结果</h1><p id="070d" class="pw-post-body-paragraph kr ks iq ku b kv nn ka kx ky no kd la me np ld le mf nq lh li mg nr ll lm ln ij bi translated">我能够得到大约78%的模型精度，这是我的结果截图。这里225是被分析的评论的数量。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/f3f93063bf3e1547dd539393ceddb0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*pYbHQ5YAC734LDhwT6xeyw.jpeg"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">获得的结果</figcaption></figure><p id="9da6" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">所描述的项目是为初学者，因此我没有使用先进的技术，如RNN(递归神经网络)。这篇文章的唯一焦点是提供机器学习领域的知识和启动阶段项目。</p><p id="33d4" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">谢谢你的宝贵时间。😊我希望你喜欢这个教程。</p><p id="988b" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">你可以在我的<a class="ae nw" href="https://github.com/PushkaraSharma/Automatic_Movie_Review_NLP" rel="noopener ugc nofollow" target="_blank"><strong class="ku ja">Github repo</strong></a><strong class="ku ja">找到相同的源代码。</strong></p><p id="75da" class="pw-post-body-paragraph kr ks iq ku b kv kw ka kx ky kz kd la me lc ld le mf lg lh li mg lk ll lm ln ij bi translated">查看我的文章<a class="ae nw" href="https://medium.com/analytics-vidhya/visualize-interesting-sorting-algorithms-with-python-bdd64bdd0713" rel="noopener"> <strong class="ku ja"> <em class="kt">用Python可视化有趣的排序算法</em> </strong> </a></p><div class="ot ou gp gr ov ow"><a href="https://medium.com/analytics-vidhya/visualize-interesting-sorting-algorithms-with-python-bdd64bdd0713" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ja gy z fp pb fr fs pc fu fw iz bi translated">用Python可视化有趣的排序算法</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">有各种类型的排序算法，有时很难理解它们…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ly ow"/></div></div></a></div></div></div>    
</body>
</html>