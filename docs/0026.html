<html>
<head>
<title>A Gaussian Approach to the Detection of Anomalous Behavior in Server Computers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检测服务器计算机异常行为的高斯方法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-gaussian-approach-to-detection-of-anomalous-behavior-in-server-computers-c70f7c3c1d94?source=collection_archive---------1-----------------------#2019-03-24">https://pub.towardsai.net/a-gaussian-approach-to-detection-of-anomalous-behavior-in-server-computers-c70f7c3c1d94?source=collection_archive---------1-----------------------#2019-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="eb7c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="b245" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">让我们检测异常点…</h2></div><p id="917a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">异常检测是属于<strong class="kt jd">半监督学习</strong>的机器学习问题的不同变体。它是<strong class="kt jd">半监督的</strong>，因为在异常检测(通常也称为离群点检测)中，模型通常涉及使用验证集标签拟合的参数，而训练过程不涉及训练集标签。此外，测试集标签用于评估模型性能指标，如准确度、精确度、召回率、F1分数和AUROC(ROC曲线下的面积)。</p><p id="8547" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一种常见的异常检测方法是<strong class="kt jd">高斯分布</strong>。在这种方法中，所有特征都被建模为高斯分布，并且给定一个新的数据点，数据点的概率由高斯/正态分布函数给出。如果概率低于特定阈值(根据验证集上模型的性能设置)，则新数据点被认为是异常值或异常值。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/b34e47fc6435e92806d136d8210efc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWvH4mP3wcPvmZlISAYZHA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">均值=和标准差= σ的高斯/正态分布</strong></figcaption></figure><p id="051c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">根据高斯/正态分布:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2188c25a5518f74a045e9b113b0d09fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*BXEVOYlK-gaC98c8GTEgkg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md"> p(x)是x在高斯分布中的概率</strong></figcaption></figure><blockquote class="mf mg mh"><p id="c302" class="kr ks mi kt b ku kv kd kw kx ky kg kz mj lb lc ld mk lf lg lh ml lj lk ll lm im bi translated"><strong class="kt jd">高斯分布异常检测算法:</strong></p></blockquote><p id="2800" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们考虑有<em class="mi"> m </em>个数据点(实例),每个数据点具有<em class="mi"> n </em>个选定特征。</p><ul class=""><li id="4872" class="mm mn it kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">每个特征的平均参数(<em class="mi"> j </em> = 1到<em class="mi"> n </em>)是拟合的。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mv"><img src="../Images/78e316a7a19034466d3852854c308668.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*bdtD7VmYfxlpkvU6TKktiw.png"/></div></div></figure><ul class=""><li id="b995" class="mm mn it kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">每个特征的方差参数(<em class="mi"> j </em> = 1到<em class="mi"> n </em>)是拟合的。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/b90c2917420e81a538b8c0d9d1c11182.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*4SfUAeBVf0Dt9EXzBK3XBg.png"/></div></figure><ul class=""><li id="0133" class="mm mn it kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">给定一个新的数据点，<em class="mi"> x </em> = <em class="mi"> {x_1，x_2，…，x_j} </em>，<em class="mi"> p(x) </em>由下式给出:</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/577e802ce552d543209626a7d44d9b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*OiXX23ImKHa3PIrNmOv3Yg.png"/></div></figure><p id="88e2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">或者，</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi my"><img src="../Images/9b82a819a11e4256d9950be1fa9ce22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWhWNlOREtWecmTw3-OjSQ.png"/></div></figure><ul class=""><li id="dc66" class="mm mn it kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">现在，选择阈值参数<strong class="kt jd"> ε </strong>，使得，</li></ul><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="ba37" class="ne nf it na b gy ng nh l ni nj">if p(x) &lt; <strong class="na jd">ε:<br/>    </strong># x is an ANOMALY or OUTLIER !!!!<br/>else:<br/>    # x is NOT an ANOMALY or OUTLIER !!!!</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><blockquote class="mf mg mh"><p id="939a" class="kr ks mi kt b ku kv kd kw kx ky kg kz mj lb lc ld mk lf lg lh ml lj lk ll lm im bi translated"><strong class="kt jd">在Python中应用高斯分布模型对服务器计算机数据集进行异常检测</strong></p></blockquote><p id="9a38" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">问题陈述</strong>:<em class="mi">检测服务器计算机</em>的异常行为</p><p id="0e9d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该数据集可在GitHub link上获得，</p><div class="nr ns gp gr nt nu"><a href="https://github.com/navoneel1092283/Server_Computer_Dataset.git" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd jd gy z fp nz fr fs oa fu fw jc bi translated">navoneel 1092283/服务器计算机数据集</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">以吞吐量(mb/s)和延迟(ms)作为异常行为检测特征的计算机服务器数据集…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi lx nu"/></div></div></a></div><p id="aa47" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> I. </strong>数据读取(数据集存在于。mat格式)</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="6a50" class="ne nf it na b gy ng nh l ni nj">import scipy.io<br/>data = scipy.io.loadmat('data.mat')</span><span id="e37d" class="ne nf it na b gy oj nh l ni nj">X = data['Xval'] # <strong class="na jd">features<br/></strong>y = data['yval'] # <strong class="na jd">class</strong> <strong class="na jd">labels (0-&gt;Non-Anomalous, 1-&gt;Anomalous)</strong></span></pre><p id="8d68" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">二世。</strong>数据可视化(以散点图的形式)</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="dfeb" class="ne nf it na b gy ng nh l ni nj">import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="e8e2" class="ne nf it na b gy oj nh l ni nj">plt.scatter(X.T[0], X.T[1])<br/>plt.xlabel('Latency (ms)')<br/>plt.ylabel('Throughput (mb/s)')<br/>plt.show()</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ed1b036fc8631115b84bf8ee7c007128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*H9TA5r3_o-4tGWcq5vjnSg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">延迟和吞吐量这两个特性的散点图</strong></figcaption></figure><p id="daab" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">三世。</strong>用于异常或异常值检测的高斯分布算法的实现</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="cdca" class="ne nf it na b gy ng nh l ni nj">import numpy as np<br/>from math import *</span><span id="5238" class="ne nf it na b gy oj nh l ni nj">def <strong class="na jd">gaussian</strong>(X, x, epsilon):<br/>    # X represents the Training Set Features <br/>    # x represents the set of new data-points (Validation/Test Set)<br/>    <br/>    mean = np.zeros(X.shape[1])<br/>    std = np.zeros(X.shape[1])<br/>    Xt = X.T<br/>    xt = x.T<br/>    p = np.zeros(x.shape[0]) # vector of output predictions </span><span id="c49f" class="ne nf it na b gy oj nh l ni nj">for i in range(0, X.shape[1]):<br/>        mean[i] = Xt[i].mean()<br/>        std[i] = Xt[i].std()</span><span id="3f5a" class="ne nf it na b gy oj nh l ni nj">for i in range(0, x.shape[0]):<br/>        prob = 1<br/>        for j in range(0, X.shape[1]):<br/>            prob = prob * (1/sqrt(2*3.14)) * exp(-pow((xt[j][i] <br/>                           - mean[j]),2)/2 * std[j] * std[j])<br/>        <br/>        if prob &lt; epsilon:<br/>            p[i] = 1<br/>    <br/>    return p</span></pre><p id="f4f6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">四。</strong>训练集、验证集和测试集的准备</p><p id="db2e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里，已经有关于训练集、验证集和测试集的准备的某些常规规则:</p><ul class=""><li id="698f" class="mm mn it kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">训练集应该有60%(大约。)的实例数。</li><li id="1797" class="mm mn it kt b ku ol kx om la on le oo li op lm mr ms mt mu bi translated">训练集中的所有实例都应该是非异常的(根据标签)。</li><li id="8096" class="mm mn it kt b ku ol kx om la on le oo li op lm mr ms mt mu bi translated">验证集应该有大约20%的实例包含异常和非异常实例(根据标签)。</li><li id="ce3e" class="mm mn it kt b ku ol kx om la on le oo li op lm mr ms mt mu bi translated">包含剩余实例的测试集也应该有异常和非异常的例子(根据标签)。</li></ul><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="1b41" class="ne nf it na b gy ng nh l ni nj"># Inspecting the distribution of class labels in the dataset...<br/>unique, counts = np.unique(y, return_counts=True)<br/>print(dict(zip(unique, counts)))</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ead24bba5ac38f6dbbaa2306e80ebbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*K_w7737LFlOW5yYzGa7geQ.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">有<strong class="bd md"> 298个非异常</strong>和<strong class="bd md"> 9个异常</strong>的例子</figcaption></figure><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="24d1" class="ne nf it na b gy ng nh l ni nj">itemindex = np.where(y==1) # storing indices of anomalous examples</span><span id="5f76" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Training Set Preparation</strong><br/>training_set = np.ones((int(0.6*X.shape[0]),X.shape[1]))<br/>y_train = np.ones(int(0.6*X.shape[0]))<br/>count = 0<br/>i = 0<br/>while(count &lt; int(0.6*X.shape[0])):<br/>    if i not in itemindex[0]: <br/>        training_set[count] = X[i]<br/>        y_train[count] = y[i]<br/>        count = count + 1<br/>    i = i + 1</span><span id="a245" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Validation Set Preparation</strong><br/>validation_set = np.ones((int(0.2*X.shape[0]+1),X.shape[1]))<br/>y_validation = np.ones(int(0.2*X.shape[0]+1))<br/>count = 0<br/>    <br/>while(count &lt;= int(0.2*X.shape[0]) - 5):<br/>    validation_set[count] = X[i]<br/>    y_validation[count] = y[i]<br/>    count = count + 1<br/>    i = i + 1<br/>    <br/>for j in range(1,6):<br/>    validation_set[-j] = X[itemindex[0][j-1]]<br/>    y_validation[-j] = y[itemindex[0][j-1]]</span><span id="b597" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Test Set Preparation</strong><br/>test_set = np.ones((int(0.2*X.shape[0]),X.shape[1]))<br/>y_test = np.ones(int(0.2*X.shape[0]))<br/>count = 0</span><span id="d5e4" class="ne nf it na b gy oj nh l ni nj">while(count &lt; int(0.2*X.shape[0]) - 4):<br/>    if i not in itemindex[0]: <br/>        test_set[count] = X[i]<br/>        y_test[count] = y[i]<br/>        count = count + 1<br/>    i = i + 1</span><span id="9adf" class="ne nf it na b gy oj nh l ni nj">for j in range(6,10):<br/>    test_set[count] = X[itemindex[0][j-1]]<br/>    y_test[count] = y[itemindex[0][j-1]]<br/>    count = count + 1</span></pre><p id="bf24" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> V. </strong>用调整的阈值参数训练模型，<strong class="kt jd"> ε </strong> = 0.0001(发现在验证集上给出最佳性能)</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="7aae" class="ne nf it na b gy ng nh l ni nj">predictions_validation = gaussian(training_set, validation_set<br/>                                  , 0.0001)</span></pre><p id="3b8d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">六。</strong>验证集上的性能分析</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="e0db" class="ne nf it na b gy ng nh l ni nj"># <strong class="na jd">Accuracy Calculation...</strong><br/>k = 0<br/>for i in range(0, y_validation.shape[0]):<br/>    if predictions_validation[i] == y_validation[i]:<br/>        k = k + 1<br/>accuracy = k/y_validation.shape[0]<br/>print("Validation Accuracy: ", accuracy)</span><span id="5cf4" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Precision Calculation...</strong><br/>tp = fp = 0<br/># tp -&gt; True Positive, fp -&gt; False Positive<br/>for i in range(0, predictions_validation.shape[0]):<br/>    if predictions_validation[i] == y_validation[i] == 0:<br/>        tp = tp + 1<br/>    elif predictions_validation[i] == 0 and y_validation[i] == 1:<br/>        fp = fp + 1<br/>precision = tp/(tp + fp)<br/>print("Precision on the Validation Set: ", precision)</span><span id="5b30" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Recall Calculation...</strong><br/>fn = 0<br/>fn = 0<br/># fn -&gt; False Negatives<br/>for i in range(0, predictions_validation.shape[0]):<br/>    if predictions_validation[i] == 1 and y_validation[i] == 0:<br/>        fn = fn + 1<br/>recall = tp/(tp + fn)<br/>print("Recall on the Validation Set: ", recall)</span><span id="84f9" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">F1-Score Calculation...</strong><br/>f1_score = (2 * precision * recall)/(precision + recall)<br/>print("F1-Score on the Validation Set: ", f1_score)</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi or"><img src="../Images/86aa157e553c788f9d07f8006d1f7396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*mhWd9Vz7pURfUqIDKJCpdg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">验证集上的性能</strong></figcaption></figure><p id="3d87" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">七。</strong>验证集上的散点图性能可视化</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="9ce1" class="ne nf it na b gy ng nh l ni nj"># <strong class="na jd">SCATTER PLOT WITH DATA-POINT HAVING ACTUAL LABELS<br/></strong>itemindex = np.where(y_validation==1)<br/>validation_non_anomalous = np.zeros((y_validation.shape[0] <br/>                           - itemindex[0].shape[0]<br/>                           , validation_set.shape[1]))<br/>count = 0</span><span id="5706" class="ne nf it na b gy oj nh l ni nj">for i in range(0, validation_set.shape[0]):<br/>    if i not in itemindex[0]:<br/>        validation_non_anomalous[count] = validation_set[i]<br/>        count = count + 1<br/>    i = i + 1</span><span id="6c59" class="ne nf it na b gy oj nh l ni nj">validation_anomalous = np.zeros((itemindex[0].shape[0]<br/>                       , validation_set.shape[1]))<br/>count = 0</span><span id="2f2e" class="ne nf it na b gy oj nh l ni nj">for i in itemindex[0]:<br/>    validation_anomalous[count] = validation_set[i]<br/>    count = count + 1</span><span id="4ad9" class="ne nf it na b gy oj nh l ni nj">plt.scatter(validation_non_anomalous.T[0], validation_non_anomalous.T[1], c = "green", label="Non-Anomalous")<br/>plt.scatter(validation_anomalous.T[0], validation_anomalous.T[1], c = "red", label="Anomalous")<br/>plt.xlabel('Latency (ms)')<br/>plt.ylabel('Throughput (mb/s)')<br/>plt.legend()<br/>plt.show()</span><span id="990e" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">SCATTER PLOT WITH DATA-POINT HAVING LABELS GIVEN BY THE MODEL</strong><br/>itemindex = np.where(predictions_validation==1)<br/>validation_predicted_non_anomalous = np.zeros((y_validation.shape[0]<br/>                                     - itemindex[0].shape[0],<br/>                                     validation_set.shape[1]))<br/>count = 0</span><span id="d6fc" class="ne nf it na b gy oj nh l ni nj">for i in range(0, validation_set.shape[0]):<br/>    if i not in itemindex[0]:<br/>        validation_predicted_non_anomalous[count]=validation_set[i]<br/>        count = count + 1<br/>    i = i + 1</span><span id="2a57" class="ne nf it na b gy oj nh l ni nj">validation_predicted_anomalous = np.zeros((itemindex[0].shape[0]<br/>                                 , validation_set.shape[1]))<br/>count = 0</span><span id="5c90" class="ne nf it na b gy oj nh l ni nj">for i in itemindex[0]:<br/>    validation_predicted_anomalous[count] = validation_set[i]<br/>    count = count + 1</span><span id="7ed4" class="ne nf it na b gy oj nh l ni nj">plt.scatter(validation_predicted_non_anomalous.T[0], validation_predicted_non_anomalous.T[1], c = "green", label="Non-Anomalous")<br/>plt.scatter(validation_predicted_anomalous.T[0], validation_predicted_anomalous.T[1], c = "red", label="Anomalous")<br/>plt.xlabel('Latency (ms)')<br/>plt.ylabel('Throughput (mb/s)')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi os"><img src="../Images/8c9a1843f42c65a427a4b29de404ab14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yD7Diw6ehkegsczO6dJ4tQ.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">含实际标签的散点图与含验证集预测标签的散点图</strong></figcaption></figure><p id="e9d8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">八。</strong>测试集上的性能分析</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="0cb5" class="ne nf it na b gy ng nh l ni nj">predictions_test = gaussian(training_set, test_set, 0.0001)</span><span id="65d8" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Accuracy Calculation...</strong><br/>k = 0<br/>for i in range(0, y_test.shape[0]):<br/>    if predictions_test[i] == y_test[i]:<br/>        k = k + 1<br/>accuracy = k/y_test.shape[0]<br/>print("Test Accuracy: ", accuracy)</span><span id="d5ca" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Precision Calculation...</strong><br/>tp = fp = 0<br/># tp -&gt; True Positive, fp -&gt; False Positive<br/>for i in range(0, predictions_test.shape[0]):<br/>    if predictions_test[i] == y_test[i] == 0:<br/>        tp = tp + 1<br/>    elif predictions_test[i] == 0 and y_test[i] == 1:<br/>        fp = fp + 1<br/>precision = tp/(tp + fp)<br/>print("Precision on the Test Set: ", precision)</span><span id="0ef3" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">Recall Calculation...</strong><br/>fn = 0<br/>fn = 0<br/># fn -&gt; False Negatives<br/>for i in range(0, predictions_test.shape[0]):<br/>    if predictions_test[i] == 1 and y_test[i] == 0:<br/>        fn = fn + 1<br/>recall = tp/(tp + fn)<br/>print("Recall on the Test Set: ", recall)</span><span id="79c3" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">F1-Score Calculation...</strong><br/>f1_score = (2 * precision * recall)/(precision + recall)<br/>print("F1-Score on the Test Set: ", f1_score)</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b3585f5948cb72720145eb5702359287.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*2dTJ6Ct2hW_GOwep-0MclQ.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">测试集上的性能</strong></figcaption></figure><p id="7d31" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">九。</strong>散点图在测试集上的性能可视化</p><pre class="lo lp lq lr gt mz na nb nc aw nd bi"><span id="db1b" class="ne nf it na b gy ng nh l ni nj"># <strong class="na jd">SCATTER PLOT WITH DATA-POINT HAVING ACTUAL LABELS<br/></strong>itemindex = np.where(y_test==1)<br/>test_non_anomalous = np.zeros((y_test.shape[0] <br/>                           - itemindex[0].shape[0]<br/>                           , test_set.shape[1]))<br/>count = 0</span><span id="f452" class="ne nf it na b gy oj nh l ni nj">for i in range(0, test_set.shape[0]):<br/>    if i not in itemindex[0]:<br/>        test_non_anomalous[count] = test_set[i]<br/>        count = count + 1<br/>    i = i + 1</span><span id="0eec" class="ne nf it na b gy oj nh l ni nj">test_anomalous = np.zeros((itemindex[0].shape[0]<br/>                       , test_set.shape[1]))<br/>count = 0</span><span id="f7b0" class="ne nf it na b gy oj nh l ni nj">for i in itemindex[0]:<br/>    test_anomalous[count] = test_set[i]<br/>    count = count + 1</span><span id="5d8a" class="ne nf it na b gy oj nh l ni nj">plt.scatter(test_non_anomalous.T[0], test_non_anomalous.T[1], <br/>            c = "green", label="Non-Anomalous")<br/>plt.scatter(test_anomalous.T[0], test_anomalous.T[1], c = "red"<br/>            , label="Anomalous")<br/>plt.xlabel('Latency (ms)')<br/>plt.ylabel('Throughput (mb/s)')<br/>plt.legend()<br/>plt.show()</span><span id="eb61" class="ne nf it na b gy oj nh l ni nj"># <strong class="na jd">SCATTER PLOT WITH DATA-POINT HAVING LABELS GIVEN BY THE MODEL</strong><br/>itemindex = np.where(predictions_test==1)<br/>test_predicted_non_anomalous = np.zeros((y_test.shape[0]<br/>                                         - itemindex[0].shape[0],<br/>                                         test_set.shape[1]))<br/>count = 0</span><span id="f408" class="ne nf it na b gy oj nh l ni nj">for i in range(0, test_set.shape[0]):<br/>    if i not in itemindex[0]:<br/>        test_predicted_non_anomalous[count]=test_set[i]<br/>        count = count + 1<br/>    i = i + 1</span><span id="472e" class="ne nf it na b gy oj nh l ni nj">test_predicted_anomalous = np.zeros((itemindex[0].shape[0]<br/>                                 , test_set.shape[1]))<br/>count = 0</span><span id="ff0b" class="ne nf it na b gy oj nh l ni nj">for i in itemindex[0]:<br/>    test_predicted_anomalous[count] = test_set[i]<br/>    count = count + 1</span><span id="dac9" class="ne nf it na b gy oj nh l ni nj">plt.scatter(test_predicted_non_anomalous.T[0]<br/>            , test_predicted_non_anomalous.T[1], c = "green"<br/>            , label="Non-Anomalous")<br/>plt.scatter(test_predicted_anomalous.T[0]<br/>            , test_predicted_anomalous.T[1], c = "red"<br/>            , label="Anomalous")<br/>plt.xlabel('Latency (ms)')<br/>plt.ylabel('Throughput (mb/s)')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ou"><img src="../Images/793c601acb9ec80144dd05661387036a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4DMiGzazf5sUvomEeriEA.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">测试集的实际标签散点图与预测标签散点图【完全相同】</strong></figcaption></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="c77a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，高斯分布算法正确地识别测试集中的所有异常值或异常，而不会错误地将非异常实例预测为异常。</p><p id="e0ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">还有许多其他高级异常检测模型，如<a class="ae ov" href="https://en.wikipedia.org/wiki/Bayesian_Network" rel="noopener ugc nofollow" target="_blank">贝叶斯网络</a>、<a class="ae ov" href="https://en.wikipedia.org/wiki/Hidden_Markov_model" rel="noopener ugc nofollow" target="_blank">隐马尔可夫模型</a> (HMMs)、基于<a class="ae ov" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">聚类分析</a>的异常检测等。我将在接下来的文章中介绍这些方法。</p></div></div>    
</body>
</html>