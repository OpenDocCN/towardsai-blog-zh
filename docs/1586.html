<html>
<head>
<title>Portfolio Management using Python — Portfolio Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行投资组合管理——投资组合优化</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/portfolio-management-using-python-portfolio-optimization-8a90dd2a21d?source=collection_archive---------1-----------------------#2021-02-27">https://pub.towardsai.net/portfolio-management-using-python-portfolio-optimization-8a90dd2a21d?source=collection_archive---------1-----------------------#2021-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="348c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-analysis" rel="noopener ugc nofollow" target="_blank">数据分析</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="94bb" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">了解投资组合优化并通过Python语言实现它的指南。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1125ade23b93c482dbcb53ae339488ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fE53grU7h2Hy6kxh"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">斯科特·格雷厄姆摄(<a class="ae le" href="https://unsplash.com/photos/5fNmWej4tAA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="3c26" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">什么是投资组合优化？</h1><p id="2683" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">投资组合优化是从所有投资组合中选择最佳投资组合的过程。</p><h1 id="9cf4" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">投资组合优化是怎么做的？</h1><p id="8ec7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">天真的方法是选择一组随机分配，并找出哪一个具有最好的夏普比率。这被称为蒙特卡罗模拟，其中随机地给投资组合中的每种证券分配一个权重，然后计算平均每日回报和每日回报的标准差。这有助于计算随机选择的分配的夏普比率。</p><p id="06bd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">要了解更多夏普比率，请查看我以前的文章:</p><div class="my mz gp gr na nb"><a href="https://jayashree8.medium.com/portfolio-management-using-python-part-1-portfolio-allocation-df0fe9147ab" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ja gy z fp ng fr fs nh fu fw iz bi translated">使用Python的项目组合管理:第1部分——项目组合分配</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">了解投资组合分配并通过Python语言实现它的指南。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">jayashree8.medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ky nb"/></div></div></a></div><p id="5771" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">但天真的方法是花时间，所以使用优化算法，工作在极小值的概念。夏普比率越高，风险调整后的回报越高，投资组合选择越好。因此直觉是最大化夏普比率，这意味着优化器应该最小化负夏普比率。优化算法将根据夏普比率为投资组合分配最佳权重。</p><h1 id="1edd" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">如何用Python实现？</h1><p id="c69c" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja"> →导入包</strong></p><p id="f480" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">像pandas、numpy和matplotlib这样的基础包都是导入的。导入quandl包是为了获取数据。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="8378" class="nv lg iq nr b gy nw nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; import</strong> numpy <strong class="nr ja">as</strong> np<br/><strong class="nr ja">&gt;&gt;&gt; import</strong> pandas <strong class="nr ja">as</strong> pd<br/><strong class="nr ja">&gt;&gt;&gt; import</strong> matplotlib.pyplot <strong class="nr ja">as</strong> plt<br/><strong class="nr ja">&gt;&gt;&gt; import</strong> quandl<br/><strong class="nr ja">&gt;&gt;&gt; %</strong>matplotlib inline</span></pre><p id="1079" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →数据</strong></p><p id="ab07" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">开始和结束日期已确定，在此期间将提取和处理数据。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="ec68" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; start <strong class="nr ja">=</strong> pd.to_datetime('2014-01-01')<br/>&gt;&gt;&gt; end <strong class="nr ja">=</strong> pd.to_datetime('2016-01-01')</span></pre><p id="7162" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">然后提取了脸书、苹果和Twitter三家公司的数据。由于将对第11列进行分析，因此将获得调整为关闭的第11列。然后，这3只股票被组合成一个单一的数据框架。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="8226" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; fb <strong class="nr ja">=</strong> quandl.get('WIKI/FB.11',start_date<strong class="nr ja">=</strong>start, end_date<strong class="nr ja">=</strong>end)<br/>&gt;&gt;&gt; twtr <strong class="nr ja">=</strong> quandl.get('WIKI/TWTR.11',start_date<strong class="nr ja">=</strong>start, end_date<strong class="nr ja">=</strong>end)<br/>&gt;&gt;&gt; aapl <strong class="nr ja">=</strong> quandl.get('WIKI/AAPL.11',start_date<strong class="nr ja">=</strong>start, end_date<strong class="nr ja">=</strong>end)</span><span id="9173" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; df <strong class="nr ja">=</strong> pd.concat([fb,twtr,aapl],axis<strong class="nr ja">=</strong>1)<br/>&gt;&gt;&gt; df.columns <strong class="nr ja">=</strong> ['Facebook','Twitter','Apple']</span><span id="3ce6" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; df.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ce1ba79dfcd620e1198038b5e5727155.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*cSDY_hO84ocPpq7rq8lWOg.png"/></div></figure><p id="5507" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →统计</strong></p><p id="3b1d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">1)平均每日回报</p><p id="a138" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">使用百分比变化函数，可以找到股票的平均日收益率。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="b75a" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; df.pct_change(1).mean()</span><span id="2390" class="nv lg iq nr b gy oa nx l ny nz">Facebook    0.001480<br/>Twitter    -0.001520<br/>Apple       0.000762<br/>dtype: float64</span></pre><p id="0823" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">2)股票之间的相关性</p><p id="6173" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">利用平均日收益率，可以确定股票之间的相关性。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="2dc2" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; df.pct_change(1).corr()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/62c4bdb5fc4cce4c5ef14e1e26ad6272.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*p5fJXNp4BmCfmmvwYejxnA.png"/></div></figure><p id="6d8e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">3)算术回报</p><p id="abc1" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">百分比变化法给出了算术回报。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="9bfd" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; arith_returns <strong class="nr ja">=</strong> df.pct_change(1)<br/>&gt;&gt;&gt; arith_returns.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ae8ac5f5a8ed8438721dec36321a0080.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*ABuZTqNS58J3PrtAorISMQ.png"/></div></figure><p id="37f1" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">4)对数收益</p><p id="8545" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">对数函数给出对数回报。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="03e8" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; log_returns <strong class="nr ja">=</strong> np.log(df<strong class="nr ja">/</strong>df.shift(1))<br/>&gt;&gt;&gt; log_returns.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/524097e6fabc9b8f28d72fe76e48022b.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*B3G-Km0wNvdvOdOa1CbUgg.png"/></div></div></figure><blockquote class="of og oh"><p id="5094" class="lx ly oi lz b ma mt ka mc md mu kd mf oj mv mi mj ok mw mm mn ol mx mq mr ms ij bi translated">要了解算术回报和对数回报之间的区别以及为什么使用对数回报，请查看下面的文章:</p></blockquote><div class="my mz gp gr na nb"><a href="https://chandlerfang.com/2017/01/09/arithmetic-vs-logarithmic-rates-of-return/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ja gy z fp ng fr fs nh fu fw iz bi translated">算术回报率与对数回报率</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">假设你持有一支从100美元涨到105美元的股票。通常，这被报道为5%的回报。…的公式</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">chandlerfang.com</p></div></div><div class="nk l"><div class="om l nm nn no nk np ky nb"/></div></div></a></div><p id="c87a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">5)协方差</p><p id="9d14" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">协方差函数给出协方差。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="1a5e" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; log_returns.cov()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2ee1809c407d538c52592d15972fccf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*-k1nw9IZQ2I_jEnXD09jpQ.png"/></div></figure><h1 id="0b11" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">优化方法——随机化</h1><p id="2962" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja"> →给股票分配随机权重</strong></p><p id="8e9e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">权重被随机分配给股票，并确保它们的总和为1。为了确保它们加起来等于1，通过除以权重之和来重新平衡权重。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="1995" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; print('The stocks are: ',df.columns)<br/>&gt;&gt;&gt; np.random.seed(200)<br/>&gt;&gt;&gt; weights <strong class="nr ja">=</strong> np.array(np.random.random(3))<br/>&gt;&gt;&gt; weights <strong class="nr ja">=</strong> weights<strong class="nr ja">/</strong>np.sum(weights)<br/>&gt;&gt;&gt; print('Random weights: ',weights)</span><span id="f3a3" class="nv lg iq nr b gy oa nx l ny nz">The stocks are:  Index(['Facebook', 'Twitter', 'Apple'], dtype='object')<br/>Random weights:  [0.53580931 0.12809422 0.33609646]</span></pre><p id="def8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →寻找预期收益</strong></p><p id="317e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">预期收益是以对数的形式给出的。回报乘以权重，然后乘以工作日数，即252。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="ec97" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; expected_return <strong class="nr ja">=</strong> np.sum((log_returns.mean()<strong class="nr ja">*</strong> weights) <strong class="nr ja">*</strong> 252)<br/>&gt;&gt;&gt; expected_return</span><span id="9cce" class="nv lg iq nr b gy oa nx l ny nz">0.16004629405548906</span></pre><p id="32b9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →求期望方差</strong></p><p id="7dc5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">预期差异表示波动性。将252天的协方差乘以权重，然后与权重进行点积。然后最后求平方根。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="c6a9" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; expected_vol <strong class="nr ja">=</strong> np.sqrt(np.dot(weights.T,np.dot(log_returns.cov()<strong class="nr ja">*</strong>252,weights)))<br/>&gt;&gt;&gt; expected_vol</span><span id="17e2" class="nv lg iq nr b gy oa nx l ny nz">0.24233721586475374</span></pre><p id="bd8a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →寻找夏普比率</strong></p><p id="33e9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">夏普比率是预期收益和预期波动性的比值。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="7a1d" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; sharpe_r <strong class="nr ja">=</strong> expected_return<strong class="nr ja">/</strong>expected_vol<br/>&gt;&gt;&gt; sharpe_r</span><span id="17c3" class="nv lg iq nr b gy oa nx l ny nz">0.6604280464491656</span></pre><p id="60f8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">分配随机权重来寻找夏普比率的整个过程只进行了一次。但理想情况下，我们需要用不同的权重组合多次重复这个过程，以找到最佳分配。因此，整个过程使用“for”循环运行多次。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="0943" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; np.random.seed(200)</span><span id="2820" class="nv lg iq nr b gy oa nx l ny nz"><em class="oi"># Initalization of variables<br/></em>&gt;&gt;&gt; portfolio_number <strong class="nr ja">=</strong> 7000<br/>&gt;&gt;&gt; weights_total <strong class="nr ja">=</strong> np.zeros((portfolio_number,len(df.columns)))<br/>&gt;&gt;&gt; returns <strong class="nr ja">=</strong> np.zeros(portfolio_number)<br/>&gt;&gt;&gt; volatility <strong class="nr ja">=</strong> np.zeros(portfolio_number)<br/>&gt;&gt;&gt; sharpe <strong class="nr ja">=</strong> np.zeros(portfolio_number)</span><span id="041d" class="nv lg iq nr b gy oa nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; for</strong> i <strong class="nr ja">in</strong> range(portfolio_number):<br/>        <em class="oi"># Random weights<br/>        </em>weights <strong class="nr ja">=</strong> np.array(np.random.random(3))<br/>        weights <strong class="nr ja">=</strong> weights<strong class="nr ja">/</strong>np.sum(weights)<br/>        <em class="oi"># Append weight<br/>        </em>weights_total[i,:] <strong class="nr ja">=</strong> weights</span><span id="10bd" class="nv lg iq nr b gy oa nx l ny nz"><em class="oi">        # Expected return<br/>        </em>returns[i] <strong class="nr ja">=</strong> np.sum((log_returns.mean()<strong class="nr ja">*</strong> weights) <strong class="nr ja">*</strong> 252)</span><span id="611f" class="nv lg iq nr b gy oa nx l ny nz"><em class="oi">        # Expected volume<br/>        </em>volatility[i] <strong class="nr ja">=</strong> np.sqrt(np.dot(weights.T,<br/>        np.dot(log_returns.cov()<strong class="nr ja">*</strong>252,weights)))</span><span id="9ce6" class="nv lg iq nr b gy oa nx l ny nz"><em class="oi">        # Sharpe ratio<br/>        </em>sharpe[i] <strong class="nr ja">=</strong> returns[i]<strong class="nr ja">/</strong>volatility[i]</span></pre><p id="e35a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">夏普比率数组中的最大值与其索引一起被找到。夏普比率的最大值表示分配的最佳组合。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="f027" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; max_sharpe <strong class="nr ja">=</strong> sharpe.max()<br/>&gt;&gt;&gt; max_sharpe<br/>1.091492698172807</span><span id="e85f" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; max_sharpe_index <strong class="nr ja">=</strong> sharpe.argmax()<br/>&gt;&gt;&gt; max_sharpe_index<br/>343</span></pre><p id="bd8c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">权重、回报和波动性是在夏普比率最大的指数上找到的。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="5e92" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; max_sharpe_weights <strong class="nr ja">=</strong> weights_total[343,:]<br/>&gt;&gt;&gt; max_sharpe_weights<br/>array([6.71707148e-01, 2.83931652e-04, 3.28008920e-01])</span><span id="c98b" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; max_sharpe_return <strong class="nr ja">=</strong> returns[max_sharpe_index]<br/>&gt;&gt;&gt; max_sharpe_return<br/>0.2714466221609141</span><span id="56ec" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; max_sharpe_vol <strong class="nr ja">=</strong> volatility[max_sharpe_index]<br/>&gt;&gt;&gt; max_sharpe_vol<br/>0.24869302617903377</span></pre><p id="72b1" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →情节</strong></p><p id="1068" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">根据得出的夏普比率绘制回报率与波动率的关系图，得出子弹形图。与此同时，夏普比率最高的点标有一个红点。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="15bd" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; plt.figure(figsize<strong class="nr ja">=</strong>(12,8))<br/>&gt;&gt;&gt; plt.scatter(volatility,returns,c<strong class="nr ja">=</strong>sharpe)<br/>&gt;&gt;&gt; plt.colorbar(label<strong class="nr ja">=</strong>'Sharpe Ratio')<br/>&gt;&gt;&gt; plt.xlabel('Volatility')<br/>&gt;&gt;&gt; plt.ylabel('Return')</span><span id="e2b9" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; plt.scatter(max_sharpe_vol,max_sharpe_return,c<strong class="nr ja">=</strong>'red',s<strong class="nr ja">=</strong>50)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/c78ede638c7a2e9bb545bf2e85c64a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McTrxar7K43pC23oFB4Emw.png"/></div></div></figure><h1 id="cb45" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">优化方法—数学</h1><p id="11b1" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">定义了一个函数，它接受权重并返回回报、波动率和夏普比率。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="a3ba" class="nv lg iq nr b gy nw nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; def</strong> stats(weights):<br/>        weights <strong class="nr ja">=</strong> np.array(weights)<br/>        expected_return <strong class="nr ja">=</strong> np.sum((log_returns.mean()<strong class="nr ja">*</strong> <br/>        weights) <strong class="nr ja">*</strong> 252)<br/>        expected_vol <strong class="nr ja">= </strong>np.sqrt(np.dot(weights.T,<br/>        np.dot(log_returns.cov()<strong class="nr ja">*</strong>252,weights)))<br/>        sharpe_r <strong class="nr ja">=</strong> expected_return<strong class="nr ja">/</strong>expected_vol<br/>        <strong class="nr ja">return</strong> np.array([expected_return,expected_vol,sharpe_r])</span></pre><p id="921d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">python SciPy模块将用于创建数学优化函数。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="0bd9" class="nv lg iq nr b gy nw nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; from</strong> scipy.optimize <strong class="nr ja">import</strong> minimize</span></pre><p id="5b27" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">优化思想是最小化负夏普比率。因此创建了一个函数，该函数否定了使用上面创建的函数获得的夏普比率。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="dba8" class="nv lg iq nr b gy nw nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; def</strong> sr_negate(weights):<br/>        neg_sr <strong class="nr ja">=</strong> stats(weights)[2] <strong class="nr ja">*</strong> <strong class="nr ja">-</strong>1<br/>        <strong class="nr ja">return</strong> neg_sr</span></pre><p id="7203" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">接下来，必须检查权重之和等于1的条件。因此为此也创建了一个函数。权重相加，然后减1。如果返回值为0，则总和为1。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="be01" class="nv lg iq nr b gy nw nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; def</strong> weight_check(weights):<br/>        weights_sum <strong class="nr ja">=</strong> np.sum(weights)<br/>        <strong class="nr ja">return</strong> weights_sum <strong class="nr ja">-</strong> 1</span></pre><p id="8280" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">接下来要做的是定义约束、界限和初始猜测。约束接受一个字典元组，其中第一个元素将类型描述为一个方程(因为“weight_check”函数通过求解一个方程返回值)，第二个元素将函数描述为“weight_check”。由于权重可以在0到1的范围内，因此相应地设置了界限，并且还提到了初始猜测。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="56a3" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; constraints <strong class="nr ja">=</strong> ({'type':'eq','fun':weight_check})<br/>&gt;&gt;&gt; bounds <strong class="nr ja">=</strong> ((0,1),(0,1),(0,1))<br/>&gt;&gt;&gt; initial_guess <strong class="nr ja">=</strong> [0.3,0.3,0.4]</span></pre><p id="8b12" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在所有这些变量都通过了scipy的最小化函数。它采用必须最小化的函数，接着是初始猜测，然后是用于执行最小化的求解器。所用的解算器将是序列最小二乘规划(SLSQP)解算器，因为它用于最基本的任务。然后还提到了边界和约束。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="f1de" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; results <strong class="nr ja">=</strong> minimize(sr_negate,initial_guess,method<strong class="nr ja">=</strong>'SLSQP',<br/>    bounds<strong class="nr ja">=</strong>bounds,constraints<strong class="nr ja">=</strong>constraints)<br/>&gt;&gt;&gt; results</span><span id="b135" class="nv lg iq nr b gy oa nx l ny nz">fun: -1.0927303413720688<br/>     jac: array([ 1.26287341e-04,  2.89727578e+00, -2.90006399e-04])<br/> message: 'Optimization terminated successfully'<br/>    nfev: 20<br/>     nit: 5<br/>    njev: 5<br/>  status: 0<br/> success: True<br/>       x: array([6.96661817e-01, 3.01299784e-15, 3.03338183e-01])</span></pre><p id="6c10" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，值“x”包含权重的优化分配，它被提取出来，然后通过“stats”函数传递，该函数返回回报率、波动率和夏普比率。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="445e" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; wt <strong class="nr ja">=</strong> results.x<br/>&gt;&gt;&gt; wt<br/>array([6.96661817e-01, 3.01299784e-15, 3.03338183e-01])</span><span id="edb4" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; stats(wt)<br/>array([0.27569923, 0.25230308, 1.09273034])</span></pre><p id="27e2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> →绘制有效边界</strong></p><p id="a778" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有效边界是一组最优投资组合，对于给定的预期回报水平，这些投资组合具有最高的预期回报和最低的风险。</p><p id="ef88" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">设置边界水平(回报水平),对于200个点取值从-0.6到0.4，因为先前获得的子弹形图上的回报具有相同的范围。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="3328" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; frontier_return <strong class="nr ja">=</strong> np.linspace(<strong class="nr ja">-</strong>0.6,0.4,200)</span></pre><p id="5ac7" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">然后，下一步必须最小化易失性，为其定义一个函数，该函数将在稍后定义约束时使用。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="24a1" class="nv lg iq nr b gy nw nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; def</strong> min_vol(weights):<br/>        vol <strong class="nr ja">=</strong> stats(weights)[1]<br/>        <strong class="nr ja">return</strong> vol</span></pre><p id="a58b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">接下来要做的是迭代通过边界，也就是收益，通过调用scipy minimize函数计算每个收益的最小波动率。定义约束条件时，会检查权重，并找出回报和预期回报之间的差异。和最初的猜测一样，方法和界限保持不变。minimize函数返回一个函数值，它是最小的易失性，它将被保存在一个数组中。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="f108" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; frontier_volatility <strong class="nr ja">=</strong> []</span><span id="4405" class="nv lg iq nr b gy oa nx l ny nz"><strong class="nr ja">&gt;&gt;&gt; for</strong> exp_return <strong class="nr ja">in</strong> frontier_return:<br/>        constraints <strong class="nr ja">=</strong> ({'type':'eq','fun':weight_check},{'type':'eq','fun':<strong class="nr ja">lambda</strong> x: stats(x)[0]<strong class="nr ja">-</strong>exp_return})<br/>        result <strong class="nr ja">=</strong> minimize(min_vol,initial_guess,method<strong class="nr ja">=</strong>'SLSQP',<br/>        bounds<strong class="nr ja">=</strong>bounds,constraints<strong class="nr ja">=</strong>constraints)<br/>        frontier_volatility.append(result['fun'])</span></pre><p id="1662" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在使用前沿回报和波动数组，有效前沿可以和之前用子弹形图得到的最初猜测一起画出来。</p><pre class="kp kq kr ks gt nq nr ns nt aw nu bi"><span id="6550" class="nv lg iq nr b gy nw nx l ny nz">&gt;&gt;&gt; plt.figure(figsize<strong class="nr ja">=</strong>(12,8))<br/>&gt;&gt;&gt; plt.scatter(volatility,returns,c<strong class="nr ja">=</strong>sharpe)<br/>&gt;&gt;&gt; plt.colorbar(label<strong class="nr ja">=</strong>'Sharpe Ratio')<br/>&gt;&gt;&gt; plt.xlabel('Volatility')<br/>&gt;&gt;&gt; plt.ylabel('Return')</span><span id="5360" class="nv lg iq nr b gy oa nx l ny nz">&gt;&gt;&gt; plt.plot(frontier_volatility,frontier_return,'r--',linewidth<strong class="nr ja">=</strong>3)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/5d09c047fb66efbdc8d0c6e72e8fa2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLhnKxIBQvDSHY5AFJpfkg.png"/></div></div></figure><p id="5c04" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有效边界告诉我们，对于每个期望的波动水平，可以获得的最佳回报是什么。</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><blockquote class="ox"><p id="cc73" class="oy oz iq bd pa pb pc pd pe pf pg ms dk translated"><em class="ph">这里指笔记本</em><a class="ae le" href="https://github.com/jayashree8/Finance_Trading_In_Python/blob/main/Portfolio%20management/Portfolio%20optimization.ipynb" rel="noopener ugc nofollow" target="_blank"><em class="ph"/></a><em class="ph">。</em></p></blockquote><blockquote class="of og oh"><p id="6cb4" class="lx ly oi lz b ma pi ka mc md pj kd mf oj pk mi mj ok pl mm mn ol pm mq mr ms ij bi translated"><em class="iq">联系我:</em><a class="ae le" href="https://www.linkedin.com/in/jayashree-domala8/" rel="noopener ugc nofollow" target="_blank"><em class="iq">LinkedIn</em></a></p><p id="7b7f" class="lx ly oi lz b ma mt ka mc md mu kd mf oj mv mi mj ok mw mm mn ol mx mq mr ms ij bi translated"><em class="iq">查看我的其他作品:</em> <a class="ae le" href="https://github.com/jayashree8" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub </em> </a></p></blockquote></div></div>    
</body>
</html>