<html>
<head>
<title>My VS Code Setup To Prototype Algorithmic Trading Strategies Locally Using LEAN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的VS代码设置使用精益在本地构建算法交易策略的原型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/my-vs-code-setup-to-prototype-algorithmic-trading-strategies-locally-using-lean-f069e0435353?source=collection_archive---------0-----------------------#2021-04-07">https://pub.towardsai.net/my-vs-code-setup-to-prototype-algorithmic-trading-strategies-locally-using-lean-f069e0435353?source=collection_archive---------0-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4f81" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/software-engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/c054412ac801fc086f9e26fcba82b0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uMPCT54s5d-1e8sV"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">约书亚·阿拉贡在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4f33" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h1><p id="f703" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这篇文章描述了我的<a class="ae ko" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS代码</a>设置的文档，该设置使用QuantConnect的<a class="ae ko" href="https://github.com/quantconnect/lean" rel="noopener ugc nofollow" target="_blank"> LEAN </a>引擎在本地机器上开发算法交易策略。这是使用<a class="ae ko" href="https://github.com/QuantConnect/lean-cli" rel="noopener ugc nofollow" target="_blank"> QuantConnect Lean CLI </a>工具的替代方法。</p><p id="fd13" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">重现本文所述结果的所有代码和脚本都可以在<a class="ae ko" href="https://github.com/hsm207/lean/tree/dev" rel="noopener ugc nofollow" target="_blank"> this </a> repo中找到。</p><p id="6a55" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">本文将首先描述创建设置的先决条件，然后是实际创建设置的步骤。然后，它将遍历3个使用示例，即:回溯测试算法、调试算法和运行研究笔记本。最后，我们将讨论这种设置的利与弊。</p><p id="996b" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">注意，尽管LEAN支持C#，但这种设置只关注Python中算法交易策略的原型。</p><h1 id="1432" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">先决条件</h1><p id="9ca2" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">您需要安装以下工具:</p><ol class=""><li id="9b08" class="mq mr it lp b lq ml lu mm ly ms mc mt mg mu mk mv mw mx my bi translated">Visual Studio代码</li><li id="1bcf" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated"><a class="ae ko" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank">码头工人</a></li></ol><p id="d49e" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">你还需要一份精益源代码的本地副本，你可以从<a class="ae ko" href="https://github.com/quantconnect/lean" rel="noopener ugc nofollow" target="_blank">这里</a>克隆/派生。</p><h1 id="a4da" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">设置</h1><h2 id="4349" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">概观</h2><p id="da45" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">该设置分为5个步骤。其背后的想法是有一个容器，我们可以从其中构建和运行精益，并依靠VS代码来运行常见的任务，例如调试算法，启动研究笔记本等。</p><h2 id="7dff" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">步骤1:为设置创建一个单独的分支</h2><p id="1ba2" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这个设置需要添加和修改一些文件，所以我们将从<code class="fe np nq nr ns b">master </code>创建一个名为<code class="fe np nq nr ns b">dev</code>的分支，这样我们就可以继续从上游获取关于<code class="fe np nq nr ns b">master</code>的最新更新，而不会出现任何问题。</p><h2 id="5e50" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">步骤2:创建一个开发容器</h2><p id="3457" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们将需要一个包含所有必要依赖项的容器来构建和运行精益。</p><p id="4328" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在项目根目录下创建一个名为<code class="fe np nq nr ns b">dev.Dockerfile</code>的文件，内容如下:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3c0026c4cd53eab39031230ef1ad05f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*v3PLgO9LcoHkLmeBM3lkEw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图1:构建和运行精益的Dockerfile文件</figcaption></figure><p id="05c7" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">接下来，告诉VS代码在由<code class="fe np nq nr ns b">dev.Dockerfile</code>定义的容器中重新打开项目。见<a class="ae ko" href="https://code.visualstudio.com/docs/remote/containers#_quick-start-try-a-development-container" rel="noopener ugc nofollow" target="_blank">这里</a>关于如何做的细节。下面截图供参考:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ny"><img src="../Images/54cc5262f514157e063ef69007b60d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fmlv90THK976kELsVr_Bbw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图2:使用命令面板在dev中重新打开项目。Dockerfile文件</figcaption></figure><h2 id="c279" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">第三步:建立精益</h2><p id="3711" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">现在我们已经进入了容器，我们可以使用以下命令来构建精益:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nz"><img src="../Images/853c088246cbada830132013362894c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aEC72Ud2ES9xeA3E_mLhw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图3:构建精益的命令</figcaption></figure><h2 id="05d9" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">步骤4:创建运行研究笔记本的脚本</h2><p id="c290" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">本文中的研究笔记本是指在JupyterLab上运行的常规Jupyter笔记本，其中安装了用于定量分析的所有通用库。</p><p id="4d27" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">您可能希望通过Lean API获取数据进行分析，但是在这之前，您需要完成一些步骤来配置Python，以便它可以通过。NET公共语言运行库，因为Lean是用C#编写的。</p><p id="0de3" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">因此，在项目目录中创建一个名为<code class="fe np nq nr ns b">run_research.sh</code>的脚本来执行这些步骤。脚本很长，所以我不会在本文中展示它。你可以在这里查看完整的脚本。它是基于Lean的<a class="ae ko" href="https://github.com/hsm207/Lean/blob/dev/DockerfileJupyter" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>发布的研究笔记本。</p><h2 id="4b65" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">步骤5:创建VS代码任务来运行常见任务</h2><p id="5f6a" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在终端中键入命令来运行研究笔记本很麻烦，所以让我们在<code class="fe np nq nr ns b">.vscode/tasks.json</code>文件中添加一个任务来自动化这个过程:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8eb313e4bb124393ebfcff027589b775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*PJOZN2nlHGpgv0_WZZZGbg.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图5:启动研究笔记本的任务</figcaption></figure><p id="cdf8" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">图5创建了一个名为“Run Research”的任务，它调用我们在上一步中创建的<code class="fe np nq nr ns b">run_research.sh</code>脚本。它还定义了环境变量来告诉Lean从哪里读取数据(DATA_DIR)以及笔记本存储在哪里(NOTEBOOK_DIR)。只要可以从容器内部访问，就可以将这些目录更改为指向任何位置。如果您计划与<a class="ae ko" href="https://www.quantconnect.com/lean/docs#topic100.html" rel="noopener ugc nofollow" target="_blank"> QuantConnect Web API </a>进行交互，则需要QC_API_USER_ID和QC_API_TOKEN。</p><p id="6cb7" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">类似地，我们也可以创建一个任务来对算法进行回溯测试，如下所示:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b1fc4938de5fa790374a0d2e38d4b99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*_z4_V8PyTy4X0PYrbOsG_w.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图6:回溯测试算法的任务</figcaption></figure><h1 id="18b4" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用</h1><h2 id="0b42" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">回溯测试算法</h2><p id="a014" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">假设我们在名为<code class="fe np nq nr ns b">SillyAlgorithm.py</code>的文件中编写了以下算法，并在<code class="fe np nq nr ns b">/tmp/secret_algo</code>将它保存在容器中的<strong class="lp jd">:</strong></p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9924715b79a8756f5697788f2c44d425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*dEco-BiSHQVwVdAewrFZrw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图7:一个愚蠢的算法</figcaption></figure><p id="5bdd" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">图7中的算法简单地基于每天随机变化的目标持仓量每天买卖SPY。</p><p id="86de" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">为了回测这个算法，我们需要修改Lean的<code class="fe np nq nr ns b">Launcher</code>目录中的<code class="fe np nq nr ns b">config.json</code>文件，告诉它我们想要回测一个Pyhton算法，以及在哪里可以找到这个算法的代码。<code class="fe np nq nr ns b">config.json</code>文件中需要更新的相关部分如下:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi od"><img src="../Images/7f2fb085396ff1eeb9861977c15a5a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*uNXmohw6J1nk3F6kGfwdiw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图8:更新Launcher/config.json以回溯测试SillyAlgorithm</figcaption></figure><p id="7d4e" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">然后，为了运行回溯测试，我们可以使用命令面板来执行<code class="fe np nq nr ns b">Tasks: Run Task</code>命令并选择<code class="fe np nq nr ns b">Backtest Algorithm</code>任务:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f6f614c6d616e29f2a6184ae5ca43f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*X-QvOF08vr4lBXiNRnk4vw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图9:从命令面板启动“回溯测试算法”任务</figcaption></figure><h2 id="5672" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">调试算法</h2><p id="e419" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">假设我们想调试我们在图7中编写的算法，当它在第27行时。</p><p id="32ac" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我们通过在相关行设置断点来开始调试过程:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c16058bd0646643654c8ec713e4d4dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*E1XEtbi0Cy_mrldoCDdxHw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图10:在SillyAlgorithm.py的第27行设置断点</figcaption></figure><p id="eed9" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">接下来，我们修改<code class="fe np nq nr ns b">/Launcher/config.json</code>,告诉它用VS代码在调试模式下运行回溯测试:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi og"><img src="../Images/db153f37c023f994fb5d3e6d8fef56b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0o1xjb9yUeY_dX4J5nMFmQ.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图11:如何在调试模式下运行回溯测试并在VS代码中进行调试</figcaption></figure><p id="fc8f" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">然后，我们像以前一样运行<code class="fe np nq nr ns b">Backtest Algorithm</code>任务。如果您注意运行任务的终端，您会注意到它会暂停，并显示消息<code class="fe np nq nr ns b">waiting for PTVSD debugger to attach at localhost:5678...</code>:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oh"><img src="../Images/a257f1f6e4dddc6bc1621dc07611f8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgnMziyev_TaKLIfGzTnRA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图12:回溯测试在继续之前正在等待来自调试器的连接</figcaption></figure><p id="335c" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这提示您转到<code class="fe np nq nr ns b">Run and Debug</code>面板并执行<code class="fe np nq nr ns b">Attach to Python (Local)</code>配置:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/0da05105042df9d58779c9096af48e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*kAVmxK2c62mtImpiBXHqSA.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图13:找到“附加到Python(本地)”配置</figcaption></figure><p id="d423" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">启动此配置将导致回测恢复其操作，并最终在指定的断点处暂停:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi oj"><img src="../Images/eedb9e2812e1bf0857ae4e9571ff4248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNuZ6WlMe9Zct_8PaoJOFw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图14:在断点处暂停的回溯测试</figcaption></figure><h2 id="9438" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">启动研究环境</h2><p id="9d5e" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">启动研究环境就像启动<code class="fe np nq nr ns b">Run Research</code>任务一样简单。该任务最终将在容器内部的端口8889上启动一个JupyterLab服务器，并自动对该端口进行端口转发，以便可以从本地主机访问它。当一切准备就绪时，您将从VS代码中得到一个“在浏览器中打开”的提示:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ok"><img src="../Images/dc18c85ea5e8451e9a4fb2f5dd242b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BWfF_oo782v71wz8UQ9MQ.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图15:“运行研究”任务的成功启动</figcaption></figure><h1 id="08ce" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">利弊</h1><h2 id="6081" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">赞成的意见</h2><p id="89b2" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这种设置有3个好处:</p><ol class=""><li id="3fb2" class="mq mr it lp b lq ml lu mm ly ms mc mt mg mu mk mv mw mx my bi translated"><strong class="lp jd">完全控制已安装的库。</strong>你可以更新<code class="fe np nq nr ns b">dev.Dockerfile</code>文件来安装/升级任何你需要的库来开发你的交易算法。在回溯测试和研究环境中都可以使用同一套库。使用精益CLI实现这一点并不那么直接，因为它需要不同的容器来进行回溯测试和研究，并且您无法控制它们。</li><li id="fe64" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated"><strong class="lp jd">减少对官方发布的依赖。</strong>假设您遇到了一个bug，或者有一个功能请求已经有一个PR正在等待审查。审查过程可能需要一段时间，但通过这种设置，您不需要等待它被合并到master中，因为您可以简单地将PR合并到您的本地Lean副本中，然后重新构建它以享受bugfix或功能。</li><li id="0f59" class="mq mr it lp b lq mz lu na ly nb mc nc mg nd mk mv mw mx my bi translated"><strong class="lp jd">更容易调试和贡献代码。</strong>现在有了源代码，研究意外行为或bug的根本原因并反馈给社区就更方便了！</li></ol><h2 id="a0c6" class="ne kq it bd kr nf ng dn kv nh ni dp kz ly nj nk ld mc nl nm lh mg nn no ll iz bi translated">骗局</h2><p id="987f" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">到目前为止，我遇到的主要问题是与<code class="fe np nq nr ns b">master </code>分支保持同步具有挑战性。</p><p id="b094" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我最初认为我可以通过从上游拉然后与<code class="fe np nq nr ns b">dev</code>合并来更新我的本地<code class="fe np nq nr ns b">master</code>。但是合并步骤经常引起合并冲突，我自己解决它们并不有趣。我发现更新<code class="fe np nq nr ns b">master</code>并重复设置步骤后，重新创建<code class="fe np nq nr ns b">dev</code>分支更容易。</p><p id="5349" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这种设置的另一个问题是初始设置步骤不是一次性的。随着引擎随着时间的推移发展新的特性或架构，您将不得不偶尔修改一些脚本和命令。</p><p id="2cbf" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">例如，在我的一个笔记本意外损坏后，我在<code class="fe np nq nr ns b">run_research.sh</code>脚本中添加了以下几行:</p><figure class="nu nv nw nx gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ol"><img src="../Images/7852e1fd9092d7d820ecc1d90b6ab2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4LfHs_j-LNvmV07kvpO3Q.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">图16:修复损坏的笔记本的热修复程序</figcaption></figure><p id="3508" class="pw-post-body-paragraph ln lo it lp b lq ml ls lt lu mm lw lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我通过研究自从我上次更新我的本地<code class="fe np nq nr ns b">master </code>分支以来对<code class="fe np nq nr ns b">DockerfileJupyter</code>文件的更新，得出了这个解决方案。</p><h1 id="79ba" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="9f06" class="pw-post-body-paragraph ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">本文描述了我在本地使用精益引擎开发算法交易策略时所遵循的设置。如果你知道一个更有效的设置，并且仍然保留了上述优点，请在评论中告诉我。</p></div></div>    
</body>
</html>