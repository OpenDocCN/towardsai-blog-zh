<html>
<head>
<title>Clash Royale Challenge Algorithm: How Many Players Can Get 12 Wins?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clash Royale挑战算法:有多少玩家可以获得12胜？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/clash-royale-challenge-algorithm-how-many-players-can-get-12-wins-fb37add82d8f?source=collection_archive---------1-----------------------#2021-01-14">https://pub.towardsai.net/clash-royale-challenge-algorithm-how-many-players-can-get-12-wins-fb37add82d8f?source=collection_archive---------1-----------------------#2021-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8924" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/mathematics" rel="noopener ugc nofollow" target="_blank">数学</a></h2><div class=""/><div class=""><h2 id="2693" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用蒙特卡罗模拟解数学谜语。完整的代码<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20210113_CRL_challenge" rel="noopener ugc nofollow" target="_blank">可在我的回购</a>。</h2></div><p id="6822" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我今年遇到的最有趣的数学问题之一是在Clash Royale的游戏动力学中，这是一个隐藏了许多挑战性但创造性的数学谜语的游戏(其中一些我已经解决了，如果你有兴趣，请阅读我如何为Clash Royale甲板应用聚类技术)。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/a22a0ccf469a636392a200c23f569b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxW8X-IGriTudkfSrsEKiw.jpeg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">皇家冲突壁纸</figcaption></figure><h1 id="959d" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">数学谜语</h1><p id="cdb8" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">游戏允许玩家参与挑战。每次玩家进入一场比赛，都必须和另一个玩家一起玩，可以赢也可以输(新的游戏动态不允许平局)。玩家进入挑战时有3条命，并能赢得多达12场比赛。\</p><blockquote class="nb nc nd"><p id="092f" class="ks kt ne ku b kv kw kd kx ky kz kg la nf lc ld le ng lg lh li nh lk ll lm ln im bi translated">自从开始玩《皇家冲突》以来，每个玩家都在问自己一个问题:有多少玩家能够赢得这场考验？</p></blockquote><p id="5f1a" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">鉴于其难度，只有少数(与数百万活跃玩家相比的相对数字)熟练玩家能够获得12胜。</p><p id="0ea5" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">本文的目的将是试图通过使用代码找到这个谜语的答案。更具体地说，当问题太复杂而无法用数学概率公式解决时，我们可以使用蒙特卡罗模拟。经过一百万次随机行走后，概率曲线应该是近似的(随着模拟次数达到无穷大，越来越精确),代表真实的概率分布。</p><h2 id="7843" class="ni mf it bd mg nj nk dn mk nl nm dp mo lb nn no mq lf np nq ms lj nr ns mu iz bi translated">导入库</h2><p id="4902" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">对于这个模拟，我将使用NumPy来促进玩家的随机选择，random将随机结果分配给玩家，最后，pandas以适当的形式表示输出。</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="f80e" class="ni mf it nu b gy ny nz l oa ob">import numpy as np<br/>import random<br/>import pandas as pd</span></pre><h1 id="2cf8" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">创建模拟</h1><p id="cc26" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我将把我所有的代码嵌入到一个函数中，我称之为simulation。通过调用这个函数，我将通过指定一些参数来执行所有我想要的蒙特卡罗。</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="a31b" class="ni mf it nu b gy ny nz l oa ob">def simulation(n_players, max_wins, n_lives):</span></pre><h2 id="9698" class="ni mf it bd mg nj nk dn mk nl nm dp mo lb nn no mq lf np nq ms lj nr ns mu iz bi translated">玩家等级</h2><p id="c795" class="pw-post-body-paragraph ks kt it ku b kv mw kd kx ky mx kg la lb my ld le lf mz lh li lj na ll lm ln im bi translated">我将生成一个非常简单的玩家类，它可以保存两个变量:生命数(默认为3)和连续获胜数，从0开始，最多可以达到12。</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="a296" class="ni mf it nu b gy ny nz l oa ob">  class player:<br/>    lives = n_lives<br/>    consecutive_wins = 0</span><span id="0eef" class="ni mf it nu b gy oc nz l oa ob">    def __init__(self):<br/>      pass</span></pre><p id="bd13" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我的想法是从所有寿命大于0的玩家开始，称为<strong class="ku jd"> pool_alive </strong>，以及所有已经结束生命并且无法重新进入挑战的玩家或通过完成12场胜利来完成挑战的玩家:<strong class="ku jd"> pool_done </strong>。我将在设置函数后声明这两个列表，作为组织代码的标准python过程。</p><p id="45f1" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">其余的功能都在这里。我将使用<strong class="ku jd"> fight(max_wins) </strong>函数来模拟由<strong class="ku jd"> pick_alive() </strong>从直播池中随机抽取的两名玩家之间的战斗。对于每场战斗，两名玩家将被暂时从直播池中抽出，以随机结果(50%赢，50%输)进行战斗，然后如果他们还活着，则重新进入<strong class="ku jd"> pool_alive </strong>，但如果他们完成了所有生命或达到12场胜利的限制，他们将进入<strong class="ku jd"> pool_done </strong>。</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="10bf" class="ni mf it nu b gy ny nz l oa ob">  def pick_alive():<br/>    return pool_alive.pop(random.randint(0, len(pool_alive)-1))</span><span id="d328" class="ni mf it nu b gy oc nz l oa ob">  def fight(max_wins):<br/>    try:<br/>      a = pick_alive()<br/>      b = pick_alive()</span><span id="62f0" class="ni mf it nu b gy oc nz l oa ob">#result<br/>      result = random.randint(0, 1)<br/>      <br/>      if result == 0:<br/>        a.lives -= 1<br/>        b.consecutive_wins += 1<br/>      else:<br/>        b.lives -= 1<br/>        a.consecutive_wins += 1<br/>      <br/>      #print(result, 'a:', a.lives, 'b:', b.lives)<br/>      #die or live<br/>      if a.consecutive_wins == max_wins:<br/>        pool_done.append(a)<br/>      else:<br/>        if a.lives == 0:<br/>          pool_done.append(a)<br/>        else:<br/>          pool_alive.append(a)</span><span id="3cb8" class="ni mf it nu b gy oc nz l oa ob">     if b.consecutive_wins == max_wins:<br/>        pool_done.append(b)<br/>      else:<br/>        if b.lives == 0:<br/>          pool_done.append(b)<br/>        else:<br/>          pool_alive.append(b)</span><span id="8989" class="ni mf it nu b gy oc nz l oa ob">#print('tried', pool_alive, a.lives, b.lives, pool_done)<br/>    except:<br/>      #print(pool_alive, 'k')<br/>      #last player remaining<br/>      pool_done.append(a)<br/>      return 0</span><span id="d0d6" class="ni mf it nu b gy oc nz l oa ob">#print(len(pool_alive))</span><span id="4a1b" class="ni mf it nu b gy oc nz l oa ob">pool_alive = [player() for x in range(n_players)]<br/>pool_done = list()</span></pre><p id="3bfe" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在设置了主要函数之后，我可以创建一个while条件，在给定初始玩家数量的情况下，战斗将一直进行，直到剩下一个玩家(最后一个人站着！)谁也将加入<strong class="ku jd"> pool_done </strong>名单。</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="43fb" class="ni mf it nu b gy ny nz l oa ob">#fight until there is no one left<br/>  #last player gets moved into the other bracket<br/>  while len(pool_alive) &gt; 0:<br/>    if fight(max_wins) == 0:<br/>      break</span><span id="56c4" class="ni mf it nu b gy oc nz l oa ob">players_done = list()<br/>  for d in pool_done:<br/>    players_done.append([d.lives, d.consecutive_wins])</span><span id="0c1c" class="ni mf it nu b gy oc nz l oa ob">players_alive = list()<br/>  for k in pool_alive:<br/>    players_alive.append([k.lives, k.consecutive_wins])</span><span id="0ed6" class="ni mf it nu b gy oc nz l oa ob">total = pd.DataFrame(players_done+players_alive)<br/>  total</span></pre><p id="1ffe" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">所有模拟结束后，我会统计pool_done列表中所有玩家中达到12胜的玩家总数。</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="ee70" class="ni mf it nu b gy ny nz l oa ob">return total, total[1][total[1]==12].count()/n_players</span><span id="b182" class="ni mf it nu b gy oc nz l oa ob">_, winners = simulation(1000000, 12, 3)<br/>winners</span></pre><p id="9abc" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">最终输出:</p><pre class="lp lq lr ls gt nt nu nv nw aw nx bi"><span id="6e66" class="ni mf it nu b gy ny nz l oa ob">0.006397</span></pre><p id="8e73" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">经过100万次模拟后，只有0.63%的玩家，或1万人中的63人成功赢得了挑战。通过再次进行同样的实验，你会发现结果是一致的。</p></div></div>    
</body>
</html>