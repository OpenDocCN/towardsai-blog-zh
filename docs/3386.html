<html>
<head>
<title>How To Quickly Build A Semantic Search System With txtai And Weaviate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用txtai和Weaviate快速构建语义搜索系统</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-to-quickly-build-a-semantic-search-system-with-txtai-and-weaviate-fd4084e93aaa?source=collection_archive---------1-----------------------#2022-12-10">https://pub.towardsai.net/how-to-quickly-build-a-semantic-search-system-with-txtai-and-weaviate-fd4084e93aaa?source=collection_archive---------1-----------------------#2022-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cd13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">weaviate-txtai图书馆简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5be2d0b2361695ea229fa728fd20c018.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*WGJaGIjN-aNUlmcPPG_ang.png"/></div></figure><h1 id="2c19" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="5968" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将解释如何使用docker compose和以下工具/库快速构建基于机器学习的语义搜索引擎:</p><ol class=""><li id="8f07" class="me mf it lk b ll mg lo mh lr mi lv mj lz mk md ml mm mn mo bi translated"><a class="ae mp" href="https://github.com/neuml/txtai" rel="noopener ugc nofollow" target="_blank"> txtai </a>:一个运行机器学习工作流来转换数据和构建人工智能支持的语义搜索应用的框架。</li><li id="66fd" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md ml mm mn mo bi translated"><a class="ae mp" href="https://github.com/semi-technologies/weaviate" rel="noopener ugc nofollow" target="_blank"> weaviate </a>:矢量搜索引擎</li><li id="112b" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md ml mm mn mo bi translated">txt-weaviate :一个小的库，使weaviate与txtai的集成变得容易</li></ol><p id="a048" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">重现这个解决方案的代码可以在<a class="ae mp" href="https://github.com/hsm207/txtai-weaviate-docker-compose" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="ffff" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">设置</h1><p id="3272" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们只需要按照3个步骤开始:</p><ul class=""><li id="bbbe" class="me mf it lk b ll mg lo mh lr mi lv mj lz mk md my mm mn mo bi translated">步骤1:为txtai API服务器定义映像</li><li id="e828" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md my mm mn mo bi translated">步骤2:定义txtai配置</li><li id="4924" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md my mm mn mo bi translated">步骤3:使用docker compose进行部署</li></ul><h2 id="a9b4" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">步骤1:为txtai API服务器定义映像</h2><p id="c8d9" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">txtai API服务器需要一些库才能与weaviate交互。我们可以使用由<a class="ae mp" href="https://hub.docker.com/u/neuml" rel="noopener ugc nofollow" target="_blank"> neuml </a>提供的图像之一作为起点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8d28be1ca97f39626ddb681e873f65c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vn7oy8Kizpz81HOIdbmO7Q.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图1:为txtai API服务器构建定制的容器</figcaption></figure><p id="e585" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">正如我们在图1中看到的，我们需要的唯一额外依赖项是<a class="ae mp" href="https://pypi.org/project/weaviate-client/" rel="noopener ugc nofollow" target="_blank"> weaviate-client </a>和<a class="ae mp" href="https://pypi.org/project/weaviate-txtai/" rel="noopener ugc nofollow" target="_blank"> weaviate_txtai </a>包。</p><h2 id="824d" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">步骤2:定义txtai配置</h2><p id="0207" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用txtai的<a class="ae mp" href="https://neuml.github.io/txtai/workflow/" rel="noopener ugc nofollow" target="_blank">工作流</a>特性来构建语义搜索引擎。</p><p id="b31f" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">我们只需要两个工作流，即<code class="fe nq nr ns nt b">index</code>和<code class="fe nq nr ns nt b">search</code>。下面是我们如何使用yaml文件定义这些工作流:</p><pre class="kj kk kl km gt nu nt nv bn nw nx bi"><span id="67e1" class="ny kr it nt b be nz oa l ob oc">embeddings:<br/>  path: sentence-transformers/all-MiniLM-L6-v2<br/><br/>nop:<br/><br/>weaviate_txtai.client.Weaviate:<br/>  url: http://weaviate:8080<br/><br/>workflow:<br/>  index:<br/>    batch: 2500<br/>    tasks:<br/>    - action: [nop, transform]<br/>      unpack: False<br/>    - action: weaviate_txtai.client.Weaviate<br/>      unpack: False<br/>  search:<br/>    tasks:<br/>    - action: transform<br/>    - action: weaviate_txtai.client.Weaviate<br/>      args: [search]</span></pre><p id="6b30" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">上面的配置使用拥抱脸的模型中枢中的<a class="ae mp" href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2" rel="noopener ugc nofollow" target="_blank">句子-变形金刚/all-MiniLM-L6-v2 </a>模型将文本转换为嵌入内容(在搜索和索引期间)。</p><h2 id="eeb0" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">步骤3:使用docker compose进行部署</h2><p id="bb82" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是构建和部署语义搜索引擎的整个docker合成文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/96238d340a21b21486745db474b37c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*2pB9eLQvFsn7BRC5pLCuPQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图2:部署语义搜索引擎的docker合成文件</figcaption></figure><p id="29d8" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">关于<code class="fe nq nr ns nt b">txtai-api</code>服务需要注意的要点是:</p><ol class=""><li id="1335" class="me mf it lk b ll mg lo mh lr mi lv mj lz mk md ml mm mn mo bi translated">我们将在上一步中定义的工作流配置文件挂载到容器中的<code class="fe nq nr ns nt b">/app/app.yaml</code>(第10行)</li><li id="512b" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md ml mm mn mo bi translated">我们还挂载一个文件夹来缓存模型、数据集等。这是从Hugging Face的模型中心下载的，这样我们就不必在每次重启容器时重新下载它们(第11和14行)</li></ol><p id="7d0a" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">用<code class="fe nq nr ns nt b">docker-compose up</code>调出这些服务。</p><h1 id="c619" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">使用</h1><p id="ed32" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用<code class="fe nq nr ns nt b"><a class="ae mp" href="https://huggingface.co/datasets/ag_news" rel="noopener ugc nofollow" target="_blank">ag_news</a></code>数据集来展示语义搜索系统的价值。</p><h2 id="2d32" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">索引</h2><p id="8339" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个简单的脚本，使用数据集库下载<code class="fe nq nr ns nt b">ag_news</code>数据集，然后使用txtai API服务器的<code class="fe nq nr ns nt b">index</code>工作流端点将其上传到weaviate:</p><pre class="kj kk kl km gt nu nt nv bn nw nx bi"><span id="a8cf" class="ny kr it nt b be nz oa l ob oc">from datasets import load_dataset<br/>import requests<br/><br/>URL = "http://localhost:8000"<br/><br/>ds = load_dataset("ag_news", split="train")<br/><br/>payload = {<br/>    "name": "index",<br/>    "elements": ds["text"]<br/>}<br/><br/>r = requests.post(f"{URL}/workflow", json=payload)</span></pre><h2 id="1dab" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">搜索</h2><p id="0bb7" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可以使用txtai API服务器的<code class="fe nq nr ns nt b">search</code>工作流对我们索引的数据运行一些查询。</p><p id="c4aa" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">由于数据集是关于来自2，000多个新闻来源的新闻文章，让我们尝试以下查询:</p><ul class=""><li id="cee5" class="me mf it lk b ll mg lo mh lr mi lv mj lz mk md my mm mn mo bi translated">关于德国的金融新闻</li><li id="2968" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md my mm mn mo bi translated">关于德国的体育新闻</li><li id="4497" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md my mm mn mo bi translated">德国健康新闻</li></ul><p id="929a" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">这次让我们使用<code class="fe nq nr ns nt b">curl</code>来执行查询，使用<code class="fe nq nr ns nt b">jq</code>来解析输出:</p><pre class="kj kk kl km gt nu nt nv bn nw nx bi"><span id="37df" class="ny kr it nt b be nz oa l ob oc">curl --request POST \<br/>  --url http://localhost:8000/workflow \<br/>  --header 'content-type: application/json' \<br/>  --header 'user-agent: vscode-restclient' \<br/>  --data '{"name": "search", <br/>           "elements": [<br/>              "Financial news about Germany", <br/>              "Sports news about Germany", <br/>              "Health news about Germany"<br/>              ] <br/>            }' | \<br/>  jq '.[] | .data.Get.Document | .[0].content' </span></pre><h2 id="aa39" class="mz kr it bd ks na nb dn kw nc nd dp la lr ne nf lc lv ng nh le lz ni nj lg nk bi translated">结果</h2><p id="3ec6" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些是上一节中<code class="fe nq nr ns nt b">curl</code>请求的结果:</p><ol class=""><li id="44da" class="me mf it lk b ll mg lo mh lr mi lv mj lz mk md ml mm mn mo bi translated">“德国官员的增长前景更好(美联社)美联社——德国金融专业人士对该国的经济增长前景变得不那么悲观，但仍然担心欧元对美元的创纪录高位将拖累出口，周二的一项月度调查显示。"</li><li id="33c9" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md ml mm mn mo bi translated">“斗篷和匕首多特蒙德那些试图通过检查德国媒体来了解德甲联赛的人将度过令人困惑的一周，因为很少有人谈论足球。”</li><li id="aa83" class="me mf it lk b ll mq lo mr lr ms lv mt lz mu md ml mm mn mo bi translated">一项调查显示，在欧洲，德国、荷兰和芬兰的员工请病假最多</li></ol><p id="f3c7" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">很明显，第一、第二和第三个结果分别是关于德国的金融、体育和健康新闻。</p><p id="4710" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">第二个和第三个查询的结果特别值得注意，因为它们不包含各自查询中的任何单词(除了“德国”)，但从语义上来说，它们是“正确的”。</p><p id="e1dc" class="pw-post-body-paragraph li lj it lk b ll mg ju ln lo mh jx lq lr mv lt lu lv mw lx ly lz mx mb mc md im bi translated">这说明了机器学习驱动的语义搜索系统的关键优势:我们不再需要构建手工制作的功能来提取用户查询背后的意义。</p><h1 id="385d" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">结论</h1><p id="1720" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文展示了如何使用txtai和weaviate快速开始构建语义搜索引擎。我希望这激发了您对这项技术的好奇心，并期待看到您将构建什么样的应用程序！</p></div></div>    
</body>
</html>