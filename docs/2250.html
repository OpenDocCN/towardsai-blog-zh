<html>
<head>
<title>Time Series Forecasting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的时间序列预测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/time-series-forecasting-in-python-4e7d65580b9?source=collection_archive---------1-----------------------#2021-10-14">https://pub.towardsai.net/time-series-forecasting-in-python-4e7d65580b9?source=collection_archive---------1-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b7ab" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><div class=""><h2 id="1745" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python中的三种时间序列预测方法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/793c187964ccd73c8d46743958db3f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGf9PrrbUyvYC-j3mNofog.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<br/>T3【马体】米罗什尼琴科T5上<a class="ae lh" href="https://www.pexels.com/photo/dawn-technology-time-watch-8327973/" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><p id="59b0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">时间序列预测是根据历史数据预测未来值的任务。跨行业的例子包括天气预报、销售数据和股票价格。最近，它被应用于预测比特币和以太坊等加密货币的价格趋势。鉴于时间序列预测应用在各行各业的流行，每个数据科学家都应该对时间序列预测的可用方法有所了解。</p><p id="471b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">时间序列预测有各种各样的方法。最常用的一种是自回归移动平均(ARMA)，这是一种利用过去值预测未来值的统计模型。然而，这种方法是有缺陷的，因为它没有捕捉到季节趋势。它还假设时间序列数据是稳定的，这意味着它的统计属性不会随时间而改变。这种类型的行为是一种理想化的假设，在实践中并不成立，这意味着ARMA可能会提供扭曲的结果。</p><p id="e2a9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">ARMA的一个扩展是自回归综合移动平均(ARIMA)模型，它不假设平稳性，但仍然假设数据很少或没有季节性。幸运的是，季节性ARIMA (SARIMA)变量是一个统计模型，可以处理非平稳数据并捕捉一些季节性。</p><p id="8a8b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Python提供了许多易于使用的库和工具来执行时间序列预测。具体来说，Python中的<a class="ae lh" href="https://www.statsmodels.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> stats </a>库提供了只需几行代码就可以构建ARMA、ARIMA和SARIMA模型的工具。由于所有这些模型都可以在一个库中获得，所以您可以在同一个脚本或笔记本中使用不同的模型轻松地运行许多实验。</p><p id="ac78" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这里，我们将看看如何建立ARMA、ARIMA和萨里玛模型来预测比特币(BTC)的未来价格。</p><p id="6d56" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">读取和显示BTC时间序列数据</strong></p><p id="8105" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将从使用熊猫数据阅读器读取BTC的历史价格开始。让我们在终端中使用简单的pip命令来安装它:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="6dba" class="mk ml it mg b gy mm mn l mo mp">pip install pandas-datareader</span></pre><p id="cba4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们打开一个Python脚本，从Pandas库中导入数据阅读器:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="1e5d" class="mk ml it mg b gy mm mn l mo mp">import pandas_datareader.data as web</span><span id="bf8b" class="mk ml it mg b gy mq mn l mo mp">import datetime</span></pre><p id="9b3a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们也导入Pandas库本身，并放宽列和行的显示限制:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="8c16" class="mk ml it mg b gy mm mn l mo mp">import pandas as pd</span><span id="0d3c" class="mk ml it mg b gy mq mn l mo mp">pd.set_option("display.max_columns", None)</span><span id="1022" class="mk ml it mg b gy mq mn l mo mp">pd.set_option("display.max_rows", None)</span></pre><p id="9d92" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们现在可以导入日期时间库，这将允许我们定义数据拉取的开始和结束日期:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="2f72" class="mk ml it mg b gy mm mn l mo mp">import datetime</span></pre><p id="0b1b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在我们已经拥有了获取比特币价格时间序列数据所需的一切。让我们从…获取数据</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="529b" class="mk ml it mg b gy mm mn l mo mp">import pandas_datareader as web</span><span id="ee1f" class="mk ml it mg b gy mq mn l mo mp">btc = web.get_data_yahoo(["BTC-USD"], start=datetime.datetime(2018, 1, 1), end=datetime.datetime(2020, 12, 2))["Close"]</span><span id="e11c" class="mk ml it mg b gy mq mn l mo mp">print(btc.head())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mr"><img src="../Images/bd3a5c5090abe528f42c078780712ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gFQdoS9YVnU4IOc-"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="4efa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们看到我们的数据框包含许多列。让我们看一下这些列的含义:</p><ol class=""><li id="2f64" class="ms mt it ll b lm ln lp lq ls mu lw mv ma mw me mx my mz na bi translated">Date:这是我们的时间序列中的索引，它指定了与价格相关的日期。</li><li id="5d21" class="ms mt it ll b lm nb lp nc ls nd lw ne ma nf me mx my mz na bi translated">收盘价格:当日购买BTC的最后价格。</li><li id="898a" class="ms mt it ll b lm nb lp nc ls nd lw ne ma nf me mx my mz na bi translated">开盘价:当天购买BTC的第一个价格。</li><li id="4183" class="ms mt it ll b lm nb lp nc ls nd lw ne ma nf me mx my mz na bi translated">高:当天购买BTC的最高价格。</li><li id="1c3b" class="ms mt it ll b lm nb lp nc ls nd lw ne ma nf me mx my mz na bi translated">低:当天购买BTC的最低价格。</li><li id="0792" class="ms mt it ll b lm nb lp nc ls nd lw ne ma nf me mx my mz na bi translated">成交量:当日总交易笔数。</li><li id="2574" class="ms mt it ll b lm nb lp nc ls nd lw ne ma nf me mx my mz na bi translated">调整收盘价:根据股息和股票分割调整后的收盘价。</li></ol><p id="a13b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将在预测模型中使用收盘价。具体来说，我们将使用历史收盘BTC价格来预测未来的BTC价格。</p><p id="90bf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们将收盘价BTC数据写入一个csv文件。通过这种方式，我们可以避免使用Pandas数据读取器重复提取数据。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="1e44" class="mk ml it mg b gy mm mn l mo mp">btc.to_csv("btc.csv")</span></pre><p id="7be8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，让我们读入csv文件并显示前五行:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="22fa" class="mk ml it mg b gy mm mn l mo mp">btc = pd.read_csv("btc.csv")</span><span id="337b" class="mk ml it mg b gy mq mn l mo mp">print(btc.head())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b7cd6104c1cc9d671e99838b12f95499.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/0*2dK8isB6O_ihDKVJ"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="c37f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了使用stats库提供的模型，我们需要将date列设置为数据框索引。我们还应该使用to_datetime方法格式化该日期:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="8693" class="mk ml it mg b gy mm mn l mo mp">btc.index = pd.to_datetime(btc["Date"], format="%Y-%m-%d")</span></pre><p id="2066" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">既然日期是索引，我们可以删除日期列:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="e15e" class="mk ml it mg b gy mm mn l mo mp">del btc["Date"]</span></pre><p id="9504" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们展示我们的数据框:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="eb73" class="mk ml it mg b gy mm mn l mo mp">print(btc.head())</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c0f8f56790266c6844f427b1dbd49628.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/0*cfdmC_YayMVXNIUl"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="98d8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们绘制我们的时间序列数据。为此，让我们导入数据可视化库Seaborn和Matplotlib:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="d06e" class="mk ml it mg b gy mm mn l mo mp">import matplotlib.pyplot as plt</span><span id="667a" class="mk ml it mg b gy mq mn l mo mp">import seaborn as sns</span></pre><p id="4efe" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们使用Seaborn格式化我们的可视化:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="a08d" class="mk ml it mg b gy mm mn l mo mp">sns.set()</span></pre><p id="8a9b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">并使用Matplotlib标记y轴和x轴。我们还将旋转x轴上的日期，以便于阅读:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="f6df" class="mk ml it mg b gy mm mn l mo mp">plt.ylabel("BTC Price")</span><span id="dbbc" class="mk ml it mg b gy mq mn l mo mp">plt.xlabel("Date")</span><span id="8949" class="mk ml it mg b gy mq mn l mo mp">plt.xticks(rotation=45)</span></pre><p id="425f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，用Matplotlib生成我们的图:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="4725" class="mk ml it mg b gy mm mn l mo mp">plt.plot(btc.index, btc["BTC-USD"], )</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/b7a03718bc8cb94efdaac160b201d69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*82TpjQXrrOi8oy-V"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="6aa9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，我们可以着手建立我们的第一个时间序列模型，自回归移动平均线。</p><p id="3caa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">分割数据用于训练和测试</strong></p><p id="61da" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">模型构建的一个重要部分是拆分我们的数据用于训练和测试。为训练和测试拆分数据可确保您构建的模型能够在训练数据之外进行归纳，并确保性能和输出在统计上有意义。</p><p id="843e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将拆分我们的数据，以便2020年11月之前的所有数据都将用作训练数据，2020年之后的所有数据都将成为测试数据:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="4f6c" class="mk ml it mg b gy mm mn l mo mp">train = btc[btc.index &lt; pd.to_datetime("2020–11–01", format="%Y-%m-%d")]</span><span id="0ccb" class="mk ml it mg b gy mq mn l mo mp">test = btc[btc.index &gt; pd.to_datetime("2020–11–01", format="%Y-%m-%d")]</span><span id="1112" class="mk ml it mg b gy mq mn l mo mp">plt.plot(train, color = "black")</span><span id="b96a" class="mk ml it mg b gy mq mn l mo mp">plt.plot(test, color = "red")</span><span id="3591" class="mk ml it mg b gy mq mn l mo mp">plt.ylabel("BTC Price")</span><span id="f557" class="mk ml it mg b gy mq mn l mo mp">plt.xlabel("Date")</span><span id="da83" class="mk ml it mg b gy mq mn l mo mp">plt.xticks(rotation=45)</span><span id="8cef" class="mk ml it mg b gy mq mn l mo mp">plt.title("Train/Test split for BTC Data")</span><span id="8eaa" class="mk ml it mg b gy mq mn l mo mp">plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nj"><img src="../Images/bbc071ea55d959aad1615f0b9f6eef3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yaW9awhq5Y9P4xkH"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="2972" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">自回归移动平均(ARMA) </strong></p><p id="a052" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">ARMA中的术语“自回归”是指模型使用过去的值来预测未来的值。具体来说，预测值是过去值的加权线性组合。这种回归方法类似于线性回归，不同之处在于此处的要素输入是历史值。</p><p id="6269" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">移动平均指的是由白噪声项的加权线性组合表示的预测，其中白噪声是随机信号。这里的想法是，ARMA使用过去值和白噪声的组合来预测未来值。自回归模型模拟市场参与者的行为，如买卖BTC。白噪音模型震惊事件，如战争、经济衰退和政治事件。</p><p id="3864" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以使用SARIMAX包定义ARMA模型:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="c090" class="mk ml it mg b gy mm mn l mo mp">from statsmodels.tsa.statespace.sarimax import SARIMAX</span></pre><p id="5297" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们定义我们的输入:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="c34b" class="mk ml it mg b gy mm mn l mo mp">y = train["BTC-USD"]</span></pre><p id="3f77" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后让我们定义我们的模型。为了用SARIMAX类定义ARMA模型，我们传入(1，0，1)的顺序参数:</p><p id="8d68" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">ARMAmodel = SARIMAX(y，order = (1，0，1))</p><p id="7c41" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后我们可以拟合我们的模型:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="995c" class="mk ml it mg b gy mm mn l mo mp">ARMAmodel = ARMAmodel.fit()</span></pre><p id="60da" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">生成我们的预测:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="359c" class="mk ml it mg b gy mm mn l mo mp">y_pred = ARMAmodel.get_forecast(len(test.index))</span><span id="640f" class="mk ml it mg b gy mq mn l mo mp">y_pred_df = y_pred.conf_int(alpha = 0.05)</span><span id="2c16" class="mk ml it mg b gy mq mn l mo mp">y_pred_df["Predictions"] = ARMAmodel.predict(start = y_pred_df.index[0], end = y_pred_df.index[-1])</span><span id="0f6b" class="mk ml it mg b gy mq mn l mo mp">y_pred_df.index = test.index</span><span id="4569" class="mk ml it mg b gy mq mn l mo mp">y_pred_out = y_pred_df["Predictions"]</span></pre><p id="36cc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">并绘制结果:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="40e8" class="mk ml it mg b gy mm mn l mo mp">plt.plot(y_pred_out, color="green", label = "Predictions")</span><span id="5a03" class="mk ml it mg b gy mq mn l mo mp">plt.legend()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/7ac0170d253b087f84f9c091325dde0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pnlPS_vKDn0q5rSB"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="3648" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们还可以使用均方根误差来评估性能:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="ca94" class="mk ml it mg b gy mm mn l mo mp">import numpy as np</span><span id="01d1" class="mk ml it mg b gy mq mn l mo mp">from sklearn.metrics import mean_squared_error</span><span id="6dcf" class="mk ml it mg b gy mq mn l mo mp">arma_rmse = np.sqrt(mean_squared_error(test["BTC-USD"].values, y_pred_df["Predictions"]))</span><span id="e06e" class="mk ml it mg b gy mq mn l mo mp">print("RMSE: ",arma_rmse)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/650bbb698a320a20acf69928893704db.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/0*Ri4izQ8admv9Rzpk"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="f122" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">RMSE相当高，这一点我们在考察地块时就已经猜到了。不幸的是，当价格实际上升时，模型预测价格会下降。同样，ARMA的局限性在于它不适用于非平稳的时间序列，并且不能捕捉季节性。让我们看看我们是否能提高ARIMA的表现</p><p id="094b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">自回归综合移动平均线(ARIMA) </strong></p><p id="baf1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们从统计库导入ARIMA包:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="d778" class="mk ml it mg b gy mm mn l mo mp">from statsmodels.tsa.arima.model import ARIMA</span></pre><p id="6002" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">ARIMA任务有三个参数。第一个参数对应于滞后(过去的值)，第二个对应于差分(这使得非平稳数据平稳)，最后一个参数对应于白噪声(用于模拟冲击事件)。</p><p id="39a4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们用顺序参数(2，2，2)定义一个ARIMA模型:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="bd7e" class="mk ml it mg b gy mm mn l mo mp">ARIMAmodel = ARIMA(y, order = (2, 2, 2))</span><span id="8cbd" class="mk ml it mg b gy mq mn l mo mp">ARIMAmodel = ARIMAmodel.fit()</span><span id="915c" class="mk ml it mg b gy mq mn l mo mp">y_pred = ARIMAmodel.get_forecast(len(test.index))</span><span id="ed18" class="mk ml it mg b gy mq mn l mo mp">y_pred_df = y_pred.conf_int(alpha = 0.05)</span><span id="83ef" class="mk ml it mg b gy mq mn l mo mp">y_pred_df[“Predictions”] = ARIMAmodel.predict(start = y_pred_df.index[0], end = y_pred_df.index[-1])</span><span id="43b9" class="mk ml it mg b gy mq mn l mo mp">y_pred_df.index = test.index</span><span id="a064" class="mk ml it mg b gy mq mn l mo mp">y_pred_out = y_pred_df["Predictions"]</span><span id="35c6" class="mk ml it mg b gy mq mn l mo mp">plt.plot(y_pred_out, color="Yellow", label = "ARIMA Predictions")</span><span id="77ff" class="mk ml it mg b gy mq mn l mo mp">plt.legend()</span><span id="5072" class="mk ml it mg b gy mq mn l mo mp">import numpy as np</span><span id="9976" class="mk ml it mg b gy mq mn l mo mp">from sklearn.metrics import mean_squared_error</span><span id="0e3b" class="mk ml it mg b gy mq mn l mo mp">arma_rmse = np.sqrt(mean_squared_error(test["BTC-USD"].values, y_pred_df["Predictions"]))</span><span id="0359" class="mk ml it mg b gy mq mn l mo mp">print("RMSE: ",arma_rmse)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/a62b7549ed517cf2ff28e66536a1d1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gGQxHJtVL4gkrXpA"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="b23a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们看到ARIMA预测(黄色)落在ARMA预测之上。让我们尝试将差分参数增加到ARIMA (2，3，2):</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nn"><img src="../Images/d123d3a01b4758295ef97ee7503595a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R1jW1UmOfpoEPzsf"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="1a50" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们看到这有助于捕捉价格上涨的方向。让我们试着用ARIMA(5，4，2)更进一步地玩参数:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/114b64b06e264d00db521245374ac8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9EwokFG3vIGANdoq"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="9cfa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们有一个793的RMSE，比ARMA好。</p><p id="7604" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，让我们看看纳入季节性的SARIMA是否会进一步提高性能。</p><p id="77b9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">季节性ARIMA(萨里玛)</strong></p><p id="d0b2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">季节性ARIMA捕捉历史价值、冲击事件和季节性。我们可以使用SARIMAX类定义一个SARIMA模型:</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="24c0" class="mk ml it mg b gy mm mn l mo mp">SARIMAXmodel = SARIMAX(y, order = (5, 4, 2), seasonal_order=(2,2,2,12))</span><span id="f57b" class="mk ml it mg b gy mq mn l mo mp">SARIMAXmodel = SARIMAXmodel.fit()</span><span id="1b74" class="mk ml it mg b gy mq mn l mo mp">y_pred = SARIMAXmodel.get_forecast(len(test.index))</span><span id="0681" class="mk ml it mg b gy mq mn l mo mp">y_pred_df = y_pred.conf_int(alpha = 0.05)</span><span id="bad2" class="mk ml it mg b gy mq mn l mo mp">y_pred_df["Predictions"] = SARIMAXmodel.predict(start = y_pred_df.index[0], end = y_pred_df.index[-1])</span><span id="9aa8" class="mk ml it mg b gy mq mn l mo mp">y_pred_df.index = test.index</span><span id="3df4" class="mk ml it mg b gy mq mn l mo mp">y_pred_out = y_pred_df["Predictions"]</span><span id="01cc" class="mk ml it mg b gy mq mn l mo mp">plt.plot(y_pred_out, color="Blue", label = "SARIMA Predictions")</span><span id="aa45" class="mk ml it mg b gy mq mn l mo mp">plt.legend()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/d03531a068bd65519997df426fdf856b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iUFA1Lbm2KHItWNL"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="4940" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里我们有一个966的RMSE，比ARIMA稍差。这可能是由于缺少超参数调整。如果我们试验一下SARIMA模型的参数，我们应该能够进一步提高性能。</p><p id="260a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我鼓励你尝试一下超参数，看看你是否能建立一个胜过ARIMA的萨里玛模型。此外，您可以使用网格搜索等方法，通过算法为每个模型找到最佳参数。</p><p id="171e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这篇文章的代码可以在<a class="ae lh" href="https://github.com/spierre91/builtiin/blob/main/time_series_forecasting.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="627b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd">结论</strong></p><p id="db4a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">时间序列预测是许多数据科学团队跨行业面临的一项常见任务。掌握常用工具和方法的可靠知识将使数据科学家能够快速运行新的实验并生成结果。了解每个模型中参数的重要性，如滞后参数、差分、白噪声和季节性，可以为建立简单的时间序列模型奠定基础。这也为理解一些更高级的技术提供了良好的基础。</p><p id="df6c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">能够准确可靠地预测未来事件是一项有价值的技能，在加密货币和传统金融市场之外也有应用。尽管如此，对于任何数据科学家来说，不管他们从事什么行业，熟悉基础知识都是有用的。Python提供了一些库，使数据科学家初学者能够轻松开始学习如何实现时间序列预测模型。</p><p id="13e9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你有兴趣学习python编程的基础知识、Pandas的数据操作以及python中的机器学习，请查看<a class="ae lh" href="https://www.amazon.com/dp/B08N38XW2Q/ref=sr_1_1?dchild=1&amp;keywords=sadrach+python&amp;qid=1604966500&amp;s=books&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"><em class="nq">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="nq">。我希望你觉得这篇文章有用/有趣。</em></p><p id="164e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd"> <em class="nq">本帖原载于</em> </strong> <a class="ae lh" href="https://builtin.com/data-science" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> <em class="nq">内置博客</em> </strong> </a> <strong class="ll jd"> <em class="nq">。原片可以在这里找到</em></strong><a class="ae lh" href="https://builtin.com/data-science/time-series-forecasting-python" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"><em class="nq"/></strong></a><strong class="ll jd"><em class="nq">。</em>T29】</strong></p></div></div>    
</body>
</html>