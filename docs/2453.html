<html>
<head>
<title>Tabibitosan for Consecutive SQL problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连续SQL问题的Tabibitosan</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/tabibitosan-for-consecutive-sql-problems-52c8159f7090?source=collection_archive---------3-----------------------#2021-12-31">https://pub.towardsai.net/tabibitosan-for-consecutive-sql-problems-52c8159f7090?source=collection_archive---------3-----------------------#2021-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ed89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将您从痛苦的交叉连接和滞后/超前窗口功能中解救出来</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6302d19650be536bd63589276e59c5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*flAM409AhpgFWdPV"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@abnair?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿斯瓦西N </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="990f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊讶的是，谷歌搜索“tabibitosan sql”只返回几年前文章的链接。尽管自从Oracle 12c以来，<code class="fe lv lw lx ly b">match_recognize</code>已经可以取代tabibitosan方法，但我认为提高对这种技术的认识仍然是有价值的，不仅可以解决非Oracle SQL风格的问题，更重要的是可以培养一般的问题解决技能。</p><h1 id="6a6d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">谁至少连续3天参加活动？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/cd4152dec84879396b997f620e557028.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*2-Ve4Fcm1ZfAyOOhkzunXA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="4e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据显示，我们有3个人tom、jerry和nibbles在2020年1月下旬左右参加了一次活动。</p><p id="aede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是能够确定Tom(1月20日至22日)和Jerry(1月23日至26日)至少连续3天参加了活动，而nibbles没有。</p><h2 id="676b" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">这项技术</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="3df6" class="ms ma it ly b gy ni nj l nk nl">select <br/>      name,<br/>      joindate,<br/>      row_number() over(partition by name order by joindate),<br/>      joindate - row_number() over(partition by name order by joindate)::int grp<br/>from event</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1e0b8c99ea136ac98a7679f464c73295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*Wcf9DLrjYDeUoxiinyk_kQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="27fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该技术旨在创建一个新的分组列(grp ),我们可以用它来回答这个问题。查看grp，我们看到它包含2020年1月21日的4个副本，标记jerry连续参加的4天。我们还看到2020年1月19日的三个副本，标记汤姆连续参加的三天。对于jerry在2020年1月21日的非连续访问，它有自己的grp值。类似地，对于nibbles的唯一访问和tom在2020年1月24日的非连续访问。</p><p id="0890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“派生的grp”列中日期的确切值根本不重要。该技术的目标是创建一列值(任何类型),其中包含我们所关心的相同值(对于该问题为连续事件访问)和我们想要划分的边界的不同值(非连续事件访问)。</p><h2 id="7cf7" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">这是什么魔法？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8cd972736ec953ff48cc115b5813d344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0VlpHDT9g0ufJ36a"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dollargill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">美元吉尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="36fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个技术归结为SELECT中的这一行<code class="fe lv lw lx ly b">joindate - row_number() over(partition by name order by joindate)::int grp</code>。</p><p id="4bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减法运算有两个操作数。左操作数是一个值，有时增加1个单位，有时增加超过1个单位。右边的操作数是一个自动生成的行号(在它自己的每个分区中)，始终增加1个单位。总的来说，左操作数有机会比右操作数移动得更快。</p><p id="81fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">沿着grp列中的行往下看(差值的结果)，当天数连续时，两个操作数以1个单位的相同速度增加，因此它们的差值保持不变。但是，当日期不连续时，左操作数(暂时)比右操作数移动得快，导致它们的差值变为新的增加值。</p><p id="948b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次强调，这个值是什么，一点也不重要。上面的查询对生成的row_number()进行了<code class="fe lv lw lx ly b">::int</code>整数转换，仅仅是为了处理<code class="fe lv lw lx ly b">operator does not exist: date - bigint</code>，因此差异是可能的。您可能需要进行其他您认为合适的转换，以使这项技术发挥作用。</p><p id="a37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，当这种技术用于分区时，grp列不一定单调增加，相同的grp值可以出现在不同的分区中。(2020–01–20分别出现在jerry和tom的第一行和最后一行)。如果我们想进行下游分析，我们必须小心，不仅要用grp列进行分组，通常还要用分区列(本例中为name)进行分组。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="6d42" class="ms ma it ly b gy ni nj l nk nl">WITH tbb as ( <br/>  select <br/>      name,<br/>      joindate,<br/>      row_number() over(partition by name order by joindate),<br/>      joindate - row_number() over(partition by name order by joindate)::int grp<br/>  from event<br/>)<br/>SELECT <br/> DISTINCT name<br/>FROM tbb<br/>GROUP BY name,grp<br/>HAVING COUNT(*) &gt;= 3</span></pre><p id="2d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><p id="9a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">姓名<br/>————<br/>汤姆<br/>杰瑞</p><p id="5cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地将前面的查询包装在一个CTE中，并查询多于或等于3行的组。选择不同的名称对于消除由于同一个人连续出现多个符合having条件的重复名称非常重要。对此的另一种观点是，最终的GROUP BY作用于(name，grp ),因此如果只查看name列，可能会有重复项。</p><p id="41a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敏锐的读者现在应该意识到，这个解决方案不仅仅局限于解决问题3，也不仅仅适用于<code class="fe lv lw lx ly b">&gt;=</code>算子。</p><h1 id="61d7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">问题:列出每个人连续就诊时间最长的行</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/ded545fbbe2246325f8df41ad3ec8fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nuOaNER-AoS2CFcx"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kaysha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kaysha </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="92fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一分耕耘一分收获，之前的问题太简单了，让我们扩展一下。</p><h2 id="131c" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">生成一些统计数据</h2><p id="f72b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了能够过滤具有最长条纹的行，首先计算一些关于哪些行是最长条纹的一部分的统计数据是有帮助的。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="01f2" class="ms ma it ly b gy ni nj l nk nl">WITH tbb as (<br/>  select <br/>      name,<br/>      joindate,<br/>      row_number() over(partition by name order by joindate),<br/>      joindate - row_number() over(partition by name order by joindate)::int grp<br/>  from event<br/>),<br/>count_stats AS ( <br/>  select <br/>    *,<br/>    COUNT(*) over(partition by name,grp order by joindate rows BETWEEN unbounded preceding and unbounded following) cnt<br/>  from tbb <br/>)<br/>SELECT * FROM count_stats</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/11334800033dada3f2eadc09a24b64b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*FbGBF68lPOS7v-6zbOgTUA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="bce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述查询的关键技术是将窗口函数的框架从默认的<code class="fe lv lw lx ly b">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>扩展到两个方向都是无界的，这样我们就可以计算整个组的统计数据。这里的分区是多级的，由name和grp列定义。</p><p id="4d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于不熟悉窗口功能的人来说，这一步也可以通过通常的<code class="fe lv lw lx ly b">GROUP BY name, grp</code>来实现，然后将<code class="fe lv lw lx ly b">cnt</code>统计数据重新加入到这个表中。我展示无界窗口函数只是为了让读者了解其他选择。</p><h2 id="53bb" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">过滤行</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f8a0" class="ms ma it ly b gy ni nj l nk nl">WITH tbb as (<br/>  select <br/>      name,<br/>      joindate,<br/>      row_number() over(partition by name order by joindate),<br/>      joindate - row_number() over(partition by name order by joindate)::int grp<br/>  from event<br/>),<br/>count_stats AS ( <br/>  select <br/>    *,<br/>    COUNT(*) over(partition by name,grp order by joindate rows BETWEEN unbounded preceding and unbounded following) cnt<br/>  from tbb <br/>),<br/>longest_streak AS (<br/>  SELECT name, max(cnt) max_cnt<br/>  FROM count_stats<br/>  GROUP BY name<br/>)<br/>SELECT * From count_stats cs join longest_streak ls on cs.name = ls.name and cs.cnt = ls.max_cnt</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/0e97c18d95a73bb0e2775a5523bb4cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO4Eo_JXm4ieySXuTrlXFQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="f490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以再通过两步来得到答案，通过计算每个名字的longest_streak来生成<code class="fe lv lw lx ly b">max_cnt</code>，然后使用一个连接来过滤上一步的数据。</p><p id="b12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此解决方案找到了导致人均最大条纹数的所有行，但没有确定它在哪个条纹中。假设相同的最大条纹出现多次，通过查找第一个、最后一个或第n个最大条纹的行，问题会变得更加困难。</p><h2 id="361e" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">用这种超能力你还能解决什么</h2><ol class=""><li id="c05f" class="nw nx it lb b lc np lf nq li ny lm nz lq oa lu ob oc od oe bi translated">每组的第一天和最后一天</li><li id="74bd" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">连续跑了多少次</li></ol><h1 id="46f3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">不知道Tabibitosan，原问题怎么解？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c58ef6d993c5ade795c00071d4652a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*efYrQXY2cGMM_M4K"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乔纳森·博尔巴在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题:谁至少连续3天出席活动？</strong></p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="beda" class="ms ma it ly b gy ni nj l nk nl">SELECT <br/>name,<br/>    joindate,<br/>    joindate-'2020-01-01' for_making_range_work,<br/>    COUNT(*) over(partition by name order by joindate-'2020-01-01' range between 2 preceding and current row)<br/>FROM event</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/88fd97f60aff2eac9be4b3b1ad4e921d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWi6C8a9CLXU3HZHYhyCFA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="8472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用RANGE关键字从当前行到当前行(包括当前行)回溯2天。如果我们数到3，那就意味着有一连串的3。如您所见，这个解决方案必须将查询中的值2硬编码为连续3天的答案，因此不如tabibitosan灵活。</p><h2 id="f08f" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">行数与范围</h2><p id="c2c1" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如果您在前面的例子中尝试使用行作为窗口，将会产生误报。行只计算物理行数，而不关心行中的值。RANGE查看单元格中的值，并向前和向后查看，在两个方向上扩展窗口框架，同时列中的值(按“超过”的顺序排列)仍在相对于当前行的值的范围内。</p><h2 id="2d86" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">细枝末节</h2><p id="9a85" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated"><code class="fe lv lw lx ly b">joindate-'2020-01-01'</code>只是为了处理<code class="fe lv lw lx ly b">RANGE with offset PRECEDING/FOLLOWING is not supported for column type date and offset type integer HINT: Cast the offset value to an appropriate type</code>而做的。令我惊喜的是，Postgres实际上告诉你如何破解数据类型来使它工作。选择<code class="fe lv lw lx ly b">2020-01-01</code>完全是任意的。任何日期都可以，目标是将日期转换为整数，以便定义的偏移量(在本例中向后2个值，向前0个值)可以在整数窗口排序列上工作。其他数据库可能能够直接处理日期偏移。</p><h1 id="2ce2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">不知道Tabibitosan或者Window函数，怎么解原问题？</h1><p id="6c93" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">这个解决方案和之前的解决方案一样是静态的，没有使用Tabibitosan，但是有一个窗口函数，但是编写起来更加繁琐。</p><ol class=""><li id="fa84" class="nw nx it lb b lc ld lf lg li om lm on lq oo lu ob oc od oe bi translated">自连接3个表，写出定义连续性的条件</li><li id="9aeb" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">生成另外4列，(lag2，lag1，lead1，lead2)并基于它们进行筛选</li></ol><h1 id="81dc" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">相关链接</h1><p id="a9f3" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我只展示了冰山一角，下面是一些有用的链接:</p><ol class=""><li id="9efb" class="nw nx it lb b lc ld lf lg li om lm on lq oo lu ob oc od oe bi translated"><a class="ae ky" href="https://towardsdatascience.com/top-sql-interview-test-questions-techniques-part-1-971bdccc745c" rel="noopener" target="_blank">https://towards data science . com/top-SQL-interview-test-questions-techniques-part-1-971 bdccc 745 c</a>(交叉连接和滞后，引导模式，对练习连接条件有价值)</li><li id="0caa" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">http://rwijk.blogspot.com/2014/01/tabibitosan.html<a class="ae ky" href="http://rwijk.blogspot.com/2014/01/tabibitosan.html" rel="noopener ugc nofollow" target="_blank">(在tabibitosan中交换谁跑得快/谁跑得慢，改变时间序列的粒度，向前/向后填充空值)</a></li><li id="e354" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://community.oracle.com/tech/developers/discussion/4417554/pl-sql-101-grouping-sequence-ranges-tabibitosan-method" rel="noopener ugc nofollow" target="_blank">https://community . Oracle . com/tech/developers/discussion/4417554/pl-SQL-101-grouping-sequence-ranges-tabi tosan-method</a>(更多tabi tosan，用<code class="fe lv lw lx ly b">dense_rank()</code>代替<code class="fe lv lw lx ly b">row_number()</code>处理重复项)</li><li id="54b3" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://social.technet.microsoft.com/wiki/contents/articles/51523.transactsql-simulating-ignore-nulls-functionality-on-first-value-last-value-functions.aspx" rel="noopener ugc nofollow" target="_blank">https://social . TechNet . Microsoft . com/wiki/contents/articles/51523 . transact sql-simulating-ignore-nulls-functionality-on-first-value-last-value-functions . aspx</a>(通用SQL数据操作技巧)</li><li id="d6b0" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://blog.jooq.org/10-sql-tricks-that-you-didnt-think-were-possible/" rel="noopener ugc nofollow" target="_blank">https://blog . jooq . org/10-sql-tricks-that-you-not-think-be-possible/</a>(更多SQL操作技巧)</li><li id="9b10" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://learnsql.com/blog/range-clause/" rel="noopener ugc nofollow" target="_blank">https://learnsql.com/blog/range-clause/</a>(实际使用范围，链接备忘单非常好)</li><li id="c858" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://sonra.io/data-warehouse/window-function-rows-and-range-on-redshift-and-bigquery/" rel="noopener ugc nofollow" target="_blank">https://sonra . io/data-warehouse/window-function-rows-and-RANGE-on-redshift-and-big query/</a>(更多范围)</li><li id="0c3d" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/47908423/db2-sql-finding-rows-with-a-gap-of-1-minute-with-other-rows" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/47908423/DB2-SQL-finding-rows-with a-gap-of-1-minute-other-rows</a>(自我测试的新挑战，不仅要跨行进行比较，还要跨列进行比较)</li></ol><h1 id="4392" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">本文的代码:</h1><p id="07bf" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在Postgres 14.1中创建了关于www.sqliteonline.com的例子。sqlfiddle.com<a class="ae ky" href="http://sqlfiddle.com" rel="noopener ugc nofollow" target="_blank"/>共享SQL片段会更容易，但他们的SQL引擎太旧了，无法处理可变的窗口框架。</p><h2 id="37c7" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">桌子摆好了</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e557" class="ms ma it ly b gy ni nj l nk nl">CREATE TABLE event(name varchar, joindate date);<br/>INSERT into event(name, joindate) values <br/>('tom','2020-01-20'),<br/>('tom','2020-01-21'),<br/>('tom','2020-01-22'),<br/>('tom','2020-01-24'),<br/>('jerry','2020-01-21'),<br/>('jerry','2020-01-23'),<br/>('jerry','2020-01-24'),<br/>('jerry','2020-01-25'),<br/>('jerry','2020-01-26'),<br/>('nibbles','2020-01-26')</span></pre><h2 id="cbbe" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">谁至少连续3天参加活动？</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="5839" class="ms ma it ly b gy ni nj l nk nl">WITH tbb as ( <br/>  select <br/>      name,<br/>      joindate,<br/>      row_number() over(partition by name order by joindate),<br/>      joindate - row_number() over(partition by name order by joindate)::int grp<br/>  from event<br/>)<br/>SELECT <br/> DISTINCT name<br/>FROM tbb<br/>GROUP BY name,grp<br/>HAVING COUNT(*) &gt;= 3</span></pre><h2 id="ad6e" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">列出每个人连续就诊时间最长的行</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="ccb9" class="ms ma it ly b gy ni nj l nk nl">WITH tbb as (<br/>  select <br/>      name,<br/>      joindate,<br/>      row_number() over(partition by name order by joindate),<br/>      joindate - row_number() over(partition by name order by joindate)::int grp<br/>  from event<br/>),<br/>count_stats AS ( <br/>  select <br/>    *,<br/>    COUNT(*) over(partition by name,grp order by joindate rows BETWEEN unbounded preceding and unbounded following) cnt<br/>  from tbb <br/>),<br/>longest_streak AS (<br/>  SELECT name, max(cnt) max_cnt<br/>  FROM count_stats<br/>  GROUP BY name<br/>)<br/>SELECT * From count_stats cs join longest_streak ls on cs.name = ls.name and cs.cnt = ls.max_cnt</span></pre><h2 id="d216" class="ms ma it bd mb mt mu dn mf mv mw dp mj li mx my ml lm mz na mn lq nb nc mp nd bi translated">无tabibitosan，硬编码窗口大小</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f132" class="ms ma it ly b gy ni nj l nk nl">SELECT <br/>name,<br/>    joindate,<br/>    joindate-'2020-01-01' for_making_range_work,<br/>    COUNT(*) over(partition by name order by joindate-'2020-01-01' range between 2 preceding and current row)<br/>FROM event</span></pre></div></div>    
</body>
</html>