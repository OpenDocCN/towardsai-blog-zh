<html>
<head>
<title>Why Map(), Filter() And Reduce() Functions are so Famous?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Map()、Filter()和Reduce()函数这么出名？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/why-map-filter-and-reduce-functions-are-so-famous-4c8e42fd0755?source=collection_archive---------0-----------------------#2021-06-01">https://pub.towardsai.net/why-map-filter-and-reduce-functions-are-so-famous-4c8e42fd0755?source=collection_archive---------0-----------------------#2021-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="efc7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="0290" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">python中避免循环和分支的函数式编程</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b5887367b2e9b8aa4402bce2d8e8f8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NNhH-BJ5gcAgqE1f"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@ricaros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·伊德里</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f9e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在python中，许多内置函数允许用户编写简单明了的代码，而不用担心循环和分支。这些函数中的一个被称为λ函数。</p><blockquote class="me mf mg"><p id="5796" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">什么是λ函数？</em>T9】</strong></p></blockquote><p id="741d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Lambda函数是没有名称的单行函数，可以有任意数量的参数，但只能包含一个表达式。Lambda函数类似于python def函数。“def”被定义为匿名函数，而lambda被认为是一次性函数。</p><p id="d552" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">语法:</strong> (lambda参数:表达式)</p><blockquote class="me mf mg"><p id="66c1" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">我们为什么要使用lambda函数？</em>T15】</strong></p></blockquote><p id="305b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在python中，编写函数是一项简单的任务。但是将这些功能结合在一个应用程序中是它变得如此沉重的地方。</p><p id="6aff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在应用程序中使用函数时，它们会很长，因此编译器也会花费额外的时间来执行每一行代码，尽管python简单易读。</p><p id="3daf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果有一种方法可以让这些函数变得易读和简短呢？这就是lambda函数发挥作用的地方。Lambda减小了程序的大小，使得执行程序的效率大大提高。</p><blockquote class="me mf mg"><p id="7d8a" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">如何使用python使用lambda函数？</em>T19】</strong></p></blockquote><p id="458a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">lambda函数由3部分组成:</p><ol class=""><li id="9720" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mq mr ms mt bi translated"><strong class="lk jd">关键词:</strong>λ</li><li id="6119" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mq mr ms mt bi translated"><strong class="lk jd">绑定变量:</strong>这个绑定变量是lambda函数的一个参数。</li><li id="b212" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mq mr ms mt bi translated"><strong class="lk jd">表达式:</strong>该部分包含我们需要执行的约束。</li></ol><p id="eda7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下示例显示了该函数的三个部分:</p><p id="72cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">例</strong>:<strong class="lk jd"/>λa:a+1</p><p id="3705" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们通过一个例子来看看普通函数和lambda函数之间的区别:</p><ol class=""><li id="b143" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mq mr ms mt bi translated"><strong class="lk jd">使用“匿名函数”和“lambda函数”打印奇数列表</strong></li></ol><ul class=""><li id="492f" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">匿名函数(不使用lambda的函数):</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="81ee" class="nf ng it nb b gy nh ni l nj nk">def odd(n):<br/>    return n%3 ==0</span><span id="17fe" class="nf ng it nb b gy nl ni l nj nk">Numbers = [23,22,16,28,14,36,12,99]<br/>even = list(filter(odd, Numbers))<br/>print(odd)</span></pre><ul class=""><li id="0cbb" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">λ函数:</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="b052" class="nf ng it nb b gy nh ni l nj nk">Numbers = [23,22,16,28,14,36,12,99]<br/>odd = list(filter(lambda n : n%3 == 0, Numbers))<br/>print(odd)</span><span id="5959" class="nf ng it nb b gy nl ni l nj nk"><strong class="nb jd">Output :<br/></strong>[23,15,13,37,99]</span></pre><h2 id="70c7" class="nf ng it bd nm nn no dn np nq nr dp ns lr nt nu nv lv nw nx ny lz nz oa ob iz bi translated"><strong class="ak">解释:</strong></h2><p id="3713" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">在程序的第一步，我们声明一个数字列表作为输入。在下一步中，我们使用lambda函数来查找偶数列表。这个函数是根据语法写的。</p><p id="6778" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数的第一部分包含关键字。第二部分提到参数，最后是表达式。这里正常函数和lambda函数的区别是:</p><ol class=""><li id="87b8" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mq mr ms mt bi translated">lambda函数计算单个表达式并产生一个函数对象，而“标准函数”可以计算多个表达式。</li><li id="05c7" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mq mr ms mt bi translated">lambda函数不包含return语句。默认情况下，它总是返回表达式的输出，而标准函数则由return语句组成。</li></ol><p id="43ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从这两个程序中，我们可以得出结论，lambda函数使得程序更加高效和易读。</p><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-list-as-big-o-and-comprehension-with-python-examples-cbea610c9e43"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">将List理解为Big O并理解Python示例</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">列表是python数据结构的一部分</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">pub.towardsai.net</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy lb ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/oops-concept-in-python-b5f5833d57db"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jd gy z fp op fr fs oq fu fw jc bi translated">Python中的OOPs概念</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">OOPs是编写程序的一种高效方式</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">pub.towardsai.net</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy lb ok"/></div></div></a></div><blockquote class="me mf mg"><p id="f821" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">内置函数使用λ</em></strong></p></blockquote><p id="ff61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在知道λ函数使</p><p id="5c31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有许多使用lambda的内置函数。这里，我们将只讨论3个函数:map()、filter()和reduce()。这三个函数为python带来了函数式编程的一小部分，为一些问题提供了更优雅和简便的方法。</p><ol class=""><li id="cc6a" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mq mr ms mt bi translated"><strong class="lk jd">滤镜()</strong></li></ol><p id="d7e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顾名思义，filter()创建了一个新的列表，其中只包含满足我们提供的条件<strong class="lk jd">的元素。</strong></p><p id="7378" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">语法:</strong> filter(函数，iterable(s))</p><p id="d6b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">程序:</strong></p><p id="a333" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用同一个例子来比较标准函数和lambda函数。</p><ul class=""><li id="71c9" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">只打印奇数的列表，有和没有lambda函数。</strong></li><li id="a414" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mz mr ms mt bi translated"><strong class="lk jd">匿名函数(不使用lambda的函数):</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="48d5" class="nf ng it nb b gy nh ni l nj nk">def odd(n):<br/>    return n%3 == 0</span><span id="39b4" class="nf ng it nb b gy nl ni l nj nk">Numbers = [23,22,19,26,33,55,64,67]<br/>odd = list(filter(odd, Number))<br/>print(odd)</span></pre><ul class=""><li id="74f9" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">使用λ的过滤功能:</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="8a9a" class="nf ng it nb b gy nh ni l nj nk">Numbers = [23,22,19,26,33,55,64,67]<br/>odd = list(filter(lambda n : n%3 == 0, Numbers))<br/>print(odd)</span><span id="5429" class="nf ng it nb b gy nl ni l nj nk"><strong class="nb jd">Output :<br/></strong>[23,19,33,55,67]</span></pre><h2 id="01de" class="nf ng it bd nm nn no dn np nq nr dp ns lr nt nu nv lv nw nx ny lz nz oa ob iz bi translated"><strong class="ak">说明:</strong></h2><p id="2298" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">在匿名函数中，我们将函数命名为“odd ”,并添加了我们想要的约束作为输出。这个函数在程序的第四行被调用。然而，在使用lambda时，我们不会面临这么多的复杂问题。lambda函数及其操作在主体内执行。我们可以看到lambda函数是如何使它变得更加简单的。</p><p id="846e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2。地图()</strong></p><p id="301f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">map函数遍历给定iterable中的所有元素，并通过我们传递的参数执行函数。</p><p id="c82b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">语法:</strong> map(函数，iterable(s))</p><p id="00cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">程序:</strong></p><p id="c077" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用同一个例子来比较标准函数和lambda函数。</p><ul class=""><li id="0380" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">打印一个只有奇数的双数列表，有和没有lambda函数。</strong></li><li id="d300" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mz mr ms mt bi translated"><strong class="lk jd">匿名函数(不使用lambda的映射函数):</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="b0e6" class="nf ng it nb b gy nh ni l nj nk">def update(n):<br/>    return n*2</span><span id="f35b" class="nf ng it nb b gy nl ni l nj nk">Numbers = [23,22,19,26,33,55,64,67]<br/>odd = list(filter(lambda n : n%3 == 0, nums))<br/>doubles = list(map(update, odd))</span><span id="7fd2" class="nf ng it nb b gy nl ni l nj nk">print(doubles)</span></pre><ul class=""><li id="939d" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">使用lambda映射功能:</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="e9e8" class="nf ng it nb b gy nh ni l nj nk">Numbers = [23,22,19,26,33,55,64,67]<br/>odd = list(filter(lambda n : n%3 == 0, nums))<br/>doubles = list(map(lambda n : n*2, odd))</span><span id="f9c0" class="nf ng it nb b gy nl ni l nj nk">print(doubles)</span><span id="f8ea" class="nf ng it nb b gy nl ni l nj nk"><strong class="nb jd">Output :<br/></strong>[46,38,66,110,134]</span></pre><h2 id="f017" class="nf ng it bd nm nn no dn np nq nr dp ns lr nt nu nv lv nw nx ny lz nz oa ob iz bi translated"><strong class="ak">解释:</strong></h2><p id="32f4" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">与上面的过滤器示例一样，匿名函数和lambda函数遵循相同的原则。映射是一个概念，它根据规定的可重复项来映射值。所以这里只把奇数乘以“2”，以列表的形式返回作为输出。</p><p id="a268" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3。Reduce() </strong></p><p id="6087" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Reduce函数不同于map()和filter()。根据我们传递的函数和iterables，它只返回一个值。</p><p id="488f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">语法:</strong> reduce(函数，序列[，初始])</p><p id="3530" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">程序:</strong></p><p id="33d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用同一个例子来比较标准函数和lambda函数。</p><ul class=""><li id="8c6c" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">打印包含和不包含lambda函数的列表中所有奇数的和。</strong></li><li id="b21a" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mz mr ms mt bi translated"><strong class="lk jd">匿名函数(不使用lambda的函数):</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="ce95" class="nf ng it nb b gy nh ni l nj nk">def add_all(x,y):<br/>    return x+y</span><span id="e61f" class="nf ng it nb b gy nl ni l nj nk">Numbers = [23,22,19,26,33,55,64,67]<br/>odd = list(filter(lambda n : n%3 == 0, nums))<br/>sum = reduce(add_all, odd)</span><span id="5072" class="nf ng it nb b gy nl ni l nj nk">print(sum)</span></pre><ul class=""><li id="ad5c" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mz mr ms mt bi translated"><strong class="lk jd">使用lambda减少功能:</strong></li></ul><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="a5b6" class="nf ng it nb b gy nh ni l nj nk">from functools import reduce</span><span id="c04f" class="nf ng it nb b gy nl ni l nj nk">Numbers = [23,22,19,26,33,55,64,67]<br/>odd = list(filter(lambda n : n%3 == 0, nums))</span><span id="3621" class="nf ng it nb b gy nl ni l nj nk">print(odd)</span><span id="1be4" class="nf ng it nb b gy nl ni l nj nk">sum = reduce(lambda a,b : a+b, odd)<br/>print(sum)</span><span id="e496" class="nf ng it nb b gy nl ni l nj nk"><strong class="nb jd">Output :<br/></strong>[23,19,33,55,67]<br/>203</span></pre><h2 id="3765" class="nf ng it bd nm nn no dn np nq nr dp ns lr nt nu nv lv nw nx ny lz nz oa ob iz bi translated"><strong class="ak">说明:</strong></h2><p id="aa2c" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">众所周知，reduce函数总是返回一个值。所以，这个程序首先打印一个奇数列表。在这个列表中，从左端取两个值，并不断相加，直到没有剩余的值。</p><pre class="ks kt ku kv gt na nb nc nd aw ne bi"><span id="5ec9" class="nf ng it nb b gy nh ni l nj nk">[<strong class="nb jd">23,19</strong>,33,55,67]<br/>⇒ <strong class="nb jd">42,33</strong>,55,67<br/>⇒ <strong class="nb jd">75,55</strong>,67<br/>⇒ <strong class="nb jd">130,67</strong><br/>⇒ 197</span></pre><blockquote class="me mf mg"><p id="c497" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">结论</em> </strong></p></blockquote><p id="74b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总之，我们可以说lambda函数在编写程序时起着重要的作用。它们是为了我们的方便而使用的，因此我们的程序被压缩并显示相同的输出，而不是编写冗长乏味的代码。</p><p id="b46f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="2c7e" class="pa ng it bd nm pb pc pd np pe pf pg ns ki ph kj nv kl pi km ny ko pj kp ob pk bi translated">推荐文章</h1><p id="76ed" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/deep-learning-88e218b74a14?source=friends_link&amp;sk=540bf9088d31859d50dbddab7524ba35">为什么LSTM在深度学习方面比RNN更有用？</a> <br/> 5。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/neural-networks-the-rise-of-recurrent-neural-networks-df740252da88?source=friends_link&amp;sk=6844935e3de14e478ce00f0b22e419eb">神经网络:递归神经网络的兴起</a> <br/> 6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae lh" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>