<html>
<head>
<title>Differences Between concat(), merge() and join() with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中concat()、merge()和join()的区别</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=collection_archive---------0-----------------------#2021-04-28">https://pub.towardsai.net/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=collection_archive---------0-----------------------#2021-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b69e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><div class=""><h2 id="9f77" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在pandas中组合数据帧</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/c78ede0ebf3a4e63271ef92fed27a785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*DaxYsIsHzXMqgbv-QcA2hA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">作者的照片</figcaption></figure><blockquote class="ld le lf"><p id="9722" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">T3】简介T5】</strong></p></blockquote><p id="cbb9" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">在本文中，我们将讨论在pandas方法的帮助下组合数据帧。有时，当我们在一个大项目中工作，数据来自不同的来源，那么我们需要将这些数据组合成一个数据框架。</p><p id="dc6e" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">在pandas中，数据科学人员很少使用方法来使数据框架处于更有价值的状态。</p><p id="4fed" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这些方法根据行和列的相加来划分。</p><p id="558e" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">方法<strong class="lj jd"> merge() </strong>和<strong class="lj jd"> join() </strong>基于SQL join方法的公共键和索引工作。</p><p id="b515" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">方法<strong class="lj jd"> concat() </strong>正在对数据帧进行处理，以将它们组合在一起，形成一个结果数据帧。</p><p id="74b1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">您可以根据需要阅读这篇关于系列和数据框架的基础文章。</p><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/fundamentals-of-series-and-data-frame-in-pandas-with-python-6e0b8a168a0d"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">用python实现熊猫系列和数据框架的基础</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">数据框中常用参数的基础知识</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">pub.towardsai.net</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kx mj"/></div></div></a></div><blockquote class="ld le lf"><p id="5656" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">串联方式</em> </strong></p></blockquote><p id="43e1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">将两个数据帧水平合并成一个。</p><p id="a69c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">python的例子:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="cc7d" class="nd ne it mz b gy nf ng l nh ni">#import the pandas' library<br/>import pandas as pd</span></pre><p id="5976" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">为了组合数据帧，我们需要至少两个数据帧。</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="b56d" class="nd ne it mz b gy nf ng l nh ni">#Data frame 1<br/>df1 = pd.DataFrame({"C1":["1", "2"], <br/>                    "C2":["3", "4"],}, <br/>                   index=[0, 1])</span><span id="ae86" class="nd ne it mz b gy nj ng l nh ni">#Data frame 2<br/>df2 = pd.DataFrame({"C1":["5", "6"], <br/>                    "C2":["7", "8"],}, <br/>                   index=[2, 3])</span><span id="6fe2" class="nd ne it mz b gy nj ng l nh ni">#combine these two data frames<br/>data = [df1,df2]<br/>combined_df = pd.concat(data)</span><span id="120d" class="nd ne it mz b gy nj ng l nh ni">combined_df</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b3d83843402e916180770c2ef6c0538f.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*_tAgkK--Xq5v6vPVSG_-YA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">组合数据框。作者的照片</figcaption></figure><p id="7441" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">我们知道，当我们水平组合两个数据框时，列是相同的，行索引是增加的。</p><h2 id="06d9" class="nd ne it bd nl nm nn dn no np nq dp nr md ns nt nu me nv nw nx mf ny nz oa iz bi translated"><strong class="ak">串联的自变量</strong></h2><ol class=""><li id="4511" class="ob oc it lj b lk od ln oe md of me og mf oh mc oi oj ok ol bi translated"><strong class="lj jd"> Keys参数:</strong>它采用sequence或none，键作为分层索引传递到最外层，如下所示:</li></ol><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="45f2" class="nd ne it mz b gy nf ng l nh ni">key_data = pd.concat(data, keys=["x", "y"])<br/>key_data</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e2f0c396a1823e5ccdf1577eb2d5135b.png" data-original-src="https://miro.medium.com/v2/resize:fit:232/format:webp/1*ZPx5NQDBUd9ERII3BsvJYg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">键索引。作者的照片</figcaption></figure><p id="50ac" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">现在，我们可以用键来访问数据，如示例所示。</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="fe11" class="nd ne it mz b gy nf ng l nh ni">key_data.loc["y"]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/161b220e9b9a7c836f31a4070128e14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:180/format:webp/1*cR2lFsBN3XRRLA7lh-9dxg.png"/></div></figure><p id="c137" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated"><strong class="lj jd"> 2。轴:</strong>该参数用于垂直组合数据帧，意味着添加更多列，如下例所示:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="8d50" class="nd ne it mz b gy nf ng l nh ni">df3 = pd.DataFrame({"C3":["10", "11"], <br/>                    "C4":["12", "13"],}, <br/>                   index=[1,2])</span></pre><p id="d701" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这里，我们给出索引(1，2)，但是在“df1”数据帧中，索引是(0，1)。于是，结果得到一个新行，缺失的值用“<strong class="lj jd"><em class="li"/></strong>”填充。</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="5c4b" class="nd ne it mz b gy nf ng l nh ni">axis_data = pd.concat([df1, df3], axis=1)<br/>axis_data</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/bd429b468c6752f8ffce0b662a5ff340.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*Jm_d2Ip-r65aU-G3z45Q-w.png"/></div></figure><p id="96f3" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated"><strong class="lj jd"> 3。连接:</strong>在这个参数中有两种类型的连接，即外部连接和内部连接。默认连接为外部连接，内部连接将提供数据框的公共交集，如下所示:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="a513" class="nd ne it mz b gy nf ng l nh ni">join_data = pd.concat([df1, df3], axis=1, join="inner")<br/>join_data</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9a8381bab5b986c4d821a6e66ef1a235.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*LtF6KYN3E_IKmSxS6K2Xnw.png"/></div></figure><h2 id="4217" class="nd ne it bd nl nm nn dn no np nq dp nr md ns nt nu me nv nw nx mf ny nz oa iz bi translated"><strong class="ak">合并数据帧和序列</strong></h2><p id="7403" class="pw-post-body-paragraph lg lh it lj b lk od kd lm ln oe kg lp md oq ls lt me or lw lx mf os ma mb mc im bi translated">这是组合系列和数据框的非常有用的方法，如下所示:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="e6b2" class="nd ne it mz b gy nf ng l nh ni">series_data = pd.Series(["21", "22"], name="C5")<br/>combine_series = pd.concat([df1, series_data], axis=1)<br/>combine_series</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/cdc955527534ee67a21e7d8ef0a33b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*lM7a7nWPqSDetU40uP_ydw.png"/></div></figure><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/a-walk-to-the-standard-library-of-python-with-examples-c5140a8ef1a7"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">带示例的Python标准库之旅</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">python中提供的一个方便有用的脚本模块</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">pub.towardsai.net</p></div></div><div class="ms l"><div class="ou l mu mv mw ms mx kx mj"/></div></div></a></div><blockquote class="ld le lf"><p id="4ac7" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">合并方法</em> </strong></p></blockquote><p id="7790" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这种方法用于连接不同的数据框架，就像结构化查询语言(SQL)中的关系数据库一样。</p><p id="c3d3" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated"><strong class="lj jd">以单键数据帧为例。</strong></p><p id="ea70" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated"> 上的<strong class="lj jd"> <em class="li">自变量用于从两个数据帧中获取公共列。</em></strong></p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="634b" class="nd ne it mz b gy nf ng l nh ni">left = pd.DataFrame({"keys":["K0", "K1"],<br/>                     "C1":["1", "2"], <br/>                     "C2":["3", "4"],})</span><span id="adcc" class="nd ne it mz b gy nj ng l nh ni">right = pd.DataFrame({"keys":["K0", "K1"],<br/>                      "C3":["10", "11"], <br/>                      "C4":["12", "13"]})</span><span id="b9f5" class="nd ne it mz b gy nj ng l nh ni">basic_join = pd.merge(left, right, on="keys")<br/>basic_join</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/b23ef468ed97677be5e9f855d1a3cdfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*mBOBQNIeF6essy4vVw23LQ.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">两个数据帧合并操作。作者的照片</figcaption></figure><p id="1a6c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated"><strong class="lj jd">用两个关键数据框举例。</strong></p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="ef9f" class="nd ne it mz b gy nf ng l nh ni">left = pd.DataFrame({"k1": ["A0", "A0", "A1", "A2"],<br/>                     "k2": ["A0", "A1", "A0", "A1"],<br/>                     "A": ["1", "2", "3", "4"],<br/>                     "B": ["5", "6", "7", "8"]})</span><span id="fc51" class="nd ne it mz b gy nj ng l nh ni">right = pd.DataFrame({"k1": ["A0", "A1", "A1", "A2"],<br/>                      "k2": ["A0", "A0", "A0", "A0"],<br/>                      "C": ["9", "10", "11", "12"],<br/>                      "D": ["13", "14", "15", "16"]})</span><span id="ed32" class="nd ne it mz b gy nj ng l nh ni">two_key_result = pd.merge(left, right, on=["k1", "k2"])<br/>two_key_result</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/083dd4a2fb72ae4ab911915ff4d47994.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*TG5WwBODhZXv3ROSONPpqg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">公共键与合并数据框相关联。作者的照片</figcaption></figure><p id="19e2" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">SQL do连接，如左连接、右连接、内连接和外连接。这些的例子如下所示:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="928e" class="nd ne it mz b gy nf ng l nh ni">left_result = pd.merge(left, right, how="left", on=["k1", "k2"])</span><span id="e89a" class="nd ne it mz b gy nj ng l nh ni">right_result = pd.merge(left, right, how="right", on=["k1", "k2"])</span><span id="4780" class="nd ne it mz b gy nj ng l nh ni">inner_result = pd.merge(left, right, how="inner", on=["k1", "k2"])</span><span id="a955" class="nd ne it mz b gy nj ng l nh ni">outer_result = pd.merge(left, right, how="outer", on=["k1", "k2"])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="oy oz di pa bf pb"><div class="gh gi ox"><img src="../Images/d768dff06c4a09c7f16e104faad6be6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-j0YE-3jF0zbgj-HNCzLg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">作者的照片</figcaption></figure><p id="0166" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">merge方法包含一个参数，该参数将分类列与结果数据框中的信息相加，如下例所示。</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="a398" class="nd ne it mz b gy nf ng l nh ni">data1 = pd.DataFrame({"C1": [4, 6], "col_left": ["a", "b"]})<br/>data2 = pd.DataFrame({"C1": [6, 3, 3], "col_right": [3, 3, 3]})</span><span id="89d1" class="nd ne it mz b gy nj ng l nh ni">#The indicator argument is "True"<br/>pd.merge(data1, data2, on="C1", how="outer", indicator=True)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/0ddfeefe962daea0e954a35ae942a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*ypdnQBdVZp76LVwRbWW9vA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">作者的照片</figcaption></figure><div class="mg mh gp gr mi mj"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-list-as-big-o-and-comprehension-with-python-examples-cbea610c9e43"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">将List理解为Big O并理解Python示例</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">列表是python数据结构的一部分</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">pub.towardsai.net</p></div></div><div class="ms l"><div class="pd l mu mv mw ms mx kx mj"/></div></div></a></div><blockquote class="ld le lf"><p id="1be2" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">加入方法</em> </strong></p></blockquote><p id="fcf3" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这种方法对于基于左和右数据帧组合两个数据帧也是有用的。</p><p id="a2a7" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">在本例中，左数据优于右数据，如下所示:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="4d01" class="nd ne it mz b gy nf ng l nh ni">left = pd.DataFrame({"X1":["1", "2"], <br/>                     "X2":["3", "4"]}, <br/>                     index = ["K0", "K1"])</span><span id="89fc" class="nd ne it mz b gy nj ng l nh ni">right = pd.DataFrame({"X3":["10", "11"], <br/>                     "X4":["12", "13"]}, <br/>                     index = ["K0", "K2"])</span><span id="93cd" class="nd ne it mz b gy nj ng l nh ni">result = left.join(right)<br/>result</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/4396e6a78b05b0c3d62a3e35be9e7697.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*T3UAeynteJyBnb9QcGNjEg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">奥托尔的照片</figcaption></figure><p id="b4c1" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">在下面的例子中，右边占优势。</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="2989" class="nd ne it mz b gy nf ng l nh ni">result1 = right.join(left)<br/>result1</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d5bac01770a9a687681a2fc266cad0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*h-ygCPFTr7aori7b_VJRxg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">作者的照片</figcaption></figure><p id="0998" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">我们还可以根据键和索引连接两个数据框，如下所示:</p><pre class="ks kt ku kv gt my mz na nb aw nc bi"><span id="bd19" class="nd ne it mz b gy nf ng l nh ni">left = pd.DataFrame({"k1": ["A0", "A1", "A0", "A1"],                     <br/>                     "C1": ["1", "2", "3", "4"],<br/>                     "C2": ["5", "6", "7", "8"]})</span><span id="3561" class="nd ne it mz b gy nj ng l nh ni">right = pd.DataFrame({"C3": ["10", "11"], "C4": ["12", "13"]}, index=["A0", "K1"])</span><span id="16f7" class="nd ne it mz b gy nj ng l nh ni">result = left.join(right, on="k1")<br/>result</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/ca71a22cf14072a0af13248e3c8133f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*6VZA5JGKdY-80RI1ZMY8Ng.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">作者的照片</figcaption></figure><blockquote class="ld le lf"><p id="6c89" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">结论:</em> </strong></p></blockquote><p id="8e1b" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">本文给出了基于索引、键组合数据帧的基本思想。数据框的组合也适用于多个键和索引，这将在以后的文章中介绍。</p><p id="bf7b" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae ph" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ph" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="fe6f" class="pi ne it bd nl pj pk pl no pm pn po nr ki pp kj nu kl pq km nx ko pr kp oa ps bi translated">推荐文章</h1><p id="d0c2" class="pw-post-body-paragraph lg lh it lj b lk od kd lm ln oe kg lp md oq ls lt me or lw lx mf os ma mb mc im bi translated"><a class="ae ph" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae ph" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae ph" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae ph" rel="noopener ugc nofollow" target="_blank" href="/principal-component-analysis-in-dimensionality-reduction-with-python-1a613006d531?source=friends_link&amp;sk=3ed0671fdc04ba395dd36478bcea8a55">用Python进行主成分分析降维</a> <br/> 5。<a class="ae ph" href="https://medium.com/towards-artificial-intelligence/fully-explained-k-means-clustering-with-python-e7caa573176a?source=friends_link&amp;sk=9c5c613ceb10f2d203712634f3b6fb28" rel="noopener">用Python全面讲解K-means聚类</a> <br/> 6。<a class="ae ph" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae ph" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae ph" href="https://medium.com/towards-artificial-intelligence/basic-of-time-series-with-python-a2f7cb451a76?source=friends_link&amp;sk=09d77be2d6b8779973e41ab54ebcf6c5" rel="noopener">用Python实现时间序列的基础知识</a> <br/> 9。<a class="ae ph" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae ph" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>