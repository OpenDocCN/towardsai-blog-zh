<html>
<head>
<title>Machine Learning/Bio-Statistics on Cellular Images to Diagnose Acute Lymphoblastic Leukemia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于细胞图像的机器学习/生物统计学诊断急性淋巴细胞白血病</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/machine-learning-cdbf0047af06?source=collection_archive---------0-----------------------#2021-12-06">https://pub.towardsai.net/machine-learning-cdbf0047af06?source=collection_archive---------0-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ed64" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/98a2fe7de0446b426fd74d9bfdd3ba39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r--ataTxndVScNmP"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">https://unsplash.com/photos/SJCalEw-1LM?utm_source=unsplash&amp;T2 UTM _ medium = referral&amp;UTM _ content = creditShareLink</figcaption></figure><p id="b465" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你喜欢我的文章，请考虑使用下面的链接成为会员:</p><p id="5908" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">【https://medium.com/@ashu.malgaonkar/membership T4】</p><h2 id="f123" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated"><strong class="ak">目录:</strong></h2><p id="c803" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">一.关于该数据集</p><p id="3d01" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">二。数据集引用</p><p id="7306" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">三。下载数据</p><p id="d7e4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">四。将数据处理成Python</p><p id="f1a3" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">动词 （verb的缩写）机器学习</p><p id="c230" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不及物动词分析指标</p><p id="4b70" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">七。结论</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="2569" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">一.关于该数据集</h2><p id="1c21" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated"><a class="ae ko" href="https://en.wikipedia.org/wiki/Acute_lymphoblastic_leukemia" rel="noopener ugc nofollow" target="_blank">急性淋巴细胞白血病</a> (ALL)是最常见的儿童癌症类型，约占儿童癌症的25%。</p><p id="a3f9" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些细胞是从显微图像中分割出来的，代表了真实世界中的图像，因为它们包含一些染色噪声和照明误差，尽管这些误差在采集过程中已经得到了很大程度的修正。</p><p id="be63" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由于形态学上的相似性，在显微镜下从正常细胞中识别未成熟白血病母细胞的任务是具有挑战性的，因此由肿瘤专家对基本事实标签进行注释。</p><p id="0d9f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">总共有来自118名患者的15，135幅图像，分为两个标记类别:</p><ul class=""><li id="dd16" class="mr ms it kr b ks kt kw kx la mt le mu li mv lm mw mx my mz bi translated">正常细胞；</li><li id="0ef7" class="mr ms it kr b ks na kw nb la nc le nd li ne lm mw mx my mz bi translated">白血病爆发。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="a1b1" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">二。数据集引用</h2><p id="7faf" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">该数据集可在以下位置找到:</p><p id="702b" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ko" href="https://www.kaggle.com/andrewmvd/leukemia-classification" rel="noopener ugc nofollow" target="_blank">白血病分类| Kaggle </a></p><h2 id="f6ca" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">数据引用</h2><ul class=""><li id="42d4" class="mr ms it kr b ks mf kw mg la nf le ng li nh lm mw mx my mz bi translated">古普塔，a .，&amp;古普塔，R. (2019)。ISBI 2019所有挑战数据集[数据集]。癌症影像档案。<a class="ae ko" href="https://doi.org/10.7937/tcia.2019.dc64i46r" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.7937/tcia.2019.dc64i46r</a></li></ul><h2 id="4240" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">出版物引文</h2><ul class=""><li id="3586" class="mr ms it kr b ks mf kw mg la nf le ng li nh lm mw mx my mz bi translated">Anubha Gupta、Rahul Duggal、Ritu Gupta、Lalit Kumar、Nisarg Thakkar和Devprakash Satpathy，“GCTI-SN:受几何学启发的显微医学图像的化学和组织不变性染色标准化”，正在审查中。<br/> Ritu Gupta、Pramit Mallick、Rahul Duggal、Anubha Gupta和Ojaswa Sharma，“显微图像中浆细胞的染色颜色标准化和分割作为开发多发性骨髓瘤计算机辅助自动化疾病诊断工具的前奏”，第16届国际骨髓瘤研讨会(IMW)，印度，2017年3月。</li><li id="0f4c" class="mr ms it kr b ks na kw nb la nc le nd li ne lm mw mx my mz bi translated">Rahul Duggal、Anubha Gupta、Ritu Gupta、Manya Wadhwa和Chirag Ahuja，“使用深度信念网络在显微图像中进行重叠细胞核分割”，印度计算机视觉、图形和图像处理会议(ICVGIP)，印度，2016年12月。<br/> Rahul Duggal、Anubha Gupta和Ritu Gupta，“使用人工神经网络分割重叠/接触的白细胞细胞核”，CME血癌病理学系列，全印度医学科学研究所(AIIMS)，印度新德里，2016年7月。</li><li id="6e1e" class="mr ms it kr b ks na kw nb la nc le nd li ne lm mw mx my mz bi translated">Rahul Duggal、Anubha Gupta、Ritu Gupta和Pramit Mallick，“SD层:医学显微成像中CNN的染色去卷积层”，载于:Descoteaux M .、Maier-Hein L .、Franz A .、Jannin P .、Collins D .、Duchesne S .(编辑)医学图像计算和计算机辅助干预-MICCAI 2017年，MICCAI 2017年。计算机科学讲义，第三部分，LNCS 10435，第435–443页。斯普林格，查姆。https://doi.org/10.1007/978-3-319-66179-7_50。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="8c8e" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">三。下载数据</h2><p id="9a8f" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">去这个链接下载资料:<a class="ae ko" href="https://www.kaggle.com/andrewmvd/leukemia-classification" rel="noopener ugc nofollow" target="_blank">白血病分类| Kaggle </a></p><p id="5fb4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">提取文件夹后，当您沿着包含图像的路径前进时，会看到两个文件夹:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ni"><img src="../Images/ca52b77c997b6b6b5fd4511291e8da97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYeM8fpVsHb--s6TaaVEhQ.png"/></div></div></figure><p id="ea28" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">“全部”文件夹包含带有癌症的图像:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nn"><img src="../Images/261f0cfa388ff31df2896e02ff0194f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eybd4kBOrXRgD7ACAQfhgA.png"/></div></div></figure><p id="9ffb" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">“hem”文件夹包含非癌症图像:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi no"><img src="../Images/dff91059cf415561321467c801449523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAN_w0E96lvbFy83O7_Hog.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="09cf" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">四。将数据处理成Python</h2><p id="8485" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">为了处理数据，我们需要一些软件包。</p><p id="b3f0" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将需要skimage io来读取图像并获取像素:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="50f9" class="ln lo it nq b gy nu nv l nw nx">from skimage import io</span></pre><p id="e88b" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后我们需要一个包来存储我们的数据。为此，我们可以使用像pandas这样的数据框包:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="171c" class="ln lo it nq b gy nu nv l nw nx">import pandas as pd</span></pre><p id="032f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，我们需要操作系统将我们指向我们的映像所在的目录:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="4bac" class="ln lo it nq b gy nu nv l nw nx">import os</span></pre><p id="8626" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">好了，现在我们有了自己的包，让我们为两个路径创建一个变量，一个用于“all”文件夹，另一个用于“hem”文件夹:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="73c0" class="ln lo it nq b gy nu nv l nw nx">pathforall= r'C:\...Desktop\Leukemia\archive\C-NMC_Leukemia\training_data\fold_0\all'</span><span id="7b88" class="ln lo it nq b gy ny nv l nw nx">pathforhem= r'C:\...Desktop\Leukemia\archive\C-NMC_Leukemia\training_data\fold_0\hem'</span></pre><p id="27dc" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们需要将Python指向这些文件夹(上面的路径变量),并将其中的文件名存储为一个列表。这两行为您提供了两个列表，一个用于“所有”图像，另一个用于“边缘”图像:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="92aa" class="ln lo it nq b gy nu nv l nw nx">dir_list=os.listdir(pathforall)<br/>dir_list2=os.listdir(pathforhem)</span></pre><p id="a78f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面是Spyder编辑器的变量资源管理器中的一个例子，我用它来编写代码:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nz"><img src="../Images/b173d4c96de9e9958166e72813867d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-8Y90fl78YX4drsM5wMKw.png"/></div></div></figure><p id="f8e2" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">好了，现在是时候存储这些图像的数据了。让我给你看完整的代码，然后分解我是如何做到这一点的:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="00c6" class="ln lo it nq b gy nu nv l nw nx">df = pd.DataFrame()</span><span id="fad1" class="ln lo it nq b gy ny nv l nw nx">for i in dir_list[:300]:<br/>    img=io.imread(pathforall + "\\" + i)<br/> <br/>    my_df = pd.DataFrame(img.flatten()).transpose()<br/>    my_df['Class'] = 'ALL'<br/>    my_df=my_df.head(n=1)<br/>    df = df.append(my_df, ignore_index=True)</span></pre><p id="58b6" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以，让我们一步一步来看:</p><p id="400a" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上述代码中的第一行创建了一个空数据框。这个名为df的数据框是我将存储“所有”数据的地方。</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="2802" class="ln lo it nq b gy nu nv l nw nx">df = pd.DataFrame()</span></pre><p id="dde4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，我将启动一个for循环，它指向“all”文件夹中的列表。记住我们的列表叫做dir_list。我只为我的项目处理了图像的一个子集，因为所有2500张图像需要我花半个小时到一个小时来完成这个程序，我不想等那么久。这就是[:300]的含义，即列表将在此结束:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="7a78" class="ln lo it nq b gy nu nv l nw nx">for i in dir_list[:300]:</span></pre><p id="9cd4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在在for循环中，我正在编写代码。这意味着代码将运行并将每个图像的数据存储到数据框中。让我们经历这一切。</p><p id="4b39" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面一行是所有文本的路径，并在它后面添加一个斜杠，然后添加来自for循环的“I”。这个“I”是第一个图像的文件名，当循环第二次运行时是第二个图像的文件名，然后是第三个图像的文件名，依此类推，即“I”遍历“all”文件夹中图像的文件名:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="9e2f" class="ln lo it nq b gy nu nv l nw nx">img=io.imread(pathforall + "\\" + i)</span></pre><p id="8c90" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">IMG是由图像的像素数据构成的n维数组。</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7f46a32fedee63a54bf9abb770e5985a.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*-PnZcgmapnvtuYyCRIxJ9A.png"/></div></figure><p id="9fc7" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是，我们需要将它展平，使它变得像一个列表。为此，我们可以使用img.flatten()。然后，我们需要将这些值存储为Pandas数据帧，以便我们可以在以后存储和操作它们。然而，当我们从我们的列表制作数据框时，它会将列表存储到一列中。这对我们没用。我们希望我们的列表水平存储在一行上，这样我们就可以将“all/cancer”类作为最后一列，然后使用机器学习算法对其进行分类。为了做到这一点，我们需要转置数据。让我首先解释这将做什么。</p><p id="c8ce" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，数组看起来像这样:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ee8be86e24383dd72e98bc7babbe7d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*HNdFO6pv-JSFHZJ1fMLLhA.png"/></div></figure><p id="390b" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">用img.flatten展平后会是这样的:</p><p id="8a6e" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi">{0,0,0,0…}</p><p id="4238" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当将其转换为数据框时，将如下所示:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7811c57a104c76b2b227be9b6e798e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*pWS4ii2AnFf3kOf7rtuLuA.png"/></div></figure><p id="8030" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然而，我们需要第一行的第一个图像和第二行的第二个图像，依此类推。所以我们必须改变它。当您转置类似上面的内容时，它看起来像这样一行:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi od"><img src="../Images/c943e5cc699fa2475cb7c373c0c78e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIvSepAQqTQ89dxQlfjySw.png"/></div></div></figure><p id="d730" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所有这些展平、转换成数据帧和转置都可以通过这段代码完成:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="7d23" class="ln lo it nq b gy nu nv l nw nx">my_df = pd.DataFrame(img.flatten()).transpose()</span></pre><p id="3b79" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，我们希望刚刚创建的行有正确的标签。在这种情况下，我们循环通过癌细胞，因此我们的标签/类别将是“全部”:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="17f9" class="ln lo it nq b gy nu nv l nw nx">my_df['Class'] = 'ALL'</span></pre><p id="6d54" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们确保，我们只取我们生成的一行:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="7c70" class="ln lo it nq b gy nu nv l nw nx">my_df=my_df.head(n=1)</span></pre><p id="4ffa" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，记住我们所做的一切都是for循环的一部分。因此，循环的最后一部分是将我们之前在循环外创建的空数据帧放入我们刚刚创建的行:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="f0bf" class="ln lo it nq b gy nu nv l nw nx">df = df.append(my_df, ignore_index=True)</span></pre><p id="dab7" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，每次循环运行时，它都会遍历该行，并将该行放在底部。</p><p id="1e21" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，让我们通过在“哼哼”路径上重复来对“哼哼”数据做同样的事情:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="1708" class="ln lo it nq b gy nu nv l nw nx">df2 = pd.DataFrame()</span><span id="b759" class="ln lo it nq b gy ny nv l nw nx">for i in dir_list2[:300]:<br/>    img2=io.imread(pathforhem + "\\" + i)<br/> <br/>    my_df2 = pd.DataFrame(img2.flatten()).transpose()<br/>    my_df2['Class'] = 'Not ALL'<br/>    my_df2=my_df2.head(n=1)<br/>    df2 = df2.append(my_df2, ignore_index=True)</span></pre><p id="0dfe" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意，这不是“全部”类。</p><blockquote class="oe of og"><p id="671c" class="kp kq oh kr b ks kt ku kv kw kx ky kz oi lb lc ld oj lf lg lh ok lj lk ll lm im bi translated">好了，现在我们有两个不同的数据帧，每行都有图像像素数据。一个数据帧包含白血病细胞的像素数据，另一个包含非白血病细胞的像素数据。</p></blockquote><p id="6361" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，为了运行一个分类算法，我们首先需要使它成为一个数据集。我们可以通过使用concat命令来实现这一点。在SQL术语中，concat命令本质上是一个“Union”。它将数据集堆叠在一起:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="1ce3" class="ln lo it nq b gy nu nv l nw nx">df_stack = pd.concat([df, df2])</span></pre><p id="54b9" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当您运行concat命令时，如上所示，您会在变量资源管理器中注意到以下内容:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ol"><img src="../Images/5bb47ff349717b056284981abd5be456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTIRwbEDW_WFcPLWpRfavQ.png"/></div></div></figure><blockquote class="oe of og"><p id="5e8a" class="kp kq oh kr b ks kt ku kv kw kx ky kz oi lb lc ld oj lf lg lh ok lj lk ll lm im bi translated">注意尺寸。df和df2的大小各为300。当你把它们叠在一起，就变成了600。这是检查工作的快捷方式。</p></blockquote></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="4b2e" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">动词 （verb的缩写）机器学习</h2><p id="c708" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">我在这里使用的算法是支持向量机:</p><p id="370c" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">支持向量机第1部分(共3部分):主要观点！！！——YouTube</p><p id="127d" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=Toet3EiSFcM" rel="noopener ugc nofollow" target="_blank">支持向量机第二部分:多项式核(第二部分，共三部分)——YouTube</a></p><p id="9f4f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=Qc5IyLW_hns&amp;t=2s" rel="noopener ugc nofollow" target="_blank">支持向量机第三部分:径向基核(第三部分，共三部分)——YouTube</a></p><p id="51b3" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们从将数据集分解为X和y开始。X将是用于预测目标变量的要素或列，即存储为y的类。</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="b3a4" class="ln lo it nq b gy nu nv l nw nx">#Store class as y and rest of data as x<br/>X = df_stack.drop('Class', axis=1)<br/>y = df_stack['Class']</span></pre><p id="e25f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们将数据集分为测试和训练两部分。训练集将占80%，测试集占20%。这意味着该算法将使用80%的数据来训练和建立规则，然后使用这些数据来预测其余20%的类别。</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="a0e7" class="ln lo it nq b gy nu nv l nw nx">#split data<br/>from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20)</span></pre><p id="44f5" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们实现我们的支持向量机:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="70b9" class="ln lo it nq b gy nu nv l nw nx">from sklearn.svm import SVC</span></pre><p id="5b91" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们要选择的内核是:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="828d" class="ln lo it nq b gy nu nv l nw nx">svclassifier = SVC(kernel='rbf')</span></pre><p id="249d" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当数据中存在重叠时，这种内核工作得最好，在图像处理等情况下，也存在重叠。您可以在这里了解关于内核的更多信息:</p><p id="6541" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=Qc5IyLW_hns&amp;t=2s" rel="noopener ugc nofollow" target="_blank">支持向量机第三部分:径向(RBF)核(第三部分，共三部分)——YouTube</a></p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="0869" class="ln lo it nq b gy nu nv l nw nx">svclassifier.fit(X_train, y_train)</span></pre><p id="3dcc" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们做一些预测:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="b03b" class="ln lo it nq b gy nu nv l nw nx">#make predictions</span><span id="547c" class="ln lo it nq b gy ny nv l nw nx">y_pred = svclassifier.predict(X_test)</span></pre><p id="157e" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们来看看预测的指标:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="0079" class="ln lo it nq b gy nu nv l nw nx">#metrics</span><span id="0432" class="ln lo it nq b gy ny nv l nw nx">from sklearn.metrics import classification_report, confusion_matrix<br/>print(confusion_matrix(y_test,y_pred))<br/>print(classification_report(y_test,y_pred))</span></pre><p id="1898" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">指标的打印结果如下所示:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi om"><img src="../Images/703944b49fda4f54a966d14e6ffe6bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CyX-BlG00yuLXLI1whLl8A.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="face" class="ln lo it bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me iz bi translated">不及物动词分析指标</h2><p id="e489" class="pw-post-body-paragraph kp kq it kr b ks mf ku kv kw mg ky kz la mh lc ld le mi lg lh li mj lk ll lm im bi translated">看混淆矩阵:</p><p id="4b9e" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi">[[59 5]</p><p id="a81f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi">[16 40]]</p><p id="1ad2" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在sklearn中，预测标签在顶部，实际标签在侧面:</p><figure class="nj nk nl nm gt kd gh gi paragraph-image"><div class="gh gi on"><img src="../Images/07999f510a8d36b4c6df813fa1437b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*6zV2xsF7h1WmzGdo9P2FZw.png"/></div></figure><p id="cca1" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这意味着在测试数据中，该算法具有以下准确度:</p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="013f" class="ln lo it nq b gy nu nv l nw nx">Accuracy --&gt; (59+40)/(59+5+16+40) = 82.5%</span></pre><p id="c46c" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd">灵敏度=真阳性数/(真阳性数+假阴性数)</strong></p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="6f70" class="ln lo it nq b gy nu nv l nw nx">Sensitivity --&gt; 59 / (59 + 5) = 59/64 = 92%</span></pre><p id="2790" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd">特异性=真阴性数/(真阴性数+假阳性数)</strong></p><pre class="nj nk nl nm gt np nq nr ns aw nt bi"><span id="07b0" class="ln lo it nq b gy nu nv l nw nx">Specificity --&gt; 40 / (16+40) = 40/56 = 71%</span></pre><blockquote class="oe of og"><p id="9dad" class="kp kq oh kr b ks kt ku kv kw kx ky kz oi lb lc ld oj lf lg lh ok lj lk ll lm im bi translated"><strong class="kr jd"/></p></blockquote></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="4925" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd">七。结论:</strong></p><p id="b2da" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当患者患有ALL时，该测试将非常有助于诊断ALL，即其具有92%  的<strong class="kr jd"> <em class="oh">良好灵敏度。然而，当这个人没有全部时，它有时可能给出一个假阳性。</em></strong></p><p id="cc18" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其他文章:</p><p id="dcc4" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/how-to-detect-image-differences-with-python-9ea04859084c"> 1 —如何使用Python检测图像差异|作者Ashutosh Malgaonkar | 2021年11月|面向人工智能</a></p><p id="fd61" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">2 — <a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-a-proximity-positioning-system-for-a-city-451ad19784d3">如何创建一个城市的邻近定位系统|作者Ashutosh Malgaonkar |朝向AI </a></p></div></div>    
</body>
</html>