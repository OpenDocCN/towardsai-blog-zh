<html>
<head>
<title>Wine Classifier Using Supervised Learning with 98% Accuracy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用监督学习的葡萄酒分类器，准确率为98%</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/wine-classifier-using-supervised-learning-with-98-accuracy-5f2e173e967e?source=collection_archive---------3-----------------------#2020-06-05">https://pub.towardsai.net/wine-classifier-using-supervised-learning-with-98-accuracy-5f2e173e967e?source=collection_archive---------3-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9f3d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">实用人工智能</h2><div class=""/><div class=""><h2 id="c71b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">监督学习指南</h2></div><p id="c1b6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">今天，我将创建一个分类器，能够以98%的准确率识别不同种类的葡萄酒。数据集可以从<a class="ae ln" href="https://data.world/uci/wine" rel="noopener ugc nofollow" target="_blank"> data.world </a>下载。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/cb0712117f66aa6ab7bcf07b824b94d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K6IV6ZnHZ0nmq_M6"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">由<a class="ae ln" href="https://unsplash.com/@vlisidis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">特里·维里斯迪斯</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7bbd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ln" href="https://github.com/arditoibryan/Projects/tree/master/20200528_Wine_Classifier" rel="noopener ugc nofollow" target="_blank">我的Github存储库中有完整的代码。</a></p><h1 id="c746" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">步伐</h1><ol class=""><li id="42cc" class="mw mx it kt b ku my kx mz la na le nb li nc lm nd ne nf ng bi translated">导入模块</li><li id="71b2" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">导入数据集</li><li id="9b29" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">看着这些数据</li><li id="8509" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">预处理</li><li id="44c2" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">剧烈的</li><li id="565b" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">机器学习模型</li><li id="6fb7" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">估价</li></ol><h1 id="cb41" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">1.导入模块</h1><p id="95c4" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">为了加快我的工作，我将使用我个人的预处理库，名为<a class="ae ln" href="https://github.com/arditoibryan/General" rel="noopener ugc nofollow" target="_blank"> tf_dataset_extractor v1.2 </a>。如果你不想使用我创建的模块，我会详细解释创建这个人工智能的每个步骤，这样你就可以选择你的方法。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="8eac" class="nu mf it nq b gy nv nw l nx ny">import sys<br/>sys.path.append('/content/drive/My Drive/Colab Notebooks/TensorFlow 2.0/modules')<br/>import pandas as pd<br/>import tf_dataset_extractor as e<br/>#import grapher_v1_1 as g<br/>#import LSTM_creator_v1_0 as l<br/>v = e.v<br/>g = e.g<br/>l = e.l</span></pre><h1 id="0010" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">2.导入数据集</h1><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="6e1c" class="nu mf it nq b gy nv nw l nx ny">import pandas as pd<br/>#importing dataset<br/>e.X = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Projects/20200528_Wine_Classifier/wine_data.csv')<br/>e.K = v.upload.make_backup()<br/>e.X</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nz"><img src="../Images/fa7f9be73d9a295d172410feb2246774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3P6-jJongTaqpfBI7w5LA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">葡萄酒数据集的示例</figcaption></figure><p id="c86a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对我们来说不幸的是，葡萄酒的名称在原始数据集中不存在。而是将三种酒分别标为1、2、3。这就够了。</p><h1 id="63cb" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">3.看着这些数据</h1><p id="b80a" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">在处理模型之前，一个非常好的做法是查看数据。我将使用我最喜欢的工具来评估我的分类器的性能:pairplot。我将使用e.X数据集，使用“Wine”作为标签。在pairplot函数中，我将把它作为“色调”输入:</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="9a39" class="nu mf it nq b gy nv nw l nx ny">#correlogram<br/># library &amp; dataset<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/> <br/># Basic correlogram<br/>sns.pairplot(e.X, hue='Wine', height=5)<br/>plt.show()</span></pre><p id="e77e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从这些数据中我可以立即看到的是，这些特征是:</p><ul class=""><li id="ab2c" class="mw mx it kt b ku kv kx ky la oa le ob li oc lm od ne nf ng bi translated">正态分布</li><li id="8a88" class="mw mx it kt b ku nh kx ni la nj le nk li nl lm od ne nf ng bi translated">他们明显地彼此分开</li></ul><p id="a8bf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">关于pairplot告诉我们什么的更多信息，我建议你阅读我以前的一篇关于这个主题的文章。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oe"><img src="../Images/32bc0554454f11c683cf8ec412f9f5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hv_2TAeycILS-QdsvtwM9A.png"/></div></div></figure><p id="1d3b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有了我刚刚从图中获得的信息，我已经有了我将要使用的分类器的想法:朴素贝叶斯分类器。这个机器学习分类器在正态分布的数据上表现得非常好(不要相信嘲笑它的开发者！).如果分布彼此远离，甚至更好，那么在三个不同的类之间进行区分将容易得多。</p><h1 id="b26a" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">4.预处理</h1><p id="3fe2" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">鉴于这是一个非常简单的数据集，并且数据已经是数字形式，我个人认为我不需要做任何预处理。如果您是初学者，知道当您必须为您的模型准备数据时，您需要预处理数据(例如，将分类数据转换为编码数据)。</p><h2 id="3164" class="nu mf it bd mg of og dn mk oh oi dp mo la oj ok mq le ol om ms li on oo mu iz bi translated">提取标签</h2><p id="3efb" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">我要做的唯一一件事是从数据集中提取标签，这样我就可以将它提供给模型。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="ca69" class="nu mf it nq b gy nv nw l nx ny">v.upload.retrieve_backup(e.K)<br/>v.extract.labels(['Wine'])<br/>e.y</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/bc86277292e9b4c9aba6126445e34d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*akAfnYKBqKjKgm8Iipk9Wg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">标签样本</figcaption></figure><h1 id="0b7b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">5.剧烈的</h1><p id="3f70" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">我现在将X(特征)和y(标签)分成训练和测试。默认情况下，我将对测试端使用0.2的比例。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="58a2" class="nu mf it nq b gy nv nw l nx ny">X_train, X_test, y_train, y_test = v.split(0.2)<br/>print(X_train.shape, X_test.shape, y_train.shape, y_test.shape)</span></pre><h1 id="5cd7" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">6.机器学习模型</h1><p id="2367" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">现在是时候创建我的人工智能了:</p><h2 id="f881" class="nu mf it bd mg of og dn mk oh oi dp mo la oj ok mq le ol om ms li on oo mu iz bi translated">创建模型</h2><p id="6aae" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">我将使用scikit-learn库，这是最好的开源机器学习库之一。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="4ea0" class="nu mf it nq b gy nv nw l nx ny">from sklearn.naive_bayes import GaussianNB<br/>clf = GaussianNB()</span></pre><h2 id="796d" class="nu mf it bd mg of og dn mk oh oi dp mo la oj ok mq le ol om ms li on oo mu iz bi translated">训练模型</h2><p id="d02c" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">我会用我的训练样本找出把X和y联系起来的规则，然后，我会在X_test上做一个估计，并和模型没见过的实际结果进行比较:y_test。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="be2e" class="nu mf it nq b gy nv nw l nx ny">clf = clf.fit(X_train, y_train)<br/>y_predict = clf.predict(X_test)<br/>from sklearn.metrics import accuracy_score<br/>print(accuracy_score(y_test, y_predict))<br/>1.0</span></pre><p id="c530" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">100%!惊人的结果！</p><h1 id="6b79" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">7.估价</h1><p id="f4f9" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">我只拆分过一次数据集，但是，为了提高模型的有效性，我可以使用交叉验证算法在10次不同的拆分中测试模型，每次拆分都使用从数据集获取的不同数据。</p><pre class="lp lq lr ls gt np nq nr ns aw nt bi"><span id="0255" class="nu mf it nq b gy nv nw l nx ny">v.statistics.cross_validation(clf, X_train, y_train, 10)</span><span id="87e5" class="nu mf it nq b gy oq nw l nx ny">Accuracy: 0.96 (+/- 0.09)<br/>[1.00, <br/>1.00, <br/>1.00, <br/>0.92, <br/>0.92,         <br/>1.00, <br/>0.85, <br/>0.92, <br/>0.92, <br/>1.00        <br/>]</span></pre><p id="78f0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">根据由分割确定的训练和测试中的数据，准确度的范围从85%到100%，平均为96%。结果可能会有所不同，在几次尝试后，我获得的最高值是98%。</p></div></div>    
</body>
</html>