<html>
<head>
<title>Topic Modeling Open Source Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主题建模开源工具</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/topic-modeling-open-source-tool-fbdcc06f43f6?source=collection_archive---------0-----------------------#2020-07-22">https://pub.towardsai.net/topic-modeling-open-source-tool-fbdcc06f43f6?source=collection_archive---------0-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a723" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="7ef3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用Python和Streamlit构建的主题建模工具</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3e1b6a634a3ed3e535b380dd43b7391a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoU5-3rXRji-mge7S45j9g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由tommyboland提供</figcaption></figure><p id="f9c4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每秒钟都有大量数据以不同的形式生成和收集。从数据中获取正确的、相关的和想要的信息是一项有趣而又难以在一定时间内完成的任务。技术和算法已经发展到获取我们正在寻找的信息，其中一些就像使用字典和搜索引擎一样简单。尽管如此，这些方法的结果需要缩小范围或用特定的主题进行总结。在文本挖掘中，用于提取正确信息的技术之一是<strong class="lj jd"> <em class="md">主题建模</em> </strong>，这是一个自动识别给定文本中存在的主题并导出潜在模式的过程。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">应用程序演示</figcaption></figure><p id="e81f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="md">通过</em> </strong> <em class="md"> </em> <a class="ae mg" href="https://topic-modelling-tool.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <em class="md">主题建模开源工具链接</em> </a>访问工具</p><p id="5e28" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="md">本文结束时，您将能够了解什么是主题建模，现有的方法和途径，主题建模的一些评估方法，了解“主题建模开源工具”是如何构建的，如何部署到Heroku，如何使用该工具，并可能对开源项目有所贡献。</em>T19】</strong></p><h2 id="6a5b" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">先决条件:</h2><ul class=""><li id="d87d" class="mz na it lj b lk nb ln nc lq nd lu ne ly nf mc ng nh ni nj bi translated">理解自然语言处理。</li><li id="da44" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">Gensim库。</li><li id="7a2c" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">文本预处理。</li><li id="c003" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">Python编程。</li><li id="9cdf" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">细流。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/12af7e5886617ed850be83e02de6a73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dryLOEtcT2TH4HgrWo8f3Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">快照</figcaption></figure><h2 id="ef15" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">内容</h2><ul class=""><li id="a19f" class="mz na it lj b lk nb ln nc lq nd lu ne ly nf mc ng nh ni nj bi translated">主题建模概述。</li><li id="7cf0" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">主题建模方法和算法。</li><li id="2261" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">话题建模的评价。</li><li id="bdcd" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">为什么主题建模开源工具。</li><li id="755a" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">项目环境设置</li><li id="f750" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">需求文件。</li><li id="c49f" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">脚本和解释。</li><li id="55a9" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">使用streamlit的项目用户界面。</li><li id="5e5c" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">streamlit中的会话状态。</li><li id="6ca6" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">部署到Heroku。</li><li id="0d86" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">如何投稿？</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/1c8088eae4ee21beb9f74f89c9882ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iREoA1kA8W52nsZUX-gIZA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由bigstockphoto提供</figcaption></figure><h2 id="1b85" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">主题建模概述</h2><p id="f8d3" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">主题建模方法和算法不同于基于规则的文本挖掘的使用，基于规则的文本挖掘使用字典中的关键字或搜索技术中的正则表达式，而是一种在大型文本簇中发现和观察称为主题的一串单词的无监督方法。通过主题建模，我们可以很容易地理解、组织和总结大量的文本信息。这些单词(主题)和模式隐藏在整个文档中，但在训练了主题模型后会被发现和注意到。</p><p id="2f04" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">主题模型的假设是每个<strong class="lj jd"> <em class="md">文档</em> </strong>由主题的混合组成，每个<strong class="lj jd"> <em class="md">主题</em> </strong>由单词的集合组成。这意味着最终目标是确定假设，进而发现潜在的一串单词(主题)。</p><p id="b8b9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过主题建模，我们可以做到以下几点:</p><ul class=""><li id="8030" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated">文本摘要</li><li id="46d3" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">改善搜索结果</li><li id="58ff" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">推荐引擎</li><li id="a953" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">文档组织等等</li></ul><h2 id="1cf5" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">主题建模方法和算法</h2><p id="afbb" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">建立和训练主题模型的算法和方法有很多，其中有<strong class="lj jd"><em class="md"/></strong>【LSA】<strong class="lj jd"><em class="md">概率潜在语义分析</em></strong>【PLSA】<strong class="lj jd"><em class="md">潜在狄利克雷分配</em></strong>【LSA】<strong class="lj jd"><em class="md"/></strong>【HDP】等。其中，最常见和最流行的是LDA，它也是这个开源工具中实现的第一个算法。其他人将尽快包括在内。</p><p id="e5a1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> LDA </strong>是一种概率主题建模。也就是说，它使用条件概率来发现潜在的主题结构。这里通常选择它，因为它很容易推广到新文档。您可以通过本文末尾的参考资料了解更多信息。</p><h2 id="dc4d" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">主题建模评估</h2><p id="a0c7" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">对无监督机器学习的评估总是具有挑战性，因为没有基本事实。主题建模也是这类机器学习的一个例子，也不例外。然而，我们仍然需要理解模型输出，并决定是否保留它。评估主题模型常用方法包括但不限于</p><ul class=""><li id="3e5d" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated">目测:在这种情况下，我们可以提取模型已经预测为主题的单词列表中的前N个单词<strong class="lj jd"><em class="md"/></strong>。</li><li id="a30a" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">评估后验分布的密度或散度</li><li id="c4cf" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">话题连贯性可以是<em class="md">内在尺度</em>或<em class="md">外在尺度</em></li></ul><p id="c07a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如<em class="md"> (Wallach et al .，2009) </em>所示，LDA通常通过测量一些次要任务(如文档分类或信息检索)的性能进行评估，或者通过估计给定一些训练文档的看不见的隐藏文档的概率进行评估。平均而言，一个更好的模型将导致更高的延迟文档概率。</p><h2 id="8c90" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">为什么主题建模开源工具</h2><p id="abb2" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">数据科学是一个迭代过程，可能涉及许多重复的步骤，目的是从给定的数据中获得最佳效果。有些任务甚至遵循相同的建模模式，只有很小的变化。这有时会很累，尤其是当你必须在过程中对所有动作点进行编码的时候。有了这个开源工具，主题建模中的重复过程可以通过点击一个按钮或选择一个动作栏来完成，而不需要编写任何代码。主题模型也可以用可视化来评估，这是一种更好的交流数据见解的方式。使用这个工具，可以在建模和评估完成后生成和下载报告。</p><h2 id="1009" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">项目环境设置</h2><p id="6bd8" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">项目文件夹、模块和脚本已经以这样一种方式进行了安排，以便于贡献和强调干净的编码最佳实践。</p><pre class="ks kt ku kv gt nx ny nz oa aw ob bi"><span id="f005" class="mh mi it ny b gy oc od l oe of">C:.<br/>|   .gitignore<br/>|   app.py<br/>|   input_output.py<br/>|   lda.py<br/>|   model_evaluator.py<br/>|   nltk.txt<br/>|   preprocessor.py<br/>|   Procfile<br/>|   README.md<br/>|   requirements.txt<br/>|   SessionState.py<br/>|   setup.sh<br/>|   __init__.py</span></pre><p id="7503" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">可以在本地PC上创建一个新的Python环境，用正确的版本安装所有必需的包、框架和库。这些库可以在requirements.txt文件中找到</p><h2 id="c1ef" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">需求文件</h2><pre class="ks kt ku kv gt nx ny nz oa aw ob bi"><span id="9bfa" class="mh mi it ny b gy oc od l oe of">pandas == 1.0.4<br/>numpy == 1.18.4<br/>pathlib<br/>streamlit == 0.62.0<br/>gensim==3.6.0<br/>matplotlib==3.0.1<br/>seaborn==0.10.1<br/>wordcloud==1.7.0<br/>PyPDF2==1.26.0<br/>nltk==3.5<br/>spacy==2.3.1<br/>https://github.com/explosion/spacy-models/releases/download/en_core_web_sm-2.3.1/en_core_web_sm-2.3.1.tar.gz#egg=en_core_web_sm==2.3.1</span></pre><h2 id="74e8" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">脚本和解释</h2><p id="592f" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">每个脚本都包含代码，这些代码处理或协同工作以实现一个共同的目标。以下是对每个脚本的高级解释。有关更多详细信息，请参见Gensim库文档或google搜索词</p><ul class=""><li id="4647" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated"><strong class="lj jd"> input_output.py: </strong>项目成功的第一步是确定如何成功地从用户那里收集数据，以及输出的格式。用<strong class="lj jd"> <em class="md">的get_input函数</em> </strong>，我们可以收集<strong class="lj jd"> <em class="md">。csv文本</em> </strong>文件或让用户<strong class="lj jd"> <em class="md">复制粘贴</em> </strong>我们创建熊猫数据帧的文本。对于<strong class="lj jd"> <em class="md">上传的CSV文件</em> </strong>，我们使用<strong class="lj jd"><em class="md">select _ feature</em></strong>功能选择包含待分析文本的特征。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">输入_输出. py脚本</figcaption></figure><ul class=""><li id="5dd8" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated"><strong class="lj jd"> Preprocessor.py </strong>:这个脚本处理所有需要的文本预处理，以确保模型的最佳性能。<strong class="lj jd"> <em class="md"> clean_data函数</em> </strong> clean有助于删除电子邮件、网站链接等不需要的单词和模式，并对语料库进行标记。我们使用“<strong class="lj jd"><em class="md">【Spacy】</em></strong>词性(POS)来选择我们需要进行分析的单词，并过滤掉那些不需要的单词。encode函数使用<strong class="lj jd"> <em class="md">词频</em> </strong>或<strong class="lj jd"> <em class="md">词频-逆词频</em> </strong>对Gensim语料库词典创建的“<strong class="lj jd"> <em class="md"> id2word </em> </strong>”进行评分和编码。<strong class="lj jd"> Extract_feature </strong>函数用于形成二元模型、三元模型，并对语料库执行词条化或词干化。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">预处理程序. py</figcaption></figure><ul class=""><li id="32cc" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated"><strong class="lj jd"> lda.py </strong>:通过这个脚本，我们使用Gensim实例化了lda模型，其中包含一些默认的超参数，用户可以通过应用程序界面更改这些参数。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">lda.py脚本</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/e17dac69dfd68ebd41802d035670419d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fi3CgtXtf5NYHKAu3CAAg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">快照2</figcaption></figure><ul class=""><li id="b708" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated"><strong class="lj jd"> Model_evualator.py: </strong>它处理模型评估，向用户显示模型输出的几个顶级角色、单词分布的可视化，以及跨每个文档和显示主导主题单词的单词云的计数。<strong class="lj jd"><em class="md">get _ model</em></strong>result函数用于显示模型输出的几行，我们可以对其进行目测，以分析模型的执行情况。利用<strong class="lj jd"><em class="md">vis _ distribution</em></strong>功能，我们可以可视化主题分布，并以PDF格式导出项目目录。<strong class="lj jd"><em class="md">vis _ word _ cloud</em></strong>和<strong class="lj jd"><em class="md">vis _ word _ count</em></strong>执行类似的任务，其中视觉效果以PDF格式导出。<strong class="lj jd"><em class="md">generate _ chart</em></strong>函数使用PyPDF2库读取、合并生成的PDF，合并后删除每一个。合并的可视化充当模型的报告。选择每个生成的图表，以便消除内存中存储文件的指数增长</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/cc34eb2bb9b077ec041b117e02e26e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buau-E53wVSeTVnuWqoapw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">可视化快照</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/1c9fe8181409ea6b1d3f9881e19d0ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zSqk16JoPxpB7bKPm-jYg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">可视化快照</figcaption></figure><h2 id="98ca" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">使用streamlit的用户界面</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6f2dee6290cd9732c4ad41e43b48b2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*61qEQkPFCo-i5rnIwHeyeg.png"/></div></figure><p id="cbd5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae mg" href="https://www.streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>是一个开源的应用程序框架，它为数据科学家和机器学习工程师提供了一种相对简单的方法，可以在几个小时内创建漂亮、高性能的应用程序！它结合了围绕Python脚本、交互编织和即时部署的三个理念。使用streamlit，将后端与前端耦合起来并不是一件困难的任务，但是跟踪用户会话状态却有点困难，因为streamlit的构建方式是自上而下地运行每一个微小的更改。项目的会话状态保持将在下一个小标题中解释。我们将用户界面分为侧面板和主面板，侧面板处理所需的大部分更改，主面板显示每个侧面板更改的效果和主面板的小操作按钮。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">标题. py</figcaption></figure><p id="be50" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">项目界面中的标题用HTML设计，但用streamlit呈现为markdown。这些函数在应用程序逻辑中的任何主要任务之前被调用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f832ca16ab021d403a9375a722ed3741.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*NeoFjQgeHdQmcHUdA-qiHw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">侧面板少数参数用户界面</figcaption></figure><p id="f68d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在app.py中，从用户处收集参数，如下面的代码片段所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">parameters.py</figcaption></figure><h2 id="f2b8" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">Streamlit中的会话状态</h2><p id="6b65" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">使用streamlit的一个主要问题是保持会话状态。该应用程序旨在接受用户需要执行任务时的更改，而不仅仅是预定义的方法。Streamlit提供了一种缓存机制，允许应用程序即使在从web加载数据、操作大型数据集或执行昂贵的计算时也能保持高性能。这可以通过使用“@st.cache”函数decorator来完成，它告诉Streamlit，无论何时调用该函数，它都需要检查一些事情:</p><ol class=""><li id="dce7" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc om nh ni nj bi translated">用来调用函数的输入参数</li><li id="e738" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc om nh ni nj bi translated">函数中使用的任何外部变量的值</li><li id="76c0" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc om nh ni nj bi translated">函数的主体</li><li id="3cc5" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc om nh ni nj bi translated">缓存函数中使用的任何函数的主体</li></ol><p id="cd0a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里缓存的问题是，我们是在类级别而不是函数级别工作，因此，我们需要一个可以在类级别运行的机制。这导致了会话状态类的创建和使用，正如下面的脚本中所描述的。采用并修改的原代码片段来自于这个Git gist:<a class="ae mg" href="https://gist.github.com/tvst/faf057abbedaccaa70b48216a1866cdd" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/tvst/faf 057 abbedaccaa 70 b 48216 a 1866 cdd</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">会话状态. py</figcaption></figure><p id="9c12" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用session state类，我们可以跟踪用户所做的每一项更改的变量状态和值，从而产生预期的输出。每次重新运行脚本时更新的任何变量都被添加到会话状态变量中，如下面的代码片段所述:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">会话状态变量</figcaption></figure><h2 id="d8e7" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">报告图表生成和下载</h2><p id="b78c" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">模型评估后有两个文件可以下载。这些是:</p><ul class=""><li id="8aa5" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated">包含模型输出的CSV文件</li><li id="ea64" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">报告图表</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/05ac0327b2b6bf28148c4a6af68cb5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FufFkBZ_3eYbnKPGEC40mA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">快照</figcaption></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og mf l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">文件_下载器. py</figcaption></figure><p id="8fc6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">报告图表生成为PDF文件，以base64编码和解码，可以通过生成的链接下载，作为调用时的函数返回。</p><h2 id="a59a" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">部署到Heroku</h2><p id="8b09" class="pw-post-body-paragraph lh li it lj b lk nb kd lm ln nc kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">该应用程序托管在Heroku上，这在以前的文章中解释过几次。这些文章的链接可以在本文的参考资料部分找到。唯一的区别是添加了“NLTK.txt”需求文件，该文件用于处理NLTK依赖项。</p><h2 id="7b27" class="mh mi it bd mj mk ml dn mm mn mo dp mp lq mq mr ms lu mt mu mv ly mw mx my iz bi translated">如何投稿</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c15b560ffc1a4914d64d61149fed4f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*hSWQiVRIQcpYdQKycn9I-Q.png"/></div></figure><p id="488f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一定要抽出时间来为这个工具做贡献，看看我的其他文章，以及参考资料部分的进一步阅读。请记得关注我，以便获得我的出版物的通知。T3】</p><p id="39ca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="md">在</em><a class="ae mg" href="https://twitter.com/opeyemibami" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd"><em class="md">Twitter</em></strong></a><em class="md">和</em><a class="ae mg" href="https://www.linkedin.com/in/bamigbade-opeyemi-49007a122/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd"><em class="md">LinkedIn</em></strong></a></p><p id="78ef" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">查看GitHub项目资源库，记得在下面的链接中注明:</strong></p><div class="op oq gp gr or os"><a href="https://github.com/opeyemibami/Topic-Modelling-Open-Source-Tool" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">opeyemibami/主题-建模-开源-工具</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">上传一个. csv文件或复制粘贴文本进行预处理构建和评估主题模型，无需编码评估…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg lb os"/></div></div></a></div><p id="6426" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">参考文献:</strong></p><div class="op oq gp gr or os"><a href="https://medium.com/@opeyemibami/deployment-of-machine-learning-models-demystified-part-2-63eadaca1571" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">揭秘机器学习模型的部署(第二部分)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">具有无风险可贷金额的贷款接受状态预测</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg lb os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://towardsdatascience.com/deployment-of-machine-learning-model-demystified-part-1-1181d91815d2" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">揭秘机器学习模型的部署(第1部分)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">如果概率度量最好用在贷款违约算法中呢？</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">towardsdatascience.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg lb os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://heartbeat.fritz.ai/deploying-machine-learning-models-on-google-cloud-platform-gcp-7b1ff8140144" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">在谷歌云平台上部署机器学习模型(GCP)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在Kaggle上训练；部署在谷歌云上</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">heartbeat.fritz.ai</p></div></div><div class="pb l"><div class="pj l pd pe pf pb pg lb os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://heartbeat.fritz.ai/deploy-a-machine-learning-model-as-a-web-application-part-1-a1c1ff624f7a" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">将机器学习模型部署为Web应用程序(第1部分)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">具有Streamlit的机器学习支持的Web应用程序</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">heartbeat.fritz.ai</p></div></div><div class="pb l"><div class="pk l pd pe pf pb pg lb os"/></div></div></a></div><ul class=""><li id="6979" class="mz na it lj b lk ll ln lo lq nu lu nv ly nw mc ng nh ni nj bi translated"><a class="ae mg" href="https://www.analyticsvidhya.com/blog/2016/08/beginners-guide-to-topic-modeling-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2016/08/初学者指南-主题建模-python/ </a></li><li id="0c91" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated"><a class="ae mg" href="https://medium.com/nanonets/topic-modeling-with-lsa-psla-lda-and-lda2vec-555ff65b0b05" rel="noopener">https://medium . com/nano nets/topic-modeling-with-LSA-psla-LDA-and-LDA 2 vec-555 ff 65 b 0b 05</a></li><li id="a0fb" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated"><a class="ae mg" href="https://www.kdnuggets.com/2016/07/text-mining-101-topic-modeling.html#:~:text=Topic%20modelling%20provides%20us%20with,documents%20according%20to%20these%20topics" rel="noopener ugc nofollow" target="_blank">https://www . kdnugges . com/2016/07/text-mining-101-Topic-modeling . html #:~:text = Topic % 20 modeling % 20提供%20us%20with，documents %根据% 20to %这些%20topics </a></li><li id="1cf4" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated"><a class="ae mg" href="https://www.tutorialspoint.com/gensim/gensim_topic_modeling.htm" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/gensim/gensim _ topic _ modeling . htm</a></li><li id="e2d2" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated"><a class="ae mg" href="https://towardsdatascience.com/evaluate-topic-model-in-python-latent-dirichlet-allocation-lda-7d57484bb5d0" rel="noopener" target="_blank">https://towards data science . com/evaluate-topic-model-in-python-latent-Dirichlet-allocation-LDA-7d 57484 bb5d 0</a></li><li id="f662" class="mz na it lj b lk nk ln nl lq nm lu nn ly no mc ng nh ni nj bi translated">(Wallach等人，2009年)Wallach，H. M .，Murray，I .，Salakhutdinov，r .，和Mimno，D. (2009年)。主题模型的评估方法。<em class="md">第26届机器学习国际会议论文集，ICML 2009 </em>，<em class="md"> 4 </em>，1105–1112。</li></ul></div></div>    
</body>
</html>