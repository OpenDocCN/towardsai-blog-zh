<html>
<head>
<title>The Power of List Comprehensions and Their Relevance in Machine Learning Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">列表理解的能力及其在机器学习编程中的相关性</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-power-of-list-comprehensions-and-their-relevance-in-machine-learning-programming-fd0dd6171f61?source=collection_archive---------3-----------------------#2021-01-05">https://pub.towardsai.net/the-power-of-list-comprehensions-and-their-relevance-in-machine-learning-programming-fd0dd6171f61?source=collection_archive---------3-----------------------#2021-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="860a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="aaee" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我对如何正确使用嵌套列表的解释</h2></div><p id="07ba" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">List comprehensions是一个编程工具，允许你同时创建和填充列表。然而，我意识到普通程序员并没有像他们应该使用的那样频繁地使用它们。我认为这是因为他们也没有完全理解这背后的力量。</p><p id="6e8f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我将尝试:</p><ul class=""><li id="d24d" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">向你展示<strong class="kt jd">为什么在一些任务中使用列表理解</strong>，以及当问题足够复杂时，你如何节省数百行代码。</li><li id="af76" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">向你展示一种在图形工具(我的草图)的帮助下理解和使用l<strong class="kt jd">is understances</strong>的可理解的方式，就像我通常在我的文章中所做的那样。</li></ul><h2 id="210e" class="mb mc it bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms iz bi translated">列表理解的最强大的用途</h2><p id="9d2e" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">从我为机器学习模型准备数据(预处理)的过程中发现，它最强大的用途<strong class="kt jd">是允许你编辑嵌套列表，而不用破坏它们并重建它们。</strong></p><p id="ded5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，我们在机器学习中需要面对的一个最常见的问题叫做one_hot conversions。许多模型只接受二进制编码的数据。</p><p id="eb8e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于[[1，2]，[3，4]]的样本数据集，您需要以二进制one_hot编码版本对每个数字进行编码:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d181" class="mb mc it nd b gy nh ni l nj nk">1 = [1, 0, 0, 0]<br/>2 = [0, 1, 0, 0]<br/>3 = [0, 0, 1, 0]<br/>4 = [0, 0, 0, 1]</span></pre><p id="720d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果没有列表理解，您将需要分解结构，应用更改，然后重新构建:<strong class="kt jd">没有嵌套列表理解。</strong></p><p id="2659" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦我们知道如何将一个数字转换成one_hot格式，我们就可以将该函数应用于列表中的所有元素，而保持其结构不变。</p><h1 id="60a8" class="nl mc it bd md nm nn no mg np nq nr mj ki ns kj mm kl nt km mp ko nu kp ms nv bi translated">理解列表理解</h1><figure class="my mz na nb gt nx gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nw"><img src="../Images/1d34426060384398f4f6a9a2fd347b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jU3g4G-rAjqnVZX8t5ZY3A.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">列表理解的每个元素的摘要</figcaption></figure><p id="04f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我容易理解和使用列表理解的方法很简单，步骤很少:</p><ol class=""><li id="ac1d" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm oi lt lu lv bi translated">确定列表中的单个元素(el)</li><li id="ed9c" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm oi lt lu lv bi translated">建立列表的外层(列表1)</li><li id="70da" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm oi lt lu lv bi translated">命名list1和el之间的所有其他层。在上面的例子中，有两层:a和b</li></ol><h2 id="7458" class="mb mc it bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms iz bi translated">例子</h2><figure class="my mz na nb gt nx gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi oj"><img src="../Images/1fbc881de977fff66a7bbab45bfb4df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBPk_BwLbNCtWC2x03HGtg.png"/></div></div></figure><p id="c10b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在上面的例子中，我有el和list1，它们之间只有一层会调用a。</p><h2 id="1138" class="mb mc it bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms iz bi translated">使用列表理解</h2><p id="3ac1" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">所有列表理解都遵循以下结构:</p><figure class="my mz na nb gt nx gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi ok"><img src="../Images/63f5e31fad82635bc88a1dfd05801e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCyg3OMBP9I0ZZ9DqcQPRQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">嵌套列表的代码结构</figcaption></figure><p id="654e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请注意，您必须调用每个层(<strong class="kt jd"> el、b和a </strong>)两次，与列表图像的顺序相反，而<strong class="kt jd"> list1 </strong>只调用一次。</p><p id="a4e0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *如果您在没有任何其他实现的情况下使用此代码，该列表将在没有任何更改的情况下重新生成</p><h2 id="0841" class="mb mc it bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms iz bi translated">向列表中的每个元素添加一个数字</h2><p id="3f3e" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">在制作one_hot编码示例之前，让我快速向您展示一些东西，让您了解一个简单的任务:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e2d9" class="mb mc it nd b gy nh ni l nj nk">list1 = [[1, 2], [3, 4]]</span><span id="f463" class="mb mc it nd b gy ol ni l nj nk">[[el+10 for el in a] for a in list1]<br/>\<br/>[[11, 12], [13, 14]]</span></pre><h2 id="3cca" class="mb mc it bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms iz bi translated">把这些数字加在一起</h2><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="fc41" class="mb mc it nd b gy nh ni l nj nk">list1 = [[1, 2], [3, 4]]</span><span id="d78f" class="mb mc it nd b gy ol ni l nj nk">def sum_numbers(a):<br/>  return a[0]+a[1]</span><span id="eacd" class="mb mc it nd b gy ol ni l nj nk">[sum_numbers(a) for a in list1]<br/>\<br/>[3, 7]</span></pre><p id="31fd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这种情况下，我对每一个<strong class="kt jd"> a </strong>都应用了一个函数，因为我想把里面所有的元素都加起来。</p><h2 id="20d7" class="mb mc it bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms iz bi translated">One_hot编码</h2><p id="c73c" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">我现在将对列表中的每个元素执行one_hot编码。它的美妙之处在于<strong class="kt jd">我不需要拆掉重建这个结构。</strong></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="3276" class="mb mc it nd b gy nh ni l nj nk">import numpy as np<br/>list1 = [[1, 2], [3, 4]]</span><span id="d00b" class="mb mc it nd b gy ol ni l nj nk">#creating set<br/>total_elements = set()<br/>[[total_elements.add(el) for el in a] for a in list1]</span><span id="a425" class="mb mc it nd b gy ol ni l nj nk">def encode_number(a):<br/>  vector = np.zeros(len(total_elements))<br/>  vector[a-1] = 1<br/>  return vector</span><span id="f301" class="mb mc it nd b gy ol ni l nj nk">#encoded list<br/>[[list(encode_number(el)) for el in a] for a in list1]<br/>\<br/>[[<br/>[1.0, 0.0, 0.0, 0.0], <br/>[0.0, 1.0, 0.0, 0.0]],  <br/>[[0.0, 0.0, 1.0, 0.0], <br/>[0.0, 0.0, 0.0, 1.0]]]</span></pre><p id="05a3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如你所见，我已经把每个元素都变成了二进制编码的向量。当编辑机器学习模型的数据时，这将被证明是非常有用的，因为大多数神经网络要求数据以非常特定的方式成形(例如，嵌入和LSTMs)。</p></div></div>    
</body>
</html>