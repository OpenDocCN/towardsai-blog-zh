<html>
<head>
<title>Statistical Forecasting of Time Series Data Part 4: Forecasting Volatility using GARCH</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据的统计预测第4部分:用GARCH预测波动性</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/statistical-forecasting-of-time-series-data-part-4-forecasting-volatility-using-garch-1e9ff832f7e5?source=collection_archive---------0-----------------------#2020-12-23">https://pub.towardsai.net/statistical-forecasting-of-time-series-data-part-4-forecasting-volatility-using-garch-1e9ff832f7e5?source=collection_archive---------0-----------------------#2020-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f387" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/ec841cba62008dce057e177c1933719a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uTVb536sFhivyGGV"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@chrisliverani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="42cf" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在这一系列文章中，标准普尔500市场指数使用流行的统计模型进行分析:<strong class="ko ja"> SARIMA </strong>(季节性自回归综合移动平均线)，和<strong class="ko ja"> GARCH </strong>(广义自回归条件异方差)。</p><p id="1a29" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在第一部分中，该系列从python中的<code class="fe lk ll lm ln b">yfinance</code> API中废弃。它被清理并用于计算标准普尔500的回报率(连续价格的百分比变化)和波动性(回报率的大小)。在第二部分中，使用了一些时间序列探索技术来从数据中获得关于趋势、季节性、平稳性等特征的见解。有了这些认识，在第三部分中，探索了SARIMA模型类。</p><p id="f315" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在本文中，GARCH模型被用来模拟标准普尔500收益的波动性。本文中使用的代码来自这个<a class="ae kl" href="https://github.com/yashveersinghsohi/Statistical_Modeling_for_Time_Series_Forecasting" rel="noopener ugc nofollow" target="_blank">资源库</a>中的<strong class="ko ja">Volatility Models/GARCH for SPX Volatility . ipynb</strong>笔记本</p><h1 id="5c44" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">目录</h1><ol class=""><li id="b78d" class="mm mn iq ko b kp mo kt mp kx mq lb mr lf ms lj mt mu mv mw bi translated">导入数据</li><li id="b3d4" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">列车测试分离</li><li id="468c" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">GARCH模型</li><li id="a2fd" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">标准普尔500回报的波动性</li><li id="e046" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">GARCH的参数估计</li><li id="0f8c" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">拟合GARCH对标准普尔500回报</li><li id="c1c8" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">预测波动性</li><li id="e620" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">评估绩效</li><li id="6a30" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">结论</li><li id="b70e" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">链接到本系列的其他部分</li><li id="17f0" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj mt mu mv mw bi translated">参考</li></ol></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="334d" class="lo lp iq bd lq lr nj lt lu lv nk lx ly lz nl mb mc md nm mf mg mh nn mj mk ml bi translated">导入数据</h1><p id="78e4" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">这里，我们导入在本系列的第1部分中被废弃和预处理的数据集。参考第1部分准备好数据，或者从这个<a class="ae kl" href="https://github.com/yashveersinghsohi/Statistical_Modeling_for_Time_Series_Forecasting" rel="noopener ugc nofollow" target="_blank">库</a>下载<strong class="ko ja"> data.csv </strong>文件。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">从本系列的第1部分导入标准包和预处理数据集的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e8ada2238edf6ec641c1f7d8a8cdb4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Hs8ScyWxMhgqIkXjJIyQFQ.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示数据集前5行的前一个代码单元格的输出</figcaption></figure><p id="ff18" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因为这与本系列前面部分中使用的代码相同，所以为了简洁起见，这里不再详细解释每一行。</p><h1 id="4da9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">列车测试分离</h1><p id="43fc" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">我们现在将数据分为训练集和测试集。这里所有来自于<code class="fe lk ll lm ln b">2019–01–01</code>的观测值构成了测试集，之前的所有观测值就是训练集。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">将数据分成训练集和测试集的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1b832eb52c1ff3c20c710c687c274511.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*3tDWhR-cwVwh5dheM28IEg.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示训练集和测试集形状的前一个代码单元的输出</figcaption></figure><h1 id="2297" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">GARCH模型</h1><p id="f1bc" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">GARCH代表<strong class="ko ja">广义自回归条件异方差。</strong>条件异方差相当于时间序列中的条件方差(或条件波动率)。GARCH模型使用波动性聚类的概念对一个序列的波动性进行建模。<strong class="ko ja">波动率聚类</strong>本质上意味着今天的波动率，取决于最近时间步的波动率。使用两个参数来指定GARCH模型:<strong class="ko ja"> GARCH(p，q) </strong>。GARCH模型的公式如下所示。</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e9a07f2274af47df80ce94da333a5650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*D32PMJthugZGO4frX2HlFw.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">GARCH如何模拟波动性的数学公式</figcaption></figure><p id="146e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">上面的等式显示了GARCH如何对波动性建模。某个时间步长的波动率平方表示为某个常数、一组过去残差项和一组过去波动率项的线性组合。参数<strong class="ko ja"> p和q </strong>分别用于控制上述等式中这些滞后残差和波动项的数量。</p><h1 id="6dab" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">标准普尔500回报的波动性</h1><p id="3bb5" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">在这篇文章中，标准普尔500收益的波动性是用GARCH建模的。为了测试预测的波动性是否与未来收益的波动性匹配，我们计算了标准普尔500收益的大小，并将其存储在序列<code class="fe lk ll lm ln b">spx_vol</code>中。</p><p id="6e0f" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，模型适合于<code class="fe lk ll lm ln b">spx_ret</code>序列，预测的波动率与<code class="fe lk ll lm ln b">spx_vol</code>进行比较。</p><h1 id="555b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">GARCH的参数估计</h1><p id="2fd1" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">PACF(部分自相关函数)图用于获得GARCH模型的参数p和q的初始估计。该图中显著滞后的数量被用作初始参数。然后使用模型汇总表(在拟合模型后显示)来了解模型中的哪些系数是重要的。在此基础上，对模型进行微调。</p><p id="23d1" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，标准普尔500收益的PACF图产生了:</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">为标准普尔500回报生成PACF图的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi oa"><img src="../Images/0329ff5fd80f3a970a7e3f57648849e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7fYPWSvAhAVyb5hfvespig.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">标准普尔500回归的PACF情节</figcaption></figure><p id="4ef2" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用<code class="fe lk ll lm ln b">statsmodels.graphics.tsaplots</code>包中的<code class="fe lk ll lm ln b">plot_pacf()</code>功能，为<code class="fe lk ll lm ln b">spx_ret</code>系列生成PACF图。在检查该图时，前两个滞后是显著的。因此，GARCH(2，2)模型适用于初始起点。</p><h1 id="7932" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">拟合GARCH对标准普尔500回报</h1><p id="ce59" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">现在，GARCH(2，2)模型适合标准普尔500收益序列。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">导入并拟合标准普尔500收益的GARCH(2，2)模型的代码</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6f9c27d1ba8ecbe383bb75c7be56d24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*HqQmOwVETvKnMbakg64ICw.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">拟合标准普尔500收益的GARCH(2，2)模型简表</figcaption></figure><p id="9505" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">arch</code>包中的<code class="fe lk ll lm ln b">arch_model()</code>函数用于实现GARCH模型。这里提到的实现是受官方文档<a class="ae kl" href="https://arch.readthedocs.io/en/latest/univariate/univariate_volatility_forecasting.html#Fixed-Window-Forecasting" rel="noopener ugc nofollow" target="_blank">这里</a>中提到的启发。在拟合模型之前，准备一个新的数据框架。该数据帧由原始数据集中的所有时间步长组成(在训练测试分割之前)。训练时间步长被S &amp; P 500的返回占用。这些实际上用于训练GARCH模型。测试周期被之前一个时间步观察到的回报所占据。这相当于说，该模型将使用今天观察到的回报来预测明天的回报波动。</p><p id="fa9e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用<code class="fe lk ll lm ln b">arch_model()</code>方法，定义了模型。该函数将上述数据集作为输入，参数:<code class="fe lk ll lm ln b">p=2</code>和<code class="fe lk ll lm ln b">q=2</code>。<code class="fe lk ll lm ln b">vol= “GARCH”</code>参数指定要使用的模型是GARCH。模型定义存储在变量<code class="fe lk ll lm ln b">model</code>中，并对其调用<code class="fe lk ll lm ln b">fit()</code>方法来训练模型。<code class="fe lk ll lm ln b">last_obs</code>参数用于确保模型仅根据训练数据进行训练。拟合模型存储在<code class="fe lk ll lm ln b">model_results</code>变量中，通过调用拟合模型上的<code class="fe lk ll lm ln b">summary()</code>显示其摘要。</p><p id="d7bf" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">输出图像中汇总表前的前几行显示了通过<code class="fe lk ll lm ln b">fit()</code>函数每次迭代后显示的拟合信息。<code class="fe lk ll lm ln b">fit()</code>函数中的<code class="fe lk ll lm ln b">update_freq=5</code>参数限制该信息在每5次迭代后显示。接下来，在汇总表中有3个部分:<strong class="ko ja">恒定均值— GARCH模型结果、均值模型、</strong>和<strong class="ko ja">波动模型。</strong>在波动率模型部分，<strong class="ko ja"> P &lt; |Z| </strong>栏明确表示所有系数在5%的置信水平下显著。</p><h1 id="9e1a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">预测波动性</h1><p id="4b9b" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">这里，拟合的模型用于预测测试集中标准普尔500收益的波动性。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">生成GARCH模型对标准普尔500回报的波动性预测的代码，并根据回报的大小(假设为波动性)绘制预测</figcaption></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi oc"><img src="../Images/213cf456164e60236e322758a37250f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ML-fUrCmIi2fXZeNUUayOA.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">显示模型预测的波动率与标准普尔500回报时间序列的假设波动率(回报幅度)的关系图。</figcaption></figure><p id="d5c6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">forecast()</code>方法用于拟合模型:<code class="fe lk ll lm ln b">model_results</code>。这将输出一个<code class="fe lk ll lm ln b">ARCHModelForecast</code>对象，其中包含均值模型和波动性模型的预测。接下来，调用<code class="fe lk ll lm ln b">residual_variance</code>属性来获得对波动性的预测。预测存储在数据帧中，周期数与<code class="fe lk ll lm ln b">data</code>中的相同。对模型进行训练的所有期间都有<code class="fe lk ll lm ln b">NaN</code>值，并且实际上只填充模型应该生成预测的期间。在这种情况下，测试集的所有周期都有实数值，而训练集的周期有<code class="fe lk ll lm ln b">NaN</code>。然后根据启发式计算的波动性(回报率的大小)绘制预测。</p><h1 id="9792" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">评估绩效</h1><p id="0298" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">上图显示，每当模型的预测波动率剧烈飙升时，回报的幅度(启发式计算的波动率)也会大幅波动。另一方面，当预测的波动率稳定时，那么收益的大小也相对稳定。因此，我们的模型显然能够识别标准普尔500回报的高波动期和低波动期。</p><p id="5e91" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">该模型的主要目的是识别市场稳定的时期和市场波动的时期，并且该模型成功地捕获了这些信息。因此，没有理由根据像<strong class="ko ja"> RMSE </strong>(均方根误差)这样的误差度量来评估模型</p><h1 id="ced3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="93bd" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">本文利用GARCH模型对标准普尔500收益率的波动性进行了分析和预测。在下一篇文章中，首先，将使用ARIMA模型来拟合标准普尔500收益。然后，GARCH模型将用于模拟ARIMA的残差。这将允许我们生成比ARIMA模型单独生成的置信区间更可靠的置信区间。</p><h1 id="8d95" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">链接到本系列的其他部分</h1><ul class=""><li id="a6f7" class="mm mn iq ko b kp mo kt mp kx mq lb mr lf ms lj od mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-1-data-preparation-and-preprocessing-b52f26f6213c" rel="noopener">时间序列数据的统计建模第1部分:预处理</a></li><li id="cede" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj od mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-2-exploratory-data-analysis-5c3aaedc04b7" rel="noopener">时间序列数据的统计建模第二部分:探索性数据分析</a></li><li id="be2b" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj od mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-modeling-of-time-series-data-part-3-forecasting-stationary-time-series-using-sarima-f0ff1284bebb" rel="noopener">时间序列数据的统计建模第三部分:利用SARIMA预测平稳时间序列</a></li><li id="48d7" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj od mu mv mw bi translated">时间序列数据的统计建模第4部分:用GARCH预测波动性</li><li id="2944" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj od mu mv mw bi translated">时间序列数据的统计建模第五部分:时间序列预测的ARMA+GARCH模型。</li><li id="02f3" class="mm mn iq ko b kp mx kt my kx mz lb na lf nb lj od mu mv mw bi translated"><a class="ae kl" href="https://medium.com/@yashveersinghsohi/statistical-forecasting-for-time-series-data-part-6-forecasting-non-stationary-time-series-using-9acc28c39db9" rel="noopener">时间序列数据的统计建模第六部分:用ARMA预测非平稳时间序列</a></li></ul><h1 id="b1c7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">参考</h1><p id="1a1f" class="pw-post-body-paragraph km kn iq ko b kp mo kr ks kt mp kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">[1]<a class="ae kl" href="https://365datascience.com/courses/time-series-analysis-in-python/" rel="noopener ugc nofollow" target="_blank">365数据科学</a>时间序列分析课程</p><p id="de85" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[2] <a class="ae kl" href="https://machinelearningmastery.com/time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">机器学习掌握</a>关于时间序列分析的博客</p><p id="4346" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[3] <a class="ae kl" href="https://en.wikipedia.org/wiki/Autoregressive_conditional_heteroskedasticity" rel="noopener ugc nofollow" target="_blank">维基百科</a>关于GARCH的文章</p><p id="8876" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[4]<a class="ae kl" href="https://www.youtube.com/channel/UCUcpVoi5KkJmnE3bvEhHR0Q" rel="noopener ugc nofollow" target="_blank">ritvikmath</a>GARCH模型上的YouTube视频。</p><p id="10e3" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[5] <a class="ae kl" href="https://arch.readthedocs.io/en/latest/univariate/univariate_volatility_forecasting.html#Fixed-Window-Forecasting" rel="noopener ugc nofollow" target="_blank"> arch </a>使用GARCH模型进行预测的文档。</p></div></div>    
</body>
</html>