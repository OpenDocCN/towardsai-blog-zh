<html>
<head>
<title>Python Tricks: Unpacking Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python技巧:解包Iterables</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/python-tricks-unpacking-iterables-a1acf8a658a6?source=collection_archive---------2-----------------------#2021-07-17">https://pub.towardsai.net/python-tricks-unpacking-iterables-a1acf8a658a6?source=collection_archive---------2-----------------------#2021-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ffa8b9cf515d15ef09b7f3e8ce290927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vNyc9IlXVKqCw6vP"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">克劳迪奥·施瓦茨在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="5bdf" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="5954" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">你并不总是需要指数</h2></div><p id="afd3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">欢迎阅读一系列短文，每篇短文都有方便的Python技巧，可以帮助你成为更好的Python程序员。在这篇博客中，我们将探讨如何解包iterables。</p><h2 id="e85b" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">你不需要指数。</h2><p id="b14e" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">假设你有一个元组<code class="fe na nb nc nd b">("a", "b", "c")</code>。</p><p id="cd15" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您想将第一个元素分配给<code class="fe na nb nc nd b">a</code>，将第二个元素分配给<code class="fe na nb nc nd b">b</code>，将第三个元素分配给<code class="fe na nb nc nd b">c</code>，您实际上不需要使用索引:</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="bc89" class="md me jj nd b gy nm nn l no np"># Don't do this<br/>t = (<!-- -->"a", "b", "c")<br/>a = t[0]<br/>b = t[1]<br/>c = t[2]</span><span id="3f50" class="md me jj nd b gy nq nn l no np"># Do this instead<br/>t = (<!-- -->"a", "b", "c")<br/>a, b, c = t</span></pre><p id="851f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">事实上，这不仅仅适用于元组:</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="79e2" class="md me jj nd b gy nm nn l no np">a, b, c = [0, 1, 2]              # List<br/>a, b, c = "abc"                  # String<br/>a, b, c = range(3)               # Range<br/>a, b, c = (i for i in range(3))  # Generator<br/>a, b, c = iter([0, 1, 2])        # Iterator<br/>a, b, c = {0, 1, 2}              # Set<br/>a, b, c = {0: 0, 1: 1, 2: 2}     # Dictionary</span></pre><p id="01f9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上述各项中，集合和字典的行为略有不同:</p><ol class=""><li id="57b9" class="nr ns jj lj b lk ll ln lo lq nt lu nu ly nv mc nw nx ny nz bi translated">Sets:解包的顺序可能不会被保留，并且会相对于元素的散列(尝试<code class="fe na nb nc nd b">a, b, c = {3, 2, 1}</code>来测试自己)</li><li id="e1eb" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated">字典:被解包的是键，而不是值，键的顺序和它被创建时一样</li></ol><h2 id="19df" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">解包时跳过值并对其分组</h2><p id="e29f" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">上面所有的例子都有需要解包的元素的确切数目(例如<code class="fe na nb nc nd b">[0, 1, 2]</code>有3个元素需要解包到3个变量<code class="fe na nb nc nd b">a, b, c</code>)。如果列表是<code class="fe na nb nc nd b">[0, 1, 2, 3, 4, 5, 6]</code>，但是我们只需要值<code class="fe na nb nc nd b">0</code>、<code class="fe na nb nc nd b">1</code>和<code class="fe na nb nc nd b">6</code>怎么办？</p><p id="d3f4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们仍然可以使用拆包:</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="5bb7" class="md me jj nd b gy nm nn l no np">a, b, *_, c = <!-- -->[0, 1, 2, 3, 4, 5, 6]</span></pre><p id="13b8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个例子中，有两个重要的要点:</p><ol class=""><li id="2cc2" class="nr ns jj lj b lk ll ln lo lq nt lu nu ly nv mc nw nx ny nz bi translated"><code class="fe na nb nc nd b">_</code>习惯用作废弃变量/虚拟变量</li><li id="6fb4" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated"><code class="fe na nb nc nd b">*</code>是一个运算符，用于解包所有尚未赋值的值。这意味着在确定给<code class="fe na nb nc nd b">*</code>(本例中为<code class="fe na nb nc nd b">_</code>)后面的变量分配多少个值之前，会优先分配其他变量</li></ol><p id="4687" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是坚持住。如果我们的列表只有三个元素呢？</p><pre class="ne nf ng nh gt ni nd nj nk aw nl bi"><span id="3dfb" class="md me jj nd b gy nm nn l no np">a, b, *_, c = <!-- -->[0, 1, 2]</span><span id="ede9" class="md me jj nd b gy nq nn l no np">a # 0<br/>b # 1<br/>c # 2<br/>_ # []</span></pre><p id="8a2b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因为在我们的例子中，值将被优先分配给<code class="fe na nb nc nd b">a</code>、<code class="fe na nb nc nd b">b</code>和<code class="fe na nb nc nd b">c</code>，所以它们中的每一个都将获得一个值，这样就不会留下任何值分配给<code class="fe na nb nc nd b">_</code>。默认情况下，<code class="fe na nb nc nd b">_</code>它将成为一个空列表。</p><h2 id="6512" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">开箱限制</h2><p id="8a93" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">虽然拆包看起来很整洁，但它也有一些关键的限制:</p><ol class=""><li id="b862" class="nr ns jj lj b lk ll ln lo lq nt lu nu ly nv mc nw nx ny nz bi translated">iterable的长度≥非星号变量的数量。否则你会得到<code class="fe na nb nc nd b">ValueError: not enough value to unpack</code></li><li id="1887" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated">只能有1个<code class="fe na nb nc nd b">*</code>变量。否则你会得到<code class="fe na nb nc nd b">SyntaxError: multiple starred expression in assignment</code></li></ol></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="c29e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇博文就讲到这里吧！我希望你已经发现这是有用的。如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="9c42" class="nr ns jj lj b lk ll ln lo lq nt lu nu ly nv mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-flattening-lists-75aeb1102337" rel="noopener" target="_blank"> Python技巧:拉平列表</a></li><li id="7460" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540" rel="noopener" target="_blank"> Python技巧:如何检查与熊猫的表格合并</a></li><li id="84b0" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71" rel="noopener" target="_blank"> Python技巧:简化If语句&amp;布尔求值</a></li><li id="5387" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4" rel="noopener" target="_blank"> Python技巧:对照单个值检查多个变量</a></li></ul><p id="be3f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="b678" class="nr ns jj lj b lk ll ln lo lq nt lu nu ly nv mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2" rel="noopener" target="_blank">改进数据科学工作流程的7种简单方法</a></li><li id="3bcd" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce" rel="noopener" target="_blank">熊猫数据帧上的高效条件逻辑</a></li><li id="7179" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/memory-efficiency-of-common-python-data-structures-88f0f720421" rel="noopener" target="_blank">常见Python数据结构的内存效率</a></li><li id="4da3" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/parallelism-with-python-part-1-196f0458ca14" rel="noopener" target="_blank">Python的并行性</a></li><li id="979b" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72" rel="noopener" target="_blank">数据科学的基本Jupyter扩展设置</a></li><li id="7dd8" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://towardsdatascience.com/mastering-root-searching-algorithms-in-python-7120c335a2a8" rel="noopener" target="_blank">Python中高效的根搜索算法</a></li></ul><p id="2dff" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="9753" class="nr ns jj lj b lk ll ln lo lq nt lu nu ly nv mc om nx ny nz bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d">Python中用于交易策略优化的遗传算法</a></li><li id="ef50" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="f205" class="nr ns jj lj b lk oa ln ob lq oc lu od ly oe mc om nx ny nz bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/ann-recommendation-system-for-stock-selection-c9751a3a0520">人工神经网络选股推荐系统</a></li></ul><div class="is it gp gr iu on"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jt gy z fp os fr fs ot fu fw js bi translated">Louis Chan—FTI Consulting | LinkedIn数据科学总监</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">www.linkedin.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ja on"/></div></div></a></div></div></div>    
</body>
</html>