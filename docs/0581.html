<html>
<head>
<title>Predicting Stock Trend Using Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习预测股票趋势</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/predict-the-stock-trend-using-deep-learning-5a4b7df1d152?source=collection_archive---------0-----------------------#2020-06-12">https://pub.towardsai.net/predict-the-stock-trend-using-deep-learning-5a4b7df1d152?source=collection_archive---------0-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b200" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="020b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用深度学习模型(递归神经网络)预测股票的未来趋势</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3683bef2bdf82bed97411409e4e5ce7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMKgzsPKQ7LT1pUBfzWK5g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用深度学习预测股票趋势</figcaption></figure><blockquote class="le lf lg"><p id="28a9" class="lh li lj lk b ll lm ka ln lo lp kd lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在这篇文章中，我们将建立一个深度学习模型(具体来说是<strong class="lk ja"> RNN </strong>模型)，它将帮助我们<strong class="lk ja">预测给定的股票在未来</strong>是上涨还是下跌。请记住，我们对预测实际值不感兴趣，因为与趋势预测相比，预测实际值要复杂得多。</p></blockquote><p id="34f7" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">如果你是第一次接触<strong class="lk ja">深度学习</strong>，不要担心，我会尽力给你一个<strong class="lk ja">简单</strong>和<strong class="lk ja">容易</strong>的完整教程讲解。此外，我认为这个特定的项目是一个入门级的项目，或者是一个人必须用递归神经网络做的最简单的项目。</p><p id="a2ae" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">所以，首先想到的问题是<strong class="lk ja">什么是递归神经网络？</strong></p><p id="9a6f" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">要了解这一点，我们得先了解一下<strong class="lk ja">神经网络</strong>。在这里，我假设你已经熟悉了<strong class="lk ja">机器学习</strong>。神经网络又称<strong class="lk ja">人工神经网络(ANN)</strong>由三个阶段组成，即<strong class="lk ja">输入层</strong>、若干<strong class="lk ja">隐含层</strong>和<strong class="lk ja">输出层</strong>。顾名思义，输入层用于获取输入并将其输入到模型中，输出层用于给出预测的结果，而隐藏层负责所有的数学计算(每个单元或细胞负责进行小的运算)。<a class="ae mh" href="https://www.tutorialspoint.com/artificial_intelligence/artificial_intelligence_neural_networks.htm" rel="noopener ugc nofollow" target="_blank"> <em class="lj">了解更多安在这里</em> </a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/84464e43def10b3aa712cc6ff79a052e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8w6is1RTCDbj-OA_nQKZA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">人工神经网络</figcaption></figure><p id="a0ac" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated"><strong class="lk ja">递归神经网络(RNN) </strong>是一种神经网络，其中一个时间步骤的输出充当下一个时间步骤的输入。比如<strong class="lk ja">“我饿了，我需要食物”</strong>这句话中，记住<strong class="lk ja">饿了</strong>这个词来预测<strong class="lk ja">食物</strong>是非常重要的。因此，为了预测即将到来的单词，记住前面的单词是很重要的。为了解决这种问题，RNN来了。RNN的主要特征是一个<strong class="lk ja">隐藏状态</strong>，它能记住序列信息。在天气、股市、文本等序列数据方面，RNN表现得非常好。关于RNN   <strong class="lk ja"> </strong>的<strong class="lk ja"> </strong> <a class="ae mh" href="https://www.geeksforgeeks.org/introduction-to-recurrent-neural-network/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja">工作方式我就不赘述了，考虑到这篇文章对初学者比较友好，不过你可以随时谷歌一下😄</strong></a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e9a52c950087f7036adbf7f54d3c5183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F_9bvnRpN3lY_9SGcyMkQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">递归神经网络</figcaption></figure><h1 id="cbfa" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">先决条件:-</h1><p id="13d7" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq me nc lt lu mf nd lx ly mg ne mb mc md ij bi translated">我假设你熟悉<strong class="lk ja"> <em class="lj"> python </em> </strong>并且已经在你的系统中安装了<strong class="lk ja"> <em class="lj"> python 3 </em> </strong>。这个教程我用了一个<strong class="lk ja"> <em class="lj"> jupyter笔记本</em> </strong>。你可以使用你喜欢的<strong class="lk ja"> IDE </strong>。</p><h1 id="09f5" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">使用的数据集:-</h1><p id="afc8" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq me nc lt lu mf nd lx ly mg ne mb mc md ij bi translated">我们在本教程中使用的数据集来自NSE Tata Global stock，可在<a class="ae mh" href="https://github.com/mwitiderrick/stockprice/blob/master/NSE-TATAGLOBAL.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja"> GitHub </strong> </a>上获得。</p><h1 id="4a4b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">安装所需的库</h1><p id="22eb" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq me nc lt lu mf nd lx ly mg ne mb mc md ij bi translated">对于这个项目，您需要在python中安装以下包。如果没有安装，可以直接使用<code class="fe nf ng nh ni b">pip install PackageName</code>。</p><ul class=""><li id="e2ce" class="nj nk iq lk b ll lm lo lp me nl mf nm mg nn md no np nq nr bi translated"><strong class="lk ja"> NumPy </strong> —这个库提供快速计算n维数组对象。</li><li id="b6ef" class="nj nk iq lk b ll ns lo nt me nu mf nv mg nw md no np nq nr bi translated"><strong class="lk ja"> pandas </strong> —它提供了一个数据框架和系列来对数据进行操作和分析。</li><li id="a19a" class="nj nk iq lk b ll ns lo nt me nu mf nv mg nw md no np nq nr bi translated"><strong class="lk ja"> matplotlib </strong> —这个库使用各种绘图来帮助可视化数据。</li><li id="c723" class="nj nk iq lk b ll ns lo nt me nu mf nv mg nw md no np nq nr bi translated"><strong class="lk ja"> scikit-learn </strong> —它是一个机器学习库，提供各种工具和算法用于预测分析。我们将使用它的工具或功能对数据进行预处理。</li><li id="842f" class="nj nk iq lk b ll ns lo nt me nu mf nv mg nw md no np nq nr bi translated"><strong class="lk ja"> Keras </strong> —它是一个基于<strong class="lk ja"> TensorFlow </strong>构建的高级深度学习库，提供了一个简单的神经网络实现。我们使用它是因为它对初学者友好并且易于实现。</li><li id="8de7" class="nj nk iq lk b ll ns lo nt me nu mf nv mg nw md no np nq nr bi translated"><strong class="lk ja">TensorFlow</strong>—<strong class="lk ja">Keras</strong>需要这个库，因为Keras运行tensor flow本身。</li></ul><h1 id="59fb" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">让我们开始编码</h1><p id="2a86" class="pw-post-body-paragraph lh li iq lk b ll na ka ln lo nb kd lq me nc lt lu mf nd lx ly mg ne mb mc md ij bi translated">首先，我们需要导入我们将在项目中使用的库。这里，<code class="fe nf ng nh ni b">numpy</code>用于创建NumPy数组，用于训练和测试数据。<code class="fe nf ng nh ni b">pandas</code>用于制作数据集的数据框架，方便取值。<code class="fe nf ng nh ni b">matplotlib.pyplot</code>绘制数据，如整体股票价格和预测价格。<code class="fe nf ng nh ni b">MinMaxScaler</code>来自<strong class="lk ja"> sklearn的</strong> (scikit-learn)预处理包，用于归一化数据。我们从<strong class="lk ja"> Keras </strong>导入了<code class="fe nf ng nh ni b">Sequential</code> <code class="fe nf ng nh ni b">dense</code> <code class="fe nf ng nh ni b">LSTM</code> <code class="fe nf ng nh ni b">Dropout</code>，这将有助于创建深度学习模型。我们稍后将讨论这些模块。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="de3c" class="ob mj iq ni b gy oc od l oe of"><strong class="ni ja">import </strong>numpy as <strong class="ni ja">np</strong><br/><strong class="ni ja">import </strong>pandas as <strong class="ni ja">pd</strong><br/><strong class="ni ja">import </strong>matplotlib.pyplot as <strong class="ni ja">plt</strong><br/><strong class="ni ja">from </strong>sklearn.preprocessing <strong class="ni ja">import </strong>MinMaxScaler<br/><strong class="ni ja">#for deep learning model</strong><br/><strong class="ni ja">from </strong>keras <strong class="ni ja">import </strong>Sequential<br/><strong class="ni ja">from </strong>keras.layers <strong class="ni ja">import </strong>Dense<br/><strong class="ni ja">from </strong>keras.layers <strong class="ni ja">import </strong>LSTM<br/><strong class="ni ja">from </strong>keras.layers <strong class="ni ja">import </strong>Dropout</span></pre><p id="b276" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">现在，我们已经将数据集作为数据框加载到名为<strong class="lk ja"> df </strong>的变量中。然后，我们检查了数据集的形状，结果是<strong class="lk ja"> (2035，8) </strong>表示数据集中有2035行和8列。之后，我们颠倒了数据集，使<strong class="lk ja">日期</strong>从最早的日期开始，到最近的日期，这样我们还必须重置索引。然后我们用<code class="fe nf ng nh ni b">head()</code>打印了数据集的一些起始行。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="abb3" class="ob mj iq ni b gy oc od l oe of">df = pd.read_csv('NSE-TATAGLOBAL.csv')<br/>df.shape<br/>df = df[::-1]<br/>df = df.reset_index(drop=True)<br/>df.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/7c45f3d337fd032ac71ff8c42cd719b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfHXR7wCNp_eqwTOzCleXg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">数据集的前5个条目</figcaption></figure><p id="6340" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">我们只选择了一个功能，即<strong class="lk ja">打开</strong>来训练我们的模型，但您可以自由选择多个功能，但代码会相应地更改。在训练集中，我们有2000个值，而在测试中，我们决定只有35个值。然后我们简单地打印出两个<code class="fe nf ng nh ni b">train_set</code> <code class="fe nf ng nh ni b">test_set</code>的形状，分别为(2000，1)和(35，1)。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="d8f5" class="ob mj iq ni b gy oc od l oe of">open_price = df.iloc[:,1:2]<br/>train_set = open_price[:2000].values<br/>test_set = open_price[2000:].values<br/>print("Train size: ",train_set.shape)<br/>print("Test size:",test_set.shape)</span></pre><p id="7729" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">这里，我们将<strong class="lk ja">日期</strong>列转换为<strong class="lk ja">日期时间</strong>格式，以便于绘制。然后简单地使用<code class="fe nf ng nh ni b">plot_date</code>在整个时间线上绘制股票的<strong class="lk ja">开盘价</strong>的数字，并使用<code class="fe nf ng nh ni b">savefig</code>保存该数字。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="aa6d" class="ob mj iq ni b gy oc od l oe of">dates = pd.to_datetime(df['Date'])<br/>plt.plot_date(dates, open_price,fmt='-')<br/>plt.savefig("test1final.png")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8678f95bab05766e32438871481941f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Av08JN-vhrYbWqyDuggntQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">NSE塔塔全球公开价格(2010–2019)</figcaption></figure><p id="83a5" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">现在，我们已经初始化了用于缩放0和1范围内的每个值的<code class="fe nf ng nh ni b">MinMaxScalar</code>。这是非常重要的一步，因为当特征处于相对相似的尺度时，神经网络和其他算法收敛得更快。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="ad70" class="ob mj iq ni b gy oc od l oe of">sc = MinMaxScaler()<br/>train_set_scaled = sc.fit_transform(train_set)</span></pre><p id="bfa9" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">棘手的部分来了。现在，我们必须使数据适合我们的<strong class="lk ja"> RNN </strong>模型，即制作具有目标最终值的数据序列。我来举例说明一下。假设我们有一个数据集，其值从1到10，序列长度为3。在这种情况下，我们的训练数据将看起来像这样-</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1674db84b21e4992bba16b6fd8e31c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*IwKWffPMOCL0Wexa6Qt0Xw.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">序列训练数据例子</figcaption></figure><p id="414e" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">在这里的代码中，序列的长度是60，这意味着只有前60个值将决定下一个值，而不是整个数据集。之后，我们创建了NumPy数组<code class="fe nf ng nh ni b">x_train</code>和<code class="fe nf ng nh ni b">y_train</code>用于快速计算，并根据我们的模型的要求重塑了训练集。<code class="fe nf ng nh ni b">x_train</code>的最终形状出来是(1940，60，1)。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="f65e" class="ob mj iq ni b gy oc od l oe of">x_train = []<br/>y_train = []<br/>for i in range(60,2000):<br/>    x_train.append(train_set_scaled[i-60:i,0])<br/>    y_train.append(train_set_scaled[i,0])<br/>x_train = np.array(x_train)<br/>y_train = np.array(y_train)</span><span id="b5cb" class="ob mj iq ni b gy oj od l oe of">x_train = np.reshape(x_train,(x_train.shape[0],x_train.shape[1],1))<br/>x_train.shape</span></pre><p id="b4b4" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">现在，我们将创建模型的架构。我们使用了<strong class="lk ja"> Keras </strong>，因为与其他可用的库相比，使用Keras使<strong class="lk ja">成为深度学习</strong>模型相当容易。这里，我们已经初始化了我们的<strong class="lk ja">序列</strong>对象，它作为模型中所有层的捆绑器。我们的模型总共有<strong class="lk ja"> 4个LSTM </strong>层和<strong class="lk ja">一个密集</strong>层。</p><p id="b2dc" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated"><strong class="lk ja"> LSTM(长短期记忆)</strong>是一种递归神经网络，它有一些<strong class="lk ja">上下文状态单元</strong>，充当长期或短期记忆单元，这些单元调节输出。当我们需要根据<strong class="lk ja">的历史背景</strong>而不仅仅是最后的输入来预测输出时，这是很重要的。例如，我们必须预测序列中的下一个数字<strong class="lk ja"> 3，4，5，？</strong>那么输出就是简单的<strong class="lk ja"> 6 </strong> (x+1)但是在序列<strong class="lk ja"> 0，2，4，？</strong>输出也是<strong class="lk ja"> 6 </strong>，但它也取决于<strong class="lk ja">上下文信息</strong>。</p><p id="039f" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated"><strong class="lk ja">丢弃</strong>用于防止<strong class="lk ja">过度拟合</strong>数据，方法是一次简单地停用一些单元(<strong class="lk ja">神经元</strong>)，在我们的例子中，一次停用<strong class="lk ja"> 20 </strong> %的单元。最后，我们有一个<strong class="lk ja">密集</strong>层，其<strong class="lk ja"> 1 </strong>单元给出了预测值。然后，我们简单地用<code class="fe nf ng nh ni b">adam</code>优化器编译我们的模型，根据数据拟合我们的模型，并运行<strong class="lk ja"> 20 </strong>次迭代，即<code class="fe nf ng nh ni b">epochs</code>。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="5dd6" class="ob mj iq ni b gy oc od l oe of">reg = Sequential()</span><span id="2701" class="ob mj iq ni b gy oj od l oe of">reg.add(LSTM(units = 50,return_sequences=True,input_shape=(x_train.shape[1],1)))<br/>reg.add(Dropout(0.2))</span><span id="fb62" class="ob mj iq ni b gy oj od l oe of">reg.add(LSTM(units = 50,return_sequences=True))<br/>reg.add(Dropout(0.2))</span><span id="f5c5" class="ob mj iq ni b gy oj od l oe of">reg.add(LSTM(units = 50,return_sequences=True))<br/>reg.add(Dropout(0.2))</span><span id="c27b" class="ob mj iq ni b gy oj od l oe of">reg.add(LSTM(units=50))<br/>reg.add(Dropout(0.2))</span><span id="211a" class="ob mj iq ni b gy oj od l oe of">reg.add(Dense(units=1))<br/>reg.compile(optimizer = 'adam',loss='mean_squared_error')<br/>reg.fit(x_train,y_train, epochs=20, batch_size =1,verbose=2)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f20117ca198923ceee39e32d20cfaf3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*nhZkDz9RSGiNuQOjnYjpzg.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">每次迭代的损失</figcaption></figure><p id="df64" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">如你所见，我们的模型收敛于<strong class="lk ja"> 15 </strong>个时期，我总共花了大约<strong class="lk ja"> 90 </strong>分钟运行<strong class="lk ja"> 20 </strong>个时期。是的<strong class="lk ja"> RNN </strong>车型需要时间来训练。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/4501ed128f1aca796ba7d156188cbd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*AYbXOJKwz8nLo2eDi-0nsw.gif"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">RNN模式需要时间</figcaption></figure><p id="d180" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">现在，是时候为测试创建输入了。<code class="fe nf ng nh ni b">input</code>的形状是(95，1 ),我们也缩放这个数据。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="181e" class="ob mj iq ni b gy oc od l oe of">input = open_price[len(open_price)-len(test_set)-60:].values<br/>input.shape<br/>input = sc.transform(input)</span></pre><p id="f5ec" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">这是最后一部分，我们简单地制作数据的<strong class="lk ja">序列</strong>来预测过去35天的股票价值。第一个序列包含从1–60预测第61个值的数据，第二个序列包含从2–61预测第62个值的数据，依此类推。<code class="fe nf ng nh ni b">x_test</code>的形状是(35，60，1)这证明了解释的正确性。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="2591" class="ob mj iq ni b gy oc od l oe of">x_test = []<br/>for i in range(60,95):<br/>    x_test.append(input[i-60:i,0])<br/>x_test = np.array(x_test)<br/>x_test = np.reshape(x_test,(x_test.shape[0],x_test.shape[1],1))<br/>x_test.shape</span></pre><p id="0a1f" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated"><strong class="lk ja">最后</strong>，我们简单地<strong class="lk ja">使用<code class="fe nf ng nh ni b">predict</code>我们定义的模型的函数来预测</strong>值，并绘制给定股票的最后<strong class="lk ja"> 35 </strong>实际值和预测值。</p><pre class="kp kq kr ks gt nx ni ny nz aw oa bi"><span id="99f8" class="ob mj iq ni b gy oc od l oe of">pred = reg.predict(x_test)<br/>pred = sc.inverse_transform(pred)<br/>plt.plot(test_set,color='green')<br/>plt.plot(pred,color='red')<br/>plt.title('Stock_prediction')<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/cdc7a236cfbc4affd69d3b7a7cce8967.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*T6FgIYJGUv57O7NAgmYhlA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">决赛成绩</figcaption></figure><p id="a755" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated"><strong class="lk ja"> <em class="lj">注</em> </strong> <em class="lj">:图中两条线是独立的，即实际值不用于预测趋势。看起来我们的预测图是滞后的，但是相信我，它只是用它的预测值来预测序列中的下一个值。代码在这个数据集上运行良好，但在其他数据集上可能不太好。同样的代码是开源的，可以随意修改。</em></p><p id="001e" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">正如你从图中看到的，我们的模型在预测给定股票的未来趋势时非常准确。😎现在你可以成为股票市场的优秀顾问。😆</p><p id="bb90" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">通过加入<strong class="lk ja">更多特性</strong>、<strong class="lk ja">增加数据集</strong>、<strong class="lk ja">调整模型</strong>本身，可以进一步改进模型。</p><p id="c920" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">源代码在<a class="ae mh" href="https://github.com/PushkaraSharma/medium_articles_code/tree/master/Predict_Stock_Trend_RNN" rel="noopener ugc nofollow" target="_blank"> <strong class="lk ja"> GitHub </strong> </a>上有。请随意改进。</p><p id="756a" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">谢谢你宝贵的时间。😊我希望你喜欢这个教程。</p><p id="467c" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq me ls lt lu mf lw lx ly mg ma mb mc md ij bi translated">还有，查看我的教程<a class="ae mh" href="https://medium.com/analytics-vidhya/visualize-interesting-sorting-algorithms-with-python-bdd64bdd0713" rel="noopener"> <em class="lj">如何可视化排序算法</em> </a> <em class="lj">。</em></p><div class="om on gp gr oo op"><a href="https://medium.com/analytics-vidhya/visualize-interesting-sorting-algorithms-with-python-bdd64bdd0713" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ja gy z fp ou fr fs ov fu fw iz bi translated">用Python可视化有趣的排序算法</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">有各种类型的排序算法，有时很难理解它们…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ky op"/></div></div></a></div></div></div>    
</body>
</html>