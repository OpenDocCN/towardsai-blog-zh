<html>
<head>
<title>Meta-Learning Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元学习简介</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/meta-learning-introduction-569bd144ee65?source=collection_archive---------2-----------------------#2022-11-25">https://pub.towardsai.net/meta-learning-introduction-569bd144ee65?source=collection_archive---------2-----------------------#2022-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e51b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们每天都会听到很多关于深度学习的新进展。我们希望我们的模型越来越好，在安全的决策过程中选择合适的基础学习者的风险最小。本文是对元学习的简要介绍。毫无疑问，在时序、自然语言等序列数据集上工作。需要大量的工作，外部因素会带来高度的不确定性。元学习就是学习学习我们用它来学习更好的学习算法的地方，例如，参数初始化，优化策略，网络架构等。近年来，我们已经看到对元学习兴趣的上升，因为它试图改进其学习算法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/00cb6954910845ad20c52241d34ba92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*ecLr0KQpK205SpZjtdSM-g.gif"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><a class="ae la" href="https://giphy.com/gifs/lanlancat-mochidad-5266-5vlqsvkApaFjtvL6CZ" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="a6f5" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么是元学习</h1><p id="d3cf" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">元学习看起来很有前景的主要原因是它与当前机器学习算法的不同。它说我们通常从零开始用特定的目标<strong class="js iu"> </strong>训练我们的模型，用学习<strong class="js iu">新概念</strong>的<strong class="js iu">限制</strong>；然而，这不是我们在这种情况下的倾向，而/这是大的预训练模型等的主要原因。方法。因此，元学习可以被认为是一种从几个学习阶段的经验中学习的策略，然后利用这些经验来提高将来的表现。换句话说，它打算“<strong class="js iu">学习学习</strong>”。</p><blockquote class="me"><p id="18a7" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated">好吧，好吧！！！我不会说太多(好孩子👦🏻🙂).所以，让我们来看看它的工作方式。</p></blockquote><h1 id="7eae" class="lb lc it bd ld le lf lg lh li lj lk ll lm mo lo lp lq mp ls lt lu mq lw lx ly bi translated">元学习</h1><h2 id="fe74" class="mr lc it bd ld ms mt dn lh mu mv dp ll kb mw mx lp kf my mz lt kj na nb lx nc bi translated">整个等效过程(与机器学习相比)</h2><p id="e994" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在<strong class="js iu"> <em class="nd">机器学习</em> </strong>中，我们经常要在我们的大部分数据集(<strong class="js iu">训练数据</strong>)上训练一个模型(实际上是<strong class="js iu">模型参数</strong>，然后在<strong class="js iu">分类</strong>和<strong class="js iu">回归任务中计算<strong class="js iu">模型的输出(预测)</strong>和<strong class="js iu">真实数据</strong> (loo函数)之间的<strong class="js iu">距离</strong>。</strong></p><p id="dd51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> <em class="nd">元学习</em> </strong>中，我们考虑fφ(。)作为<strong class="js iu">学习算法</strong>其中它的输入是训练数据，输出是我们学习的模型参数。φ是元学习中我们喜欢学习的<strong class="js iu">元参数</strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/90a88a071c220edf960047b10ba4370e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uxn-9DXOO6kc1yb1qzdTuw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">定义1</figcaption></figure><p id="3fa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要一个<strong class="js iu">任务</strong>来<strong class="js iu">学习元参数</strong>(<strong class="js iu">φ</strong>)，这个被命名为<strong class="js iu"> <em class="nd"> T_train ( </em>元训练任务<em class="nd"> ): </em> </strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0e64c4cca84ef9cfa3bf3938bf87acc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*wrnJmnUOrPt6vhM0iHnYYw.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Eq 1。培训任务</figcaption></figure><h2 id="1972" class="mr lc it bd ld ms mt dn lh mu mv dp ll kb mw mx lp kf my mz lt kj na nb lx nc bi translated">元学习中的训练和测试数据集等价</h2><p id="cb38" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">每个任务包含两个集合，包括1。<strong class="js iu"> <em class="nd">一个支持集(序号</em> </strong> ) 2。<strong class="js iu"> <em class="nd">一个查询集合(Qn </em> </strong>)其中这两个构造<strong class="js iu">对</strong>的例子(<strong class="js iu"> <em class="nd"> D </em> </strong>)。</p><p id="cf52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">问)</strong>这些套的作用是什么？</p><p id="24ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> A) </strong> <strong class="js iu">支持</strong>集合和<strong class="js iu">查询集合</strong>是机器学习项目中<strong class="js iu">训练</strong>和<strong class="js iu">测试数据</strong>的等价物。</p><blockquote class="me"><p id="1a53" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated"><em class="nk">支持集=训练数据</em></p><p id="ccea" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated"><em class="nk">查询集=测试数据</em></p></blockquote><ul class=""><li id="980b" class="nl nm it js b jt nn jx no kb np kf nq kj nr kn ns nt nu nv bi translated">请注意，这些是一样的，只要想象我们在元学习的宇宙中。</li></ul><h2 id="b374" class="mr lc it bd ld ms mt dn lh mu mv dp ll kb mw mx lp kf my mz lt kj na nb lx nc bi translated">元学习中的损失函数等价</h2><p id="0c6d" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">好的，那么我们是否以不同的方式定义损失函数？？</p><p id="8e06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a)不完全是，这里的损失是说一个学习算法是如何“坏”或“好”地被在<strong class="js iu">训练任务</strong> (T_training)上的<strong class="js iu">元参数(</strong>φ)参数化；看等式2:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nw"><img src="../Images/6b37fe0bf5545c836dea9d2b5734443f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5WJLuxBB899NFsssWb3Pg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">等式2</figcaption></figure><p id="ad8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">定义2指出:</p><p id="d3b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们使用我们的<strong class="js iu">支持集</strong> ( <strong class="js iu"> <em class="nd"> Sn </em> </strong>)(训练数据)来<strong class="js iu">训练</strong>我们的模型并实现<strong class="js iu">学习模型</strong>。(称为<strong class="js iu"> <em class="nd">任务内培训</em> </strong>)</p><p id="b2cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，<strong class="js iu">在<strong class="js iu">查询集</strong> ( <strong class="js iu"> <em class="nd"> Qn </em> </strong>)(测试数据)上对学习到的模型进行评估。(称为<strong class="js iu"> <em class="nd">任务内测试</em> </strong>)</strong></p><p id="74ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，总结所有任务的任务内测试结果。</p><p id="ad43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个<strong class="js iu"> <em class="nd">任务内训练</em> </strong> <em class="nd"> </em>和<strong class="js iu"> <em class="nd">任务内测试</em> </strong> <em class="nd"> </em>的组合称为一个<strong class="js iu"> <em class="nd">集</em> </strong> <em class="nd">。</em></p><h2 id="0466" class="mr lc it bd ld ms mt dn lh mu mv dp ll kb mw mx lp kf my mz lt kj na nb lx nc bi translated">元学习中的优化函数等价</h2><p id="7f06" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">它被称为优化任务，用于学习元参数φ，参见等式3:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nx"><img src="../Images/c00ad6d88de817f09b82a044f3b50031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZEIcdFr-P2JNIrOqmLmDA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">等式3</figcaption></figure><p id="984b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们进退两难，不知道这里用什么函数L:</p><ol class=""><li id="9fc9" class="nl nm it js b jt ju jx jy kb ny kf nz kj oa kn ob nt nu nv bi translated">如果<strong class="js iu">φ</strong>是<strong class="js iu">可微的</strong> — — →我们可以利用<strong class="js iu">梯度下降(GD) </strong></li><li id="cd8b" class="nl nm it js b jt oc jx od kb oe kf of kj og kn ob nt nu nv bi translated">否则，我们可以利用<strong class="js iu">强化学习算法</strong>或<strong class="js iu">进化算法</strong>。</li></ol><ul class=""><li id="14cc" class="nl nm it js b jt ju jx jy kb ny kf nz kj oa kn ns nt nu nv bi translated">解方程3被称为<strong class="js iu">跨任务训练</strong>，它包括在任务上运行许多片段。</li><li id="75bc" class="nl nm it js b jt oc jx od kb oe kf of kj og kn ns nt nu nv bi translated">同样，我们有与<strong class="js iu">相同的术语跨任务测试</strong>来评估<strong class="js iu">上的φ*<em class="nd">元测试任务</em> T_test </strong>(通过一个<strong class="js iu">插曲</strong>对<strong class="js iu">每个T_test </strong>进行<strong class="js iu"> <em class="nd">参数化模型</em>评估</strong>)。</li></ul><h2 id="30fe" class="mr lc it bd ld ms mt dn lh mu mv dp ll kb mw mx lp kf my mz lt kj na nb lx nc bi translated">任务构建</h2><p id="5fc8" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">测试和训练(T_test和T_train)都有几种元学习任务构造的设置:</p><ol class=""><li id="8e20" class="nl nm it js b jt ju jx jy kb ny kf nz kj oa kn ob nt nu nv bi translated"><strong class="js iu">跨域名转让</strong></li><li id="7289" class="nl nm it js b jt oc jx od kb oe kf of kj og kn ob nt nu nv bi translated"><strong class="js iu">跨语言迁移</strong></li><li id="e072" class="nl nm it js b jt oc jx od kb oe kf of kj og kn ob nt nu nv bi translated"><strong class="js iu">交叉问题训练</strong></li><li id="cb5b" class="nl nm it js b jt oc jx od kb oe kf of kj og kn ob nt nu nv bi translated"><strong class="js iu">领域泛化(DG) </strong></li><li id="cca7" class="nl nm it js b jt oc jx od kb oe kf of kj og kn ob nt nu nv bi translated"><strong class="js iu">任务增强</strong></li></ol><blockquote class="oh oi oj"><p id="3505" class="jq jr nd js b jt ju jv jw jx jy jz ka ok kc kd ke ol kg kh ki om kk kl km kn im bi translated">我没有举例说明这些结构，以防止文章变长，但如果你感兴趣，你可以让我知道要写它们，或者只是谷歌一下。</p></blockquote><p id="d7a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">元学习有着广阔的前景，如下图所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/68bec7cf7684df52d4bfed79a3f4e99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*faKGazEMMxTJK8pL7V3xzg.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">图1 [ <a class="ae la" href="https://csdl-downloads.ieeecomputer.org/trans/tp/2022/09/09428530.pdf?Expires=1669107021&amp;Policy=eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cHM6Ly9jc2RsLWRvd25sb2Fkcy5pZWVlY29tcHV0ZXIub3JnL3RyYW5zL3RwLzIwMjIvMDkvMDk0Mjg1MzAucGRmIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNjY5MTA3MDIxfX19XX0_&amp;Signature=BJzy49NEOtsUAdXHFLnUuQm4-zQORN8L1uWf9tDD~XPTyPFcCLgaQgzgvMi4hrlSOxMWSY3gG31XnyNdcxmkv4XlSP50FUvQ8nCP8ycv-EOsasfx0k63dslfZ~X-DHUheyfgpZObB0nB1G-JTJgAIiO02ls32xJz-9cuDazC47qPvNZTIdmkVim8GFoOuXpyC80vVWYqSkEE2yUNOZ1zv1eQJPQdD0QvaYSOpTh1wSCzPoZ1raFYDxy1DhKeK-h4OAHDggzxrY3zZv-cHDcQ7gHa3dMFayX5Wrx3fDvR1OUa6VBpExJOvUHUagNbzz0eBYKJQgAjVfibS5W6m7~IKw__&amp;Key-Pair-Id=K12PMWTCQBDMDT" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><blockquote class="me"><p id="18f7" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated">这是元学习术语的简要介绍。下一篇文章，我将发表关于元学习在时间序列中的应用，之后我将发表关于如何为时间序列预测提出一个元学习模型。</p></blockquote><p id="4e20" class="pw-post-body-paragraph jq jr it js b jt nn jv jw jx no jz ka kb ov kd ke kf ow kh ki kj ox kl km kn im bi translated">如果你有任何想法或问题，你可以告诉我🙂。怎么会？？你可以通过<a class="ae la" href="http://www.linkedin.com/in/rezayazdanfar" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>轻松联系我。</p><p id="9f8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章对你的工作有用，如果你发现有什么错误，让我知道，或者如果你认为有什么遗漏，让我知道添加到文章中。</p></div></div>    
</body>
</html>