<html>
<head>
<title>Method Overloading and Method Overriding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的方法重载和方法覆盖</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/method-overloading-and-method-overriding-in-python-2acf154b7548?source=collection_archive---------1-----------------------#2021-06-03">https://pub.towardsai.net/method-overloading-and-method-overriding-in-python-2acf154b7548?source=collection_archive---------1-----------------------#2021-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ce4d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="b117" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">python中的一个概念</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/de5cd90ac24c0a64057bfbfe5306c61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M4Dvo52frMBKTi_y"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@rezanamdari?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">礼萨·南达里</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a433" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将讨论方法重载和方法重写。这两个概念都是多态性的类型。多态性是来自面向对象编程(OOPs)的一个概念，即相同的方法表现出不同的特征。</p><h2 id="ed14" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">方法重载</h2><p id="d919" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">简单地说，重载意味着我们有相同的方法名，但是参数不同，或者参数的数量或类型不同。但是python中没有方法重载的概念，也就是说，我们不能在同一个类中创建两个同名的方法。</p><p id="3f4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们会让你明白在python中实现方法重载</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="8608" class="me mf it nc b gy ng nh l ni nj">class student:<br/>         <br/>    def sum(self,a, b):<br/>        s = a+b<br/>            <br/>        return s<br/>    <br/>s1 = student()<br/>print(s1.sum(2,3))</span><span id="a6e6" class="me mf it nc b gy nk nh l ni nj">#output:<br/>5</span></pre><p id="8620" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个简单的类方法有一个名为sum的方法，它接受两个参数“a”和“b ”,在传递值后我们得到结果“5”。但是如果我们传递这三个值，就会产生错误。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="3ce6" class="me mf it nc b gy ng nh l ni nj">class student:<br/>         <br/>    def sum(self,a, b):<br/>        s = a+b<br/>            <br/>        return s<br/>    <br/>s1 = student()<br/>print(s1.sum(2,3,4))</span><span id="9063" class="me mf it nc b gy nk nh l ni nj">#output:<br/><strong class="nc jd">TypeError</strong>: sum() takes 2 positional arguments but 4 were given</span></pre><p id="5f34" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，我们将两个值传递给三个参数，它给出了错误。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="46c0" class="me mf it nc b gy ng nh l ni nj">class student:<br/>         <br/>    def sum(self, a,b,c):<br/>        s = a+b+c<br/>            <br/>        return s<br/>    <br/>s1 = student()<br/>print(s1.sum(2,3))</span><span id="39a4" class="me mf it nc b gy nk nh l ni nj">#output:<br/><strong class="nc jd">TypeError</strong>: sum() missing 1 required positional argument: 'c'</span></pre><p id="2b2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们在其他语言中创建了一个额外的方法来接受三个值，但是在python中，我们可以用不同的方法来实现，如下例所示:</p><p id="c262" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用“None”作为参数的默认值，也可以使用可变长度的参数。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="7fc5" class="me mf it nc b gy ng nh l ni nj">class student:<br/>        <br/>    def sum(self,a=None, b=None, c=None):<br/>        s = 0<br/>        <br/>        if a!=None and b!=None and c!=None:<br/>            s = a+b+c<br/>        <br/>        elif a!=None and b!=None:<br/>            s = a+b<br/>            <br/>        else:<br/>            s = a<br/>            <br/>        return s</span><span id="dc20" class="me mf it nc b gy nk nh l ni nj">s1 = student()<br/>print(s1.sum(4,2,5))</span><span id="ef73" class="me mf it nc b gy nk nh l ni nj">#output:<br/>11</span></pre><p id="d260" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使我们不向参数传递任何值，这个类方法也会工作。</p><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/oops-concept-in-python-b5f5833d57db"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">Python中的OOPs概念</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">OOPs是编写程序的一种高效方式</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pub.towardsai.net</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lb no"/></div></div></a></div><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/7-beginners-tips-to-help-you-get-better-at-learn-python-33149417b447"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">帮助你更好地学习Python的7个初学者技巧</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">成为python专家的分步主题</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pub.towardsai.net</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc lb no"/></div></div></a></div><h2 id="c382" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">方法覆盖</h2><p id="eaa4" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在方法重写中，我们有相同名称的方法，有相同数量的参数，但不在同一个类中，这样继承的概念就出现了。</p><p id="03d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">方法覆盖概念在软件行业中非常重要。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="c8d7" class="me mf it nc b gy ng nh l ni nj">class apple:<br/>         <br/>    def fruit(self):<br/>        print("You are eating Apple")</span><span id="0c13" class="me mf it nc b gy nk nh l ni nj">class orange:<br/>    pass<br/>            <br/>f = orange()<br/>f.fruit()</span><span id="519a" class="me mf it nc b gy nk nh l ni nj">#output:<br/><strong class="nc jd">AttributeError</strong>: 'orange' object has no attribute 'fruit'</span></pre><p id="4f91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以观察到orange类没有水果方法，所以它给出了一个错误。</p><p id="387b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们可以用一个继承的概念作为父类和子类来继承父类的所有属性呢？在本例中，我们将apple作为父类，orange作为子类。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="0c5a" class="me mf it nc b gy ng nh l ni nj">class apple:<br/>         <br/>    def fruit(self):<br/>        print("You are eating Apple")</span><span id="7385" class="me mf it nc b gy nk nh l ni nj">class orange(apple):<br/>    pass<br/>            <br/>f = orange()<br/>f.fruit()</span><span id="1bc2" class="me mf it nc b gy nk nh l ni nj">#output:<br/>You are eating Apple</span></pre><p id="60b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，对象首先在orange类的方法中搜索句子，没有找到，但是orange方法继承了apple类的所有属性，然后对象转到apple类来检查fruit方法。</p><p id="01da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在orange类中创建相同的水果方法，如下例所示:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="8e9b" class="me mf it nc b gy ng nh l ni nj">class apple:<br/>         <br/>    def fruit(self):<br/>        print("You are eating Apple")</span><span id="cbea" class="me mf it nc b gy nk nh l ni nj">class orange:<br/>    <br/>    def fruit(self):<br/>        print("You are eating Orange")<br/>            <br/>f = orange()<br/>f.fruit()</span><span id="8300" class="me mf it nc b gy nk nh l ni nj">#output:<br/>You are eating Orange</span></pre><p id="32ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这次对象在orange类中找到了水果方法。</p><h2 id="ec71" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">结论</h2><p id="b042" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这两个概念在软件开发中非常有用，可以简化软件的工作功能。</p><p id="9ea3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="1452" class="oe mf it bd mg of og oh mj oi oj ok mm ki ol kj mp kl om km ms ko on kp mv oo bi translated">推荐文章</h1><ol class=""><li id="86ce" class="op oq it lk b ll mw lo mx lr or lv os lz ot md ou ov ow ox bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener">NLP——用Python零到英雄</a></li><li id="6e43" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/fully-explained-hierarchical-clustering-with-python-ebb256317b50?source=friends_link&amp;sk=7e7113e2a07591a862c77e890fefed10">用Python全面解释层次聚类</a></li><li id="f563" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a></li><li id="f899" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/deep-learning-88e218b74a14?source=friends_link&amp;sk=540bf9088d31859d50dbddab7524ba35">为什么LSTM在深度学习方面比RNN更有用？</a></li><li id="bb9b" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/neural-networks-the-rise-of-recurrent-neural-networks-df740252da88?source=friends_link&amp;sk=6844935e3de14e478ce00f0b22e419eb">神经网络:递归神经网络的兴起</a></li><li id="6ac0" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python全面解释线性回归</a></li><li id="62b5" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python全面解释逻辑回归</a></li><li id="a9ba" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">Python中concat()、merge()和join()的区别</a></li><li id="33c2" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据争论—第1部分</a></li><li id="4844" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></li><li id="dc45" class="op oq it lk b ll oy lo oz lr pa lv pb lz pc md ou ov ow ox bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/machine-learning-modeling-data-with-python-92bfebfe4052?source=friends_link&amp;sk=b0f2d74eacefed5843f1e61152513674">用Python机器学习建模数据</a></li></ol></div></div>    
</body>
</html>