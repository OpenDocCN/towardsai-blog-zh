<html>
<head>
<title>KDTree To Evaluate Behavior by Demographics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过人口统计评估行为的KDTree</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/kdtree-to-evaluate-behavior-by-demographics-394752a80d78?source=collection_archive---------0-----------------------#2022-02-26">https://pub.towardsai.net/kdtree-to-evaluate-behavior-by-demographics-394752a80d78?source=collection_archive---------0-----------------------#2022-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有没有考虑过定位的角度进行客户行为分析？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb952455f67c786b322be8d3f87c8d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xepw3xbsU-pOyyGtfi85Qw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Pixabay</figcaption></figure><h2 id="3975" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">摘要:</strong></h2><p id="8895" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">行为分析是对学习和行为原则的科学研究。这个科学领域涉及描述、理解、预测和改变行为。他们通过观察生物和环境因素来寻找答案，尽管他们主要对环境在行为改变中的作用感兴趣。</p><p id="ddde" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">在数据科学中，行为分析充分利用大数据和人工智能在用户行为数据上的结合，以识别模式、趋势、违规行为和其他有用的见解，从而采取适当的行动。根据使用案例，行为分析被用于许多行业和应用，包括电子商务、医疗保健、银行、保险和网络安全。</p><p id="dbc8" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">常见的数据科学挑战之一是根据人口统计信息分析行为和评分。目标通常是根据几个参数对实体(个人/公司)进行评分，如:</p><p id="2167" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">以往购买</strong></p><p id="688c" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">购买间隔时间</strong></p><p id="a675" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">购买数量和价值</strong></p><p id="bf2a" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">个人/公司之间的距离</strong></p><p id="7acc" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">数据内部的可变性和其他外部影响因素</strong></p><p id="e472" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">最有趣的领域之一是查看彼此之间的客户距离，以了解是否存在因两个客户之间的距离而产生的行为模式？这个问题通常困扰着每个组织。</p><h2 id="cf61" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">场景:</strong></h2><blockquote class="ms mt mu"><p id="967e" class="lu lv mv lw b lx mn ju lz ma mo jx mc mw mp me mf mx mq mh mi my mr mk ml mm im bi translated">在开始“解决方案”之前，可以使用实体之间的距离来解决一些场景:</p></blockquote><p id="51b2" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu"> 1。基于两个地址之间的信息和距离的匹配来合并实体/客户:</strong>如果有两个地址相似且非常接近的客户记录，可以将它们合并为一个。</p><p id="60b4" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu"> 2。了解与影响者的距离是否会对购买行为产生影响:</strong>在行为分析的空间中，考察影响者/推广者之间的距离是否会对当地产生影响。</p><p id="fe27" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu"> 3。超市/商店影响顾客的合理距离是多少？:</strong>帮助确定一家商店与其自身和竞争对手之间的距离。</p><p id="6117" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu"> 4。一群“推动者”如何影响当地的“潜力”？:</strong>当有一群促销员的时候，他们在当地会有什么影响？</p><p id="8799" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">当组织处于吸引、吸引和留住客户的征服模式时，许多这样的问题将是至关重要的。在每一个这样的场景中，位置都扮演着重要的角色。这可能会泄露许多关键信息，如影响范围、对购买模式的暗示等。</p><h2 id="0e35" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">代码显示:</strong></h2><p id="d476" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">转移到主题的中心，一个人如何根据距离建立群体？</p><p id="f5b0" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">第0步:我会从时间表开始:</strong></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="22a1" class="ky kz it na b gy ne nf l ng nh">def timeit(method):<br/>    def timed(*args, **kw):<br/>        ts = time.time()<br/>        result = method(*args, **kw)<br/>        te = time.time()<br/>        if 'log_time' in kw:<br/>            name = kw.get('log_name', method.__name__.upper())<br/>            kw['log_time'][name] = int((te - ts) )<br/>        else:<br/>            print('%r  %2.2f s' % \<br/>                  (method.__name__, (te - ts) ))<br/>        return result<br/>    return timed</span></pre><p id="b3e9" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">第一步:我将从纬度和经度创建笛卡尔坐标:</strong></p><p id="e463" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">为了使定义简单，在笛卡尔坐标系中:</p><p id="0a7a" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">x轴穿过long，lat (0，0)，因此经度0与赤道相交</p><p id="7688" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">y轴穿过(0，90)</p><p id="1485" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">z轴穿过磁极</p><p id="3039" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">其中R是地球的半径:6，378，137米</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2298" class="ky kz it na b gy ne nf l ng nh"><a class="ae ni" href="http://twitter.com/timeit" rel="noopener ugc nofollow" target="_blank">@timeit</a><br/>def to_cartesian(data, lat, lon):<br/>   rad = 6378137<br/>   data[‘x’] = data.apply(lambda row: rad* math.cos(np.deg2rad(row.lat))*math.cos(np.deg2rad(row.lon)),axis=1)<br/>   data[‘y’] = data.apply(lambda row: rad * math.cos(np.deg2rad(row.lat))*math.sin(np.deg2rad(row.lon)),axis=1)<br/>   data[‘z’] = data.apply(lambda row: rad* math.sin(np.deg2rad(row.lat)), axis = 1)<br/>   return data</span></pre><p id="07e5" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">注意:如果您的数据只包含地址，也可以使用“geopy”之类的包将其转换为地理坐标</p><p id="ea12" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">第三步:下一步是创建树:</strong></p><p id="e85e" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">用于快速最近邻查找的kd树。这个类提供了一组k维点的索引，可以用来快速查找任意点的最近邻。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c2af" class="ky kz it na b gy ne nf l ng nh"><a class="ae ni" href="http://twitter.com/timeit" rel="noopener ugc nofollow" target="_blank">@timeit</a><br/>def create(df):<br/>  print(‘creating…’)<br/>  tree = cKDTree(df)<br/>  print(‘created…’)<br/>  return tree</span></pre><p id="b09e" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">第四步:基于距离查询树</strong></p><p id="c27d" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这里我用的是query_ball_point。这将找到距离点x . r内的所有点，然后将查询的点追加到列表中。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6683" class="ky kz it na b gy ne nf l ng nh"><a class="ae ni" href="http://twitter.com/timeit" rel="noopener ugc nofollow" target="_blank">@timeit</a><br/>def query(tree, df):<br/>  print(‘query started…’)<br/>  dist_in_mtr = 5 * 1609.34<br/>  #BATCH_SIZE = 100_000<br/>  results = []<br/>  neigh_pair = tree.query_ball_point(df,dist_in_mtr,p=2,n_jobs=-1)<br/>  for neighs in neigh_pair:<br/>    if len(neighs) &gt; 1:<br/>      results.append([neighs[0],‘,’.join([str(x) for x in neighs[1:]]), i])<br/>  print(‘query finished…’)<br/>  return results</span></pre><p id="7dd4" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">第五步:展开列表</strong></p><p id="6bb3" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">使用Explode函数根据列表构建数据框，以便获得相邻对。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b373" class="ky kz it na b gy ne nf l ng nh"><a class="ae ni" href="http://twitter.com/timeit" rel="noopener ugc nofollow" target="_blank">@timeit</a><br/>def list_to_pandas(data):<br/>  return pd.DataFrame(data, columns = [‘source’, ‘neighs’]).explode(‘neighs’)</span></pre><p id="333c" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">步骤加成:导入导出数据</strong></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0457" class="ky kz it na b gy ne nf l ng nh"><a class="ae ni" href="http://twitter.com/timeit" rel="noopener ugc nofollow" target="_blank">@timeit</a><br/>def save(df, file_name):<br/>    path_out = 'import/file/path' + file_name<br/>    df.to_parquet(path_out, sep = '|', index = False)<br/>    print('save finished...')</span><span id="631e" class="ky kz it na b gy nj nf l ng nh"><a class="ae ni" href="http://twitter.com/timeit" rel="noopener ugc nofollow" target="_blank">@timeit</a><br/>def load_df():<br/>    print("fetching...")<br/>    path = 'export/file/path'<br/>    df = pd.read_parquet(path , sep = '|')<br/>    print("fetched...")<br/>    print(df.shape)<br/>    return df</span></pre><h2 id="d5f5" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">结论:</strong></h2><p id="aeb0" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">KDTree是一种计算实体间距离的简单方法，它直观地显示了数据在地图上的分布情况，并有助于查询树中的数据和评估距离。</p><p id="7d57" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">当数据很大时，需要大量的代码优化，因为树会跳舞，查询会溢出内存，或者函数爆炸会创建一个巨大的数据集。</p><p id="275e" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">通过LinkedIn与我进行有趣的对话:<a class="ae ni" href="http://www.linkedin.com/comm/mynetwork/discovery-see-all?usecase=PEOPLE_FOLLOWS&amp;followMember=shreepadahs" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/comm/mynetwork/discovery-see-all?use case = PEOPLE _ FOLLOWS&amp;follow member = shreepadahs</a></p><h2 id="59f7" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考:</h2><p id="a98d" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated"><a class="ae ni" href="https://pypi.org/project/geopy/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/geopy/</a></p><p id="06d1" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><a class="ae ni" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.html" rel="noopener ugc nofollow" target="_blank">https://docs . scipy . org/doc/scipy/reference/generated/scipy . spatial . CKD tree . html</a></p><p id="d642" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Geodetic_Reference_System_1980" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Geodetic _ Reference _ System _ 1980</a></p><p id="dff6" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><a class="ae ni" href="https://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates#:~:text=Just%20to%20make%20the%20definition,axis%20goes%20through%20the%20poles" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1185408/converting-from-经度-纬度-笛卡尔坐标#:~:text = Just % 20 to % 20 make % 20 the % 20 definition，axis % 20 goes % 20 through % 20 the % 20 poles</a>。</p></div></div>    
</body>
</html>