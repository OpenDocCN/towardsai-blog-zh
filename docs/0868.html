<html>
<head>
<title>Comprehensive Guide To Optimize Your Pandas Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化你的熊猫代码的综合指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/comprehensive-guide-to-optimize-your-pandas-code-62980f8c0e64?source=collection_archive---------0-----------------------#2020-08-30">https://pub.towardsai.net/comprehensive-guide-to-optimize-your-pandas-code-62980f8c0e64?source=collection_archive---------0-----------------------#2020-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b2ed" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><div class=""><h2 id="bc31" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">熊猫的实用优化</h2></div><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="ab gu cl kw"><img src="../Images/080b3eb8ee566eacd9c87bbd363683bb.png" data-original-src="https://miro.medium.com/v2/0*9C2ECXKhWOG2ZvLi"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae ld" href="https://www.reddit.com/r/funny/comments/7umfdz/darth_panda/" rel="noopener ugc nofollow" target="_blank"> Reddit </a></figcaption></figure><p id="8f1f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在本指南中，我将向您展示一些最常见的陷阱，这些陷阱会导致原本非常好的Pandas代码对于任何时间敏感的应用程序来说都太慢，并通过一组提示和技巧来避免它们。</p><p id="cfff" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们提醒自己，除了可爱的动物，熊猫是什么🐼。这是一个广泛用于数据分析和操作的库，它将所有数据加载到RAM中。</p><p id="6c87" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在本文中，我将使用包含餐饮发票的数据集(一百万行)📉。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="5423" class="mf mg it mb b gy mh mi l mj mk">df = load_dataset()<br/>df.head()</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="ab gu cl kw"><img src="../Images/035a62c671e7cd6a1c0ce4a85d63f700.png" data-original-src="https://miro.medium.com/v2/format:webp/1*UaBm7Dt9yBoNt_tiQcxpVw.png"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="56be" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">为什么是性能🤨</h1><ul class=""><li id="0c9c" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jd">快比慢好- </strong>因为没有人喜欢等待自己的代码被执行🐇。</li><li id="dabc" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">内存效率好- </strong>因为“内存不足”异常很吓人。💾</li><li id="586d" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">省钱是很棒的- 通过使用功率较小的机器，我们可以降低成本💸。</li><li id="da06" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">硬件只能带你走这么远- </strong>硬件性能是有限的💻。</li></ul><p id="19cd" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">好了，现在我已经“说服”你我们应该关心性能，我想解决的下一个问题是什么时候我们应该优化我们的代码。<br/>剧透提醒令人惊讶的答案是:“不总是。”</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="ab gu cl kw"><img src="../Images/796cb6eddbbb98ebce73cdc7e759c256.png" data-original-src="https://miro.medium.com/v2/0*jipnZ05oAmmYFMVh"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://www.pinterest.ie/pin/764415736723944164/" rel="noopener ugc nofollow" target="_blank">https://www.pinterest.ie/pin/764415736723944164/</a></figcaption></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="62e4" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">何时优化⏰</h1><p id="8fea" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">因为程序可读性是我们的首要任务，因为我们的目标是让程序员的生活更轻松，我们应该只在需要的时候优化我们的代码，换句话说"<strong class="lg jd">所有的优化都是不成熟的，除非"</strong>:</p><ul class=""><li id="d19c" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated"><strong class="lg jd">程序不符合要求- </strong>对用户来说是否太慢，或者是否占用太多内存🚔。</li><li id="c74e" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">程序执行影响开发进度- </strong>如果程序运行缓慢，那么它将影响开发人员的生产力，这将使每个功能的开发时间变得更长👷。</li></ul><p id="7120" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">由于优化我们的代码可能很耗时，我们应该只重构有问题的部分。</p><p id="40df" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这可以通过分析我们的程序来识别瓶颈来实现。因为这是一个很大的话题，所以我不会深究细节，并且<strong class="lg jd">将使用下面的分析器</strong>:</p><ul class=""><li id="2a6a" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated"><code class="fe of og oh mb b">%time-</code>单个语句的执行时间⌛.</li><li id="058c" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><code class="fe of og oh mb b">%timeit-</code>像时间一样，但为了更精确而重复⌛.</li><li id="1c7c" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><code class="fe of og oh mb b">%memit-</code>衡量单个语句的内存使用情况💾。</li><li id="b550" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><code class="fe of og oh mb b">%mprun-</code>使用逐行内存分析器运行代码💾。</li></ul><p id="b57f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">除了找到需要重构的代码部分，我们还希望重构本身是安全的。像<strong class="lg jd">每一个重构任务一样，你希望有相同的行为并返回相同的结果</strong>。实现这一点的最好方法是确保代码经过了良好的测试。</p><p id="8c7e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我要解决的下一个问题是，“有可能优化我们的python代码吗？Python是一种动态语言，缺乏大量编译优化”。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b8dc" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">可能吗？🦾</h1><p id="9eb2" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">人们倾向于认为问题出在python领域，对此我们无能为力。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/76e2b73d2f4a77a3ba519f7416621787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*OPhrGHLgCIykzkx9.jpg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://www.reddit.com/r/ProgrammerHumor/comments/9cdj7z/nah_dude_i_dont_think_python_is_slow_my_app_runs/" rel="noopener ugc nofollow" target="_blank">https://www . Reddit . com/r/programmer humor/comments/9 cdj 7 z/nah _ dude _ I _ dont _ think _ python _ is _ slow _ my _ app _ runs/</a></figcaption></figure><p id="4939" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">但是，事实并非如此，本文旨在展示如何优化pandas代码。</p><p id="8dc5" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">接下来，我们将解决这个百万美元的问题，“<strong class="lg jd">我们如何优化我们的熊猫代码？”</strong>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="a0ae" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">怎么👀</h1><p id="1d3c" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated"><em class="oj">重要提示:</em>每种技术都有一个图标，指示它是否应该提高性能⌛和/或内存占用💾。</p><p id="d959" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我将列出我今天要讲的技巧。</p><ul class=""><li id="b6cb" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated">用你需要的💾⌛</li><li id="af8d" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">不要多此一举，⌛💾</li><li id="0779" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">避免⌛循环</li><li id="a1db" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">选择正确的类型💾⌛</li><li id="4da3" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">熊猫使用⌛💾</li><li id="5df4" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">编译代码⌛</li><li id="3328" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">通用Python优化⌛💾</li><li id="80e4" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">熊猫替代品⌛💾</li></ul><p id="9a7e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在我开始之前，重要的是要说明所有这些优化都依赖于数据集的特征。例如，对于小型数据集，其中一些优化可能是不相关的。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="ae5a" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">用你需要的🧑</h1><ul class=""><li id="91c1" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jd">只加载需要的列- </strong>删除我们在数据分析/操作中不使用的所有列可以节省大量内存。</li><li id="0338" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">只加载需要的行- </strong>删除我们在数据分析/操作中不使用的所有行可以节省大量内存和执行时间。</li></ul><p id="5daa" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">虽然这看起来很基本，但它会产生巨大的影响，人们似乎忽略了这一点。你应该像这个可爱的家伙一样，只使用你需要的东西。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/473b812ea19bf168a20c16045a47ce22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/0*f4h_3vKCajZ5WDsJ.jpg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://knowyourmeme.com/photos/1092618-image-macros" rel="noopener ugc nofollow" target="_blank">https://knowyourmeme.com/photos/1092618-image-macros</a></figcaption></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d644" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">不要多此一举。🎡</h1><ul class=""><li id="afec" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jd">庞大的生态系统- </strong>相关的包和教程层出不穷。大概已经有人做了你要找的事情。</li><li id="3b01" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">使用现有的解决方案- </strong>现在有很多成熟的包，使用它们会导致更少的错误和更优化的代码(它们是用高度优化的C/Fortran编写的，只有python绑定)。</li></ul><p id="4195" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">例如，你应该使用<a class="ae ld" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> scipy </a>或skit <a class="ae ld" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> -learn </a>实现，而不是自己实现。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/378231f4e7b0080f7bd71b93d8c0c774.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*GNMai84YUVVfVM6w.jpg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://imgflip.com/i/1px0z1" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/i/1px0z1</a></figcaption></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="6c6b" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">避免♾循环</h1><p id="9ecf" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">Pandas是为向量操作而设计的。矢量化是对整个数组执行操作的过程，<strong class="lg jd">这使得循环效率低下</strong>。</p><h2 id="89a5" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">错误的选择😈</h2><p id="d279" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">pandas中的一个新手错误将是通过使用错误或常规循环来循环所有行。</p><p id="ce7f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在下面的代码片段中，我们通过从餐费本身减去小费来计算原始餐费(不含小费)。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="b8d4" class="mf mg it mb b gy mh mi l mj mk">def iterrows_original_meal_price(df):<br/>    for i, row in df.iterrows():<br/>        row["orig_meal_price"] = row["meal_price"] - row["meal_tip"]<br/>    return df</span><span id="6295" class="mf mg it mb b gy ow mi l mj mk">%%timeit -r 1 -n 1<br/>iterrows_original_meal_price(df)</span><span id="17dc" class="mf mg it mb b gy ow mi l mj mk">35min 13s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><p id="805c" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">正如你所看到的，执行时间大约是35分钟，<strong class="lg jd">确实令人不满。</strong>但是不要担心，正如我所说的，使用iterrows是一个新手的错误，我在这里向您展示一个更好的方法。</p><h2 id="d475" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">更好的选择🤵</h2><p id="b514" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">幸运的是，有一种更好的方法，使用apply。应用接受任何在数据帧上应用转换/聚合的用户定义函数(迭代)。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="4239" class="mf mg it mb b gy mh mi l mj mk">def calc_<!-- -->orig_meal_price(row):<br/>    return row['meal_price'] - row['meal_tip']</span><span id="0cac" class="mf mg it mb b gy ow mi l mj mk">def apply_original_meal_price(df):<br/>    df["orig_meal_price"] = df.apply(<!-- -->calc_<!-- -->orig_meal_price, axis=1)<br/>    return df</span><span id="60d7" class="mf mg it mb b gy ow mi l mj mk">%%timeit <br/>apply_original_meal_price(df)</span><span id="f74d" class="mf mg it mb b gy ow mi l mj mk">22.5 s ± 170 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="4d6f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">正如我们所看到的，这里的性能提升是疯狂的，而不是35分钟，同样的程序花了我们21秒，这是好得多。我很乐意接受执行时间比iterrows⌛.快100倍 <br/> <strong class="lg jd"> </strong>所以教训是<strong class="lg jd"> Iterrows是纯粹的恶</strong>😈。</p><p id="ae4a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">但我们能做的只有这些吗？难道不能让同样简单的代码速度极快吗？这是可以做到的，现在我将向你们展示最好的方法，也就是矢量化。</p><h2 id="9b2f" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">最佳选择👼</h2><p id="0b9e" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">提醒一下，矢量化是对整个阵列执行操作的过程。Pandas/NumPy/SciPy包含了大量的矢量化函数，从数学运算到聚合，或者用np.vectorize创建新的函数。</p><p id="dc62" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">矢量化效果更好的原因是现代计算机处理器包含:</p><ul class=""><li id="836c" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated">SISD(单指令，单数据):这是处理Python for循环的结构——每一个指令，每一个数据元素，每一个时刻，为了产生一个结果。这种方法的优点在于它很灵活——您可以对数据执行任何操作。缺点是它不是处理大量数据的最佳选择。</li><li id="d7b7" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">SIMD(单指令，多数据):这是如何处理NumPy和Pandas矢量化的结构——每一时刻每任意数量的数据元素一条指令，以便产生多个结果。当代的CPU在其每个内核中都有一个处理SIMD运算的组件，允许并行处理。</li></ul><p id="56d6" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在下面的代码片段中，我们将从整个<em class="oj">餐费价格</em>列中减去整个<em class="oj">餐费小费</em>列。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="3dcf" class="mf mg it mb b gy mh mi l mj mk">def vectorized_original_meal_price(df):<br/>    df["orig_meal_price"] = df["meal_price"] - df["meal_tip"] <br/>    return df</span><span id="52b5" class="mf mg it mb b gy ow mi l mj mk">%%timeit <br/>vectorized_original_meal_price(df)</span><span id="3fd2" class="mf mg it mb b gy ow mi l mj mk">2.46 ms ± 18.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="ab50" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">这太疯狂了。</strong>我们可以马上看到矢量化功能的好处。我们到了2.5毫秒。还有10万左右。<strong class="lg jd">与应用方法</strong> ⌛.相比，执行时间 <strong class="lg jd">提高了8000倍所以教训是<strong class="lg jd">矢量化运算规则</strong>😇。</strong></p><p id="938e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">有一个很棒的演讲展示了如何向量化你的函数，你可以在这里找到<a class="ae ld" href="http://drastically" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="afba" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">选择正确的类型🌈</h1><p id="f598" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">我将展示选择正确类型的动机。这将大大减少我们的内存占用🏆。</p><p id="dee2" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">首先，我要创建一个数组，反复以5000这个数字1结尾。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="6b91" class="mf mg it mb b gy mh mi l mj mk">ones = np.ones(shape=5000)<br/>ones</span><span id="b828" class="mf mg it mb b gy ow mi l mj mk">array([1., 1., 1., ..., 1., 1., 1.])</span></pre><p id="58c7" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">然后，我将使用不同的类型进行造型，并展示一个简单的类型更改是如何极大地改变内存占用的。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="e736" class="mf mg it mb b gy mh mi l mj mk">types = ['object', 'float64', 'int64', 'int16', 'int8', 'bool']<br/>df = pd.DataFrame({t: ones.astype(t) for t in types})<br/>df.memory_usage(index=False, deep=True)</span><span id="1383" class="mf mg it mb b gy ow mi l mj mk">object        160000<br/>float64        40000<br/>int64          40000<br/>int16          10000<br/>int8            5000<br/>bool            5000<br/>dtype: int64</span></pre><p id="da9d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">正如你所看到的，选择正确的类型可以给我们带来80倍的内存改进，这是相当疯狂的。<strong class="lg jd">我希望清楚列的类型影响内存占用。</strong></p><p id="d5cd" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在，我们已经了解了优化数据集类型的动机，让我们看看整个数据集的内存占用，以及它是如何逐列分布的🌈。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="e398" class="mf mg it mb b gy mh mi l mj mk">df.memory_usage(deep=True).sum()</span><span id="3c38" class="mf mg it mb b gy ow mi l mj mk">478844140</span><span id="b616" class="mf mg it mb b gy ow mi l mj mk">df.memory_usage(deep=True)</span><span id="6e46" class="mf mg it mb b gy ow mi l mj mk">Index                 8002720<br/>order_id             73024820<br/>date                 67022780<br/>date_of_meal         82027880<br/>participants         84977580<br/>meal_price           36012240<br/>type_of_meal         63688760<br/>heroes_adjustment    32076480<br/>meal_tip             32010880<br/>dtype: int64</span></pre><p id="569b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">因此，很明显，我们应该瞄准具有相同功能的最低内存占用的类型。我将描述支持的类型。</p><h2 id="8910" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">支持的类型🌈</h2><ul class=""><li id="73b4" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jd"> int </strong> —整数。</li><li id="bef6" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd"> float </strong> —浮点数。</li><li id="b85d" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">布尔型</strong> —布尔型真值和假值。</li><li id="63a1" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">对象</strong> —字符串或混合类型。</li><li id="8ae9" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">字符串</strong> </a> —字符串(1.0.0版本新增)。</li><li id="b72a" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pythonspeed.com/articles/pandas-string-dtype-memory/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">字符串【py arrow】</strong></a>—字符串(1.3版本新增)。</li><li id="a546" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">日期时间</strong> —日期和时间值。</li><li id="9286" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd">时间增量</strong> —两个日期时间之间的时间差。</li><li id="a2c8" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">类别</strong> </a> —存储在高效内存查找中的有限值列表。当相同的元素反复出现时，这是很好的(0.23版本中的新功能)。</li><li id="5d5c" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pandas.pydata.org/docs/user_guide/sparse.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">稀疏类型</strong> </a> —当数组的大部分包含空值时，稀疏类型是好的(0.24.0版本中的新功能)。</li><li id="7322" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pandas.pydata.org/docs/user_guide/integer_na.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">可空整数</strong> </a> <strong class="lg jd"> / </strong> <a class="ae ld" href="https://pandas.pydata.org/docs/user_guide/boolean.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lg jd">可空布尔</strong> </a> —当元素为整数/布尔且包含空值时，可空类型是好的。这是因为NaN是一个浮点型，它强制将整个数组转换为浮点型，因此具有更大的内存占用(0.24.0版中的新功能)。</li></ul><p id="baec" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">由于熊猫使用NumPy数组作为它们的后端结构，<code class="fe of og oh mb b">int</code> s和<code class="fe of og oh mb b">float</code> s可以被区分为更高效的内存类型，如<code class="fe of og oh mb b">int8</code>、<code class="fe of og oh mb b">int16</code>、<code class="fe of og oh mb b">int32</code>、<code class="fe of og oh mb b">int64</code>、<code class="fe of og oh mb b">unit8</code>、<code class="fe of og oh mb b">uint16</code>、<code class="fe of og oh mb b">uint32,</code>和<code class="fe of og oh mb b">uint64</code>以及<code class="fe of og oh mb b">float32</code>和<code class="fe of og oh mb b">float64</code>。</p><p id="5c13" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">如果这还不够，你可以使用扩展数组来使用自定义类型，尽管优化需要大量的努力和技能🦸🏼🦸‍♀️.<br/>如果您选择这样做，您可以使用:</p><ul class=""><li id="94eb" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=xx7H5EkzQH0" rel="noopener ugc nofollow" target="_blank">自己的类型</a>。</li><li id="8ce4" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">开源类型，如用于IP类对象的<a class="ae ld" href="https://github.com/ContinuumIO/cyberpandas" rel="noopener ugc nofollow" target="_blank"> cyberpandas </a>和用于空间类对象的<a class="ae ld" href="https://github.com/geopandas/geopandas" rel="noopener ugc nofollow" target="_blank"> geopandas </a>。</li></ul><h2 id="2972" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">我们优化类型的选择🌈</h2><ul class=""><li id="ed18" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated">加载特定类型的数据帧(最佳方式)。</li><li id="31b8" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">使用类型方法。</li><li id="7803" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">使用带有向下转换参数的to_x方法。</li></ul><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="f811" class="mf mg it mb b gy mh mi l mj mk">df = df.astype({'order_id': 'category',<br/>                'date': 'category',<br/>                'date_of_meal': 'category',<br/>                'participants': 'category',<br/>                'meal_price': 'int16',<br/>                'type_of_meal': 'category',<br/>                'heroes_adjustment': 'bool',<br/>                'meal_tip': 'float32'})</span><span id="3059" class="mf mg it mb b gy ow mi l mj mk">df.memory_usage(deep=True).sum()</span><span id="48a8" class="mf mg it mb b gy ow mi l mj mk">36999962</span></pre><p id="b855" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">这太疯狂了，</strong>我们可以看到选择正确类型的好处让我们达到了3.7兆字节，这比简单类型的内存提高了<strong class="lg jd">12倍。</strong></p><p id="a300" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">不仅如此，我们还可以改进一些数学方法的执行，如均值/求和/众数/最小值/等优化🧮.</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="4be4" class="mf mg it mb b gy mh mi l mj mk">%%timeit<br/>df["meal_price_with_tip"].astype(object).mean()</span><span id="5225" class="mf mg it mb b gy ow mi l mj mk">96 ms ± 499 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="987f" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df["meal_price_with_tip"].astype(float).mean()</span><span id="f7f7" class="mf mg it mb b gy ow mi l mj mk">4.27 ms ± 34.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="8fa5" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">同样，我们可以看到选择正确类型的好处，它让我们从96毫秒减少到4.3毫秒，与简单类型的⌛.相比，执行时间<strong class="lg jd">提高了<strong class="lg jd">20倍</strong></strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/424bcecafe91ba7863c6ed0bdd8a51a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/0*Cjtwwy9lT6YygtYq.jpg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">【https://knowyourmeme.com/photos/549339-rule-34 T4】</figcaption></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d351" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">熊猫用法🐼</h1><ol class=""><li id="3c29" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz oy nr ns nt bi translated"><strong class="lg jd"> Concat vs Append ➕ — </strong>每次追加都会创建一个新的DataFrame对象，因此多次追加会变得低效，应该使用Concat，对于一些更改，追加可能会更快。</li><li id="266b" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz oy nr ns nt bi translated"><strong class="lg jd">排序优化📟— </strong> pandas sort对于应该使用哪种算法有一个额外的参数，同样使用GPU，PyTorch/Tensorflow排序可能会更快:</li></ol><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="0184" class="mf mg it mb b gy mh mi l mj mk">%%timeit<br/>df.sort_values(["meal_price_with_tip", "meal_tip", "type_of_meal"], kind='quicksort')</span><span id="664a" class="mf mg it mb b gy ow mi l mj mk">147 ms ± 1.43 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="c537" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df.sort_values(["meal_price_with_tip", "meal_tip", "type_of_meal"], kind='mergesort')</span><span id="10b6" class="mf mg it mb b gy ow mi l mj mk">147 ms ± 876 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="da4f" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df.sort_values(["meal_price_with_tip", "meal_tip", "type_of_meal"], kind='heapsort')</span><span id="e5f3" class="mf mg it mb b gy ow mi l mj mk">147 ms ± 1.51 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="4c0f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> 3)大块🍰— </strong>将大型数据集分割成较小的部分将允许我们处理大型数据集(比内存大得多)，只要组块之间没有太多的交互。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="b437" class="mf mg it mb b gy mh mi l mj mk">def proccess_file(huge_file_path, chunksize = 10 ** 6):<br/>    for chunk in pd.read_csv(path, chunksize=chunksize):<br/>        process(chunk)</span></pre><p id="cbb9" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> 4)分组优化👩‍👩‍👧:</strong></p><ul class=""><li id="b48d" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated">早期过滤</li><li id="f40e" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">自定义功能很慢</li><li id="46f2" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">尽可能提取自定义功能的逻辑<a class="ae ld" href="https://medium.com/dunder-data/pandas-challenge-001-optimize-custom-grouping-function-44a9f2f321f8" rel="noopener"/></li><li id="0f97" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://github.com/pandas-dev/pandas/issues/24333" rel="noopener ugc nofollow" target="_blank">避免按多个类别分组</a></li><li id="0695" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">考虑使用<a class="ae ld" href="https://duckdb.org/" rel="noopener ugc nofollow" target="_blank"> DuckDB </a>。</li></ul><p id="3330" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> 5)合并优化🔍:</strong></p><ul class=""><li id="e958" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated">早期筛选/聚合</li><li id="90ef" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">半连接</li><li id="0586" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://stackoverflow.com/questions/53645882/pandas-merging-101" rel="noopener ugc nofollow" target="_blank">加入索引</a></li><li id="355c" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">考虑使用<a class="ae ld" href="https://duckdb.org/" rel="noopener ugc nofollow" target="_blank"> DuckDB </a>。</li></ul><p id="81d8" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> 6)数据帧序列化🏋— </strong>各种文件格式有不同的优势，包括保存和加载时间。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/755a9bdb50e19a8a2bba7526c6142f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/0*k72DXKQeQAdBb0cA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://towardsdatascience.com/the-best-format-to-save-pandas-data-414dca023e0d" rel="noopener" target="_blank">https://towards data science . com/the-best-format-to-save-pandas-data-414 DCA 023 e0d</a></figcaption></figure><p id="7baa" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd"> 7)查询/评估🧬 </strong></p><ul class=""><li id="d4ce" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated">如果安装，使用<a class="ae ld" href="https://pypi.org/project/numexpr/" rel="noopener ugc nofollow" target="_blank"> numexpr </a>和<a class="ae ld" href="https://github.com/pydata/bottleneck" rel="noopener ugc nofollow" target="_blank">瓶颈</a>。</li><li id="74e7" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">缩短执行时间—预期行为速度提高了2倍👍。</li><li id="dd47" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">提高内存——NumPy为每个中间步骤分配内存，通过使用numexpr，它计算相同的表达式，而不需要分配完整的中间数组👍。</li><li id="394b" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">并非所有操作都受支持👎</li></ul><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="2970" class="mf mg it mb b gy mh mi l mj mk">%%timeit<br/>df[df.type_of_meal=="Breakfast"]</span><span id="3691" class="mf mg it mb b gy ow mi l mj mk">103 ms ± 348 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="89aa" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df.query("type_of_meal=='Breakfast'")</span><span id="c077" class="mf mg it mb b gy ow mi l mj mk">82.4 ms ± 223 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="b3db" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">挺酷的，% 20性能Improvement⌛.<br/>重要注意事项，</strong>pandas API指示仅对中等规模或更大规模的数据集(超过10，000行，因为传统方法对于较小的阵列🧞.更快)使用查询/评估</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="6543" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">编译代码🤯</h1><p id="5287" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">由于其动态性，纯Python的代码做一些操作非常慢。这是因为操作序列不能像其他语言如C和Fortran那样被编译成高效的机器代码。</p><p id="2cf2" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">为了展示性能提升，我将创建一个名为<code class="fe of og oh mb b">pure_python_foo</code>的纯python方法，它累加所有的数字，直到一个给定的数字。</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="d585" class="mf mg it mb b gy mh mi l mj mk">def pure_python_foo(N):<br/>    accumulator = 0<br/>    for i in range(N):<br/>        accumulator = accumulator + i<br/>    return accumulator</span><span id="1d92" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df.meal_price_with_tip.map(foo)</span><span id="6385" class="mf mg it mb b gy ow mi l mj mk">17.9 s ± 25.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each</span></pre><p id="56d1" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">正如我们可以这个简单的方法需要18秒来运行，这是<strong class="lg jd">根本无法接受的。幸运的是，有各种各样的尝试添加一些编译魔法来解决这个弱点🧙:</strong></p><ul class=""><li id="0c44" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated"><strong class="lg jd"> Cython </strong> —将Python代码转换为兼容的C代码:<br/>——从纯Python代码加速到50倍👍。<br/> -学习曲线👎。<br/> -由于单独的编译步骤<strong class="lg jd">，需要额外的工作来集成到代码中👎</strong>。<br/> -由于独立的编译步骤<strong class="lg jd">，运行时没有编译开销👍</strong>。</li><li id="9447" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><strong class="lg jd"> Numba </strong> —将Python代码转换为快速LLVM字节码:<br/>—与纯Python相比，速度提高了200倍👍。<br/> -简单——简单地给一个方法添加一个装饰器👍。<br/> -高度可配置👍。<br/> -大多是数字👎。<br/> -调试业务逻辑很容易，因为我们只需移除装饰器，然后我们就可以像调试常规python代码一样调试它<strong class="lg jd">👍</strong>。</li></ul><p id="0132" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这些是Cython和Numba的例子:</p><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="7c45" class="mf mg it mb b gy mh mi l mj mk">%%cython<br/>def cython_foo(long N):<br/>    cdef long accumulator<br/>    accumulator = 0</span><span id="daf4" class="mf mg it mb b gy ow mi l mj mk">    cdef long i<br/>    for i in range(N):<br/>        accumulator += i</span><span id="7bdf" class="mf mg it mb b gy ow mi l mj mk">    return accumulator</span><span id="b164" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df.meal_price_with_tip.map(cython_foo)</span><span id="b51f" class="mf mg it mb b gy ow mi l mj mk">365 ms ± 2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><span id="e93e" class="mf mg it mb b gy ow mi l mj mk">@jit(nopython=True)<br/>def numba_foo(N):<br/>    accumulator = 0<br/>    for i in range(N):<br/>        accumulator = accumulator + i<br/>    return accumulator</span><span id="ee91" class="mf mg it mb b gy ow mi l mj mk">%%timeit<br/>df.meal_price_with_tip.map(numba_foo)</span><span id="a098" class="mf mg it mb b gy ow mi l mj mk">414 ms ± 596 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="26fd" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">如你所见，使用Cython我们获得了49倍的性能提升，使用Numba </strong> ⌛.我们获得了43倍的性能提升</p><p id="6db3" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">作为一个通用的经验法则，您应该首先尝试矢量化方法，如果不够的话，再尝试Numba，然后才是Cython。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2145" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">常规Python优化🐍</h1><p id="1f67" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">由于我们在编写pandas代码时使用python方法，了解常规的python优化可以带来很好的改进。</p><p id="528c" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">由于这是一个很大的话题，我将只给出一些技术的概述，更多技术请阅读“<a class="ae ld" href="https://www.amazon.com/gp/product/1449361595/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=eyaltrabelsi-20&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=1449361595&amp;linkId=536e0e2afc034dfabd2eb1b881b06049" rel="noopener ugc nofollow" target="_blank">高性能Python书籍”</a>📖。</p><h2 id="d310" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">贮藏🏎</h2><ul class=""><li id="5a93" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated">避免不必要的工作/计算。</li><li id="77ed" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://medium.com/fintechexplained/advanced-python-how-to-implement-caching-in-python-application-9d0a4136b845" rel="noopener">更快的代码</a></li></ul><h2 id="f682" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">发电机</h2><ul class=""><li id="546c" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated">生成器是简单的函数，一次返回一组可迭代的项目。</li><li id="2882" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://medium.com/@chetaniam/optimize-python-code-with-generators-aef839996ee4" rel="noopener">可以大幅减少内存占用</a><a class="ae ld" href="https://medium.com/@chetaniam/optimize-python-code-with-generators-aef839996ee4" rel="noopener">。</a></li></ul><h2 id="cbe8" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">中间变量👩‍👩‍👧‍👧</h2><ul class=""><li id="c488" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated">中间计算</li><li id="ed5e" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">两个对象的内存占用</li><li id="ff9b" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">更智能的变量分配</li></ul><pre class="kr ks kt ku gt ma mb mc md aw me bi"><span id="9c43" class="mf mg it mb b gy mh mi l mj mk">def another_foo(data):<br/>    return data * 2</span><span id="ed6b" class="mf mg it mb b gy ow mi l mj mk">def foo(data):<br/>    return data + 10</span><span id="e4a1" class="mf mg it mb b gy ow mi l mj mk">%reload_ext memory_profiler</span><span id="35c4" class="mf mg it mb b gy ow mi l mj mk">def load_data():<br/>    return np.ones((2 ** 30), dtype=np.uint8)</span><span id="0c03" class="mf mg it mb b gy ow mi l mj mk">%%memit<br/>def proccess():<br/>    data = load_data()<br/>    return another_foo(foo(data))</span><span id="78f0" class="mf mg it mb b gy ow mi l mj mk">proccess()</span><span id="5910" class="mf mg it mb b gy ow mi l mj mk">peak memory: 8106.62 MiB, increment: 3042.64 MiB</span><span id="9819" class="mf mg it mb b gy ow mi l mj mk">%%memit<br/>def proccess():<br/>    data = load_data()<br/>    data = foo(data)<br/>    data = another_foo(data)<br/>    return data</span><span id="fae3" class="mf mg it mb b gy ow mi l mj mk">proccess()</span><span id="648c" class="mf mg it mb b gy ow mi l mj mk">peak memory: 7102.64 MiB, increment: 2038.66 MiB</span></pre><h2 id="b9ac" class="mf mg it bd mt om on dn mx oo op dp nb ln oq or nd lr os ot nf lv ou ov nh iz bi translated">并发性和并行性🎸🎺🎻🎷</h2><ul class=""><li id="959e" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated">Pandas方法使用单一过程。</li><li id="40b5" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">CPU受限可以从并行性而不是顺序执行中获益。</li><li id="6a8c" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">IO绑定可以受益于并发性，无论是多线程还是异步执行。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c0b3" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">熊猫替代品🐨🐻</h1><p id="9d77" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">如果所有这些技术都不能满足您的需求，您可能应该使用不同的Dataframe API:</p><ul class=""><li id="af82" class="nj nk it lg b lh li lk ll ln oc lr od lv oe lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=lV7rtDW94do" rel="noopener ugc nofollow" target="_blank"> cudf </a> —一个支持GPU的DataFrame API。</li><li id="8035" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="http://spark.apache.org/docs/latest/api/python/index.html" rel="noopener ugc nofollow" target="_blank">py spark</a>—Apache spark的python绑定。</li><li id="42ef" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=-HjLd_3ahCw" rel="noopener ugc nofollow" target="_blank">modin</a>—Dask或ray上的抽象，用于在多台机器上并行化pandas。</li><li id="2bdf" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">只需更改一行代码，就可以在所有CPU上并行执行pandas操作。</li><li id="b1fc" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.pola.rs/" rel="noopener ugc nofollow" target="_blank">Polars</a>—Rust中实现的DataFrame API。</li></ul><p id="b072" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">就像生活中的所有事情一样，没有免费的午餐🥢。每一种都有其局限性，在你选择其中一种之前，你应该做足功课并<a class="ae ld" href="https://www.youtube.com/watch?v=YpFACw3g0AY&amp;list=WL&amp;index=4&amp;ab_channel=BigThingsConference" rel="noopener ugc nofollow" target="_blank">理解</a> <a class="ae ld" href="https://towardsdatascience.com/pandas-is-not-enough-a-comprehensive-guide-to-alternative-data-wrangling-solutions-a4730ba8d0e4" rel="noopener" target="_blank">权衡</a>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="49c7" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">临终遗言</h1><p id="2ed9" class="pw-post-body-paragraph le lf it lg b lh nl kd lj lk nm kg lm ln nz lp lq lr oa lt lu lv ob lx ly lz im bi translated">在本文中，我们回顾了一些最常见的陷阱，这些陷阱可能导致原本非常好的Pandas代码对于任何时间敏感的应用程序来说都太慢，并通过一组提示和技巧来避免它们。<br/> <br/>由于题目的范围，有许多东西我都简要地涉及了。出于这个原因，如果你想多走一步，我在最后添加了额外的资源。</p><p id="8460" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我希望我能够分享我对这个迷人的话题的热情，并且你会发现它是有用的，并且我一如既往地欢迎任何建设性的反馈。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1546" class="ms mg it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">额外资源📚</h1><ul class=""><li id="47c6" class="nj nk it lg b lh nl lk nm ln nn lr no lv np lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=EEUXKG97YRw" rel="noopener ugc nofollow" target="_blank">矢量化思维模式📖</a></li><li id="d924" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://numpy.org/doc/stable/reference/index.html" rel="noopener ugc nofollow" target="_blank"> Numpy </a> / <a class="ae ld" href="https://pandas.pydata.org/pandas-docs/stable/index.html" rel="noopener ugc nofollow" target="_blank">熊猫</a> / <a class="ae ld" href="https://docs.scipy.org/doc/scipy/reference/special.html" rel="noopener ugc nofollow" target="_blank"> Scipy </a>矢量化方法📖</li><li id="60f3" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">🛠的Numba工作室</li><li id="b56f" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=FepqwPI6U80" rel="noopener ugc nofollow" target="_blank">赛森工作室</a> 🛠</li><li id="47a9" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated">Numba VS C++  ⚖</li><li id="6eac" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://notes-on-cython.readthedocs.io/en/latest/std_dev.html" rel="noopener ugc nofollow" target="_blank">赛森VS C </a> ⚖</li><li id="3605" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://towardsdatascience.com/the-best-format-to-save-pandas-data-414dca023e0d" rel="noopener" target="_blank">序列化时间</a>📖</li><li id="31ca" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pandas.pydata.org/docs/user_guide/scale.html" rel="noopener ugc nofollow" target="_blank">组块</a>📖</li><li id="6557" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://www.youtube.com/watch?v=RRtqIagk93k" rel="noopener ugc nofollow" target="_blank">熊猫替代品</a>📖</li><li id="e53e" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://medium.com/datadriveninvestor/all-things-caching-use-cases-benefits-strategies-choosing-a-caching-technology-exploring-fa6c1f2e93aa" rel="noopener">缓存</a>📖</li><li id="11c9" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://pythonspeed.com/articles/function-calls-prevent-garbage-collection/" rel="noopener ugc nofollow" target="_blank">中间变量</a>📖</li><li id="06a3" class="nj nk it lg b lh nu lk nv ln nw lr nx lv ny lz nq nr ns nt bi translated"><a class="ae ld" href="https://amzn.to/38CKsuU" rel="noopener ugc nofollow" target="_blank">高性能Python书籍</a>📖</li></ul></div></div>    
</body>
</html>