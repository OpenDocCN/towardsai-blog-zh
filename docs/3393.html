<html>
<head>
<title>Grid Search in Python A-Z :
Searching for Perfection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python A-Z中的网格搜索:寻找完美</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/grid-search-in-python-a-z-searching-for-perfection-4a055fd2577d?source=collection_archive---------2-----------------------#2022-12-12">https://pub.towardsai.net/grid-search-in-python-a-z-searching-for-perfection-4a055fd2577d?source=collection_archive---------2-----------------------#2022-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a56d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在机器学习中找到完美的超参数？使用网格搜索和随机搜索，下面是例子，也是在Python的深度学习中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/577d2aa70f8458b7abc5d3a3ca812309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r-45qgL6CIHpUGzpz9C0tg.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">在Canva设计</figcaption></figure><h1 id="0ef7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="8702" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">由于机器学习中存在许多提高性能的技术，最近我打算向您解释其中的一种，即网格搜索&amp;随机搜索。</p><p id="16b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些技术用于寻找机器学习模型中的最佳参数。</p><h2 id="9d1d" class="mn kv it bd kw mo mp dn la mq mr dp le lv ms mt lg lz mu mv li md mw mx lk my bi translated">什么是网格搜索？</h2><p id="aec5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">网格搜索和随机搜索是超参数优化中常用的两种技术。</p><p id="89d9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它是为机器学习模型选择最佳超参数集的过程。</p><p id="7338" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在网格搜索中，该算法在预定义的超参数值网格上进行搜索。</p><p id="3c72" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它会尝试网格中每个值的组合，并评估每个组合的模型性能。</p><p id="198b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这可能是一个耗时的过程，尤其是对于具有许多超参数的复杂模型，但这是一种简单而可靠的优化超参数的方法。</p><h2 id="9820" class="mn kv it bd kw mo mp dn la mq mr dp le lv ms mt lg lz mu mv li md mw mx lk my bi translated">什么是随机搜索？</h2><p id="0c23" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">相反，随机搜索包括从预定义的范围内选择超参数的随机组合，并评估每个组合的模型性能。这种方法可能比网格搜索更快，特别是如果您有许多超参数，但它不太彻底，可能无法找到超参数的最佳集合。</p><h2 id="721e" class="mn kv it bd kw mo mp dn la mq mr dp le lv ms mt lg lz mu mv li md mw mx lk my bi translated">网格搜索和随机搜索有什么区别？</h2><p id="8500" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">网格搜索和随机搜索的主要区别在于它们搜索可能的超参数值空间的方式。网格搜索使用预定义的值网格，而随机搜索从预定义的范围内生成值的随机组合。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="2a4b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><a class="ae ng" href="https://medium.com/geekculture/decision-tree-in-energy-efficiency-analysis-9779322db2e8" rel="noopener">这里</a>，我已经给你解释过如何把机器学习模型应用到你的问题上。在那篇文章中，我向您解释了如何预测建筑、数据集和代码的热负荷。</p><p id="55a7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我将应用两种不同的技术来预测热负荷。</p><p id="7fd2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们从。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="7752" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">内容表</strong></p><p id="7362" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> </strong> <a class="ae ng" href="#0ef7" rel="noopener ugc nofollow"> <strong class="lo iu">简介</strong> </a> <strong class="lo iu"> <br/> </strong> <a class="ae ng" href="#e3e3" rel="noopener ugc nofollow"> <strong class="lo iu"> 1 .导入库</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#584f" rel="noopener ugc nofollow"><strong class="lo iu">2。加载数据集</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#a221" rel="noopener ugc nofollow"><strong class="lo iu">3。选择目标值</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#d29a" rel="noopener ugc nofollow"><strong class="lo iu">4。模型建筑</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#628d" rel="noopener ugc nofollow"><strong class="lo iu">5。网格搜索</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#6be9" rel="noopener ugc nofollow"><strong class="lo iu">6。网格搜索最佳参数</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#de40" rel="noopener ugc nofollow"><strong class="lo iu">7。评估为网格搜索</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#207c" rel="noopener ugc nofollow"><strong class="lo iu">10。随机搜索</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#6b20" rel="noopener ugc nofollow"><strong class="lo iu">11。最佳参数随机搜索</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#728f" rel="noopener ugc nofollow"><strong class="lo iu">12。模型评价为随机搜索最佳参数</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#13bc" rel="noopener ugc nofollow"><strong class="lo iu">13。最终评价</strong></a><strong class="lo iu"><br/></strong><a class="ae ng" href="#4045" rel="noopener ugc nofollow"><strong class="lo iu">结论</strong> </a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="e3e3" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">1.导入库</h1><p id="6b0b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，我们需要下面的库。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="c800" class="nr kv it nn b be ns nt l nu nv">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.model_selection import GridSearchCV, RandomizedSearchCV, train_test_split<br/>from sklearn.metrics import mean_squared_error<br/>from sklearn.metrics import r2_score2</span></pre><h1 id="584f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">2.加载数据集</h1><p id="71bd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们使用pandas excel库加载数据框。</p><p id="0af4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我在这里下载库<a class="ae ng" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00242/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0e65" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下载到你的库中后，定义你的路径。然后从excel中读取。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="f274" class="nr kv it nn b be ns nt l nu nv">path = "/Users/randyasfandy/Downloads/Datasets/energydata.xlsx"<br/>df = pd.read_excel(path)<br/></span></pre><p id="fa8a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我会重命名列名，这里也是用UC Irvine <a class="ae ng" href="https://archive.ics.uci.edu/ml/datasets/Energy+efficiency" rel="noopener ugc nofollow" target="_blank">写的。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/756448f6b414bd2bc3975d99860afc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZKKRl60FK0WU0KZ87RMkw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ng" href="https://archive.ics.uci.edu/ml/datasets/Energy+efficiency" rel="noopener ugc nofollow" target="_blank">参考</a></figcaption></figure><p id="bb68" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是代码。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="828c" class="nr kv it nn b be ns nt l nu nv">df = df.rename(columns={<br/>"X1" : "Relative Compactness",<br/>"X2" :"Surface Area",<br/>"X3":  "Wall Area",<br/>"X4" : "Roof Area",<br/>"X5" :"Overall Height",<br/>"X6" :"Orientation",<br/>"X7" :"Glazing Area",<br/>"X8" :"Glazing Area Distribution",<br/>"Y1" :"Heating Load",<br/>"Y2" :"Cooling Load"})</span></pre><h1 id="a221" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">3.选择目标值</h1><p id="eef8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里，我将预测热负荷，但我们有两种选择:热负荷和冷负荷。</p><p id="5934" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们来定义它们。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="6e2d" class="nr kv it nn b be ns nt l nu nv">y = df["Heating Load"]<br/>x = df[["Relative Compactness","Surface Area","Wall Area" ,"Roof Area" ,"Overall Height","Orientation","Glazing Area","Glazing Area Distribution"]]</span></pre><h1 id="d29a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">4.模型结构</h1><p id="d18e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，是时候建立我们的机器学习模型了。对于这个问题，我选择一个随机森林回归量。</p><p id="0e99" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以选择你喜欢的任何东西。</p><p id="01e6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是代码。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="1567" class="nr kv it nn b be ns nt l nu nv">x_train, x_test, y_train, y_test = train_test_split(<br/> x, y, <br/> test_size=0.2, random_state=44<br/>)<br/>forest_reg = RandomForestRegressor()</span></pre><p id="0c35" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们建立了自己的模型，现在是寻求完美的时候了。</p><h1 id="628d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">5.网格搜索</h1><p id="9dd1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在进行网格搜索之前，首先，您应该定义一个字典，其中包含您希望找到最佳版本的参数。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="965d" class="nr kv it nn b be ns nt l nu nv">param_grid = [<br/> {‘n_estimators’ : [3,10,40], ‘max_features’: [2,4,6,8]},<br/> {‘bootstrap’ : [False], ‘n_estimators’ : [3,10], ‘max_features’: [2,3,4]},<br/>]</span></pre><p id="eda6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，是时候应用网格搜索了。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="ef70" class="nr kv it nn b be ns nt l nu nv">grid_search = GridSearchCV(forest_reg, param_grid, cv = 5, <br/> scoring = ‘neg_mean_squared_error’, return_train_score = True)<br/>grid_search.fit(x_train, y_train)</span></pre><h1 id="6be9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">6.网格搜索的最佳参数</h1><p id="a36e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你还有兴趣的话。请发送掌声，并跟我来这里。</p><p id="9fea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好吧，我们继续。</p><p id="f4b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是寻找最佳参数的代码。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="df91" class="nr kv it nn b be ns nt l nu nv">grid_search.best_params_</span></pre><h1 id="de40" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">7.网格搜索的评估</h1><p id="6d14" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">好吧，既然我们找到了最佳参数。让我们使用它们并评估我们的模型。首先，让我们定义列表和包含列表值的字典。因为我们会在本文最后比较网格搜索值和随机搜索。让我们来定义它们。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="5cda" class="nr kv it nn b be ns nt l nu nv">train_error_random_g = []<br/>test_error_random_g = []<br/>r_sq_g = []</span></pre><pre class="ob nm nn no bn np nq bi"><span id="ede2" class="nr kv it nn b be ns nt l nu nv">gri_search = {<br/> ‘R_s ‘ : r_sq_g,<br/> ‘Train Error’ : train_error_random_g,<br/> ‘Test Error’ : test_error_random_g,<br/>}</span></pre><p id="8e61" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好，让我们定义一个自定义函数。这个自定义函数有不同的特性。</p><p id="56aa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，它采用网格搜索找到的最佳参数。</p><p id="3403" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第二，拟合回归模型。</p><p id="6777" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第三，找到测试、训练错误和R2。</p><p id="c361" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，将它们添加到我们已经创建的列表中。</p><p id="56a2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是代码。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="8bcf" class="nr kv it nn b be ns nt l nu nv">def evaluate_grid():<br/> m = grid_search.best_params_[‘max_features’] <br/> n = grid_search.best_params_[‘n_estimators’]<br/> regressor = RandomForestRegressor(n_estimators = n, max_features = m) <br/> regressor.fit(x_train, y_train)<br/> y_predict=regressor.predict(x_train)<br/> train_error = mean_squared_error(y_train, y_predict, squared=False)<br/> y_predict=regressor.predict(x_test)<br/> test_error = mean_squared_error(y_test, y_predict, squared=False)<br/> r2 = r2_score(y_test,y_predict)<br/> print(“Train error = “‘{}’.format(train_error))<br/> print(“Test error = “‘{}’.format(test_error))<br/> print(“R2 score is {}”.format(r2))<br/> train_error_random_g.append(train_error)<br/> test_error_random_g.append(test_error)<br/> r_sq_g.append(r2)</span></pre><pre class="ob nm nn no bn np nq bi"><span id="c02c" class="nr kv it nn b be ns nt l nu nv">evaluate_grid()</span></pre><p id="b7fd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好吧，创建一个数据框。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="0ef9" class="nr kv it nn b be ns nt l nu nv">grid = pd.DataFrame(gri_search)<br/>grid.index = ['Grid Search']</span></pre><p id="37b2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好了，是时候应用随机搜索了。</p><h1 id="207c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">10.随机搜索</h1><p id="4fb7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们先定义随机搜索，拟合x_train和y_train。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="f7b5" class="nr kv it nn b be ns nt l nu nv">random_search = RandomizedSearchCV(forest_reg<br/> ,param_grid,cv=5, scoring=’neg_mean_squared_error’,return_train_score = True<br/> )<br/>random_search.fit(x_train,y_train)</span></pre><h1 id="6b20" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">11.随机搜索的最佳参数</h1><p id="8032" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">好了，现在是找到随机搜索的最佳参数的时候了。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="c3eb" class="nr kv it nn b be ns nt l nu nv">random_search.best_params_</span></pre><h1 id="728f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">12.随机搜索最佳参数的模型评价</h1><p id="21a8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在是时候重复我们首先为网格搜索所做的动作了。让我再给你解释一遍。为此，首先，创建一个空列表和一个字典来填充它们。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="0668" class="nr kv it nn b be ns nt l nu nv">train_error_random = []<br/>test_error_random = []<br/>r_sq = []</span></pre><pre class="ob nm nn no bn np nq bi"><span id="128a" class="nr kv it nn b be ns nt l nu nv">Random_search = {<br/> ‘R_s ‘ : r_sq,<br/> ‘Train Error’ : train_error_random,<br/> ‘Test Error’ : test_error_random,<br/>}</span></pre><p id="5558" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，它采用随机搜索找到的最佳参数。</p><p id="18cd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第二，拟合回归模型。</p><p id="908a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第三，找到测试、训练错误和R2。</p><p id="4140" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，将它们添加到我们已经创建的列表中。</p><p id="4f0f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是代码。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="404b" class="nr kv it nn b be ns nt l nu nv">def evaluate_random():<br/> a = random_search.best_params_[‘max_features’] <br/> b = random_search.best_params_[‘n_estimators’]<br/> regressor = RandomForestRegressor(n_estimators = b, max_features = a) <br/> regressor.fit(x_train, y_train)<br/> y_predict=regressor.predict(x_train)<br/> train_error = mean_squared_error(y_train, y_predict, squared=False)<br/> y_predict=regressor.predict(x_test)<br/> test_error = mean_squared_error(y_test, y_predict, squared=False)<br/> r2 = r2_score(y_test,y_predict)<br/> print(“Train error = “‘{}’.format(train_error))<br/> print(“Test error = “‘{}’.format(test_error))<br/> print(“R2 score is {}”.format(r2))<br/> train_error_random.append(train_error)<br/> test_error_random.append(test_error)<br/> r_sq.append(r2)</span></pre><pre class="ob nm nn no bn np nq bi"><span id="4eef" class="nr kv it nn b be ns nt l nu nv">evaluate_random()</span></pre><p id="39cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">顺便说一下，要填写这些列表，不要忘记运行这段代码。</p><p id="519f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们也创建一个数据框。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="4b45" class="nr kv it nn b be ns nt l nu nv">random = pd.DataFrame(Random_search)<br/>random.index = [‘Random Search’]</span></pre><h1 id="13bc" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">13.最终评估</h1><p id="518c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">好了，现在让我们创建一个最终的数据框将它们附加在一起。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="db9c" class="nr kv it nn b be ns nt l nu nv">final_evaluation = random.append(grid)</span></pre><p id="6db9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好吧，为了更好地看到结果，让我们画一个图。</p><p id="d0c9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">代码中已经有了解释。</p><pre class="kj kk kl km gt nm nn no bn np nq bi"><span id="5add" class="nr kv it nn b be ns nt l nu nv">labels = [‘Random Search ‘, ‘Grid Search’]<br/>r_s = list(final_evaluation.iloc[:, 0])<br/>test_error = list(final_evaluation[‘Test Error’])<br/>train_error = list(final_evaluation[‘Train Error’])<br/>x = np.arange(len(labels)) # the label locations<br/>width = 0.24 # the width of the bars<br/>fig, ax = plt.subplots()<br/>rects1 = ax.bar(x - width/3, r2, width, label='r_s')<br/>rects2 = ax.bar(x + 3*width/4, test_error, width, label='test error')<br/>rects3 = ax.bar(x + width*1.8, train_error, width, label='train error')<br/># Add some text for labels, title and custom x-axis tick labels, etc.<br/>ax.set_title('Train and Test Errors According To the Algorithm')<br/>ax.set_xticks(x, labels)<br/>ax.legend()<br/>ax.bar_label(rects1, padding=3)<br/>ax.bar_label(rects2, padding=3)<br/>ax.bar_label(rects3, padding=3)<br/>fig.tight_layout()<br/>plt.show()</span></pre><p id="435a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们看看结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/59200769e78eba44629faeae0d7c367f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*StzgnhfcYXfgNnZdgJ4yhA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</figcaption></figure><h1 id="4045" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="c500" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这里，我解释了Python中的随机搜索和网格搜索应用程序。以下是我们遵循的步骤；</p><ul class=""><li id="941b" class="od oe it lo b lp mi ls mj lv of lz og md oh mh oi oj ok ol bi translated">分割成一个数据框。</li><li id="9ecc" class="od oe it lo b lp om ls on lv oo lz op md oq mh oi oj ok ol bi translated">应用机器学习模型。</li><li id="6163" class="od oe it lo b lp om ls on lv oo lz op md oq mh oi oj ok ol bi translated">找到网格搜索和随机搜索的最佳参数。</li><li id="1fa1" class="od oe it lo b lp om ls on lv oo lz op md oq mh oi oj ok ol bi translated">将它们应用到模型中。</li><li id="6dbe" class="od oe it lo b lp om ls on lv oo lz op md oq mh oi oj ok ol bi translated">将结果与图表进行比较。</li></ul><p id="1a6c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">感谢阅读我的文章。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="831d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="or">这里是我的</em> </strong> <a class="ae ng" href="https://gencay.ck.page/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> <em class="or"> Numpy小抄</em> </strong> </a> <strong class="lo iu"> <em class="or">。</em>T13】</strong></p><p id="7ee4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="or">下面是“</em> </strong> <a class="ae ng" href="https://gencay.ck.page/billionaire" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu"> <em class="or">如何成为亿万富翁</em> </strong> </a> <strong class="lo iu"> <em class="or">”数据项目的源代码。</em>T13】</strong></p><p id="78d4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="or">这里是使用Python的</em></strong><strong class="lo iu"><em class="or"><a class="ae ng" href="https://gencay.ck.page/bfd9d41fdc" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="or">分类任务6种不同算法的源代码数据项目。</em> </strong></a></em></strong></p><p id="9707" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="or">这里是能效分析</em></strong><strong class="lo iu"><em class="or"><a class="ae ng" href="https://gencay.ck.page/2df5d07388" rel="noopener ugc nofollow" target="_blank"><strong class="lo iu"><em class="or">决策树数据项目的源代码。</em>T41】</strong></a></em></strong></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="ced8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="or">如果你还不是Medium的一员，渴望通过阅读来学习，这里是我推荐的</em> </strong> <a class="ae ng" href="https://medium.com/@geencay/membership" rel="noopener"> <strong class="lo iu"> <em class="or">链接。</em>T50</strong></a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><blockquote class="os"><p id="bf25" class="ot ou it bd ov ow ox oy oz pa pb mh dk translated">“机器学习是人类需要做出的最后一项发明。”尼克·博斯特罗姆</p></blockquote></div></div>    
</body>
</html>