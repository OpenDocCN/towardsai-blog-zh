<html>
<head>
<title>Running an NLP Bert or Machine Learning Model from HuggingFace in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Java中从HuggingFace运行NLP Bert或机器学习模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/running-an-nlp-task-or-machine-learning-model-from-huggingface-in-java-8a3c7c131c10?source=collection_archive---------2-----------------------#2022-12-23">https://pub.towardsai.net/running-an-nlp-task-or-machine-learning-model-from-huggingface-in-java-8a3c7c131c10?source=collection_archive---------2-----------------------#2022-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4095" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">HuggingFace使得在Python中运行机器学习模型变得极其容易。</p><p id="b2c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果你需要在Java中运行这些模型呢？一个简单的解决方案是建立一个Python服务并从Java发出一个HTTP请求。</p><p id="119b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是有时候，你不能向服务发出HTTP请求。因此，如何在Java中直接运行模型呢？</p><p id="233f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以使用“深度Java库”(<a class="ae ko" href="https://djl.ai/" rel="noopener ugc nofollow" target="_blank">https://djl.ai/</a>)和“开放式神经网络交换”(<a class="ae ko" href="https://onnx.ai/" rel="noopener ugc nofollow" target="_blank">https://onnx.ai/</a>)来让事情发生。</p><p id="843d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将给出一个工作示例来开始。</p><h1 id="8ca1" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">在Python中运行代码</h1><p id="f7a7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">首先，让我们在Python中运行我们希望在Java中运行的代码，以确保我们得到相同的值。</p><p id="1bd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看这个gist(<a class="ae ko" href="https://gist.github.com/carlos-aguayo/2d1fe4c246a7ad2c54cd726c17c30a77" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Carlos-agua yo/2d 1 Fe 4c 246 a7 ad 2c 54 CD 726 c 17 c 30 a 77</a>0)</p><p id="a22f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到，我们将一个句子“Hello world”标记化，通过一个预先训练的模型运行它，并查看最后一个隐藏状态的第一个值。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/8d3aac4e85361a7b1ff6b2eec32402d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFN2-DXCcv6w8HsEWWFmLQ.png"/></div></div></figure><p id="2870" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到，我们显示了“<code class="fe me mf mg mh b">[CLS] Hello world [SEP]</code>”中每个令牌嵌入的第一维度，即<code class="fe me mf mg mh b">[0.1000, 0.5740, 0.7239, 0.0975]</code>。如果我们在Java中得到相似的值，我们可以确信我们运行的是相同的代码。</p><h1 id="f787" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">序列化记号赋予器和模型</h1><p id="f1b7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">为了在Java中运行，我们需要序列化标记器和模型。</p><p id="6700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以看看这里做序列化的代码(<a class="ae ko" href="https://gist.github.com/carlos-aguayo/2bb28c893584fc6325216cbe43711a1b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Carlos-agua yo/2bb 28 c 893584 fc 6325216 CBE 43711 a1b</a>)。这很简单。</p><p id="5840" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们下载我们需要的分词器，并使用“<code class="fe me mf mg mh b">save_pretrained</code>”方法保存它。我们需要文件<code class="fe me mf mg mh b">tokenizer.json,</code>，一旦执行了代码，您可以直接从Colab下载它。如果您不熟悉从Colab下载文件，有几种方法可以做到。看看这个Stackoverflow问题(<a class="ae ko" href="https://stackoverflow.com/questions/48774285/how-to-download-file-created-in-colaboratory-workspace" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/48774285/how-to-download-file-created-in-co-laboratory-workspace</a>)</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mi"><img src="../Images/65fe8ad72f4484babe29aa683243b6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XBfJiO5cs--dlNdw8SJGw.png"/></div></div></figure><p id="b7bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，我们需要使用ONNX格式序列化模型。这也是一项简单的任务。您调用这个命令</p><p id="b0e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe me mf mg mh b">!python -m transformers.onnx -- model=’sentence-transformers/all-distilroberta-v1' onnx/</code></p><p id="97f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到它将HuggingFace模型作为一个参数，并将您想要保存的内容放在这个目录中。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mj"><img src="../Images/40c8cd21c93df3fc95392576cb8836f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwdcC-YCDnYk1iqvS3WuPQ.png"/></div></div></figure><p id="99f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行该命令后，将会生成一个文件'<code class="fe me mf mg mh b">model.onnx</code>'。</p><p id="c388" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些型号往往体积较大，如你所见，<code class="fe me mf mg mh b">model.onnx</code>约为330MB。出于某种原因，Colab很难下载大文件。更容易挂载Google Drive，把文件复制到那里，直接从Google Drive下载。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mk"><img src="../Images/342686478312b82f1f7089c0ec0ef7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3bsEF-RxayQlTVFJXed7g.png"/></div></div></figure><p id="9e92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开你的Google Drive，你会找到<code class="fe me mf mg mh b">model.onnx</code>文件。</p><h1 id="7169" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">用适当的依赖项创建Java项目</h1><p id="a968" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">使用Gradle、Maven或任何您喜欢的构建工具创建一个新的Java项目。或者更新现有项目的依赖项。</p><p id="3dcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个简单的pom.xml的要点(<a class="ae ko" href="https://gist.github.com/carlos-aguayo/ea8772c4a8a86601829d69be0a3752d6" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Carlos-agua yo/ea 8772 C4 A8 a 86601829d 69 be 0a 3752d 6</a>)</p><p id="3fec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是您在Maven格式中需要的依赖项:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/0a665df6dfe5f8862da8bed694c871a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*dzIMI6XFs5ctrDOQumi7vA.png"/></div></figure><p id="c8a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<code class="fe me mf mg mh b">artifacts</code>的文件夹，添加我们在上一步中生成的<code class="fe me mf mg mh b">tokenizer.json</code>和<code class="fe me mf mg mh b">model.onnx</code>文件。</p><h1 id="aefe" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">用Java运行模型</h1><p id="b685" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们现在终于可以用Java运行我们的代码了。看看这个gist的工作示例(<a class="ae ko" href="https://gist.github.com/carlos-aguayo/f2743e15186a0965e1958a599055683c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Carlos-agua yo/f 2743 e 15186 a 0965 e 1958 a 599055683 c</a>)</p><p id="f14e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，你可以看到我们将对与上一步相同的句子进行编码:“Hello world”。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/9f63fab6ccb66bcd3b71e0ac2ccac0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*QtQAaLon_QLgVtsMu7XZqg.png"/></div></figure><p id="4bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们实例化一个标记器，并对句子进行编码。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mn"><img src="../Images/e7ab91ad56095e9f6890f3d97c9739d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDzL7rKkkyXpJSU2QITR3w.png"/></div></div></figure><p id="7dee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们将模型加载到内存中。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1cc24e7d9595fcf7b61b31ea3d00ea26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*i0Z0uJ20G8ej95p2fUmhPA.png"/></div></figure><p id="84bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的模型有两个输入，<code class="fe me mf mg mh b">input_ids</code>和<code class="fe me mf mg mh b">attention_mask.</code>记号赋予器提供这些值。我们需要创建张量和地图来传递给我们的模型。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b984e61c946f77631b5297b3a378d159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*vjjgFjt2zs_6Msaj3WqsNg.png"/></div></figure><p id="67f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们可以将这些输入传递给我们的模型，并检查结果</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/7c46e49bef77a824ed2812447f2870c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*ecWBmhj_hb-jQE4WqaZ0bg.png"/></div></figure><p id="a168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这段代码时，您应该会得到类似下面这样的输出</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/98de346a3a98a429f74462b14ed09ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*mcvYayQbTYiaSc-m3kpSow.png"/></div></figure><p id="8d4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些值与我们在Python中运行代码时在第一步中获得的值相同:<code class="fe me mf mg mh b">[0.1000, 0.5740, 0.7239, 0.0975].</code></p><h1 id="e446" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="3c34" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在这篇博文中，您用Python运行了一个从HuggingFace hub下载的令牌化器和模型。然后，我们序列化了记号赋予器和模型，随后使用“深度Java库”(<a class="ae ko" href="https://djl.ai/" rel="noopener ugc nofollow" target="_blank">https://djl.ai/</a>)和“开放神经网络交换”(<a class="ae ko" href="https://onnx.ai/" rel="noopener ugc nofollow" target="_blank">https://onnx.ai/</a>)在Java中加载它们，并确认我们得到了相同的值。</p></div></div>    
</body>
</html>