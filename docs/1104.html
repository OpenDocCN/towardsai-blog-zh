<html>
<head>
<title>Testing Data-driven Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试数据驱动的微服务</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/testing-data-driven-microservices-a56a77d839b7?source=collection_archive---------2-----------------------#2020-11-01">https://pub.towardsai.net/testing-data-driven-microservices-a56a77d839b7?source=collection_archive---------2-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="8e26" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><p id="be26" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">测试总是开很多题，测试哪些案例？有哪些边缘案例？使用哪个测试平台..等等。<br/>这些问题没有单一的答案。</p><p id="6c9c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">但是当涉及到测试微服务时，复杂程度就提高了一个档次。因为它们经常要处理大量不同性质的数据。此外，微服务体系结构要求数据在组件(MQ、数据库……)之间传递，这可能会导致难以检测的侵蚀和损坏，例如:当数据流入微服务之间的MQ时，会发生舍入，或者发生转换错误，从而导致“静默”问题。从这个意义上说，数据的完整性是速度和多样性之外的另一个挑战。</p><p id="73c3" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">此外，数据服务通常会执行大量的计算功能，例如:最小值、最大值、卡方值、对数损失、标准差……在处理大批量数据和计算这些计算功能时，错误开始出现在数据的粒度部分。</p><p id="b638" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">此外，在微服务架构中工作时，我们希望确保应用程序的完整性。使用微服务需要在许多组件(MQ、数据库……)之间传递数据，这有时会导致我们甚至不知道的数据损坏。<br/>例如，当微服务和数据之间的数据流进入MQ时，会产生舍入或转换错误，从而导致无法捕获的问题。</p><p id="034b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">总之，这些错误是如此难以发现，以至于在测试阶段选择正确的边缘案例成为一项(几乎)不可能完成的任务。这就是我想要解决的问题，并试图在这里简化。</p><p id="018a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">让我们来谈谈当今大多数数据科学团队都在使用的一个神奇的工具，叫做Jupyter Notebook。该工具通过交互式可视化为数据分析和探索提供了一个高效的界面。在使用这个工具并实现Jupyter笔记本中的所有计算功能时，我发现选择边缘情况要容易得多，因为它们很清楚，几乎毫不费力就可以看到。</p><p id="94db" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">使用Jupyter Notebook进行测试的具体例子<br/> </strong>在下面选择的例子中，我们将回顾一下测试基于Jupyter Notebook的数据微服务。在这种情况下，我们计算了笔记本电脑中的所有计算功能，并将它们与存储在数据库中的微服务结果进行了比较，从而可以轻松检测和修复结果中的任何差异。<br/> <br/>在编写测试笔记本之后，测试笔记本应该与CI集成，以避免每天手动运行测试。</p><p id="94d1" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">将笔记本作为CI部分的一部分运行的一个很酷的框架是“Papermill”，这是一个参数化和执行Jupyter笔记本的伟大工具。<br/>它允许您使用CLI运行笔记本电脑，并保存笔记本电脑的输出，以便以后进行诊断。</p><p id="515a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">最后，我们可以配置测试笔记本，以便在笔记本的结果与我们的slack通道有差距时发送通知，我们使这个测试管道完全自动化。</p><p id="f2c3" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">整个管道的示意图:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/34334bad915884d56b555702afb30bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lS1dzz9Fw4ocWmtZjeFbpA.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">测试平台架构</figcaption></figure><p id="9515" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在图中，我们可以看到Jenkins触发CI来启动Papermill工具，该工具运行所有的测试Jupyter笔记本。一旦笔记本完成运行，它们的输出将存储在AWS S3中，笔记本的结果(通过或失败)将被发送到Slack。</p><p id="9649" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">在理解了整个架构之后，让我们标记一下使用Jupyter笔记本进行测试的好处:</strong></p><p id="c30b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> V </strong>运行海量数据。</p><p id="565e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> V </strong>作为CI的一部分运行，确保应用程序的完整性。</p><p id="5c61" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> V </strong>支持即时诊断和数据探索探索。</p><p id="0fce" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> V </strong>对错误和边缘情况给出清晰可见的见解。</p><p id="efbb" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">v易于调试。</p><p id="4a70" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在，让我们执行一个简单的“入门”任务，使用Jupyter Notebook和Papermill进行测试。</p><p id="fa37" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">假设我们每天都在计算一个<a class="ae lk" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank"> <em class="ll">精度</em> </a>指标，并将其用于以后的分析和性能测量。</p><p id="5e56" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们希望确保应用数据库中存储的精度是正确的，因为它会影响我们的业务决策。</p><p id="d1d1" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">所以让我们为它创建测试。</p><p id="04c7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">第一步是创建一个笔记本，它从应用程序中获取原始数据。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lm"><img src="../Images/b98aa43117c1f7047635503bd7edb5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAktupbFgjQXvJTJgueGUQ.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">Jupyter笔记本—第1部分</figcaption></figure><p id="e7ab" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">原始数据包括两个日期(“2020–01–01”和“2020–01–02”)的预测记录和实际值。</p><p id="2938" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在创建笔记本的第一阶段后，我们应该根据原始数据计算精度指标，这将是我们想要与生产数据进行比较的真实精度。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ln"><img src="../Images/b4c341a14b6e83d53f4b6061da130eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kvJvjg9S6bMek6YYFaJUg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">Jupyter笔记本—第二部分</figcaption></figure><p id="6ff4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这里，我们可以看到“2020–01–1”的精度值是1.0(这是一个很好的统计数据！)而在2020年1月2日，这个数字是0.5。</p><p id="65d0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">最后，我们必须从生产数据库中获取我们的精度结果，并将它们与实际结果(笔记本结果)进行比较。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lo"><img src="../Images/880ff36ba675364a43f9522722b04794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNa6HoVQp2UIPDfelBeb2g.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">朱庇特笔记本—第三部分</figcaption></figure><p id="c863" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在最后一个单元格中，我们可以看到在“2020–01–02”中，笔记本电脑结果和生产数据库结果之间的结果是不同的，并且它们以红色着色，以便于识别和修复。</p><p id="5d49" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">所以现在，我们有了一个测试笔记本，可以验证我们需要的每个时间框架的精度正确性，如果有一些差距，它们很容易检测和修复。</p><p id="7569" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">对于创建的笔记本，还有另外一件额外的事情要做。我们可以将笔记本集成为CI的一部分，因为它可以使用Papermill工具在夜间(或在另一个时间表中)运行。</p><p id="f5f0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">要安装Papermill，请运行命令:</p><pre class="kv kw kx ky gt lp lq lr ls aw lt bi"><span id="bcae" class="lu lv iq lq b gy lw lx l ly lz">$ pip install papermill</span></pre><p id="c212" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">要运行Papermill并将结果存储在AWS S3(可能在其他任何地方)并传递时间范围参数:</p><pre class="kv kw kx ky gt lp lq lr ls aw lt bi"><span id="5aaa" class="lu lv iq lq b gy lw lx l ly lz">$ papermill local/metric_calc.ipynb s3://notebooks/nightly/results/metric_calc_output.ipynb -p FROM_TS 2020-01-01 -p TO_TS 2020-01-02</span></pre><p id="9250" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在，我们可以在早上看到结果，看看我们的系统是否有一些错误，并确保我们的应用程序正常工作！</p><p id="28fa" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">另一个有价值的技巧是集成笔记本，以便在结果有差距时向Slack通道发送通知。</p><p id="cd96" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">注:</strong></p><ul class=""><li id="0dc4" class="ma mb iq jy b jz ka kd ke kh mc kl md kp me kt mf mg mh mi bi translated">您可以将papermill的结果集成到其他云提供商。</li></ul><p id="bb1f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">参考文献:</strong></p><ul class=""><li id="9e0d" class="ma mb iq jy b jz ka kd ke kh mc kl md kp me kt mf mg mh mi bi translated">【https://github.com/nteract/papermill】T4。</li><li id="ed68" class="ma mb iq jy b jz mj kd mk kh ml kl mm kp mn kt mf mg mh mi bi translated"><a class="ae lk" href="https://github.com/keitakurita/jupyter-slack-notify" rel="noopener ugc nofollow" target="_blank">https://github.com/keitakurita/jupyter-slack-notify</a>。</li><li id="cfb3" class="ma mb iq jy b jz mj kd mk kh ml kl mm kp mn kt mf mg mh mi bi translated"><a class="ae lk" href="https://jupyter.org/documentation" rel="noopener ugc nofollow" target="_blank">https://jupyter.org/documentation</a>。</li></ul><blockquote class="mo mp mq"><p id="fe63" class="jw jx ll jy b jz ka kb kc kd ke kf kg mr ki kj kk ms km kn ko mt kq kr ks kt ij bi translated"><em class="iq">链接到试玩笔记本:</em> <a class="ae lk" href="https://superwise-public.s3.amazonaws.com/demo_notebook.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="jy ja"> <em class="iq">笔记本</em> </strong> </a> <strong class="jy ja"> <em class="iq">。</em> </strong></p><p id="7b01" class="jw jx ll jy b jz ka kb kc kd ke kf kg mr ki kj kk ms km kn ko mt kq kr ks kt ij bi translated">作者:Oryan Omer — superwise.ai</p></blockquote></div></div>    
</body>
</html>