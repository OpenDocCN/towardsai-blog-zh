<html>
<head>
<title>Performing a Market Basket Analysis with Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习执行购物篮分析</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/performing-a-market-basket-analysis-with-machine-learning-94b5514ce1cb?source=collection_archive---------2-----------------------#2020-06-30">https://pub.towardsai.net/performing-a-market-basket-analysis-with-machine-learning-94b5514ce1cb?source=collection_archive---------2-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fd57" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Apriori，关联分析，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="5ac6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用AI提升营销。完整的代码<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20200629_Market_Basket_Analysis" rel="noopener ugc nofollow" target="_blank">可在我的Github回购</a></h2></div><p id="f9bf" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">无监督学习有3个主要部分:聚类、降维和关联。虽然我做了一些编辑和简化，你可以在这个源码找到原始代码<a class="ae kr" href="https://rasbt.github.io/mlxtend/user_guide/frequent_patterns/association_rules/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/5058bc3c38c77ab5716a5f6aae841c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3BFtkOqFv1Jx7TSy"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@_gemmajade?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> gemma </a>在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a5e1" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">通常，关联分析的目标是找到以下关系:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi me"><img src="../Images/13e76ffdf39622cbc8fca7153998060f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oN-JQbIiknyPlsmVfAOig.png"/></div></div></figure><h1 id="27c8" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">澄清术语</h1><p id="fa1c" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">经过几次搜索，我发现很多人把关联分析和购物篮分析混为一谈。如果我没理解错的话，关联分析(也叫关联规则生成、亲和度分析、关联规则挖掘……只是为了让事情更简单)指的是一类问题。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/37c48cebd5fea79298fe0e83dc12982d.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*tWAbXjBXU3l4DG5_MYI6Cg.png"/></div></figure><h2 id="57f9" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">市场篮子分析</h2><p id="631f" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">在这一类别中，购物篮分析代表了其中的一个子类别，当每个消费者购买的商品有许多清单时，它就会被应用。例如，同样的方法适用于<strong class="ku jd">观看的电影</strong>。不同的关联问题需要使用不同的关联子部分，这些子部分不会在市场篮分析中进行分类。</p><p id="b28d" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">为了执行购物篮分析，我将使用臭名昭著的apriori算法。</p><h1 id="1022" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">步伐</h1><p id="8a40" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">幸运的是，构建该算法的步骤非常简单:</p><ol class=""><li id="ea96" class="no np it ku b kv kw ky kz lb nq lf nr lj ns ln nt nu nv nw bi translated">安装模块</li><li id="47c9" class="no np it ku b kv nx ky ny lb nz lf oa lj ob ln nt nu nv nw bi translated">导入库</li><li id="01ea" class="no np it ku b kv nx ky ny lb nz lf oa lj ob ln nt nu nv nw bi translated">准备数据集</li><li id="c8e0" class="no np it ku b kv nx ky ny lb nz lf oa lj ob ln nt nu nv nw bi translated">提取频繁项目集</li><li id="bfe5" class="no np it ku b kv nx ky ny lb nz lf oa lj ob ln nt nu nv nw bi translated">提取关联规则</li><li id="830b" class="no np it ku b kv nx ky ny lb nz lf oa lj ob ln nt nu nv nw bi translated">提取规则</li><li id="6d7b" class="no np it ku b kv nx ky ny lb nz lf oa lj ob ln nt nu nv nw bi translated">定义阈值并提取最终关联</li></ol><h1 id="621a" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">1.安装模块</h1><p id="8dfe" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">我将使用pip导入模块。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="ed31" class="nd mg it od b gy oh oi l oj ok">! pip install mlxtend<br/>! pip install xlrd</span></pre><h1 id="8911" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">2.导入库</h1><p id="9dad" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">Scikit-Learn不支持apriori算法。我将使用名为mlxtend的python库的扩展。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="40eb" class="nd mg it od b gy oh oi l oj ok">import pandas as pd<br/>from mlxtend.preprocessing import TransactionEncoder<br/>from mlxtend.frequent_patterns import apriori<br/>from mlxtend.frequent_patterns import association_rules</span></pre><h1 id="ccfa" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">3.准备数据集</h1><p id="b036" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">因为我想概述这个问题的简化版本，我发现互联网上唯一兼容的数据集有成千上万的信息。我将自己创建一个数据集，这样您可以更好地了解它是如何工作的。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="904b" class="nd mg it od b gy oh oi l oj ok">#Onion, Sausages, Cheese, Water, Butter, Sugar, Eggs<br/>df = [['Onion', 'Sausages', 'Cheese', 'Butter'],<br/>      ['Onion', 'Sausages', 'Water', 'Sugar'],<br/>      ['Onion', 'Water', 'Sausages'],<br/>      ['Butter', 'Sugar', 'Eggs'],<br/>      ['Butter', 'Sugar', 'Eggs', 'Cheese'],<br/>      ['Water', 'Cheese', 'Eggs'],<br/>      ['Water', 'Butter'],<br/>      ['Onion', 'Butter', 'Sugar'],<br/>      ['Onion', 'Butter', 'Cheese'],<br/>      ['Onion', 'Butter', 'Water'],<br/>      ]<br/>df = pd.DataFrame(df)<br/>df</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/4bdaf55a03fbdfca4b07a05d4dbd958b.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*wlHbzLAsvkOu5TP96MOjvA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">这是我们数据集的格式:成分作为特征，客户作为行</figcaption></figure><h2 id="c6a6" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">将数据帧转换为兼容列表</h2><p id="596e" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">实际上，数据集在转换成数据帧之前就已经准备好了。然而，这篇文章的重点是向你说明什么是购物篮分析的组成部分。因为您可能会从存储在pandas数据框架中的信息开始，这将在将来证明是有用的(如果不感兴趣，您可以跳过)。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="095a" class="nd mg it od b gy oh oi l oj ok">#1. conversione in list: il problema che ha None values<br/>df = dataset.values.tolist()<br/>df<br/>[['Onion', 'Sausages', 'Cheese', 'Butter'],<br/> ['Onion', 'Sausages', 'Water', 'Sugar'],<br/> ['Onion', 'Water', 'Sausages', None],<br/> ['Butter', 'Sugar', 'Eggs', None],<br/> ['Butter', 'Sugar', 'Eggs', 'Cheese'],<br/> ['Water', 'Cheese', 'Eggs', None],<br/> ['Water', 'Butter', None, None],<br/> ['Onion', 'Butter', 'Sugar', None],<br/> ['Onion', 'Butter', 'Cheese', None],<br/> ['Onion', 'Butter', 'Water', None]]</span></pre><p id="088c" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">转换后，如你所见，我们的列表中仍然没有值。如果我们把它提供给模型，Apriori将抛出一个错误。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="a893" class="nd mg it od b gy oh oi l oj ok">#Removing None values in list, 2 dimensions<br/>df_ = list()<br/>for _ in df:<br/>  #using list comprehension <br/>  _ = [x for x in _ if x is not None]<br/>  df_.append(_)<br/>df = df_<br/>df<br/>[['Onion', 'Sausages', 'Cheese', 'Butter'],<br/> ['Onion', 'Sausages', 'Water', 'Sugar'],<br/> ['Onion', 'Water', 'Sausages'],<br/> ['Butter', 'Sugar', 'Eggs'],<br/> ['Butter', 'Sugar', 'Eggs', 'Cheese'],<br/> ['Water', 'Cheese', 'Eggs'],<br/> ['Water', 'Butter'],<br/> ['Onion', 'Butter', 'Sugar'],<br/> ['Onion', 'Butter', 'Cheese'],<br/> ['Onion', 'Butter', 'Water']]</span></pre><p id="b836" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我使用<strong class="ku jd"> df_ </strong>重新创建了列表，但是删除了None值。因为DataFrame是使用二维嵌套列表构建的，所以如果您想在多维列表中不删除任何内容，则此算法不适用。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="f040" class="nd mg it od b gy oh oi l oj ok">#one_hot encoding (boolean output)<br/>te = TransactionEncoder()<br/>te_ary = te.fit(df).transform(df)<br/>df = pd.DataFrame(te_ary, columns=te.columns_)<br/>df</span></pre><p id="db68" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">Scikit-Learn不支持apriori算法，为此我安装了<strong class="ku jd"> mlxtend </strong>。它将把二维列表转换成one_hot编码的数据帧。</p><p id="93b8" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如上所述，这应该是最终结果:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e4227d6178a2b606aa1ebab5ea5f7401.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*FQK-fVINHRpdaFIyitCh_Q.png"/></div></figure><p id="0c32" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">对于每一个顾客来说，买一种食材就相当于真，而不是买假。正如您所注意到的，apriori算法不考虑数量，而只考虑产品是否被购买。</p><h1 id="dae2" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">4.提取频繁项目集</h1><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="db6f" class="nd mg it od b gy oh oi l oj ok">frequent_itemsets = apriori(df, min_support=0.4, use_colnames=True)<br/>frequent_itemsets</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/72eaef9767d7ce24440d791a6b2f26c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*zhUPlsQrBz2XsDngnMKQAw.png"/></div></figure><h1 id="785d" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">5.提取关联规则</h1><p id="3b92" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">在所有项目中，我将选择最低置信度为0.4的项目:</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="8bca" class="nd mg it od b gy oh oi l oj ok">association_rules(frequent_itemsets, metric="confidence", min_threshold=0.4)</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oo"><img src="../Images/17b26a9c9bd49a2f455381d1a7e8193e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stzcSDqOTC9xMsSjgwO0XQ.png"/></div></div></figure><h1 id="c38b" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">6.提取规则</h1><p id="9622" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">通过这一步，我将对0.7的升力施加一个最小阈值:</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="a479" class="nd mg it od b gy oh oi l oj ok">rules = association_rules(frequent_itemsets, metric="lift", min_threshold=.7)</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi op"><img src="../Images/1246dbc525bec18bac36befba370141a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uATYlT_nXk90vBD63kvuGw.png"/></div></div></figure><h1 id="f28d" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">7.定义阈值并提取最终关联</h1><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="bb59" class="nd mg it od b gy oh oi l oj ok">rules["antecedent_len"] = rules["antecedents"].apply(lambda x: len(x))</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oq"><img src="../Images/d432f6380101b254cf629d3513dfd004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTGGLz4toDwulqrbQbeDlw.png"/></div></div></figure><p id="97fd" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">正如我们所看到的，买洋葱的人可能会买黄油，这个规则也适用，反之亦然。</p><h2 id="3ccb" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">根据具体情况做出选择</h2><p id="3e8e" class="pw-post-body-paragraph ks kt it ku b kv mx kd kx ky my kg la lb mz ld le lf na lh li lj nb ll lm ln im bi translated">如果您想基于阈值选择关联规则，您会发现这个算法很有用。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="43b1" class="nd mg it od b gy oh oi l oj ok">rules[ (rules['antecedent_len'] &gt;= 1) &amp;<br/>       (rules['confidence'] &gt; 0.75) &amp;<br/>       (rules['lift'] &gt; 1.2) ]</span></pre><h2 id="3514" class="nd mg it bd mh ne nf dn ml ng nh dp mp lb ni nj mr lf nk nl mt lj nm nn mv iz bi translated">根据成分进行选择</h2><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="9ec1" class="nd mg it od b gy oh oi l oj ok">#select the ones you want<br/>rules[rules['antecedents'] == {'Onion'}]</span></pre></div></div>    
</body>
</html>