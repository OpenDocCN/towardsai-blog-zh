<html>
<head>
<title>How to Choose the Best Nearest Neighbors Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何选择最佳最近邻算法</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-to-choose-the-best-nearest-neighbors-algorithm-8d75d42b16ab?source=collection_archive---------1-----------------------#2020-12-05">https://pub.towardsai.net/how-to-choose-the-best-nearest-neighbors-algorithm-8d75d42b16ab?source=collection_archive---------1-----------------------#2020-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ef2c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>，<a class="ae ep" href="https://towardsai.net/p/category/opinion" rel="noopener ugc nofollow" target="_blank">意见</a></h2><div class=""/><div class=""><h2 id="aea3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一种数据驱动的方法，用于在您的自定义数据集上选择最快、最准确的人工神经网络算法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e75607d5e35fa81a947b0127841832cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d1wLLbfK5NJr2l1rljxwg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">最快最准确的。<a class="ae lh" href="https://github.com/stephenleo/adventures-with-ann/blob/main/ann_benchmarking.ipynb" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="3d97" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">ANN背景</h1><p id="f0f7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在我之前的帖子里，KNN死了！】，我比较了一个名为<code class="fe mw mx my mz b">HNSW</code>的人工神经网络算法和<code class="fe mw mx my mz b">sklearn's</code> KNN，证明了HNSW具有非常优越的性能，速度提高了380倍，同时提供了99.3%的相同结果。</p><p id="db81" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">为了让事情更有趣，有几个人工神经网络算法，如</p><ol class=""><li id="7983" class="nf ng it mc b md na mg nb mj nh mn ni mr nj mv nk nl nm nn bi translated">Spotify的<a class="ae lh" href="https://github.com/spotify/annoy" rel="noopener ugc nofollow" target="_blank">惹恼了</a></li><li id="8b2a" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">谷歌的<a class="ae lh" href="https://github.com/google-research/google-research/tree/master/scann" rel="noopener ugc nofollow" target="_blank"> ScaNN </a></li><li id="eab9" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">脸书的失败</li><li id="216a" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">我个人最喜欢的:层次可导航小世界图<a class="ae lh" href="https://github.com/nmslib/hnswlib" rel="noopener ugc nofollow" target="_blank"> HNSW </a></li><li id="b119" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">还有更多</li></ol><p id="a641" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">作为一名数据科学家，我非常支持做出数据驱动的决策，正如我在<a class="ae lh" href="https://towardsdatascience.com/how-to-choose-the-best-keras-pre-trained-model-for-image-classification-b850ca4428d4" rel="noopener" target="_blank">如何选择最佳的Keras预训练模型</a>中提到的。因此，在这篇文章中，我将展示一种数据驱动的方法，通过使用优秀的<code class="fe mw mx my mz b"><a class="ae lh" href="https://github.com/erikbern/ann-benchmarks" rel="noopener ugc nofollow" target="_blank">ann-benchmarks</a></code> GitHub库来决定哪种人工神经网络算法是定制数据集的最佳选择。</p><h1 id="f11f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">人工神经网络基准</h1><p id="b4e0" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe mw mx my mz b"><a class="ae lh" href="https://github.com/erikbern/ann-benchmarks" rel="noopener ugc nofollow" target="_blank">ann-benchmarks</a></code>代码通过绘制每个算法的<code class="fe mw mx my mz b">Recall</code>与<code class="fe mw mx my mz b">Queries per second.</code>来比较多个人工神经网络算法。这样，您可以直观地选择最快(每秒查询数)的算法，同时提供最小的期望召回。我们选择Recall作为感兴趣的度量，因为我们想知道ANN [ <a class="ae lh" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">精度和Recall </a> ]检索到的真实最近邻的百分比。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6907412e4a71b2604654dadcf2610a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*Ij5F3ESeJsaBwBfy.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">来源:<a class="ae lh" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">维基百科</a>上的<a class="ae lh" href="https://commons.wikimedia.org/wiki/User:Walber" rel="noopener ugc nofollow" target="_blank">沃尔伯</a></figcaption></figure><p id="2c5d" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">下图是使用<code class="fe mw mx my mz b">angular</code>距离度量在<code class="fe mw mx my mz b">glove-100</code>数据集上运行ANN-Benchmarks得到的图表。在这个数据集上，<code class="fe mw mx my mz b">scann</code>算法在任何给定的<code class="fe mw mx my mz b">Recall</code>都有最高的<code class="fe mw mx my mz b">Queries per second</code>，因此是这个数据集上最好的算法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bb04be79b4da61643b93b79dbc548d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yQU4MnkWaGzPYbsq"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用角距离度量在glove-100数据集上的ANN基准。<a class="ae lh" href="https://github.com/erikbern/ann-benchmarks" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="b53b" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">设置</h1><p id="57ac" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是在自定义数据集上运行ann-benchmarks代码所涉及的步骤。</p><ol class=""><li id="a2cb" class="nf ng it mc b md na mg nb mj nh mn ni mr nj mv nk nl nm nn bi translated">在python 3.6环境中安装ann基准。</li><li id="0cb6" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">将您的自定义嵌入数据帧上传到<code class="fe mw mx my mz b">ann-benchmarks/data</code>目录。</li><li id="14ca" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">更新<code class="fe mw mx my mz b">ann-benchmarks/ann-benchmarks/dataset.py</code>以读取和分割新的定制嵌入数据帧。</li><li id="6642" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">运行基准测试代码。</li><li id="61c1" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">绘制结果，瞧！最佳算法会出现在你面前。</li></ol><h1 id="51f8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">1.在python 3.6环境中安装人工神经网络基准</h1><p id="adab" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这个步骤的代码需要在您的<code class="fe mw mx my mz b">Terminal</code>中执行。我使用anaconda进行环境设置。这将需要几分钟才能完成。您可以通过使用— <code class="fe mw mx my mz b">proc</code>参数增加并发进程的数量来加快速度。我故意在安装完成后才升级<code class="fe mw mx my mz b">pandas and scipy</code>。</p><p id="1464" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated"><strong class="mc jd"> <em class="nu">重要！截至本文撰写之时，Ann-benchmarks仅支持Python 3.6。</em></strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="f64f" class="nx lj it bd lk ny nz dn lo oa ob dp ls mj oc od lu mn oe of lw mr og oh ly iz bi translated">潜在问题:</h2><ol class=""><li id="937d" class="nf ng it mc b md me mg mh mj oi mn oj mr ok mv nk nl nm nn bi translated"><code class="fe mw mx my mz b">gcc</code>未安装:使用<code class="fe mw mx my mz b">sudo apt-get install gcc</code>安装GCC。</li><li id="f52e" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated"><code class="fe mw mx my mz b">Docker</code>未安装:根据此<a class="ae lh" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">链接</a>的说明安装Docker。请记住选择正确的发行版。</li><li id="aab4" class="nf ng it mc b md no mg np mj nq mn nr mr ns mv nk nl nm nn bi translated">权限问题:如果您在运行<code class="fe mw mx my mz b">python install.py</code>时遇到任何权限问题，只需使用<code class="fe mw mx my mz b">sudo /opt/conda/envs/ann/bin/python install.py</code>运行即可。当您使用<code class="fe mw mx my mz b">sudo</code>时，记得在您的<code class="fe mw mx my mz b">ann</code>环境中提供anaconda python的完整路径。</li></ol><h1 id="896a" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">2.上传您的自定义嵌入数据框架</h1><p id="2835" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在此步骤中，您可以将自定义数据框文件粘贴到<code class="fe mw mx my mz b">ann-benchmarks/data</code>目录中。对于这篇文章，我的数据框架是相同的[ <a class="ae lh" href="http://deepyeti.ucsd.edu/jianmo/amazon/" rel="noopener ugc nofollow" target="_blank">亚马逊产品数据集</a> ]，具有我在上一篇文章中使用的FastText句子嵌入:<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/knn-k-nearest-neighbors-is-dead-fc16507eb3e" rel="noopener"><em class="nu">KNN(K-Nearest Neighbors)死了！</em> </a>但我只是随机抽取了50K行，以确保基准测试在合理的时间内运行。下面是将嵌入数据框保存为pickle文件<code class="fe mw mx my mz b">custom-euclidean.pkl</code>的代码，该文件位于正确的目录中，同时也是数据框前5行的摘录。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c13b4e3beeccba355414088263826dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*_5A-by90PKUoZl1HDjhQFA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">自定义数据集的前5行。<a class="ae lh" href="https://github.com/stephenleo/adventures-with-ann/blob/main/ann_benchmarking.ipynb" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="2650" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">3.更新<code class="fe mw mx my mz b">datasets.py</code>来处理您的自定义数据帧</h1><p id="bd1b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们需要更新ANN基准代码，以了解如何处理我们的新数据框架。我们通过在<code class="fe mw mx my mz b">ann-benchmarks/ann-benchmarks/datasets.py</code>文件的末尾添加一个新的函数和字典元素来做到这一点。距离参数允许的选项是<code class="fe mw mx my mz b">"euclidean", "angular", "hamming" or "jaccard"</code>。距离度量的选择取决于您的问题。对于我的情况，我发现“欧几里得”提供了良好的最近邻。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="a847" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">4.运行基准代码</h1><p id="3643" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果到目前为止一切顺利，我们现在可以简单地通过从您的<code class="fe mw mx my mz b">Terminal</code>调用下面的行来运行基准测试。将<code class="fe mw mx my mz b">parallelism</code>的值更改为您想要使用的CPU内核数。我使用的是16核CPU，所以我选择<code class="fe mw mx my mz b">parallelism=14</code>为其他任务保留2核。这将需要一些时间来完成。我的50K行数据框架在20%测试集下运行了大约7个小时。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="a36a" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">5.标绘结果</h1><p id="662f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">一旦运行完成，我们可以通过运行<code class="fe mw mx my mz b">plot.py</code>来绘制结果。我们还可以启用y轴以<code class="fe mw mx my mz b">log</code>比例绘图。注意这里我使用了<code class="fe mw mx my mz b">sudo</code>和我的Anaconda Python的完整路径，因为我在正常运行plot.py时遇到了权限问题:<code class="fe mw mx my mz b">python plot.py --dataset=custom-euclidean --y-log</code>。你可以用任何适合你的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4a2f" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">结果图作为png文件保存在<code class="fe mw mx my mz b">results</code>目录中。对于我在本文中使用的50K行亚马逊数据集，结果如下。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e75607d5e35fa81a947b0127841832cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d1wLLbfK5NJr2l1rljxwg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在我们的自定义数据集上，多个人工神经网络算法的每秒召回数与查询数。<a class="ae lh" href="https://github.com/stephenleo/adventures-with-ann/blob/main/ann_benchmarking.ipynb" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="07e4" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">从这个图中，我们看到一些算法，如<code class="fe mw mx my mz b">NGT-onng, hnsw(nmslib), n2, hnswlib, SW-graph(nmslib)</code>明显比其他算法好，在任何给定的召回中每秒提供更高的查询。因此，我们可以在亚马逊产品数据集上进一步探索这些算法。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h1 id="5a8d" class="li lj it bd lk ll ot ln lo lp ou lr ls ki ov kj lu kl ow km lw ko ox kp ly lz bi translated">结论</h1><p id="5f39" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">总之，通过使用<code class="fe mw mx my mz b">ann-benchmarks</code>，并组合一些额外的代码，我们可以在我们自己的定制数据集上测试大量的人工神经网络算法，以缩小几个人工神经网络算法的范围，供进一步研究。这篇文章的所有代码都可以在我的<a class="ae lh" href="https://github.com/stephenleo/adventures-with-ann/blob/main/ann_benchmarking.ipynb" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到。感谢您的阅读！</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="737d" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">下一步是什么？如果你想在“大数据”上部署HNSW ANN，你可以在Docker容器中使用Elasticsearch</p><div class="oy oz gp gr pa pb"><a href="https://medium.com/towards-artificial-intelligence/approximate-nearest-neighbors-on-elastic-search-with-docker-15342153f22a" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd jd gy z fp pg fr fs ph fu fw jc bi translated">基于Docker弹性搜索的近似最近邻</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">将人工神经网络扩展到上亿</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp lb pb"/></div></div></a></div><p id="a327" class="pw-post-body-paragraph ma mb it mc b md na kd mf mg nb kg mi mj nc ml mm mn nd mp mq mr ne mt mu mv im bi translated">编辑1:将代码片段转换成GitHub gists</p></div></div>    
</body>
</html>