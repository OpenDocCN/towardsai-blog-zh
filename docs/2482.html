<html>
<head>
<title>An Insight of Marketing Analytics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">营销分析洞察</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/an-insight-of-marketing-analytics-305902addd07?source=collection_archive---------1-----------------------#2022-01-12">https://pub.towardsai.net/an-insight-of-marketing-analytics-305902addd07?source=collection_archive---------1-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b97161918c08146ae8efb7797c633854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vs_RFpJWO97IG9FIs3hITw.jpeg"/></div></div></figure><div class=""/><h1 id="f839" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="16ae" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">许多行业领先的公司已经在使用数据科学来做出更好的决策，并改善他们的营销分析。随着行业数据的扩展、数据源可用性的提高以及存储和处理成本的降低，组织现在可以借助多种数据科学程序来咀嚼大量经常粒度化的数据，并利用这些数据来创建复合模型、交付现代任务以及以更高的准确性获取重要的消费者洞察。对于许多公司来说，在营销分析中使用数据科学原理是一种经济高效、实用的方法，可以观察客户的旅程，并提供更加定制化的体验。</p><h1 id="37c7" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">客户数据的分段</h1><p id="58f2" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">客户数据细分是根据人口统计或行为数据将目标客户划分为不同群体的过程，以便营销计划可以更精确地针对每个群体进行定制。这也是正确指定营销资源的一个重要部分，因为通过瞄准特定的客户群，营销活动可以获得更高的费用回报。</p><h2 id="05fe" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">客户细分数据聚类(无监督学习)</h2><p id="2adc" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">无监督学习是一种对客户数据进行细分的现代方法。它非常适合客户数据细分，因为它收集彼此最相似的数据点并将它们组合在一起，这正是良好的客户细分程序应该做的。</p><p id="8e1d" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><strong class="ky jc">聚类</strong>是一种无监督的机器学习，它看到数据中的组或簇在外部提前知道它们。以下是集群的优势:</p><ul class=""><li id="5a67" class="ml mm jb ky b kz mg ld mh lh mn ll mo lp mp lt mq mr ms mt bi translated">它可以获得数据分析师无法预见或不熟悉的客户群。</li><li id="10f1" class="ml mm jb ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">它是有弹性的，可以应用于广泛的数据。</li><li id="bcdd" class="ml mm jb ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">它减少了对客户人口统计和行为之间联系的广泛专业知识的需求。</li><li id="cb93" class="ml mm jb ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">它可以迅速采取行动，也可以扩展到非常大的数据集。</li></ul><p id="86a8" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">集群的局限性:</p><ul class=""><li id="d703" class="ml mm jb ky b kz mg ld mh lh mn ll mo lp mp lt mq mr ms mt bi translated">创造的客户积累可能不容易解释。</li><li id="8735" class="ml mm jb ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">如果数据不是基于消费者交付的(例如购买的产品或服务)，那么如何使用所看到的聚类可能并不明显。</li></ul><h2 id="c8b0" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">客户数据中的连接</h2><p id="2ae8" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要使用聚类进行客户细分，必须确定相似性，或者特别注意确定哪种客户是相似的。</p><p id="d65d" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">示例:</p><p id="9560" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">如果公司想要设计销售服装的营销策略，根据顾客倾向于购买的面包质量来细分顾客数据可能没有意义。</p><p id="dc0a" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">客户行为，例如他们过去对营销活动的反应，通常是最重要的一类数据。</p><h2 id="b0a0" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">标准化客户数据</h2><p id="97e9" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了能够基于连续变量来确定客户，需要重新调整这些参数，以便数据处于相似的范围内。</p><p id="19fe" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">示例:</p><p id="3414" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">就拿年龄和工资来说吧。这些是非常不同的计算。一个人的工资可以是90000美元，年龄可以是40岁。因此，就客户关系而言，需要精确地了解其中一个变量的变化与其他变量的变化有多大。为每个变量手动生成这种类型的演示具有挑战性。因此，这需要将数据标准化，在标准范围内对它们进行协调。</p><p id="beb1" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">Z-score是一种标准化聚类参数的方法，其步骤如下:</p><ul class=""><li id="1b38" class="ml mm jb ky b kz mg ld mh lh mn ll mo lp mp lt mq mr ms mt bi translated">减少每个数据点的数据平均值。</li><li id="d722" class="ml mm jb ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">减少每个数据点的数据平均值。</li></ul><p id="1996" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">标准差是对我们的分数的计算。下面的公式用于计算数据点的标准化值:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/8601aba52e4170dcad459f19dc03fbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JkitsR_eWxrTjRru.jpg"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">图:标准化等式</figcaption></figure><p id="f91b" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在哪里，</p><p id="f9cf" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">zi =第I个标准化值</p><p id="0b5b" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">x =所有值</p><p id="2a06" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">mean(x) =所有x值的平均值</p><p id="7a12" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">STD(x)= x值的标准偏差</p><h2 id="23e7" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">客户年龄和收入数据标准化示例</h2><p id="88dc" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面Python代码将对客户的年龄和收入数据进行标准化。</p><p id="c8d7" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">导入所有必需的包。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="bbab" class="lu jz jb nj b gy nn no l np nq">import numpy as np</span><span id="7c14" class="lu jz jb nj b gy nr no l np nq">import pandas as pd</span></pre><p id="50ed" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">生成随机的客户收入和年龄数据。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="23a1" class="lu jz jb nj b gy nn no l np nq">np.random.seed(100)</span><span id="d410" class="lu jz jb nj b gy nr no l np nq">df = pd.DataFrame()</span><span id="c156" class="lu jz jb nj b gy nr no l np nq">df['salary'] = np.random.normal(80000, scale=10000, size=100)</span><span id="b17d" class="lu jz jb nj b gy nr no l np nq">df['age'] = np.random.normal(50, scale=10, size=100)</span><span id="26e1" class="lu jz jb nj b gy nr no l np nq">df = df.astype(int)</span><span id="a7a1" class="lu jz jb nj b gy nr no l np nq">df.head()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9bee8db742989c5d027d62db1c9b32cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*6Eh-asjDhjDUTZbBi9KeRw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">客户收入和年龄数据</figcaption></figure><p id="3fbd" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">使用std函数同时计算两列的标准偏差。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="0c6a" class="lu jz jb nj b gy nn no l np nq">df.std()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/57144eeb685b56e21d4c308f9e885aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*x70etMls3KQMZRLUCnhdoA.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">标准偏差</figcaption></figure><p id="c209" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">计算两列的平均值。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="dd0b" class="lu jz jb nj b gy nn no l np nq">df.mean()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/7dc50ba839ba6a43811dee544157a983.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*tIypjstUJCanmtmVuc2TLA.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">年龄和收入平均值</figcaption></figure><p id="c1a8" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">使用标准偏差和平均值标准化变量。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="19d5" class="lu jz jb nj b gy nn no l np nq">df['z_salary'] = (df['salary'] -df['salary'].mean())/df['salary'].std()</span><span id="d8eb" class="lu jz jb nj b gy nr no l np nq">df['z_age'] = (df['age'] - df['age'].mean())/df['age'].std()</span><span id="8648" class="lu jz jb nj b gy nr no l np nq">df.head()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5023dc1f6b0a110369fbc1ff2e4a5b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*LLG5Nlkm0TssLq2524kQeg.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">标准化变量</figcaption></figure><p id="44fb" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">检查标准化。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="4ebf" class="lu jz jb nj b gy nn no l np nq">df.std()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/8d582973d343db62d945fcb880672547.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*_SLhVLq6swKJioy_xTF7EA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">年龄和收入的标准化</figcaption></figure><p id="dd60" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">一旦数据标准化，就需要计算客户之间的相似度。这主要是通过测量特征空间中客户之间的距离来实现的。在二维散点图中，两个客户之间的<strong class="ky jc">欧几里德距离</strong>就是他们点之间的距离。</p><h2 id="cef7" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">计算客户数据点之间的距离</h2><p id="61f4" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们来计算三个客户之间的距离。</p><p id="691c" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">导入所有必需的包。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="8432" class="lu jz jb nj b gy nn no l np nq">import math</span></pre><p id="64b7" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">创建年龄和收入数据。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="aa71" class="lu jz jb nj b gy nn no l np nq">ages = [50, 40, 30]</span><span id="e53f" class="lu jz jb nj b gy nr no l np nq">salary = [50000, 60000, 40000]</span></pre><p id="0583" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">计算第一个和第二个客户之间的距离/</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="11a6" class="lu jz jb nj b gy nn no l np nq">math.sqrt((ages[0] - ages[1])**2 + (salary[0] - salary[1])**2)</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f6504a69fd70b2051baf705b76499efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*eT3BZcndTbZoi2iHo8I8fw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">第一个和第二个客户之间的距离。</figcaption></figure><p id="923b" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">计算第一个和第三个客户之间的距离。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="872e" class="lu jz jb nj b gy nn no l np nq">math.sqrt((ages[0] - ages[2])**2 + (salary[0] - salary[2])**2)</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/470e88a6e34a4cb6f48d9b0e973b5782.png" data-original-src="https://miro.medium.com/v2/resize:fit:214/format:webp/1*LkBdY44VTjCZ2HhjB8lfOg.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">第一个和第三个客户之间的距离。</figcaption></figure><p id="8e86" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这里，在输出中，第一个和第三个客户以及第一个和第二个客户之间的距离是不同的。</p><p id="2f85" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">使用平均值和标准差标准化年龄和工资。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="cba5" class="lu jz jb nj b gy nn no l np nq">z_ages = [(age - 40)/10 for age in ages]</span><span id="467b" class="lu jz jb nj b gy nr no l np nq">z_incomes = [(salary - 50000)/10000 for salary in salaries]</span></pre><p id="564c" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">再次，计算第一个和第二个客户的标准化分数之间的距离。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="02b2" class="lu jz jb nj b gy nn no l np nq">math.sqrt((z_ages[0] - z_ages[1])**2 + (z_salaries[0] - z_salaries[1])**2)</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/71b62b8d89f0f3136cb3bfdd54a273c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*IApEEsO39xVOt21tSqM3LA.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">标准化后第一个和第二个客户之间的距离</figcaption></figure><p id="91cf" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">计算第一个和第三个客户的标准化分数之间的距离。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="ff95" class="lu jz jb nj b gy nn no l np nq">math.sqrt((z_ages[0] - z_ages[2])**2 + (z_salaries[0] - z_salaries[2])**2)</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5577121948320e0b2b6ddd6600e7e457.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*G2F_ORL5sJxuJDF6VAiIvQ.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">第一个和第三个客户之间的距离。</figcaption></figure><p id="ab4a" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这里，标准化之后，第一和第二客户之间的距离以及第一和第三客户之间的距离是相同的。</p><h1 id="1d2d" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">k均值聚类</h1><p id="c522" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">k-means聚类是一种非常流行的无监督学习方法，具有非常广泛的用途。它非常熟悉，因为它可以扩展到非常大的数据集，并且在应用程序中运行良好。</p><p id="4221" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">k-means聚类是一种算法，它试图找到将数据点分组为<em class="ob"> k </em>个独立组的最佳方式，其中<em class="ob"> k </em>是算法的一个参数。然后，该算法反复工作，试图找到最佳分组。</p><p id="c589" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">以下是执行该算法的步骤:</p><ul class=""><li id="373b" class="ml mm jb ky b kz mg ld mh lh mn ll mo lp mp lt mq mr ms mt bi translated">该算法从随机选取空间中的<em class="ob"> k </em>点作为聚类的质心开始。然后，将每个数据点分配给离它最近的质心。</li><li id="f7dc" class="ml mm jb ky b kz mu ld mv lh mw ll mx lp my lt mq mr ms mt bi translated">质心被刷新为指定给它们的所有数据点的平均值。然后，数据点被重新分配到离它们最近的质心。</li></ul><p id="37c0" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">重复第二步，直到质心更新后没有数据点改变它们被分配的质心。</p><h2 id="b274" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">示例:客户工资和年龄数据的K均值聚类</h2><p id="5eef" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对客户工资和年龄数据执行K均值聚类。</p><p id="5a13" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">导入所有必需的库。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="a536" class="lu jz jb nj b gy nn no l np nq">import pandas as pd</span><span id="5cad" class="lu jz jb nj b gy nr no l np nq">import matplotlib.pyplot as plt</span><span id="989a" class="lu jz jb nj b gy nr no l np nq">from sklearn import cluster</span><span id="bdea" class="lu jz jb nj b gy nr no l np nq">%matplotlib inline</span></pre><p id="78d2" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">导入客户的CSV数据。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="88c3" class="lu jz jb nj b gy nn no l np nq">df = pd.read_csv('/content/customer.csv')<br/>df.head()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d137185b43bc33740cd3d55c1893267d.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Wlur01O9rVAMR4dMfsXkZw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">客户数据</figcaption></figure><p id="5b4e" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">为薪金和年龄值创建标准化值列，并将它们存储在z_salary和z_age变量中。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="df21" class="lu jz jb nj b gy nn no l np nq">df['z_salary'] = (df['salary'] - df['salary'].mean())/df['salary'].std()</span><span id="7ebc" class="lu jz jb nj b gy nr no l np nq">df['z_age'] = (df['age'] - df['age'].mean())/df['age'].std()</span></pre><p id="b5cd" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">绘制客户数据。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="8f7a" class="lu jz jb nj b gy nn no l np nq">plt.scatter(df['salary'], df['age'])</span><span id="855f" class="lu jz jb nj b gy nr no l np nq">plt.xlabel('Salary')</span><span id="d350" class="lu jz jb nj b gy nr no l np nq">plt.ylabel('Age')</span><span id="7592" class="lu jz jb nj b gy nr no l np nq">plt.show()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/968a9fc6b816118fc8bf0261e76e6444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*dtJp7LBnCb-gKA9CBMUgxA.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">绘制客户数据</figcaption></figure><p id="459a" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">用四个聚类执行k-means聚类。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="50e0" class="lu jz jb nj b gy nn no l np nq">model = cluster.KMeans(n_clusters=4, random_state=10)</span><span id="89cf" class="lu jz jb nj b gy nr no l np nq">model.fit(df[['z_salary','z_age']])</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/c4874ac00095063c27eec58db9eb05fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3fzuWoKTF4SSXYj4LDj4A.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">k均值聚类</figcaption></figure><p id="6838" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">创建一个名为cluster的列，其中包含每个数据点所属的分类的标签。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="259d" class="lu jz jb nj b gy nn no l np nq">df['cluster'] = model.labels_</span><span id="72c8" class="lu jz jb nj b gy nr no l np nq">df.head()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e299c982f9d52ebb8881811ea38e50fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*0C8c1j1GUqnmKQigB8GRRw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">聚类后的客户数据</figcaption></figure><p id="b114" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">绘制数据。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="3b7c" class="lu jz jb nj b gy nn no l np nq">colors = ['r', 'b', 'k', 'g']</span><span id="ae86" class="lu jz jb nj b gy nr no l np nq">markers = ['^', 'o', 'd', 's']</span><span id="0c95" class="lu jz jb nj b gy nr no l np nq">for c in df['cluster'].unique():</span><span id="00fa" class="lu jz jb nj b gy nr no l np nq">d = df[df['cluster'] == c]</span><span id="703b" class="lu jz jb nj b gy nr no l np nq">plt.scatter(d['salary'], d['age'], marker=markers[c], color=colors[c])</span><span id="eaf2" class="lu jz jb nj b gy nr no l np nq">plt.xlabel('Salary')</span><span id="f4bd" class="lu jz jb nj b gy nr no l np nq">plt.ylabel('Age')</span><span id="8ba9" class="lu jz jb nj b gy nr no l np nq">plt.show()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e6dd74d6c4a905a43d80d2b439559a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*PhOhDN_NZXVGsNPFuZ6IQw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">客户数据的k均值聚类</figcaption></figure><p id="6fa2" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这里是一个数据图，用颜色/形状表示每个数据点被分配到哪个聚类。</p><h1 id="8911" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">高维数据和降维</h1><p id="1d72" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">拥有不止两个维度的数据是很常见的。如果我们了解这些客户对促销的反应，他们购买了多少产品，或者有多少人住在他们的家里，那么它将有更多的维度。</p><p id="887d" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">当数据具有额外的维度时，可视化该数据变得更加困难。因此，降维就成了问题。<strong class="ky jc">降维</strong>的目的是将多维数据降维，通常降维为二维，以达到可视化的目的，同时尽量保持点与点之间的距离。</p><p id="57af" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">主成分分析(PCA)用于执行维数减少。PCA是一种转换数据的方法。它采用原始维度，并创建新维度来捕获数据中的最大差异。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/0ff9e845b1a0b8a0770e97f220caf8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xPXzHOky2mhhuf1i.jpg"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">PCA功能</figcaption></figure><h2 id="3a99" class="lu jz jb bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">示例:使用PCA对高维数据进行降维</h2><p id="2757" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">导入所有必需的包。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="3b6b" class="lu jz jb nj b gy nn no l np nq">import pandas as pd</span><span id="8869" class="lu jz jb nj b gy nr no l np nq">from sklearn import cluster</span><span id="0ba3" class="lu jz jb nj b gy nr no l np nq">from sklearn import decomposition</span><span id="b6c1" class="lu jz jb nj b gy nr no l np nq">import matplotlib.pyplot as plt</span><span id="231e" class="lu jz jb nj b gy nr no l np nq">%matplotlib inline</span></pre><p id="8eca" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">导入客户的CSV数据。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="b7ca" class="lu jz jb nj b gy nn no l np nq">df = pd.read_csv('/content/pca_data.csv')</span><span id="419c" class="lu jz jb nj b gy nr no l np nq">df.head()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1f75e47fa85100e91a089f1ed3f935e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*yT4r3AytcIBQQJLRSOKIWA.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">客户数据</figcaption></figure><p id="aec4" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">将三列标准化，并将标准化列的名称保存在列表中</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="b57d" class="lu jz jb nj b gy nn no l np nq">cols = df.columns</span><span id="eff3" class="lu jz jb nj b gy nr no l np nq">zcols = []</span><span id="3bb1" class="lu jz jb nj b gy nr no l np nq">for col in cols:<br/>  df['z_' + col] = (df[col] - df[col].mean())/df[col].std()<br/>  zcols.append('z_' + col)</span><span id="8161" class="lu jz jb nj b gy nr no l np nq">df.head()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/74fa2e84e8f853f62575d54f92005dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9b_O80W-D-ro_kXVOEww5g.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">标准化数据</figcaption></figure><p id="2869" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">对标准化分数执行k均值聚类。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="ba07" class="lu jz jb nj b gy nn no l np nq">model = cluster.KMeans(n_clusters=4, random_state=10)</span><span id="0985" class="lu jz jb nj b gy nr no l np nq">df['cluster'] = model.fit_predict(df[zcols])</span></pre><p id="0358" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">对数据执行PCA。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="8620" class="lu jz jb nj b gy nn no l np nq">pca = decomposition.PCA(n_components=2)</span><span id="dd5c" class="lu jz jb nj b gy nr no l np nq">df['pc1'], df['pc2'] = zip(*pca.fit_transform(df[zcols]))</span></pre><p id="5eb1" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在降维空间中绘制聚类图。</p><pre class="na nb nc nd gt ni nj nk nl aw nm bi"><span id="3b64" class="lu jz jb nj b gy nn no l np nq">colors = ['r', 'b', 'k', 'g']</span><span id="8ce2" class="lu jz jb nj b gy nr no l np nq">markers = ['^', 'o', 'd', 's']</span><span id="37ee" class="lu jz jb nj b gy nr no l np nq">for c in df['cluster'].unique():<br/>  d = df[df['cluster'] == c]</span><span id="f171" class="lu jz jb nj b gy nr no l np nq">  plt.scatter(d['pc1'], d['pc2'], marker=markers[c],    color=colors[c])</span><span id="73cf" class="lu jz jb nj b gy nr no l np nq">plt.show()</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a951531d2a237df25c745b09b99f5b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*6ND_cfdi9AeifDxN25dcZg.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">主成分分析绘图</figcaption></figure><p id="90f9" class="pw-post-body-paragraph kw kx jb ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在绘图中，x轴和y轴是主要部分，因此不容易解释。但是，通过可视化聚类，我们可以根据它们重叠的程度来了解聚类的好坏。</p><h1 id="5df9" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="6805" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">无监督机器学习是执行客户细分的优秀现代技术。K-means聚类，一种普遍使用的快速且易于扩展的聚类算法。数据处理的研究也是任何数据科学的重要组成部分。呈现高级分析和创建可视化以使处理过程易于理解是理解客户数据的一种极好的技术。Matplotlib和seaborn库是一个很好的创建可视化的库。当我们开发分析管道时，第一步是建立数据模型。数据模型是对我们将要处理的数据源、它们与其他数据源的关联、来自特定数据源的数据将进入管道的确切位置以及格式(例如，Excel文件、数据库或来自互联网数据源的JSON或REST API)的总结。随着时间的推移，随着数据源和方法的改变，管道的数据模型逐渐出现。传统上，营销数据包括所有三种类型的数据。最初，大多数数据点是从不同的(主要是手动的)数据源开始的，因此一个字段的值可能具有不同的长度，一个字段的值不会等同于其他字段的值，因为有不同的字段名称，一些从相同来源接收数据的行也可能有一些字段的值消失。但很快，由于技术的发展，结构化和半结构化数据变得高度可用，并经常被用于实施分析。如今数据有两种格式——结构化和非结构化。非结构化数据是流行的，不受模式限制。数据处理和争论是数据科学管道的开始，也是非常有价值的部分。如果数据工程师或数据科学家正在准备数据，以获得一些关于数据的领域知识，这通常是很重要的。数据处理也需要创新的解决方案和技术。如果数据工程师确信项目数据排列正确，它将与其他数据源相结合。他们还去掉了重复的和不需要的列，最后，去掉了丢失的数据。执行完这些步骤后，项目数据就可以进行分析和建模了，并且可以不可避免地放入数据科学管道中。</p></div></div>    
</body>
</html>