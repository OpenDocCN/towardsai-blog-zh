<html>
<head>
<title>LSTM for Time-series: Chaos in the AI Industry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列的LSTM:人工智能行业的混乱</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/lstm-for-time-series-chaos-in-the-ai-industry-63b8efc12696?source=collection_archive---------0-----------------------#2020-05-09">https://pub.towardsai.net/lstm-for-time-series-chaos-in-the-ai-industry-63b8efc12696?source=collection_archive---------0-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a685" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="da06" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为什么LSTMs如此难以编码？</h2></div><p id="5fac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">LSTM是预测时间序列最常用的神经网络之一。不幸的是，这种神经网络是复杂的(特别是数据准备)，不仅因为时间序列数据需要特定的结构来适应人工智能(如滑动窗口技术)，而且因为创建LSTM的关键步骤(数据准备、整形……)表达成完全取决于工程师习惯的路径变化。</p><p id="79be" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当我在互联网上搜索代码进行研究时，我总是发现很难将另一个程序员的代码合并到我的项目中。具体到LSTM，我认为导致更多麻烦的关键步骤是:</p><ul class=""><li id="f898" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">为LSTM准备数据集的顺序</li><li id="c8fa" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">我们选择哪种数据结构来存储数据集</li></ul><p id="5300" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">简单地说，因为对于两个关键步骤有多种方法可以达到相同的结果，所以另一个程序员选择的路径可能与我的不同。</p><p id="bc1c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我将阐明我的立场，即为什么有必要下定决心使用一组特定的范例，尤其是在编写乏味的LSTM时，这既是出于调试的原因，也是为了共享简化。</p><h1 id="76e0" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">LSTM的数据准备</h1><p id="f323" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">本质上，当我们为模型准备时间序列数据时，这些关键步骤可以互换:</p><ul class=""><li id="3850" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">按时间分割数据集</li><li id="98d1" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">将数据集转换为监督学习问题</li></ul><p id="4176" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不幸的是，程序员还没有想出一个精确的顺序。一部分程序员首先拆分数据集。然后他们将其转化为监督学习问题。剩下的程序员颠倒顺序:</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi my"><img src="../Images/a0580f93da4bbf0b8ebadf55c9f132c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWV5di47tDRzPa7ThsKlhQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在拆分之前，然后转换为监督学习问题</figcaption></figure><p id="7f99" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面那个是我比较喜欢的范式。需要的编码更少，并且我在库中收集的所有算法都遵循相同的结构。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi no"><img src="../Images/57385dcfaf907bee7de8f96c9fb3b475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_laxdEau52-2M9RPo4Ksw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在转换到监督学习问题之前，然后拆分</figcaption></figure><p id="82cf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">甚至上面的结构也是可能的，但是我的算法需要一些编辑，我不能仅仅颠倒几行代码来获得相同的结果:</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/529bde99d696fdba862c2b452eac6000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7A7wyCL4XIEFk-Sw-Pxgg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">决赛成绩</figcaption></figure><p id="dd02" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如我们所看到的，两种方法导致相同的结果。但是我们都意识到，当程序员使用他们独特的方法来解决一个与程序员社区共享的问题时，在共享或发布代码时绝对是混乱的。</p><h1 id="e65a" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">数据结构</h1><p id="ffc3" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">在我们决定了为LSTM准备数据的正确顺序之后，我们需要选择我们将使用的数据结构。我发现世界分为三类:</p><ul class=""><li id="b7b0" class="ln lo it kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">那些喜欢NumPy数组的</li><li id="e41c" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">喜欢熊猫数据框的</li><li id="7a4a" class="ln lo it kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">那些喜欢列表的人</li></ul><h1 id="1598" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">熊猫数据框</h1><p id="3dd3" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">我属于第二类:我相信pandas是一个舒适可靠的图书馆，可以有序地保存数据。每当我们为人工智能编写代码时，我们应该总是能够在过程的任何一步检查我们的数据，以便于调试。</p><p id="d341" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">用简单的一行代码:</p><pre class="mz na nb nc gt nq nr ns nt aw nu bi"><span id="cf61" class="nv mc it nr b gy nw nx l ny nz">df.head()</span></pre><p id="6d97" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以立即检查数据的状态。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oa"><img src="../Images/895a612134a486ffbaea6c60474a86f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5Graw8-zYcNE9EHk9gKSg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">一个用熊猫形象化的谷歌股票的例子。</figcaption></figure><p id="69db" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">每当我写一个人工智能的时候，我总是尽我最大的努力在代码的每一步把数据保持在熊猫数据帧的形式。简单地说，每当出现问题时，我都想看一看数据，以检查是否有任何可见的错误。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0ba7f177608dffab6609663d52c869f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*GTxzDud8F2iNj2KcnWjYQA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">熊猫数据框架作为监督学习问题的一个例子</figcaption></figure><p id="4145" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然而，如果我们使用一个不可理解的多维列表，将很难看到我们正在做什么。</p><h1 id="3879" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">Numpy数组</h1><p id="0bc0" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">所有数据集迟早都会被转换成NumPy数组，以便进行编辑或缩放。例如，如果我们希望在0和1之间缩放数据集，我们可以使用一个名为MinMaxScaler的工具，该工具需要数据集作为值。</p><pre class="mz na nb nc gt nq nr ns nt aw nu bi"><span id="96d3" class="nv mc it nr b gy nw nx l ny nz">from sklearn.preprocessing import MinMaxScaler</span><span id="f553" class="nv mc it nr b gy oc nx l ny nz">#df is pandas DataFrame<br/>#conversion to numpy array<br/>df = df.Values<br/>scaler = MinMaxScaler(feature_range=(0, 1))<br/>scaled_values = scaler.fit_transform(df)</span></pre><p id="ceff" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">将整个数据集作为NumPy数组的问题是，您无法详细了解其中的内容。您看不到命名列下的数据。当您将数据集转换为监督学习问题时，这变得非常重要。</p><p id="cc73" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">幸运的是，您可以轻松地从NumPy数组切换回DataFrame，但是拆分方法完全不同。您可以通过形状直接编辑数据集，但这并不会使它更有利于调试。</p><h1 id="f2ad" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">列表</h1><p id="8e13" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">将数据集的内容存储在多维列表中是荒谬的。就在几天前，我在Kaggle上发布的代码中目睹了这一点:</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi od"><img src="../Images/37fb5878e5193c15af50c420d879c5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*7A7aQQeYtVXP6oZC6mML0g.png"/></div></figure><p id="fa19" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面的示例说明了如何使用形状列表存储每天有四个参数的时间序列:</p><pre class="mz na nb nc gt nq nr ns nt aw nu bi"><span id="a44f" class="nv mc it nr b gy nw nx l ny nz">(52, 7, 4)</span></pre><p id="04bd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">确切地说，告诉我，你将如何查看数据内部，并用相似的结构按名称组织所有的列？</p><h1 id="4aee" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">最后但并不是最不重要的</h1><p id="3845" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">这个问题不仅限于LSTM，但我遇到的次数更多了。至少在我看来，你不能一个接一个地调用一系列函数。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oe"><img src="../Images/d25fe10eb6d6d6170f4a75c12292fd7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KolU53fjbYnOuM7BHZqJkQ.png"/></div></div></figure><p id="c5f5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我可以向你保证。代码可能看起来短小精悍，但是查找错误绝对是个问题。在函数声明期间，输入的名称可能会改变，当您想要检查隐藏在代码中的变量的值或输出时，您不能简单地在最后调用它，您必须提取它及其所有以前的代码。那会很不舒服。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi of"><img src="../Images/c584527497ad1b91e113e3bd9adb9882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdumJGHy8DKehVFjikCNqQ.png"/></div></div></figure><p id="cd5b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是我喜欢的构建代码的方式。有几行代码一个接一个地调用不同的函数，而不是只有一行。这看起来更费时间，但是我可以很容易地检查每个函数的输出，而不会发疯，而且我可以用一种更容易的方式隔离每个函数中的变量。</p><h1 id="a134" class="mb mc it bd md me mf mg mh mi mj mk ml ki mm kj mn kl mo km mp ko mq kp mr ms bi translated">谈到LSTMs</h1><p id="3086" class="pw-post-body-paragraph kr ks it kt b ku mt kd kw kx mu kg kz la mv lc ld le mw lg lh li mx lk ll lm im bi translated">你还有什么要补充的吗？</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="0888" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由<a class="ae on" href="https://towardsai.net/" rel="noopener ugc nofollow" target="_blank">向艾</a>发布</p></div></div>    
</body>
</html>