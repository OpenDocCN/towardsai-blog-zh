<html>
<head>
<title>5 Tricky SQL Queries Solved — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决了5个棘手的SQL查询—第二部分</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/5-tricky-sql-queries-solved-part-ii-8acceec170b0?source=collection_archive---------0-----------------------#2020-11-25">https://pub.towardsai.net/5-tricky-sql-queries-solved-part-ii-8acceec170b0?source=collection_archive---------0-----------------------#2020-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="915d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="4c92" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">是时候提高标准了。让我们尝试解决更复杂的SQL查询。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4f9e4939e70a578344cf26134a9478df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWPTwnLBSgrKVb3uqAvdvw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">micha Parzuchowski在<a class="ae lh" href="https://unsplash.com/s/photos/tricky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8b67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">“庆祝你所取得的成就，但是每一次成功都要把标准提高一点”——【米娅·哈姆】</em></p><p id="989d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我的上一篇文章<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/5-tricky-sql-queries-solved-919266e2d524" rel="noopener">解决了5个棘手的SQL查询</a>中，我解释了解决一些复杂查询的方法。在收到一个不错的回应后，我决定<strong class="lk jd">提高标准，</strong>通过描述我解决一些更复杂的问题的方法，这些问题更实际，也更有挑战性。</p><blockquote class="mf mg mh"><p id="331a" class="li lj me lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd">注— </strong>每个问题都有可能用各种方式解决。在讨论我的解决方案之前，试着想想策略。在回答部分，你也可以建议不同的方法。</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="de43" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询1</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/9b9829e58eee0c6cc531c4df5de0fb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bajKYubJNm1t8JW6ZDU_A.png"/></div></div></figure><p id="1bb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有两张桌子。<br/> <strong class="lk jd">账户</strong>表——该表的每一行包含银行中每个用户的账号和姓名。<br/> <strong class="lk jd">交易</strong>表—该表的每一行包含所有账户的交易。如果用户收到钱，金额为正；如果用户转账，金额为负。所有账户的初始余额都是零。</p><p id="56b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要编写一个SQL查询来返回余额<em class="me">大于</em>10，000的所有用户的<strong class="lk jd">名称</strong>和<strong class="lk jd">余额</strong>。<br/>余额=收款总额-转账总额</p><h2 id="5c83" class="nl mt it bd mu nm nn dn my no np dp nc lr nq nr ne lv ns nt ng lz nu nv ni iz bi translated">我的解决方案</h2><p id="9836" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">首先，我们需要连接两个表。因为我们需要找到每个账户的余额，所以我们可以在<code class="fe ob oc od oe b">Account ID</code>列上使用<code class="fe ob oc od oe b">GROUP BY</code>子句。我们可以找到按<code class="fe ob oc od oe b">Account ID</code>分组的金额列的<strong class="lk jd">总和</strong>，并过滤总和&gt;为10000的行。</p><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="c9cc" class="nl mt it oe b gy oj ok l ol om">SELECT    <br/>a.name AS name,    <br/>sum(b.amount) AS balance<br/>FROM Users AS a JOIN Transactions AS b<br/>on a.account = b.account<br/>GROUP BY    a.account<br/>HAVING balance &gt; 10000;</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7419" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询2</h1><p id="8e68" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">给定一个学生及其GRE考试分数的表，编写一个查询来返回两个学生，他们的<em class="me">考试分数与</em>考试分数最接近，而他们的<strong class="lk jd">考试分数与</strong>考试分数有差异。如果存在多个对，<em class="me">将它们的名字按升序排序</em>，然后返回第一个<em class="me">对</em>对。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7e207fcb22cfb4a3084cb97d93546ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*NKjJsNd6zsg2i9lidF7QZA.png"/></div></figure><h2 id="9a37" class="nl mt it bd mu nm nn dn my no np dp nc lr nq nr ne lv ns nt ng lz nu nv ni iz bi translated">我的解决方案</h2><p id="0fb2" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">这需要SQL中的一些<em class="me">创造性思维</em>。因为只有一个包含两列的表，所以我们需要自引用同一个表的不同创建。我们可以通过可视化两个具有相同值的表来解决这类问题。</p><p id="60f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们有两份相同的上述得分表，分别命名为s1和s2。因为我们需要比较每个学生和其他学生。我们可以通过设置来执行内部连接:</p><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="b9dd" class="nl mt it oe b gy oj ok l ol om">scores <strong class="oe jd">AS</strong> s1 <strong class="oe jd">INNER JOIN</strong> scores <strong class="oe jd">AS</strong> s2<br/> <strong class="oe jd">ON</strong> s1.ID != s2.ID</span></pre><p id="38dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我们可以将每个学生与其他学生进行比较，同时避免将学生与自己进行比较。但是，如果我们使用上面的连接条件运行最终查询，请观察输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/354769e2ffecdc6cc4e4fd37235d21e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*CNoJ-Pi9TXBWQGQXN788LQ.png"/></div></figure><p id="df1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们将s1中的每个学生与s2中的每个其他学生进行比较，<strong class="lk jd">重复</strong>正在发生。如果存在一百万行，我们的查询将是低效的。为了<em class="me">优化</em>，查询让我们添加一个条件<strong class="lk jd"> s1.id &gt; s2.id </strong>以确保比较只发生一次。</p><p id="7f69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们现在需要做的就是从每个得分中减去每个得分，并使用<strong class="lk jd"> ORDER BY </strong>子句对这个差异进行升序排序。由于我们需要最接近的分数，我们将使用<strong class="lk jd"> LIMIT </strong>子句只打印第一行。</p><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="026f" class="nl mt it oe b gy oj ok l ol om">SELECT <br/>    s1.name AS s1_name<br/>    , s2.name AS s2_name<br/>    , ABS(s1.score - s2.score) AS score_diff<br/>FROM scores AS s1<br/>INNER JOIN scores AS s2<br/>    ON s1.id != s2.id<br/>        AND s1.id &gt; s2.id<br/>ORDER BY score_diff ASC, s1_name ASC<br/>LIMIT 1</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9391" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询3</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/d1526dfa46245b16ee6fc088e1460046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IR5NLr__CFluGRuzTH9CQ.png"/></div></div></figure><p id="f510" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">给定上述两个员工和部门表，选择<em class="me">最高</em>部门，该部门由工资<em class="me">超过</em> 1500且<em class="me">至少有2名</em>员工的<em class="me">最高百分比</em>的员工组成。</p><h2 id="ef7c" class="nl mt it bd mu nm nn dn my no np dp nc lr nq nr ne lv ns nt ng lz nu nv ni iz bi translated">我的解决方案</h2><p id="3897" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">我们可以把给定的问题分解成独立的分句。<br/> 1)顶级部门。年薪超过1500英镑的雇员的百分比。3)部门必须至少有2名员工。</p><p id="86bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在解决上述子句之前，让我们有一个两个表的组合表示，其中每个雇员都与他们的部门名称相关联。由于两个表有一个公共列<code class="fe ob oc od oe b">department_id</code>,我们可以使用</p><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="2ae4" class="nl mt it oe b gy oj ok l ol om">employees <strong class="oe jd">AS</strong> e <strong class="oe jd">INNER</strong> <strong class="oe jd">JOIN</strong> departments <strong class="oe jd">AS</strong> d<br/><strong class="oe jd">ON</strong> e.department_id = d.id</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ba2fce49f7c39f726337b4ef0d838fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*kClJjtYPhx7DE8dIq2tGBQ.png"/></div></figure><p id="e57a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们有了完整的表示，我们可以开始过滤、聚合以获得我们的输出。我们知道，我们需要计算每个部门收入超过1500英镑的员工总数。我们可以在dept_name上使用<strong class="lk jd"> GROUP BY </strong>子句，因为我们需要每个部门一行。</p><p id="3dbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要找到收入超过1500的人的百分比，我们可以使用— <br/> <em class="me">(收入超过1500的人数)/(该部门的总人数)</em></p><p id="d6b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们需要计算雇员id的数量，以过滤拥有2名以上雇员的部门。</p><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="25d7" class="nl mt it oe b gy oj ok l ol om"><strong class="oe jd">SELECT</strong> <br/>       d.Dept_Name <strong class="oe jd">AS</strong> d_name, <br/>      <strong class="oe jd">SUM</strong>(<strong class="oe jd">CASE WHEN</strong> e.salary &gt; 1500 <strong class="oe jd">THEN</strong> 1 <strong class="oe jd">ELSE</strong> 0 <strong class="oe jd">END</strong>)/<strong class="oe jd">COUNT</strong>(<strong class="oe jd">DISTINCT</strong> e.id) AS pct_above_1500,<br/>      <strong class="oe jd">COUNT</strong>(<strong class="oe jd">DISTINCT</strong> e.id) AS number_of_employees<br/><strong class="oe jd">FROM</strong> employees e <strong class="oe jd">JOIN</strong> departments d <strong class="oe jd">ON</strong> e.dept_id = d.dept_id<br/><strong class="oe jd">GROUP BY</strong> d_name<br/><strong class="oe jd">HAVING</strong> number_of_employees &gt;= 2<br/><strong class="oe jd">ORDER BY</strong> pct_above_1500 <strong class="oe jd">DESC</strong><br/><strong class="oe jd">LIMIT</strong> 1</span></pre><p id="c32b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用<strong class="lk jd"> SUM </strong>和<strong class="lk jd"> CASE </strong>子句来查找工资高于1500的雇员人数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/7be80b6db5f10836956032844ad1d08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnM4nOF-0agr45LrKtulHg.png"/></div></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="f270" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">查询4</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5120a3fd47a60ed9550f9e2bc3fa75d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*ZK2Kw51nGf_79BoDIJzqrQ.png"/></div></figure><p id="6f0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上表中，我们得到了id的分数。我们需要编写一个SQL查询来输出这些分数的<strong class="lk jd">排名</strong>。在分数相等的情况下，相同的等级必须分配给两个分数。</p><h2 id="5a57" class="nl mt it bd mu nm nn dn my no np dp nc lr nq nr ne lv ns nt ng lz nu nv ni iz bi translated"><strong class="ak">我的解决方案</strong></h2><p id="9f37" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">首先，让我们分离不同的分数，并创建输入表的另一个副本。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/cfaab0c69b462c5d49b59e195eac88f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*XhxCnbuGpJFCiXhRTxkx9g.png"/></div></figure><p id="2994" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于S: Scores表中的每个分数<strong class="lk jd">来说，我们想要找出S2:Scores表中大于或等于的分数的数量。我们可以按ID分组，比较分数。</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c5d5f261d4443fb650553ac517df67a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*elve6HItqw4lUsa71YlKzQ.png"/></div></figure><p id="1a55" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是那个特定分数的排名！</p><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="80b8" class="nl mt it oe b gy oj ok l ol om">SELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,<br/>(SELECT DISTINCT Score FROM Scores) AS S2<br/>WHERE S.Score&lt;=S2.Score<br/>GROUP BY S.Id <br/>ORDER BY S.Score DESC;</span></pre><h1 id="d726" class="ms mt it bd mu mv ov mx my mz ow nb nc ki ox kj ne kl oy km ng ko oz kp ni nj bi translated">查询5</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/301dd6f5fbd5c35c33fa1d0e85e2e434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*q7Ahv8fG_ROPm4mlmJAV3w.png"/></div></figure><p id="9192" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上表由访问者ID、访问者日期和特定日期的访问者数量组成。不存在两个相同的日期。编写一个SQL查询来显示三个或更多连续的<strong class="lk jd">ID，让大于或等于100的访问者按他们的访问日期排序。id将是连续的和唯一的。<br/>您可能会认为ID 2和3也有超过100个访问者，并且没有显示在输出中。主要条件是在此展示3个或3个以上访客超过100的id。因此，显示5，6，7，8。</strong></p><h2 id="ee37" class="nl mt it bd mu nm nn dn my no np dp nc lr nq nr ne lv ns nt ng lz nu nv ni iz bi translated">我的解决方案</h2><p id="9534" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">我发现这个问题很棘手，正如本文的标题所示:)类似于查询2，我们需要在stadium表上创建一个自连接。我们可以比较id并计算我们的结果。给定的行s1可以是3个连续行中的第一行、中间行或最后一行。</p><ul class=""><li id="2a3c" class="pa pb it lk b ll lm lo lp lr pc lv pd lz pe md pf pg ph pi bi translated">开头的S1:(S1 . id+1 = S2 . id和s1.id + 2 = s3.id)</li><li id="0b3a" class="pa pb it lk b ll pj lo pk lr pl lv pm lz pn md pf pg ph pi bi translated">中间的S1:(S1 . id—1 = S2 . id和s1.id + 1 = s3.id)</li><li id="66b8" class="pa pb it lk b ll pj lo pk lr pl lv pm lz pn md pf pg ph pi bi translated">最后的S1:(S1 . id—2 = S2 . id和s1.id — 1 = s3.id)</li></ul><pre class="ks kt ku kv gt of oe og oh aw oi bi"><span id="53ee" class="nl mt it oe b gy oj ok l ol om">SELECT s1.* FROM stadium AS s1, stadium AS s2, stadium as s3<br/>    WHERE <br/>    ((s1.id + 1 = s2.id<br/>    AND s1.id + 2 = s3.id)<br/>    OR <br/>    (s1.id - 1 = s2.id<br/>    AND s1.id + 1 = s3.id)<br/>    OR<br/>    (s1.id - 2 = s2.id<br/>    AND s1.id - 1 = s3.id)<br/>    )<br/>    AND s1.people&gt;=100 <br/>    AND s2.people&gt;=100<br/>    AND s3.people&gt;=100</span><span id="264e" class="nl mt it oe b gy po ok l ol om">GROUP BY s1.id<br/>ORDER BY s1.visit_date</span></pre><p id="1adb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一定要看这个无声视频，以便清楚地了解。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pp pq l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="6463" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">结论</h1><p id="4cee" class="pw-post-body-paragraph li lj it lk b ll nw kd ln lo nx kg lq lr ny lt lu lv nz lx ly lz oa mb mc md im bi translated">掌握SQL需要时间和练习。我在这篇文章中提出了五个更具挑战性的问题，并解释了解决它们的方法。SQL的特殊之处在于可以用许多不同的方式编写每个查询。欢迎在回答中分享你的策略。我希望今天你学到了新的东西！<br/>如果您想联系，<strong class="lk jd">请在</strong><a class="ae lh" href="https://www.linkedin.com/in/saiteja-kura-49803b13b/" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">LinkedIn</strong></a><strong class="lk jd">上联系我。</strong></p></div></div>    
</body>
</html>