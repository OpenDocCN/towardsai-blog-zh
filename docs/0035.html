<html>
<head>
<title>Calculating the Backpropagation of a Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算网络的反向传播</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/calculating-back-propagation-of-a-network-1febbcaa2b5d?source=collection_archive---------0-----------------------#2019-05-02">https://pub.towardsai.net/calculating-back-propagation-of-a-network-1febbcaa2b5d?source=collection_archive---------0-----------------------#2019-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a370" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">在数学中推动反向传播算法| <a class="ae ep" href="https://pub.towardsai.net" rel="noopener ugc nofollow" target="_blank">朝向人工智能</a></h2><div class=""/><div class=""><h2 id="da0b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">反向传播背后的数学初学者指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/30d52444b3824dc35abdc9f42cde31ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*JAUV1Qf_Ip5IxUdbhwjVGA.png"/></div></figure><p id="73b7" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器学习已经成为许多程序员和公司研究和利用的热门话题。尽管有各种各样的框架和工具来帮助开发你自己的网络，但它最终是一个黑匣子，我们在那里发送数据，它生成所需的输出；假设您尝试了各种网络架构。</p><p id="a667" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你和我一样，很想知道黑匣子里有什么；特别是反向传播以及它如何影响网络，我希望这篇文章能帮助你更好地理解它。</p><h1 id="c221" class="lv lw it bd lx ly lz ma mb mc md me mf ki mg kj mh kl mi km mj ko mk kp ml mm bi translated"><strong class="ak">我们为什么需要这样做？</strong></h1><p id="4801" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在训练网络时，您可以不断改变变量，并执行前向传播，直到您获得所需的输出。但是这个过程会很耗时，除非你第一次运气好。另一种方法是使用反向传播来确定向最优解变化的方向和幅度。这个过程给了你一个解决问题的正确方法。所以为了得到一个清晰的画面，让我们看看下面的过程。</p><h2 id="4061" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml iz bi translated"><strong class="ak">训练的一般流程</strong></h2><ol class=""><li id="a91e" class="nd ne it lb b lc mn lf mo li nf lm ng lq nh lu ni nj nk nl bi translated">初始化网络中的权重。</li><li id="d2c4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">计算成本函数(又名损失函数)</li><li id="dcba" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">找到各层的梯度。</li><li id="3887" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">这些计算出的梯度用于更新网络的权重。</li><li id="613c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">重复该过程，直到它满足结束标准。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a4ca231844c1504047a0cde660ce9531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*yWNm66xPyKJ5xrCageOs3Q.png"/></div></figure><p id="d9f6" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，梯度用于确定成本函数相对于特定变量的变化。这将用于使用如下函数更新权重:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/109752ad0e5557e1ebcd17d6220e0107.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*Ucfo9fh__McMXhpVoaSQ6A.png"/></div></figure><p id="e5c7" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更深入地研究这个过程的第3步，让我们以一个简单的网络为例，它有一个隐藏节点和两个激活函数。</p><h2 id="9481" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml iz bi translated"><strong class="ak">样本网络</strong></h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9cc949244e5aabff62e892212515dd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*mZNm-tX1HMXBTn6UuM89rw.png"/></div></figure><p id="f969" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了清楚起见，我现在描述一下每个变量指的是什么。</p><blockquote class="nt nu nv"><p id="d99f" class="kz la nw lb b lc ld kd le lf lg kg lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">w是从输入到隐藏单元的权重</p><p id="ce53" class="kz la nw lb b lc ld kd le lf lg kg lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">h是隐藏单元的输出</p><p id="a6ba" class="kz la nw lb b lc ld kd le lf lg kg lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">h是通过第一个激活函数后隐藏单元的输出</p><p id="3348" class="kz la nw lb b lc ld kd le lf lg kg lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">v是从隐藏到输出单位的权重</p><p id="fa20" class="kz la nw lb b lc ld kd le lf lg kg lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">y是隐藏单元的计算输出</p><p id="5761" class="kz la nw lb b lc ld kd le lf lg kg lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">y是通过第二激活功能后最终输出单元的输出</p></blockquote><p id="a732" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[注:通常，重量表示为Wij，i &amp; j表示层数。这里，我给出了一个单独的变量名，以帮助理解清楚]</p><p id="de27" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当训练网络时，成本函数被用作在更新权重之前确定网络表现如何的度量。因此，成本函数通常在网络末端计算。在这种情况下，它将是来自第二激活层的输出的函数。让我们指定，L为成本函数。</p><p id="5d6c" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化，我将设置一些简单的功能描述。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/02e0c091428db56a3bbdeab8de05eb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*wvhogl4GMWIalN5mxezK0w.png"/></div></div></figure><p id="33ce" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">A1和A2是一些激活功能。</p><p id="586a" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们的网络中，我们总共可以识别4个梯度；即网络可以操纵的每个变量一个。它们是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a3ab85d2dc35e0b05b99ec72c520eea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*pWHyrJ4BeLYOCtYIU8KWTA.png"/></div></figure><h1 id="0072" class="lv lw it bd lx ly lz ma mb mc md me mf ki mg kj mh kl mi km mj ko mk kp ml mm bi translated"><strong class="ak">回答大问题。</strong></h1><p id="8d6f" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是反向传播数学的起点。当我开始研究这个问题的时候，当我开始我的机器学习之旅的时候，我确实获得了很多可以学习的材料。但这让我比以前更困惑了。所以，我筛选出你需要理解的要点，相信我，你需要的只是基本的微积分知识来理解它。让我们从相对于v的梯度开始。</p><h2 id="b8ba" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml iz bi translated">第一步:识别衍生品</h2><p id="5d64" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从网络结构中，我们可以观察到变量经过两个计算阶段，即y &amp; Y。对于这种简单的网络，我建议将成本函数追溯到变量v。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c4cac62c1ccb639e4e987cba7e49f2b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*4nsFPp_GD45o6pZ0ieN4ow.png"/></div></figure><p id="c18d" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道Y是函数Y输出的后续函数，Y处理直接利用V进行计算的函数。因此，通过偏导数和链式法则方法，我们的第一梯度如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/40d8bef56b873af5cb951c46722aea6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/format:webp/1*ZgQHqT7JSKEehOJlCH0svw.png"/></div></figure><h2 id="bcd4" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml iz bi translated">第二步:计算单个导数</h2><p id="1bc0" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，看看幂偏导数。</p><p id="93f8" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的就是找到三个函数的三个不同的微分，然后把它们相乘。不用复杂的多元微分方程，我们可以用微分的基本知识来求解。</p><p id="e66c" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb jd">衍生1 </strong></p><p id="c408" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们将成本函数L设置为多个函数的交叉熵损失:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/8efe7e9a79c6bc6617fce522a3293829.png" data-original-src="https://miro.medium.com/v2/resize:fit:212/format:webp/1*NWD7qzNFgdtCndgkca2Pcg.png"/></div></figure><p id="40b5" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个偏微分会是，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/704a34ff6c8bef89837b81c23c1735c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:162/format:webp/1*qZbdsYARQ1FzYQ2UsqxVBQ.png"/></div></figure><p id="e113" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb jd">衍生2 </strong></p><p id="67eb" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于y相对于V:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/061957aeaab1d52ee780949d54d223c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:152/format:webp/1*1azXtbu0D-cHquQWp_f_ag.png"/></div></figure><p id="843b" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb jd">导数3 </strong></p><p id="2cd5" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们还没有设置激活函数，我们假设A2是一个SoftMax函数。因此，新的等式将是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/98137192bdc487a1bd8929866ddd14f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*J82oqztHk5lI25Ga10pGSw.png"/></div></figure><p id="3d95" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可以自己计算微分或者使用互联网，因为有许多数学家已经解决了这个问题。</p><p id="f157" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，softmax函数的<a class="ae om" href="https://ljvmiranda921.github.io/notebook/2017/08/13/softmax-and-the-negative-log-likelihood/" rel="noopener ugc nofollow" target="_blank">导数为:</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/b49f420e470705ab02eb7364d0f9dca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/format:webp/1*7N9WRkkcuk3yNQctI6yoEg.png"/></div></figure><h2 id="ba49" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml iz bi translated">步骤3:计算最终梯度</h2><p id="2406" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了单独的导数，我们只需要乘以比就可以得到答案。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/da1aca7ce38ea3dc5c47cc9d264fc7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*VPVnM6voDLDL_S0QgXk90A.png"/></div></figure><h2 id="8d79" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml iz bi translated">步骤4:更新权重</h2><p id="1cde" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">更新权重的最后一步是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e272f15d31e132cab9999850bbefe791.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*RGOtuMao4Rt4UgCjFhyjgA.png"/></div></figure><p id="dc53" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个变量的结尾。</p><h1 id="80f5" class="lv lw it bd lx ly lz ma mb mc md me mf ki mg kj mh kl mi km mj ko mk kp ml mm bi translated"><strong class="ak">计算其他梯度</strong></h1><p id="70c3" class="pw-post-body-paragraph kz la it lb b lc mn kd le lf mo kg lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">用类似的方法，我们也可以计算输出节点的偏置梯度。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/3c650c03523e3d77f182599437074144.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*9L1cVQQz9TXjpYKS9PEsZA.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/fffdc664f8a9e0e1c19ba3b76fd3d466.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*r-USP0ia_Fni6IJGY7wmPw.png"/></div></figure><p id="b12e" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，输入和隐藏节点之间的权重，可以观察到它通过了权重V，但和以前一样，我们只采用数学函数，这将有助于我们追溯。因此，对于相对于W的梯度，我们将得到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/4fe7ec39b6bde4fbf7ce71b64bf05961.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*1ivMtvlLeGGC1zH3Lyv2WQ.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2104f03a938040baa16d09b56272ab95.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*kIud4TOjy2MTcRSM6cI3DQ.png"/></div></figure><p id="e9fc" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个，我希望你有清晰的计算自己的梯度，如果你觉得有点冒险写自己的过滤器或网络。</p></div></div>    
</body>
</html>