<html>
<head>
<title>How You Should Save the Output of your Spark ETL Jobs (If you are not Writing to a Database)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该如何保存Spark ETL作业的输出(如果没有写入数据库)</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-you-should-save-the-output-of-your-spark-etl-jobs-if-you-are-not-writing-to-a-database-c95a113eef1?source=collection_archive---------0-----------------------#2019-09-25">https://pub.towardsai.net/how-you-should-save-the-output-of-your-spark-etl-jobs-if-you-are-not-writing-to-a-database-c95a113eef1?source=collection_archive---------0-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="eda6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">将Spark ETL作业的输出| <a class="ae ep" href="https://towardsai.net" rel="noopener ugc nofollow" target="_blank">保存到AI </a></h2><div class=""/><h1 id="0535" class="jz ka it bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="4148" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将分享我对保存Spark ETL作业输出的最佳方式的想法，以便以后更容易进行分析工作。<strong class="kz jd"> </strong>代码重现的例子可以在<a class="ae lv" href="https://github.com/hsm207/blog-spark-save-files" rel="noopener ugc nofollow" target="_blank">这里找到</a>。</p><h1 id="7121" class="jz ka it bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">集群设置</h1><p id="fc42" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在本文中用来运行代码的集群托管在Databricks上，配置如下:</p><ul class=""><li id="7b78" class="lw lx it kz b la ly le lz li ma lm mb lq mc lu md me mf mg bi translated">集群模式:标准</li><li id="6750" class="lw lx it kz b la mh le mi li mj lm mk lq ml lu md me mf mg bi translated">Databricks运行时版本:5.5 LTS ML(包括Apache Spark 2.4.3 Scala 2.11)</li></ul><p id="41b4" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">有8个工作线程，工作线程和驱动程序都是M4 . XL大型实例(16.0 GB，4个内核)。</p><h1 id="0650" class="jz ka it bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">个案研究</h1><p id="afd5" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象你在下面的场景中:</p><blockquote class="mp mq mr"><p id="f389" class="kx ky ms kz b la ly lc ld le lz lg lh mt mm lk ll mu mn lo lp mv mo ls lt lu im bi translated">您刚刚加入了一家广受欢迎的在线零售商，其客户遍布全球。这家公司每年创造数十亿美元的收入。因此，您知道它每天生成如此多的事务性数据，只有使用像Apache Spark这样的分布式计算框架才能有效地处理这些数据。您的任务是建立一个模型来预测每日营业额，并决定从对过去的交易进行一些探索性的数据分析开始。</p><p id="9f5a" class="kx ky ms kz b la ly lc ld le lz lg lh mt mm lk ll mu mn lo lp mv mo ls lt lu im bi translated">数据工程团队友好地同意让您以平面文件的形式访问这些数据，这些文件被转储到位于云中的某个文件夹中。该团队非常注重客户满意度，因此他们更进一步，询问您希望如何组织该文件夹中的文件。</p><p id="cd2f" class="kx ky ms kz b la ly lc ld le lz lg lh mt mm lk ll mu mn lo lp mv mo ls lt lu im bi translated">你将如何回应？</p></blockquote><p id="f7b8" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">一种常见的布局是将文件组织到具有3个层次的文件夹中，即“年”、“月”和“日”。“日”文件夹将包含与当天交易相关的文件。</p><p id="25e9" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">下一节将说明为什么这种布局不是数据分析的最佳选择。</p><h1 id="3099" class="jz ka it bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">按年-&gt;月-&gt;日保存</h1><p id="d781" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更具体，我们将使用<code class="fe mw mx my mz b">asa/airlines</code>数据集作为本文剩余部分的运行示例。该数据集是Databricks的<a class="ae lv" href="https://docs.databricks.com/getting-started/databricks-datasets.html" rel="noopener ugc nofollow" target="_blank">公开可用数据集</a>的一部分。</p><p id="90c4" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">以下是该数据集在此布局方案下的外观:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/53cc7bfe350edff12a35d0401d68765a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA-xN6lV64y6mTf0Yfdj9A.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图1:2006年的目录结构</figcaption></figure><p id="934c" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">图1显示了一个名为“2006”的文件夹的目录结构，它表示2006年的所有事务。在这个文件夹中有另一组名为1，2，…，12的文件夹，代表一月，二月，…，十二月。这些文件夹又包含表示特定月份中某一天的文件夹。实际数据以包含多个相对较小的csv文件的另一个文件夹的形式存储在一个月中的某一天文件夹中，因为每天的数据非常大。</p><p id="ae82" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">现在假设您想知道2008年1月的交易数量。这可以通过下面的代码片段轻松实现:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/bd232fa30b8a1e04b8757ea00d064ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*-SL2Pm9cEy4SlCXmCPEZoQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图2:统计2008年1月的交易数量</figcaption></figure><p id="9932" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">请注意，使用通配符，即“*”符号可以轻松检索文件夹中的所有文件。</p><p id="0c6e" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">如果您想知道2008年1月前6个月的交易数量，该怎么办？将<code class="fe mw mx my mz b">/tmp/asa/folders/2008/*/*/*</code>作为调用<code class="fe mw mx my mz b">csv</code>的参数是行不通的，因为它将读取2008年的所有12个月。您可以读取所有这些文件，然后过滤它们，只显示相关月份，但是:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nr"><img src="../Images/db25160bcb0907e1ef289dd06c4c573a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxO0GmixVwlNQ6o0hgFIbQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图3:“真正过滤所有文件”和“只读取相关文件”方法的物理计划</figcaption></figure><p id="de3f" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">图3显示，读取所有12个月的数据，然后过滤以仅返回前6个月的数据，结果是读取670 MB的数据，而不是仅读取前6个月的343.2 MB。因此，前一种方法效率低，不可扩展，尤其是对于大型数据集。给定文件夹布局，我们将不得不编写一些代码，以编程方式构造相关文件的路径。有一种方法可以做到:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ns"><img src="../Images/f328591c5341785baf5577ac31be4ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEns-ybkvYdrhmybjSSEaw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图4:以编程方式构建相关文件路径的示例</figcaption></figure><p id="6cef" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">图4显示，在我们继续分析之前，我们只需要多写一行代码。</p><p id="ee4b" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">让我们考虑这样一种情况，我们希望对过去两年中每年最后7天的交易进行计数，即获得2007年和2008年12月25日至12月31日之间的交易计数。生成路径可能有点棘手，因为现在路径有两个不同的部分:年份和月份。您可以创建一个年和日的列表，然后做一个笛卡尔积来得到一个(年，日)元组，然后您可以用它来创建文件路径，如下所示:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c8b9f28b2763e721b5ac9e61fa94f4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*XunLcwNZSMHFvxGioGECEw.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图5:生成更复杂的文件路径</figcaption></figure><p id="a360" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">另一个解决方案是创建一个从2007年初到2008年底的日期列表，然后应用适当的过滤器。这比前一个解决方案更复杂，所以为了简洁起见，我在这里不做尝试。</p><p id="c627" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">无论如何，我不是这种文件读取方法的粉丝，原因如下:</p><ul class=""><li id="0ed7" class="lw lx it kz b la ly le lz li ma lm mb lq mc lu md me mf mg bi translated"><strong class="kz jd">冗长:</strong>在继续分析之前，您需要编写额外的代码。根据您的编码风格和习惯，生成文件路径的代码可能是晦涩的，这使得其他人很难理解您的分析。</li><li id="1300" class="lw lx it kz b la mh le mi li mj lm mk lq ml lu md me mf mg bi translated"><strong class="kz jd">脆性:</strong>这个方法隐含地假设一年中的每一天都有一个文件。由于许多原因，例如系统维护、系统故障、公共假日等，情况可能并非如此。当这种情况发生时，你会得到一个<code class="fe mw mx my mz b">Path does not exist</code>异常。</li></ul><p id="fcb6" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">我们能做得比这种方法更好吗？</p><h1 id="10ec" class="jz ka it bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">按分区保存</h1><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nu"><img src="../Images/bba452ba2af6caba912b5c133a1dd1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUMdSr2uPN_nH9qs1v9jNA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图6:组织文件的更好方式</figcaption></figure><p id="8beb" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">图6显示了为您的特定用例组织文件的理想方式。使用这种布局，您可以依靠Spark的<code class="fe mw mx my mz b">filter()</code>函数只检索您感兴趣的数据。例如，下面是计算2008年1月所有交易的方法:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nv"><img src="../Images/5f2e6389cd84f436f50421420dfcb91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idwrqAfnUvBXO4Hlhp7GoA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图7:统计2008年1月交易的更好方法</figcaption></figure><p id="e0aa" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">注意，您只需要定义一个谓词来表达您想要满足的条件(<code class="fe mw mx my mz b">Jan2008</code>)，然后将它传递给<code class="fe mw mx my mz b">filter</code>函数。</p><p id="e87a" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">接下来的两个数字显示了在这种目录布局下，如何分别计算2008年前6个月以及2007年和2008年最后7天的交易数量:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/bbb3dcfd5fe37760acff874683e7276e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*W8TsSbcDe8qE8SdpKa60xQ.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图8:统计2008年前6个月交易的更好方法</figcaption></figure><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nx"><img src="../Images/49f1e2dc9c1717b7fa9742cc1bb09729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3H3ZKBZSXFeEIKLK8Pv-A.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图9:统计2007年和2008年最后7天交易的更好方法</figcaption></figure><p id="db97" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">很明显，这种方法产生了可读性更好的代码。您也不需要担心遇到<code class="fe mw mx my mz b">Path does not exist</code>异常。</p><p id="8ad8" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">我们是如何实现这种目录布局的？请看下图:</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/372032068964c6bf0c90af8a7cbc5331.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*eYbZWyy7OX6Ta5N2ZTgqSA.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">图10:如何获得理想的目录布局</figcaption></figure><p id="6eaf" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">想象一下，您的数据工程团队在获得事务数据之前必须做一些复杂的预处理，例如将几个表连接在一起，添加一些派生的特性，等等。<code class="fe mw mx my mz b">df</code>代表最终可供您使用的数据。他们需要做的就是将它保存到指定的文件夹中。</p><p id="056a" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">实现图6所示布局的关键步骤是调用图10第5行中的<code class="fe mw mx my mz b">partitionBy</code>。图10的结果是创建一个名为<code class="fe mw mx my mz b">data.csv</code>的文件夹(保存为csv时我们指定的文件名)。您可以将<code class="fe mw mx my mz b">data.csv</code>视为一个大文件，它在内部被<code class="fe mw mx my mz b">Year</code>、<code class="fe mw mx my mz b">Month</code>和<code class="fe mw mx my mz b">DayOfMonth</code>列(即您在调用<code class="fe mw mx my mz b">partitionBy</code>时指定的列)中的值分解。</p><h1 id="67ea" class="jz ka it bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结束语</h1><p id="371d" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文向读者介绍了<code class="fe mw mx my mz b">partitionBy</code>函数，它是<a class="ae lv" href="http://spark.apache.org/docs/latest/api/scala/#org.apache.spark.sql.DataFrameWriter" rel="noopener ugc nofollow" target="_blank"> DataFrameWriter </a>类的一个方法。这里的关键思想是，当您编写ETL作业的输出时，您应该按照用户在进行分析之前经常过滤的列对其进行划分。这不仅大大加快了阅读时间，而且正如本文所示，用户不必编写复杂的代码来获取所需的数据。</p><p id="4a48" class="pw-post-body-paragraph kx ky it kz b la ly lc ld le lz lg lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">请在评论中告诉我你对这种方法的看法。</p></div></div>    
</body>
</html>