<html>
<head>
<title>Worst, Best, and Average Performance of Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法的最差、最佳和平均性能</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/worst-best-and-average-performance-of-algorithms-7535c43cee05?source=collection_archive---------2-----------------------#2022-11-09">https://pub.towardsai.net/worst-best-and-average-performance-of-algorithms-7535c43cee05?source=collection_archive---------2-----------------------#2022-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c893" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">算法给计算机一组特定的指令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8d715780a677ec8483ba7f26c4bc8bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k6GGz3UMVTG_TlWy"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="42b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经意识到，通过互联网或书籍，任何文本信息都可以在世界各地获得。在互联网的情况下，我们所要做的就是输入我们想要搜索的文本查询，瞧！似乎是。这些都是从计算机科学角度来看的字符串。搜索引擎使用许多算法来理解所有这些信息，使搜索更加有效。现在问题来了:<strong class="lb iu">什么是算法</strong>？</p><p id="b330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你们中有些人知道这个词，有些人不知道。算法是在计算或其他解决问题的操作中应该遵循的一组规则(<strong class="lb iu">或</strong>)，通常通过递归操作，在有限的步骤中解决数学问题的过程。</p><p id="d0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法分析的基础包括以下内容:</p><ol class=""><li id="e83f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">框架分析</li><li id="f43d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">输入大小的测量</li><li id="5aa1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">测量运行时间的单位。</li><li id="badf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最坏情况、最好情况和一般情况</li><li id="62cb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">渐近符号</li></ol><blockquote class="mj mk ml"><p id="847e" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">框架分析</em> </strong></p></blockquote><p id="17ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种效率-</p><ul class=""><li id="414a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mq mb mc md bi translated">时间效率表示给定算法的运行速度。</li><li id="9507" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">空间效率—处理算法所需的额外空间。</li></ul><blockquote class="mj mk ml"><p id="7ef7" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">输入尺寸的测量</em> </strong></p></blockquote><p id="b8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的效率是某个参数n的函数，该参数表示该算法的输入大小。在大多数情况下，这样一个参数的选择是非常简单的。例如，它将是排序问题、搜索、查找最小列表元素和大多数其他列表问题的列表大小。对于计算多项式p(x) = an x n +…和n次0的问题，这将是多项式的次数或其系数的数量，比其次数大1。在某些情况下，指示输入大小的参数的选择很重要。例如，计算两个n乘n矩阵的乘积。</p><p id="158b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的两个自然衡量标准是:</p><ol class=""><li id="3099" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">矩阵的顺序<strong class="lb iu"> <em class="mm"> n </em> </strong></li><li id="1d6a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">矩阵中要相乘的元素总数N。</li></ol><ul class=""><li id="016f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mq mb mc md bi translated">由于有一个简单的公式将这两个度量联系起来，我们可以很容易地从一个转换到另一个。但是关于算法有效性的答案将会有质的不同，这取决于我们使用两种度量中的哪一种。</li><li id="efb4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">适当度量大小的选择会受到算法操作的影响。例如，我们应该如何测量拼写检查算法的输入大小？如果一个算法检查其输入中的单个字符，我们应该通过字符的数量来衡量大小；如果它通过处理单词来工作，我们应该在输入中计算它们的数量。</li><li id="1e0d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">对于涉及数字属性的算法，应该特别注意测量输入的大小(例如，检查给定的整数n是否是质数)。</li><li id="9b03" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">计算机专家更喜欢用n的二进制表示中的b位数来衡量大小:</li></ul><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="3662" class="mw mx it ms b gy my mz l na nb"><strong class="ms iu">by b=|log2n|+1</strong></span></pre><p id="a65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种度量通常能更好地反映相应算法的效率。</p><blockquote class="mj mk ml"><p id="c9cd" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">测量运行时间的单位</em> </strong></p></blockquote><ul class=""><li id="c284" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mq mb mc md bi translated">为了测量实现算法的程序的运行时间，我们可以简单地使用一些标准的时间单位——一秒、一毫秒等等。这种方法有明显的缺点。</li><li id="6fba" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">依赖于特定计算机的速度。</li><li id="c484" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">这依赖于程序中实现的算法的质量。</li><li id="fdd6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">编译器用于生成机器码。</li><li id="da01" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">很难测量程序的实际运行时间。既然需要衡量算法效率，就应该有一个不依赖于这些外部因素的度量。一种可能的方法是计算每个算法操作已经执行的次数。这种方法既困难又不必要。</li></ul><p id="5b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要目标是确定算法中最重要的操作(称为基本操作，对总运行时间贡献最大的操作),并计算基本操作的执行次数。</p><blockquote class="mj mk ml"><p id="9e5e" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">最差、最好和一般情况下的表现</em> </strong></p></blockquote><ul class=""><li id="7df9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mq mb mc md bi translated">将算法的效率作为指示算法输入大小的参数的函数来测量是合理的。</li><li id="eada" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">然而，有许多算法的运行时间不仅取决于输入大小，还取决于特定输入的细节。</li><li id="7384" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">例如，顺序搜索。这是一种简单的算法，通过检查列表中出现的连续元素，在n个元素的列表中搜索给定的项目(某个搜索关键字K)。该算法继续检查，直到找到与搜索关键字匹配的内容，否则，列表将被用尽。</li><li id="443f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu mq mb mc md bi translated">下面是算法伪代码，为了简单起见，列表是作为一个数组实现的。(它还假设，如果检查数组索引不超过上限的第一个条件失败，则不会检查第二个条件A[i] i= K。</li></ul><blockquote class="mj mk ml"><p id="db4e" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">渐近符号</em> </strong></p></blockquote><p id="e50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤数用于比较计算相同函数的两个程序的时间复杂度，并预测实例特征改变时运行时间的增加。确定精确的步骤数是困难的，也是不必要的，因为值不是精确的量。我们只需要像<strong class="lb iu"> <em class="mm"> c1n2 tp(n) c2n2 </em> </strong>这样的比较语句。</p><p id="92c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如考虑复杂度<strong class="lb iu"> <em class="mm"> c1n2 + c2n </em> </strong>和<strong class="lb iu"> <em class="mm"> c3n </em> </strong>的两个程序。对于较小的n值，复杂度取决于c1、c2和c3的值。但是也会有n，超过n复杂度c3n比复杂度<strong class="lb iu"> <em class="mm"> c1n2 + c2n </em> </strong>要好。这个n值叫做临界点。</p><p id="36c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:<em class="mm"> c3n </em> </strong>在临界点为零的情况下永远快。</p><blockquote class="mj mk ml"><p id="e923" class="kz la mm lb b lc ld ju le lf lg jx lh mn lj lk ll mo ln lo lp mp lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">结论</em> </strong></p></blockquote><p id="aa2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在寻找逻辑的世界中，算法是一种需要。它构成了操场的主干。在计算机科学中，算法给计算机一组特定的指令，允许它做任何事情，无论是运行计算器还是火箭。</p><p id="d61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算法思维，或定义解决问题的清晰步骤的能力，在许多不同的领域都是必不可少的。即使我们没有意识到，我们也一直在使用算法和算法思维。算法思维允许我们分解问题，并以离散的步骤概念化解决方案。理解和实现一个算法需要学生练习结构化思维和推理。</p><p id="2f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章。你可以在下一篇文章中评论你想让我讲的内容。读者们，下一个话题再见。</p><p id="0432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae ky" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="dd36" class="nc mx it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">推荐文章</h1><p id="6aca" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/15-most-usable-numpy-methods-with-python-4d20eb93e149?sk=911d2bebf042b148be8f366b907af158"> 1。用Python </a> <br/> 2最有用的NumPy方法。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a>T5】3。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff?source=friends_link&amp;sk=11c6809f6623dd4f6dd74d43727297cf">熊猫:处理分类数据</a> <br/> 5。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/hyper-parameters-randomseachcv-and-gridsearchcv-in-machine-learning-b7d091cf56f4?source=friends_link&amp;sk=cab337083fb09601114a6e466ec59689">超参数:机器学习中的RandomSeachCV和GridSearchCV</a><br/>6。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/data-distribution-using-numpy-with-python-3b64aae6f9d6?source=friends_link&amp;sk=809e75802cbd25ddceb5f0f6496c9803">数据分发使用Numpy与Python </a> <br/> 9。<a class="ae ky" href="https://medium.com/pythoneers/40-most-insanely-usable-methods-in-python-a983c78f5bfd?sk=07df9058ea3e8c2fce4318a73cd8fce9" rel="noopener"> 40种Python中最疯狂可用的方法</a> <br/> 10。<a class="ae ky" href="https://medium.com/pythoneers/20-most-usable-pandas-shortcut-methods-in-python-c9bc065ce11e?sk=1faf673d0cdfb46234975cbdeed12beb" rel="noopener">Python中最常用的20种熊猫快捷方式</a></p></div></div>    
</body>
</html>