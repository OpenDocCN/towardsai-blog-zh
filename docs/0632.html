<html>
<head>
<title>Top List of Quick Pandas Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速熊猫方法排行榜</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/top-list-of-quick-pandas-methods-eef778a82bb1?source=collection_archive---------2-----------------------#2020-06-28">https://pub.towardsai.net/top-list-of-quick-pandas-methods-eef778a82bb1?source=collection_archive---------2-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ce32" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><div class=""><h2 id="bb25" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用这些有用的技巧节省你的时间</h2></div><p id="7130" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在每天学习熊猫3个月后，这些是你可以用来快速但有意义的编辑而不会失去耐心的顶级算法。如果你是一个专家，你可能已经知道所有这些，但是如果你是一个<strong class="kt jd">初学者</strong>，这些将对你非常有用。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/8f0236e0da8741890e92eccd7f126a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2f60pHl_PVsJtLX9"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@itookthose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">锡德·巴拉钱德朗</a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9ae5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我从创建一个数据集开始，我将用许多不同的方式编辑它</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="6f6b" class="mj mk it mf b gy ml mm l mn mo">df = [<br/>      ['001', 101, 2000, 'red'], <br/>      ['002', 99, 2080, 'blue'], <br/>      ['003', 94, 1980, 'yellow'], <br/>      ['004', 107, 2020, 'red'], <br/>]<br/>df</span><span id="1fa2" class="mj mk it mf b gy mp mm l mn mo">import pandas as pd<br/>df = pd.DataFrame(df)<br/>df</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/dfd7c3900a279dcaaa56268ae13f9d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*Mk-gJqLbCD2gbjJavND4GQ.png"/></div></figure><h1 id="b0be" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">编辑列标题</h1><p id="be8b" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nk lc ld le nl lg lh li nm lk ll lm im bi translated">不幸的是，这些列被简单地存储为0，1，2，3。为了编辑标题，我将使用下面一行代码:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="e680" class="mj mk it mf b gy ml mm l mn mo">df.columns = ['id', 'radius', 'weight', 'color']</span></pre><p id="babd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将列作为列表传递，以更改标题。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/494bd171a75c71bf55fca57454628519.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*j_wTLsNJsHR8b3VZxmvSJw.png"/></div></figure><h1 id="a08a" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">添加索引</h1><p id="5461" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nk lc ld le nl lg lh li nm lk ll lm im bi translated">默认情况下，数据帧有一个数字索引。但是，您可能希望根据自己的需要进行更改。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi no"><img src="../Images/14a3f775bcbcec3e4d6ec7b603299a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*Cbxb1KueBXhPJj9xWFVRCw.png"/></div></figure><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="66b0" class="mj mk it mf b gy ml mm l mn mo">df.index = df['id']<br/>df.pop('id')<br/>df</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b21dff6bef4579af1908600c3669bd94.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*Ywu_b_1xgjFGhy5sHuAPuA.png"/></div></figure><p id="c378" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一个可能需要使用索引的非常常见的实际应用是时间序列。当训练LSTM神经网络时，你必须丢弃数据集的时间戳。但是，您可以将它作为索引添加，而不是删除它。</p><h1 id="08ef" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">编辑整个数据集</h1><p id="a90f" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nk lc ld le nl lg lh li nm lk ll lm im bi translated">这绝对是我最喜欢的功能。使用apply和lambda函数，我可以根据我的指令编辑数据集中的所有信息。</p><p id="8e79" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，我想向半径列添加两倍的权重值。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="acb0" class="mj mk it mf b gy ml mm l mn mo">df['radius'] = df['weight'].apply(lambda x : x+df['radius'])<br/>df</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/22ece5f5d35e87d258ada6efe521b44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*HGjrn0-ybrg2Xc04sBWbqA.png"/></div></figure><h1 id="63ec" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">删除第n行</h1><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="0f0a" class="mj mk it mf b gy ml mm l mn mo">df = df.drop(df.index[[0]])<br/>df</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/50d80c195a48303a40a40f7f2eb6fb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*FVKI-_vLwiArxCZRCq95Ww.png"/></div></figure><h1 id="18c5" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">将序列转换为数据帧</h1><p id="b74a" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nk lc ld le nl lg lh li nm lk ll lm im bi translated">熊猫的一个看似不切实际的用途是自动将一个列转换成一个系列。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="98d6" class="mj mk it mf b gy ml mm l mn mo">row = df['radius']<br/>row</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b4961661329250ee2ed262174de4841f.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*9-JiN-lYwev6n6dFD9rhIg.png"/></div></figure><p id="9464" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我可以应用于DataFrame的所有设置和方法都无效了，因为它本质上表现得像一个NumPy数组。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="62ca" class="mj mk it mf b gy ml mm l mn mo">row = pd.DataFrame(df['radius'])<br/>row</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a2e514c0ec0e34b2cb0498dc4c7f12f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*swBsCuf8tFADNeMrGk56ug.png"/></div></figure><p id="ea97" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如您所见，您可以将单个列(系列)转换回DataFrame。</p><h1 id="4372" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">制作数据集的副本</h1><p id="5b9e" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nk lc ld le nl lg lh li nm lk ll lm im bi translated">一个错误的假设是，通过定义另一个变量，您可以简单地复制数据集:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="5ce8" class="mj mk it mf b gy ml mm l mn mo">a = df<br/>a</span></pre><p id="704b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我不会修改a的元素:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="4649" class="mj mk it mf b gy ml mm l mn mo">a['color'][0] = 'black'<br/>a</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/866d33c07f2281521b250cf122416ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*4Mid1OEGAID2nz-7sE3wtg.png"/></div></figure><p id="7bdd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是，如果我们看一下df，我们没有直接编辑:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="f276" class="mj mk it mf b gy ml mm l mn mo">df</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e8120e135c0b431299ee16b46cf8e8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*gZbBcfyAmXi2jf-O-aDMuA.png"/></div></figure><p id="2903" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以看到两个数据集都被修改了。这是因为Pandas通过向新变量分配引用来工作。</p><p id="a74d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要解决这个问题:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="033e" class="mj mk it mf b gy ml mm l mn mo">a = df.copy()</span></pre><p id="098f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们进行同样的实验，你会看到只有将被修改。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bbf56391a54a378363e7dc892bc63b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*29XVW6NtMqU95pW0Zww8AA.png"/></div></figure><h1 id="615b" class="mr mk it bd ms mt mu mv mw mx my mz na ki nb kj nc kl nd km ne ko nf kp ng nh bi translated">仅维护具有特定值的行</h1><p id="d2d1" class="pw-post-body-paragraph kr ks it kt b ku ni kd kw kx nj kg kz la nk lc ld le nl lg lh li nm lk ll lm im bi translated">现在让我假设我只想保存权重值大于2000的行。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="dc73" class="mj mk it mf b gy ml mm l mn mo">df = df.loc[df['weight'] &gt; 2000]<br/>df</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0dec6636fbb4ef108a6f81ffbceee1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*4NzMbtYIs53xwSHnshDwAA.png"/></div></figure></div></div>    
</body>
</html>