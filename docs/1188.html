<html>
<head>
<title>Feature Transformation and Scaling Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">特征变换和缩放技术</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/feature-transformation-and-scaling-techniques-f9645cb538e?source=collection_archive---------1-----------------------#2020-11-28">https://pub.towardsai.net/feature-transformation-and-scaling-techniques-f9645cb538e?source=collection_archive---------1-----------------------#2020-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e978" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="ff21" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">提高机器学习模型性能的9种方法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a3fcbae28b3d288ae3fbfe8b151b33cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ylc1M_lond5kwslM"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@scw1217?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">苏珊·威廉姆斯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9a9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">特征变换只是将特征从一种表示形式变换到另一种表示形式的函数。要素缩放是一种转换同一范围内要素的所有值的技术。比如0比1。</p><p id="b501" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">为什么特性转换是必要的？？</strong></p><p id="b73f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，我们的数据集中不同的列有不同的单位，比如一列可以用千米表示，而另一列可以用米或厘米表示。或者在相同的场景中，我们有一个年龄列，范围从0到1000，另一方面，我们有一个薪水列，所有值都大于10，000。那么在这样的场景下，这些值之间的差异就变得非常大。由于这种差异，<strong class="lk jd">值越大的列对输出的影响越大。</strong>因此，我们需要执行特征缩放和变换，以使所有值位于相同的范围内。</p><p id="244b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇博客中，我们将讨论9种功能缩放和转换技术。</p><ol class=""><li id="6a09" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">最小最大缩放器</li><li id="4b7c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">标准缩放器</li><li id="36da" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">MaxAbsScaler</li><li id="5670" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">鲁棒定标器</li><li id="1068" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">分位数变压器定标器</li><li id="099a" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">对数变换</li><li id="507c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">电力变压器定标器</li><li id="ccb3" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">单位向量缩放器/规格化器</li></ol><p id="b0f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们从使用pandas创建一个更简单的数据框开始</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="512e" class="mx my it mt b gy mz na l nb nc">### TO REMOVE UNECESSARY WARNINGS #####<br/>import warnings<br/>warnings.filterwarnings('ignore')</span><span id="d8d0" class="mx my it mt b gy nd na l nb nc">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd</span><span id="4636" class="mx my it mt b gy nd na l nb nc">%matplotlib inline</span><span id="e840" class="mx my it mt b gy nd na l nb nc">df = pd.DataFrame({<br/>    'salary':[18000,20000,10000,2600,23000],<br/>    'age':[23,24,20,18,28],<br/>    'department':['HR','Marketing','Development','Managment','Legal']<br/>})<br/>df.head()</span></pre><h2 id="0d5e" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">1️⃣最小最大缩放器</h2><p id="bd70" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">最小最大缩放器是理解和实现起来比较简单的缩放器之一。它缩小0到1之间的所有值。列中的最大值被赋予值1，列中的最小值被赋予值0，除此之外的所有值被赋予0到1之间的值。</p><p id="5486" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">公式:</strong></p><h2 id="461d" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated"><strong class="ak"><em class="nz">x _ scaled =(x—x _ min)/(x _ max—x _ min)</em></strong></h2><p id="d411" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">x_scaled =缩放后的col值<br/> x =原始值<br/> x_min =列中的最小值<br/> x_max =列中的最大值</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="89de" class="mx my it mt b gy mz na l nb nc"><strong class="mt jd">### Defining Scaler ###</strong><br/>from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler()</span><span id="cc46" class="mx my it mt b gy nd na l nb nc"><strong class="mt jd">#### MinMax Scaling ###<br/></strong>col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col_names] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a3d46005bd43b942d904df32c6e49764.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*FaKLaG5bd9pkmquuxjOS4A.png"/></div></figure><p id="f469" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最小最大缩放器将缩小0到1之间的所有值。如果我们想在自定义范围内缩小数值，那么我们可以使用<strong class="lk jd"> feature_range </strong>定义我们自己的范围。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="f7d5" class="mx my it mt b gy mz na l nb nc">### Defining Scaler ###<br/>from sklearn.preprocessing import<strong class="mt jd"> MinMaxScaler</strong><br/><strong class="mt jd">scaler = MinMaxScaler(feature_range=(2,4)) ##Custom Scaling Range</strong></span><span id="fbed" class="mx my it mt b gy nd na l nb nc">#### MinMax Scaling ###<br/>col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col_names] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/604bcb5f74d2992dd9f5b9ec8b8193db.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*gHis3es3jIh8ev624i0UVg.png"/></div></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="8946" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">2️⃣标准标尺</h2><p id="b3d3" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">标准定标器也是最常用和最容易理解的定标器之一。它不是在0到1之间缩放值，而是以均值为0、方差为1的方式缩放值。</p><p id="951e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">公式:-</p><h2 id="c774" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated"><strong class="ak"> x_scaled = x —平均值/标准差</strong></h2><p id="76df" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">标准定标器假设变量的分布是正态的。因此在变量不是正态分布的情况下，</p><ol class=""><li id="7853" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">或者，选择不同的缩放器</li><li id="a733" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">或者首先，将变量转换为正态分布，然后应用scaler。</li></ol><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="0cf4" class="mx my it mt b gy mz na l nb nc">from sklearn.preprocessing import <strong class="mt jd">StandardScaler</strong><br/>scaler = StandardScaler()</span><span id="d35d" class="mx my it mt b gy nd na l nb nc">col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col_names] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b0af8c031b988211fe9b85a5273d7c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*OAsYYAvikfeH4Wtmn02d-w.png"/></div></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="7471" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">3️⃣马克斯布斯卡勒</h2><p id="6be2" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">这个缩放器的工作原理与其他两个没有什么不同。它取每列的绝对最大值，然后用该值除以该列中的每个值。这是一个分三步走的过程。</p><ol class=""><li id="9ef8" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">获取列中每个值的绝对值。</li><li id="f474" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">求该列的最大值。</li><li id="824e" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">将最大值除以列中的每个值。</li></ol><p id="6b88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们在上面创建的数据框中再添加一列。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="9304" class="mx my it mt b gy mz na l nb nc">features = df[['salary','age']]<br/>features['balance'] = [100.0, 25245.567, 134.567, 4567.2345,2345.345]</span></pre><p id="ae66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用两个过程来衡量这些值。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="6c8c" class="mx my it mt b gy mz na l nb nc"><strong class="mt jd">🔰 Using Sklearn Library<br/></strong>from sklearn.preprocessing import <strong class="mt jd">MaxAbsScaler</strong><br/>scaler = MaxAbsScaler()<br/>col_names = ['salary','age','balance']<br/>features[col_names] = scaler.fit_transform(features.values)<br/>print(features.balance)</span><span id="128b" class="mx my it mt b gy nd na l nb nc">🔰 <strong class="mt jd">Using Custom Code</strong></span><span id="6c6b" class="mx my it mt b gy nd na l nb nc">values = [100.0, 25245.567, 134.567, 4567.2345,2345.345]<br/>abs_values = [abs(ele) for ele in values]<br/>max_val = max(abs_values)<br/>val = [ele/max_val for ele in abs_values]<br/>val</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/531731e3606faad84dcfcc4a508acb24.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*RIcOTIr8_3d6ApGizvEnCw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">平衡栏-&gt;使用Sklearn |自定义代码</figcaption></figure><p id="f9e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经看到了三个定标器，但是它们都使用列的最大值或最小值来定标数据。这些值对异常值很敏感，如果数据集中有许多异常值，那么这些值很容易受到异常值的影响。鲁棒定标器是一种对异常值<strong class="lk jd"> <em class="ol">不敏感的定标器。</em>T3】</strong></p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="b0ea" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">4️⃣鲁棒定标器</h2><p id="e4d4" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">鲁棒定标器的关键特性和优势之一是它对异常值不敏感。它使用IQR(四分位数间距)来缩放数据。</p><ol class=""><li id="71eb" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">它从数据中去除了中间值。</li><li id="9355" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">并且，使用IQR缩放数据</li></ol><p id="e215" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">公式:</strong></p><p id="e5a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">IQR = Q3-Q1</p><p id="587c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">X_scaled = (X-Q1)/(Q3-Q1)</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="e966" class="mx my it mt b gy mz na l nb nc">from sklearn.preprocessing import <strong class="mt jd">RobustScaler</strong><br/>scaler = RobustScaler()</span><span id="9d38" class="mx my it mt b gy nd na l nb nc">col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0b3984bb8c8287e61b005328ca9bd967.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*v7gEWvfpl8nS4B-lilK4iA.png"/></div></figure><h2 id="9f9b" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">5️⃣分位数变压器定标器</h2><p id="c6a1" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">这种技术就像一种神奇的结合。它将数据的分布转换为正态分布，并相应地进行缩放。因为它使变量呈正态分布，所以它也处理异常值。</p><p id="3d6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">✔异常值剔除<br/> ✔标度数据<br/> ✔转换成正态分布</p><p id="bb65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">流程</strong></p><ol class=""><li id="53b2" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">首先，它计算变量的累积分布函数</li><li id="1b64" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">然后，它使用该CDF将值映射到正态分布</li><li id="a287" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">最后，它使用相关联的分位数函数将获得的值映射到期望的输出分布</li></ol><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="9253" class="mx my it mt b gy mz na l nb nc">from sklearn.preprocessing import <strong class="mt jd">QuantileTransformer</strong><br/>scaler = QuantileTransformer()</span><span id="3b62" class="mx my it mt b gy nd na l nb nc">col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col_names] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/db0a7b39da2793779c8e1258c68b3b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*c-eV6c3JNzy0toj0MzRc2A.png"/></div></figure><h2 id="3c23" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">6️⃣对数变换</h2><p id="17ed" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated"><strong class="lk jd">用于将偏态分布转换为正态分布或不偏态分布。</strong>在这种技术中，我们取列的值的对数，并将它们作为一列。</p><p id="80e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用一些倾斜的数据条目再次添加balance列。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="40d7" class="mx my it mt b gy mz na l nb nc">features = df2[['salary','age']]<br/>features['balance'] = [15000, 1800, 120000, 10000,12000]<br/>features.balance.hist()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8e6e5cdb440b6aee67927ba20872ce22.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*ba4fokyi1YDZmn3EJJKB8w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">左偏数据</figcaption></figure><p id="b42d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们使用日志转换器进行缩放。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="75fb" class="mx my it mt b gy mz na l nb nc">import numpy as np<br/>features['balance'] = np.log(features['balance'])<br/>print(features.balance)<br/>features.balance.hist(bins=5)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/bcf812fc781e21f5230ab5246536e47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*dchu3UuZjii9_PB3oFRxCA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">正态分布数据</figcaption></figure><p id="2967" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上图显示了如何将对数转换分布转换为正态分布。</p><h2 id="c469" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">7️⃣电力变压器定标器</h2><p id="33c2" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">它还将变量的分布更改为更接近高斯(正态)的分布。有两种类型。</p><ol class=""><li id="1d42" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><a class="ae lh" href="https://www.statisticshowto.com/box-cox-transformation/" rel="noopener ugc nofollow" target="_blank"> Box-Cox变换</a></li><li id="7b59" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://www.stat.umn.edu/arc/yjpower.pdf" rel="noopener ugc nofollow" target="_blank">杨-约翰逊变换</a></li></ol><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="8d82" class="mx my it mt b gy mz na l nb nc">from sklearn.preprocessing import <strong class="mt jd">PowerTransformer</strong><br/>scaler = <strong class="mt jd">PowerTransformer(method = 'box-cox')</strong></span><span id="3a0a" class="mx my it mt b gy nd na l nb nc">'''<br/>parameters:<br/>method = 'box-cox' or 'yeo-johnson'<br/>'''</span><span id="e548" class="mx my it mt b gy nd na l nb nc">col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d1425a72198325c7b78025086ebeef4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*e4GlBpBGIlGQQgZ5JutRlA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">博克斯-考克斯变换</figcaption></figure><h2 id="20e8" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">8️⃣单位向量定标器/规格化器</h2><p id="86f9" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">它和其他的不一样。它作用于数据框的每一行，而不是列。在这里，我们有两个规范l1和l2。</p><ul class=""><li id="5340" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md or mk ml mm bi translated">如果我们使用的是L1范数，那么每一列中的值都会被转换，这样它们在这一行中的绝对值之和就是1。</li><li id="b463" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md or mk ml mm bi translated">如果我们使用L2范数，那么每一列中的值首先被平方并相加，使得它们沿着行的绝对值之和是1。</li></ul><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="ac2f" class="mx my it mt b gy mz na l nb nc">from sklearn.preprocessing import Normalizer<br/>scaler = <strong class="mt jd">Normalizer(norm='l2')</strong></span><span id="560f" class="mx my it mt b gy nd na l nb nc"># norm = 'l2' is default</span><span id="fbbf" class="mx my it mt b gy nd na l nb nc">col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col] = scaler.fit_transform(features.values)<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/71b6916a0a7c6ea7cb9a663b8ac24fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*SSKck-XykvK3AIzz4B0Buw.png"/></div></div></figure><p id="b9b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果我们将前两列相加，那么总和大约为1。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="c85c" class="mx my it mt b gy mz na l nb nc">features['sum']=abs(features['age'])+abs(features['salary'])<br/>features</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/1a38cd8178b70e6bf054256c1482a63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*rhxkmIuFEJiQGm2VzkqwkA.png"/></div></figure><h2 id="70b2" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">9️⃣定制变压器</h2><p id="ddb0" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">考虑这样一种情况，您有自己的python函数来转换数据。Sklearn提供了使用FunctionTransformer对数据应用您自己的函数的能力。</p><p id="3ec0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用一个更简单的函数，我们需要取该列中所有值的log2。</p><pre class="ks kt ku kv gt ms mt mu mv aw mw bi"><span id="67ff" class="mx my it mt b gy mz na l nb nc">from sklearn.preprocessing import FunctionTransformer<br/>transformer  = FunctionTransformer(np.log2,validate=True)</span><span id="d531" class="mx my it mt b gy nd na l nb nc">col_names = ['salary', 'age']<br/>features = df[col_names]<br/>features[col] = transformer.fit_transform(features.values)<br/>features</span></pre><p id="05c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/Abhayparashar31/feature-engineering/blob/main/Feature%20Transformation%20Methods%20.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="ol">笔记本&amp; Github链接</em></strong>T5】</a></p><h2 id="e486" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">额外小费</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/30a85ee90b7be5c1b452d752526e969f.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/0*FV9Gm_xTuQY3V8ZW.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://i.stack.imgur.com/kRbSk.png" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="d547" class="mx my it bd ne nf ng dn nh ni nj dp nk lr nl nm nn lv no np nq lz nr ns nt iz bi translated">-:推荐读物🚀:-</h2><p id="78a5" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/handling-outliers-in-machine-learning-f842d8f4c1dc" rel="noopener">处理机器学习中的异常值</a></p><p id="128d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/different-feature-selection-techniques-f47ec43f71b8" rel="noopener">不同的特征选择技术</a></p><p id="3ea8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/different-approaches-to-handle-categorical-values-a2e35fbd6128" rel="noopener">处理分类值的不同方法</a></p><p id="ec03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/9-ways-to-handle-missing-values-in-machine-learning-1bbda345699a" rel="noopener">机器学习中处理缺失值的9种方法</a></p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><blockquote class="ov ow ox"><p id="cd8e" class="li lj ol lk b ll lm kd ln lo lp kg lq oy ls lt lu oz lw lx ly pa ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">感谢阅读😃，更多请跟我来</em> </strong> <a class="ae lh" href="https://parasharabhay13.medium.com/" rel="noopener"> <strong class="lk jd"> <em class="it">这里</em> </strong> </a> <strong class="lk jd"> <em class="it">👈</em>T29】</strong></p></blockquote></div></div>    
</body>
</html>