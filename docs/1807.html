<html>
<head>
<title>How Go Helped Me Accelerate My Machine Learning Computations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">How Go帮助我加快了机器学习计算的速度</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-go-helped-me-accelerate-my-machine-learning-computations-b2ea961130ad?source=collection_archive---------1-----------------------#2021-05-01">https://pub.towardsai.net/how-go-helped-me-accelerate-my-machine-learning-computations-b2ea961130ad?source=collection_archive---------1-----------------------#2021-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a655" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><h1 id="9db8" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">TL；博士:很久了，你不想读了？</strong></h1><p id="14db" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，我支持你:在这里，我分享我使用<strong class="kw ja"> Go语言</strong>将我项目的<strong class="kw ja">机器学习</strong>计算时间从一周减少到24小时以内的故事。为了赶上最后期限，我必须在3天内提交我的结果。</p><p id="f3d8" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">说服够了吗？:D接着跟着一起走！</p><h1 id="eb09" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">背景故事</h1><p id="429b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名硕士生，我有一大堆事情要做，包括写论文、申请博士职位、可能的实习等等。最重要的是，我必须准备好提交给目标会议的研究报告。事实上，我已经得到了我的大部分结果，并且和我的研究顾问一起写了我的手稿并修改了几次。我想添加更多的结果来支持我的方法。</p><p id="75d0" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">然而，就像任何其他研究生一样，我有一个主要问题:<strong class="kw ja">时间！</strong></p><p id="2d3e" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">离会议的最后期限只有3天了。我需要至少7整天来完成计算，并花半天时间来填充我的结果。我有两个选择:</p><ol class=""><li id="9e09" class="lx ly iq kw b kx ls lb lt lf lz lj ma ln mb lr mc md me mf bi translated">放弃目标会议，另找一个目标。</li><li id="de00" class="lx ly iq kw b kx mg lb mh lf mi lj mj ln mk lr mc md me mf bi translated">想办法提高我的计算速度。</li></ol><p id="3744" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">我的选择是什么？你正在读这篇文章的事实本身就说明了一切。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/74da55dfe80e9d5ff3e2a9fe8cc8127b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDBxzwi6Th5IDLwk8cC2hg.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">(本人照片)</figcaption></figure><p id="0791" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">我用来开发和实现我的实验的主要工具是<strong class="kw ja"> PyTorch。</strong>它是一个非常稳定且易于理解的框架，利用<strong class="kw ja">NVIDIA</strong><strong class="kw ja">GPU</strong>的力量来完成机器学习任务。我开发了自己的方法，并且已经有了结果。然而，对于基线方法，我更喜欢通过使用一个稳定的、写得好的和文档记录好的库来节省时间。但是有一个问题:这个库只使用了<strong class="kw ja"> NumPy </strong>开发了其中一个方法(姑且称之为<strong class="kw ja"> too_long_method </strong>),没有任何GPU加速的实现。too_long_method 由一个长循环中的大量迭代组成。因此，对于单个数据点，大约需要15分钟才能完成。为了能够计算出所有数据的结果，我在几个实例中运行了代码。然而，这不是一个选项。即使在具有8个物理内核的游戏系统上，这样的配置也需要7天才能完成。</p><h1 id="5dab" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">可能的解决方案？</h1><p id="2bba" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到上述所有问题，我可以想出几种方法来解决这个问题:</p><ol class=""><li id="5197" class="lx ly iq kw b kx ls lb lt lf lz lj ma ln mb lr mc md me mf bi translated">在PyTorch中重写<strong class="kw ja"> too_long_method </strong>的代码。(<strong class="kw ja">不可选项！:</strong>因为开发和调试将花费更多的时间，并导致混乱和挫折。)</li><li id="7a81" class="lx ly iq kw b kx mg lb mh lf mi lj mj ln mk lr mc md me mf bi translated">使用云服务来分担众多计算机的计算负担。(<strong class="kw ja">不可选项！那会花掉我很多钱。此外，弄清楚如何利用这些特定的云服务需要一段时间。)</strong></li><li id="c5be" class="lx ly iq kw b kx mg lb mh lf mi lj mj ln mk lr mc md me mf bi translated">使用PyTorch内置的多处理能力以某种方式并行运行代码(<strong class="kw ja">不是一个选项！尽管一开始我尝试过，但我很快意识到这不会有多大帮助，原因我将在后面解释。)</strong></li><li id="1325" class="lx ly iq kw b kx mg lb mh lf mi lj mj ln mk lr mc md me mf bi translated">在多个实例中运行代码(但与上一次不同，在小批数据上运行)(<strong class="kw ja">我的选择！！！我发现运行多个程序实例并让操作系统代表我处理并行和多线程的负担要容易得多。)</strong></li></ol><h1 id="c663" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">我的路线图</h1><p id="ca1b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择在多个实例中运行我的代码。为此，我编写了两段具有两个主要功能的代码:</p><p id="5808" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated"><strong class="kw ja">生产者:</strong>一个单独的程序，它将迭代地向代码实例的外部池提供数据点。</p><p id="c481" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated"><strong class="kw ja">消费者:</strong>包含<strong class="kw ja"> too_long_method </strong>的代码，将处理提供给它的小批量数据点，并存储结果。</p><p id="f778" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">整个系统的总体架构可以描述如下:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nb"><img src="../Images/677f8a22c534da78ffebe4576aa0343f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRhmOap1yoWxh9x9VXKnew.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">生产者和消费者(图片由本人提供)</figcaption></figure><p id="3beb" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">我尝试了以下场景，但没有成功获得我期望的性能:</p><ul class=""><li id="aeee" class="lx ly iq kw b kx ls lb lt lf lz lj ma ln mb lr nc md me mf bi translated">PyTorch的多重处理能力:当我试图以这种方式解决问题时，我面临的问题是，我必须在不同的进程之间管理数据点的划分，这将需要不同的时间来完成。另外，在我看来，增加子进程的数量不会增加整个系统的吞吐量。然而，很明显，系统的资源如CPU内核和RAM并没有像我预期的那样被使用。(不管怎样，永远不要忘记！我没有太多时间去寻找和询问可能的解决方案。所以，我可能错了。)</li><li id="2bfe" class="lx ly iq kw b kx mg lb mh lf mi lj mj ln mk lr nc md me mf bi translated">我试着用python写制作人。然而，我注意到它不能运行超过虚拟CPU数量的外部程序实例。我认为这是一个瓶颈，因为CPU资源仍然可用，尽管事实上代码正在以其最高的能力运行。我寻找了与python解释器相关的不同配置，但是想不出python方面有任何可能的瓶颈。</li></ul><p id="8d82" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">在上面的场景中玩了几个小时，没有任何结果，让我筋疲力尽。所以，我决定用python之外的编程语言来编写生产者代码。幸运的是，几年前我已经阅读并了解了关于<a class="ae nd" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ja">围棋</strong> </a>的知识。我知道它内置的处理并发的能力。所以，我决定试一试。</p><h1 id="b15e" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">你想知道的一些编程概念:</strong></h1><p id="71b2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在深入研究代码之前，让我首先提供一些我使用过的概念的简要定义，以防您对它们不太熟悉。然而，如果你从未用过围棋，有大量的资源可以帮助你轻松地学习围棋<a class="ae nd" href="https://www.tutorialspoint.com/go/index.htm" rel="noopener ugc nofollow" target="_blank"/>和快速地学习<a class="ae nd" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6eea" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated"><strong class="kw ja">并行性:</strong>在独立的处理单元上同时运行多个任务(实际上，大部分是相同的任务，但是在不同的数据块上)。并行性的要点在于，在每一个时刻，参与并行处理的每一个处理单元都在独立处理不同的数据。</p><p id="3d6d" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated"><strong class="kw ja">并发性:</strong>处理不需要相同时间完成的多个任务。这不一定需要分布在不同的处理单元中。举个例子，当你打开一个网站时，下载和显示网站需要一些时间。然而，当你的计算机等待输入数据完全到达时，它可以让你移动鼠标和做其他事情。即使您的计算机只有一个处理单元。因此，在您考虑并发任务的随机时刻，您可能会看到CPU只处理其中一个任务，而其他任务由于等待外部因素而暂停。</p><p id="f183" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">他们说一张照片胜过千言万语:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ne"><img src="../Images/312259be467438bb7b1bc7f7c70af135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXxaRA6iJ2Zgy0SRyttYtQ.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">并行性与并发性(我自己的图像)</figcaption></figure><p id="bb4d" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">以下是来自<strong class="kw ja"> Go </strong>语言的一些单词和定义:</p><p id="1a37" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated"><strong class="kw ja">Go routine:</strong>Go中的内置结构，那是一个轻量级的线程。它在Go程序中提供并发性。</p><p id="860a" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">通道:可以看作是一个数据管道，goroutines可以向它发送数据，也可以从它接收数据。因此，允许goroutines一起处理数据。通道可以具有任意大小的长度，以提供某种类型的数据对象队列(缓冲通道)。</p><p id="0bef" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">任务:这不是一个专门针对任何语言或语境的技术术语。在这里，通过使用“任务”，我指的是一个python代码，它对给定的数据执行特定的耗时的机器学习方法。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nf"><img src="../Images/9cf54678db17bdc61eb23f768d5b16e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQ-3CKrN7KAX0Ql0eVC5ww.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">路线、频道、任务。与由goroutines调用的外部程序不同，生成器运行在程序的主线程上。(图片由本人提供)</figcaption></figure><h1 id="51d1" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">好了，我们现在可以看代码了吗？</h1><p id="0dc2" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经在我的github账号上发布了代码，这样你就可以直接看到了。</p><p id="e83c" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">代码从<strong class="kw ja"> main() </strong>函数开始。主函数中无限for-loop的一般结构只是为用户提供一组菜单选项的<a class="ae nd" href="https://www.tutorialspoint.com/design_pattern/state_pattern.htm" rel="noopener ugc nofollow" target="_blank">状态设计模式</a>。整个魔术开始的最重要部分如下:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="312f" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">让我们一行一行地看一下它的重要部分:</p><p id="7530" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">在第3行，创建了一个等待组，这是Go中并发性所必需的。所有的神奇都发生在8号线上！首先，创建一个缓冲通道来处理任务(tasks_chan)。这可以被认为是可以从不同的例程访问的先进先出(FIFO)队列。对于我的应用程序，在运行了几次代码之后，我发现32是工作人员的最佳数量。即没有一个进程会由于缺少计算资源而停止的工作进程的最大数量，并且在没有来自任何子进程的任何<strong class="kw ja">存储器异常</strong>的情况下，存储器使用将达到其最高可能值。</p><p id="d121" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">在接下来的几行中，<strong class="kw ja"> call_workers() </strong>函数实际上创建了一个goroutines池，并将对tasks_chan的引用传递给它们。以便他们每个人都可以访问任务队列。事实上，这些goroutines中的每一个都在单独的线程中运行<strong class="kw ja"> spawn_worker() </strong>函数:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="56e7" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">每当代码到达<strong class="kw ja"> go </strong>关键字时，它不会停止执行。相反，它继续运行主线程。因此，for循环会一直运行，直到所有worker goroutines都被调用。每个工人都有一个号码。以便我们可以跟踪终端中每个工人的状态。我们可以看到，一旦打印出“所有工人在线”，这个函数就完成了执行。</p><p id="9895" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">让我们看看<strong class="kw ja"> spawn_worker </strong>函数，看看调用它时会发生什么:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ab82" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">这个函数的第一行在整个函数体完全运行后执行。所以让我们暂时忘记它。在第4行，开始了一个无限for循环。在for循环内部，有一个特殊的<strong class="kw ja">选择用例</strong>结构。任何首先被触发的case语句，其主体都会被执行。例如，如果有任何对象可以从tasks通道中选取，那么第6行的情况就会触发。并且调用另一个函数(spawn_pytorch)来执行该任务(在第9行)。任务结束后，第15行的break语句结束select语句。因此，无限for循环进入下一次迭代，select语句从头开始。</p><p id="44b4" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">另一方面，在输入select - case语句后，如果10秒钟过去了而没有执行其他case，那么第17行的case语句将被触发。在这种情况下，函数返回。此时，第一行功能(即defer wg。Done())通知线程组(wg)它已经完成。</p><p id="53ac" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">因此，在开始时，当call_workers开始在单独的goroutines中生成worker时，所有生成的worker都开始等待10秒钟，直到它们完全停止执行。</p><p id="22b4" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">回头看看主函数，在调用call_workers之后，一旦所有的worker都准备好了，就调用函数<strong class="kw ja"> generate_tasks() </strong>。我们还需要将任务通道传递给这个函数。这个函数开始用任务填充任务缓冲区，直到缓冲区满了。一旦缓冲区满了，它就在第8行(或者最后在第15行)阻塞主线程的执行。</p><p id="71ae" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">因此，当这个线程生成任务并将它们发送到通道时，worker goroutines一看到通道中有可用的任务就开始读取任务。这就是Go为您处理所有这些复杂问题的方式！</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b3d0" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">现在，这个程序如何工作的一般结构已经变得更加清楚，让我们进入运行任务的更多细节。在spawn_worker函数的第9行，调用了<strong class="kw ja"> spawn_pytorch() </strong>函数。它实际上将批处理文件作为外部应用程序运行。批处理文件包含设置pytorch虚拟环境的命令。然后，包含机器学习逻辑的python文件的实际执行(即too_long_method，remmeber？).任务的规格是task_index和batches_count。这些too数字决定了too_long_method的每个实例应该考虑数据集的哪个块来进行计算。</p><p id="342d" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">spawn_pytorch其实是这样定义的:(后面再解释)</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cd4d" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">从第5行到第14行，定义了一个外部命令对象，并准备运行一个名为<strong class="kw ja"> python_job.bat </strong>的批处理文件。</p><p id="4802" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">从第15行到第18行，task_index和batches_count被定义为命令对象的参数。</p><p id="0ef8" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">在第19到24行，命令实际上正在运行。</p><p id="7fae" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">就好像一个人在PyTorch虚拟环境中用给定的参数调用python代码一样。如果在此过程中出现任何错误，该函数将返回false。否则，它返回true。</p><h1 id="6ac2" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">遗言</strong></h1><p id="7bb5" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，在编程中有很多方法可以达到某个目标。然而，这就是我如何面对这个问题，并设法加速我的计算，这可能需要连续7天以上才能完成，现在不到24小时。围棋语言的优势<a class="ae nd" href="https://www.zdnet.com/article/developers-say-googles-go-is-most-sought-after-programming-language-of-2020/" rel="noopener ugc nofollow" target="_blank">近年来吸引了很多人的兴趣</a>。这也是分享我的故事的另一个动机。请让我知道你对这篇文章的看法，如果你在这篇文章中发现任何问题，请随时联系我。</p><h1 id="6091" class="jw jx iq bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">参考资料:</h1><p id="3eb1" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]https://github.com/k-timy/go_producer_consumer<a class="ae nd" href="https://github.com/k-timy/go_producer_consumer" rel="noopener ugc nofollow" target="_blank"/></p><p id="61ee" class="pw-post-body-paragraph ku kv iq kw b kx ls kz la lb lt ld le lf lu lh li lj lv ll lm ln lw lp lq lr ij bi translated">[2]<a class="ae nd" href="https://www.zdnet.com/article/developers-say-googles-go-is-most-sought-after-programming-language-of-2020/" rel="noopener ugc nofollow" target="_blank">https://www . zdnet . com/article/developers-say-Google-go-is-most-seen-after-programming-language-of-of-2020/</a></p></div></div>    
</body>
</html>