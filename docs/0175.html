<html>
<head>
<title>Feature Scaling with Python’s Scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的Scikit-learn扩展功能</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/feature-scaling-with-pythons-scikit-learn-10ab42119ae0?source=collection_archive---------1-----------------------#2019-10-07">https://pub.towardsai.net/feature-scaling-with-pythons-scikit-learn-10ab42119ae0?source=collection_archive---------1-----------------------#2019-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c423" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><p id="ab21" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">标准化的主要目标之一是使数据接近于零。这使得优化问题更加“数值稳定”。</p><p id="6384" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，使用平均值和标准偏差的缩放假设数据是正态分布的，也就是说，大部分数据足够接近平均值。因此，将平均值移至零可以确保大多数数据点的大部分成分接近于0。具体来说，68%的数据介于-1和1之间，如下图所示:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/c3e742f0545ceddc417a324842485549.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*QjQ61rmbUM-KmriAcJ5nmQ.png"/></div></div></figure><p id="47b3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本帖中，我们将探讨scikit-learn中实现的3种功能缩放方法:</p><ul class=""><li id="ce7f" class="lj lk it kb b kc kd kg kh kk ll ko lm ks ln kw lo lp lq lr bi translated"><code class="fe ls lt lu lv b">StandardScaler</code></li><li id="3c9b" class="lj lk it kb b kc lw kg lx kk ly ko lz ks ma kw lo lp lq lr bi translated"><code class="fe ls lt lu lv b">MinMaxScaler</code></li><li id="d399" class="lj lk it kb b kc lw kg lx kk ly ko lz ks ma kw lo lp lq lr bi translated"><code class="fe ls lt lu lv b">RobustScaler</code></li><li id="383f" class="lj lk it kb b kc lw kg lx kk ly ko lz ks ma kw lo lp lq lr bi translated"><code class="fe ls lt lu lv b">Normalizer</code></li></ul><h1 id="da45" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">标准缩放器</h1><p id="ed55" class="pw-post-body-paragraph jz ka it kb b kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw im bi translated"><code class="fe ls lt lu lv b">StandardScaler</code>假设您的数据在每个要素内呈正态分布，并将对其进行缩放，使分布现在以0为中心，标准差为1。</p><p id="231b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">计算特征的平均值和标准偏差，然后根据以下内容对特征进行缩放:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ne"><img src="../Images/38dea177bdd54db96671ad82799e2982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*veXuiUYsoj7XN1tjblz_dQ.png"/></div></div></figure><p id="15d7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果数据不是正态分布的，这不是最好的缩放器。</p><p id="e76d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们来看看它的运行情况:</p><p id="e8e8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在[1]中:</p><pre class="ky kz la lb gt nf lv ng nh aw ni bi"><span id="0d21" class="nj mc it lv b gy nk nl l nm nn"><strong class="lv jd">import</strong> <strong class="lv jd">pandas</strong> <strong class="lv jd">as</strong> <strong class="lv jd">pd</strong><br/><strong class="lv jd">import</strong> <strong class="lv jd">numpy</strong> <strong class="lv jd">as</strong> <strong class="lv jd">np</strong><br/><strong class="lv jd">from</strong> <strong class="lv jd">sklearn</strong> <strong class="lv jd">import</strong> preprocessing<br/><strong class="lv jd">import</strong> <strong class="lv jd">matplotlib</strong><br/><strong class="lv jd">import</strong> <strong class="lv jd">matplotlib.pyplot</strong> <strong class="lv jd">as</strong> <strong class="lv jd">plt</strong><br/><strong class="lv jd">import</strong> <strong class="lv jd">seaborn</strong> <strong class="lv jd">as</strong> <strong class="lv jd">sns</strong><br/>%<strong class="lv jd">matplotlib</strong> inline<br/>matplotlib.style.use('ggplot')</span></pre><p id="440d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在[2]中:</p><pre class="ky kz la lb gt nf lv ng nh aw ni bi"><span id="9de9" class="nj mc it lv b gy nk nl l nm nn">np.random.seed(1)<br/>df = pd.DataFrame({<br/>    'x1': np.random.normal(0, 2, 10000),<br/>    'x2': np.random.normal(5, 3, 10000),<br/>    'x3': np.random.normal(-5, 5, 10000)<br/>})</span><span id="212d" class="nj mc it lv b gy no nl l nm nn">scaler = preprocessing.StandardScaler()<br/>scaled_df = scaler.fit_transform(df)<br/>scaled_df = pd.DataFrame(scaled_df, columns=['x1', 'x2', 'x3'])</span><span id="d99f" class="nj mc it lv b gy no nl l nm nn">fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(6, 5))</span><span id="0b92" class="nj mc it lv b gy no nl l nm nn">ax1.set_title('Before Scaling')<br/>sns.kdeplot(df['x1'], ax=ax1)<br/>sns.kdeplot(df['x2'], ax=ax1)<br/>sns.kdeplot(df['x3'], ax=ax1)<br/>ax2.set_title('After Standard Scaler')<br/>sns.kdeplot(scaled_df['x1'], ax=ax2)<br/>sns.kdeplot(scaled_df['x2'], ax=ax2)<br/>sns.kdeplot(scaled_df['x3'], ax=ax2)<br/>plt.show()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c51fa346ccdaeacacd0bf4e711c2eab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*zlZSLJ4923EJ4rVJOFlJeA.png"/></div></figure><p id="f53b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，所有要素的相对比例都相同。</p><h1 id="46e0" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">最小-最大缩放器</h1><p id="6c24" class="pw-post-body-paragraph jz ka it kb b kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw im bi translated"><code class="fe ls lt lu lv b">MinMaxScaler</code>可能是最著名的缩放算法，每个特征遵循以下公式:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nq"><img src="../Images/5db30a46868d7e56a43bd837582bdb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MDi7kf1jg2ZUlg0QLha4w.png"/></div></div></figure><p id="a0e5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">它实质上缩小了范围，使范围现在介于0和1之间(如果有负值，则为-1到1)。</p><p id="c83c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这个定标器更适用于标准定标器不太适用的情况。如果分布不是高斯分布或者标准偏差非常小，最小-最大缩放器会更好。</p><p id="6a84" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">但是，它对异常值很敏感，所以如果数据中有异常值，您可能需要考虑下面的<code class="fe ls lt lu lv b">Robust Scaler</code>。</p><p id="12da" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，让我们看看<code class="fe ls lt lu lv b">min-max</code>缩放器的运行</p><p id="985c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在[3]中:</p><pre class="ky kz la lb gt nf lv ng nh aw ni bi"><span id="6a92" class="nj mc it lv b gy nk nl l nm nn">df = pd.DataFrame({<br/>    # positive skew<br/>    'x1': np.random.chisquare(8, 1000),<br/>    # negative skew <br/>    'x2': np.random.beta(8, 2, 1000) * 40,<br/>    # no skew<br/>    'x3': np.random.normal(50, 3, 1000)<br/>})</span><span id="f676" class="nj mc it lv b gy no nl l nm nn">scaler = preprocessing.MinMaxScaler()<br/>scaled_df = scaler.fit_transform(df)<br/>scaled_df = pd.DataFrame(scaled_df, columns=['x1', 'x2', 'x3'])</span><span id="0d72" class="nj mc it lv b gy no nl l nm nn">fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(6, 5))<br/>ax1.set_title('Before Scaling')<br/>sns.kdeplot(df['x1'], ax=ax1)<br/>sns.kdeplot(df['x2'], ax=ax1)<br/>sns.kdeplot(df['x3'], ax=ax1)<br/>ax2.set_title('After Min-Max Scaling')<br/>sns.kdeplot(scaled_df['x1'], ax=ax2)<br/>sns.kdeplot(scaled_df['x2'], ax=ax2)<br/>sns.kdeplot(scaled_df['x3'], ax=ax2)<br/>plt.show()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1b232d99f29bad3aacadbd2f6e6cd7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*a_0N3pDkH5ySpuV55qEPqQ.png"/></div></figure><p id="1cd6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">请注意，分布的偏斜度保持不变，但3个分布被置于相同的范围内，因此它们重叠。</p><h1 id="9ee0" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">鲁棒定标器</h1><p id="325b" class="pw-post-body-paragraph jz ka it kb b kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw im bi translated"><code class="fe ls lt lu lv b">RobustScaler</code>使用与最小-最大缩放器类似的方法，但它使用四分位数范围，而不是最小-最大值，因此它对异常值具有鲁棒性。因此，它遵循以下公式:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ns"><img src="../Images/75162e7193fa67de07171e9c169475ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqf-0vFwr_IOg--zFCbyow.png"/></div></div></figure><p id="7f96" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">对于每个特性。</p><p id="8c44" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当然，这意味着它使用更少的数据进行缩放，因此更适合数据中有异常值的情况。</p><p id="68ac" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们来看看这个在一些有异常值的数据上的应用</p><p id="e3f0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在[4]中:</p><pre class="ky kz la lb gt nf lv ng nh aw ni bi"><span id="00d2" class="nj mc it lv b gy nk nl l nm nn">x = pd.DataFrame({<br/>    # Distribution with lower outliers<br/>    'x1': np.concatenate([np.random.normal(20, 1, 1000), np.random.normal(1, 1, 25)]),<br/>    # Distribution with higher outliers<br/>    'x2': np.concatenate([np.random.normal(30, 1, 1000), np.random.normal(50, 1, 25)]),<br/>})</span><span id="eaf1" class="nj mc it lv b gy no nl l nm nn">scaler = preprocessing.RobustScaler()<br/>robust_scaled_df = scaler.fit_transform(x)<br/>robust_scaled_df = pd.DataFrame(robust_scaled_df, columns=['x1', 'x2'])</span><span id="7f2e" class="nj mc it lv b gy no nl l nm nn">scaler = preprocessing.MinMaxScaler()<br/>minmax_scaled_df = scaler.fit_transform(x)<br/>minmax_scaled_df = pd.DataFrame(minmax_scaled_df, columns=['x1', 'x2'])</span><span id="8a95" class="nj mc it lv b gy no nl l nm nn">fig, (ax1, ax2, ax3) = plt.subplots(ncols=3, figsize=(9, 5))<br/>ax1.set_title('Before Scaling')<br/>sns.kdeplot(x['x1'], ax=ax1)<br/>sns.kdeplot(x['x2'], ax=ax1)<br/>ax2.set_title('After Robust Scaling')<br/>sns.kdeplot(robust_scaled_df['x1'], ax=ax2)<br/>sns.kdeplot(robust_scaled_df['x2'], ax=ax2)<br/>ax3.set_title('After Min-Max Scaling')<br/>sns.kdeplot(minmax_scaled_df['x1'], ax=ax3)<br/>sns.kdeplot(minmax_scaled_df['x2'], ax=ax3)<br/>plt.show()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8fedd587ef19054d3fca84ddb2c9e905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*7Ofb8EPbUDjjQDvCqzbZWg.png"/></div></figure><p id="63c5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">请注意，在稳健缩放后，分布被带入相同的比例并重叠，但异常值仍在新分布的主体之外。</p><p id="7511" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然而，在最小-最大比例中，两个正态分布被0-1范围内的异常值分开。</p><h1 id="b245" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">标准化者</h1><p id="e7dd" class="pw-post-body-paragraph jz ka it kb b kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw im bi translated">对于nn个特征，规格化器通过将每个值除以其在nn维空间中的大小来缩放每个值。</p><p id="69d0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">假设您的要素是x、y和z笛卡尔坐标，则x的缩放值为:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nu"><img src="../Images/bbf0cf48eb7ae7110497412b467c3b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdZ6xtug2aKEdN3aw6J8oQ.png"/></div></div></figure><p id="30dc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，每个点都在笛卡尔坐标系原点的1个单位内。</p><p id="ea4a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在[5]中:</p><pre class="ky kz la lb gt nf lv ng nh aw ni bi"><span id="1ac9" class="nj mc it lv b gy nk nl l nm nn"><strong class="lv jd">from</strong> <strong class="lv jd">mpl_toolkits.mplot3d</strong> <strong class="lv jd">import</strong> Axes3D</span><span id="4f61" class="nj mc it lv b gy no nl l nm nn">df = pd.DataFrame({<br/>    'x1': np.random.randint(-100, 100, 1000).astype(float),<br/>    'y1': np.random.randint(-80, 80, 1000).astype(float),<br/>    'z1': np.random.randint(-150, 150, 1000).astype(float),<br/>})</span><span id="5582" class="nj mc it lv b gy no nl l nm nn">scaler = preprocessing.Normalizer()<br/>scaled_df = scaler.fit_transform(df)<br/>scaled_df = pd.DataFrame(scaled_df, columns=df.columns)</span><span id="4ccc" class="nj mc it lv b gy no nl l nm nn">fig = plt.figure(figsize=(9, 5))<br/>ax1 = fig.add_subplot(121, projection='3d')<br/>ax2 = fig.add_subplot(122, projection='3d')<br/>ax1.scatter(df['x1'], df['y1'], df['z1'])<br/>ax2.scatter(scaled_df['x1'], scaled_df['y1'], scaled_df['z1'])<br/>plt.show()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/159130a06c94c03840f96d9c5007b1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*tu0QKOibSvubLiOcfhykXw.png"/></div></figure><p id="3430" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">请注意，所有的点都在一个球内，该球在任一点离原点最多1。此外，以前不同刻度的轴现在都是一个刻度。</p></div></div>    
</body>
</html>