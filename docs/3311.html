<html>
<head>
<title>A Step-by-Step Approach To Building a Text Summarization Webapp in Python From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一步一步从头开始用Python构建文本摘要Webapp</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-step-by-step-approach-to-building-a-text-summarization-webapp-in-python-from-scratch-5d6754306f3b?source=collection_archive---------0-----------------------#2022-11-16">https://pub.towardsai.net/a-step-by-step-approach-to-building-a-text-summarization-webapp-in-python-from-scratch-5d6754306f3b?source=collection_archive---------0-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cc65" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用拥抱脸推理API，Flask，HTML &amp; CSS</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/af75ee4bebeacc0d4af966269d5044ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sHxIW7eK4gwgtHeb"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">帕特里克·托马索在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b1f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">目的是什么？</em> </strong>构建一个可以获取输入文本并显示其<a class="ae kv" href="#e4e2" rel="noopener ugc nofollow">摘要</a>的web应用程序。</p><p id="74a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">我们要用什么？</em> </strong> <a class="ae kv" href="https://huggingface.co/docs/api-inference/index" rel="noopener ugc nofollow" target="_blank">抱紧脸加速推理API </a>，<a class="ae kv" href="https://flask.palletsprojects.com/en/2.2.x/" rel="noopener ugc nofollow" target="_blank"> Python Flask框架</a>，<a class="ae kv" href="https://en.wikipedia.org/wiki/HTML" rel="noopener ugc nofollow" target="_blank"> HTML </a>，<a class="ae kv" href="https://en.wikipedia.org/wiki/CSS" rel="noopener ugc nofollow" target="_blank"> CSS </a>。</p><p id="c126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">是怎么做到的？</em> </strong> <em class="ls"> </em>通过<em class="ls"> c </em>执行以下步骤。</p><blockquote class="lt lu lv"><p id="3ec4" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">三步流程</strong></p><p id="eab6" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><a class="ae kv" href="#a577" rel="noopener ugc nofollow"> <strong class="ky ir"> 1。从拥抱人脸库中识别文本摘要模型的推理API。</strong> </a></p><p id="e73e" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><a class="ae kv" href="#7ba3" rel="noopener ugc nofollow">2<strong class="ky ir">。用HTML和CSS构建前端。</strong> </a></p><p id="d846" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><a class="ae kv" href="#280f" rel="noopener ugc nofollow"> <strong class="ky ir"> 3。用Python Flask构建后端，并包含摘要任务。</strong> </a></p></blockquote><p id="2907" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi lz translated"><span class="l ma mb mc bm md me mf mg mh di">T</span>T<strong class="ky ir">ext summary</strong>是从给定的一组句子中提取摘要的任务。摘要可以有两种类型——抽象摘要<strong class="ky ir">或摘录摘要<strong class="ky ir"/>。摘要包含从给定输入中提取的<strong class="ky ir">个单词，</strong>将它们放在一起形成一个摘要。抽象摘要生成摘要<strong class="ky ir">不仅通过复制输入中的单词，还基于对文本的理解创造新单词。</strong></strong></p><p id="a490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://huggingface.co/docs/api-inference/index" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">拥抱面部加速推理API </strong> </a> <strong class="ky ir">构建一个抽象摘要应用程序。</strong>要通过向模型提供输入来利用模型，并获得模型的输出，我们只需进行API调用。</p><blockquote class="lt lu lv"><p id="9aaa" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">加速推理通过API调用实现了对机器学习模型的<strong class="ky ir">【即插即用】</strong>类型的使用。</p></blockquote><p id="6a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请参考下面的博客链接，通过一个实现演示来理解推理API的工作及其好处。</p><div class="mi mj gp gr mk ml"><a href="https://blog.jovian.ai/plug-and-play-ml-models-with-accelerated-inference-api-from-hugging-face-964d25d9dd65" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">即插即用的ML模型，带有来自拥抱脸的“加速推理API”</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">python实现的4步指南</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">blog.jovian.ai</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz kp ml"/></div></div></a></div><p id="25a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi lz translated">我们项目的web应用程序部分可以很容易地用<code class="fe na nb nc nd b">Flask</code>框架构建。Flask<a class="ae kv" href="https://www.tutorialspoint.com/flask/index.htm" rel="noopener ugc nofollow" target="_blank">帮助开发web应用程序，并呈现HTML文件，可以在web浏览器中查看。</a></p><div class="mi mj gp gr mk ml"><a href="https://flask.palletsprojects.com/en/2.2.x/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">欢迎使用Flask - Flask文档(2.2.x)</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">欢迎阅读Flask的文档。开始安装，然后了解快速入门概述。有…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">flask.palletsprojects.com</p></div></div><div class="mu l"><div class="ne l mw mx my mu mz kp ml"/></div></div></a></div><p id="3a83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi lz translated">我们的web应用程序的前端是用HTML和CSS构建的。超文本标记语言(HTML)和级联样式表(CSS)分别用于设计网页的结构和网页的呈现。</p><p id="508a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看了我们将要使用的所有东西的要点之后，让我们对我们将要构建的东西有一个概念。我们的网络应用将会有</p><ul class=""><li id="0e5d" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">一个<strong class="ky ir"> </strong>前端——一个网页，<strong class="ky ir">获取用户输入的</strong>文本，<strong class="ky ir">显示摘要</strong>作为输出。</li><li id="a673" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">后端——用户输入<strong class="ky ir">输入到模型中，从模型</strong>中提取和<strong class="ky ir">结果</strong>。</li></ul><p id="d3ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，请确保完成构建摘要应用程序的3步流程。</p><h2 id="a577" class="nt nu iq bd nv nw nx dn ny nz oa dp ob lf oc od oe lj of og oh ln oi oj ok ol bi translated">1.从拥抱脸中识别并利用文本摘要模型</h2><ul class=""><li id="f918" class="nf ng iq ky b kz om lc on lf oo lj op ln oq lr nk nl nm nn bi translated">对于我们的项目，我们将使用Lewis等人提供的模型<code class="fe na nb nc nd b"><a class="ae kv" href="https://github.com/facebookresearch/fairseq/tree/main/examples/bart" rel="noopener ugc nofollow" target="_blank">facebook/bart-large-cnn</a> </code>[<a class="ae kv" href="https://github.com/facebookresearch/fairseq/tree/main/examples/bart" rel="noopener ugc nofollow" target="_blank">BART</a>:自然语言生成、翻译和理解的去噪序列间预训练</li><li id="53fe" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">要使用模型的推理API，从拥抱人脸库中选择<a class="ae kv" href="https://huggingface.co/facebook/bart-large-cnn" rel="noopener ugc nofollow" target="_blank">模型</a>，然后点击<code class="fe na nb nc nd b">Deploy</code>按钮下的<code class="fe na nb nc nd b">Inference API</code>。</li><li id="3d0a" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">单击它，我们将看到一个python脚本，可以用于推理，如下所示。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/875810f0c533c3cf4eb1b6a703634872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNnKy4Ac18wzQgFbBdgjzg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">从拥抱脸中选择推理API</figcaption></figure><ul class=""><li id="09b9" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">需要一个<code class="fe na nb nc nd b">Access Token</code>来获得<code class="fe na nb nc nd b">API_URL and headers.</code></li><li id="7df9" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">在<a class="ae kv" href="https://huggingface.co/join" rel="noopener ugc nofollow" target="_blank">拥抱脸</a>中创建一个配置文件，并通过以下路径<code class="fe na nb nc nd b">Profile -&gt; Settings -&gt; Access Tokens Tab.</code>创建一个新的访问令牌</li><li id="360c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">新创建的访问令牌可以用来代替<code class="fe na nb nc nd b">Bearer and headers</code></li><li id="6d91" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">现在让我们进入项目的下一部分，创建一个web应用程序。</li></ul><h2 id="7ba3" class="nt nu iq bd nv nw nx dn ny nz oa dp ob lf oc od oe lj of og oh ln oi oj ok ol bi translated">2.用HTML和CSS构建前端。</h2><ul class=""><li id="c07e" class="nf ng iq ky b kz om lc on lf oo lj op ln oq lr nk nl nm nn bi translated">前端的代码由两部分组成<br/> —一个静态文件<br/> —一个HTML文件</li></ul><p id="8569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> T </span> <strong class="ky ir">何静态</strong>文件包含对<strong class="ky ir">我们前端的临时起意</strong>的定制。顾名思义，静态文件的内容不会根据用户的输入或动作而改变。静态文件可以包括任何内容，如图像、视频、级联样式表(CSS)、flash文件等。这些不是像典型的HTML响应一样由web服务器动态生成的，因为它们保持静态。</p><ul class=""><li id="42cb" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">在所需的位置，创建两个名为<code class="fe na nb nc nd b">static</code>和<code class="fe na nb nc nd b">templates</code>的文件夹</li><li id="8ea3" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">在<code class="fe na nb nc nd b">static </code>文件夹中，创建一个名为<code class="fe na nb nc nd b">main.css,</code>的新文件，其中CSS是用于设置HTML样式的级联样式表。</li><li id="5cdf" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe na nb nc nd b">main.css</code>由HTML代码中的标签及其相应的样式和格式组成。关于如何使用CSS的更详细的教程，请参考这个<a class="ae kv" href="https://www.w3schools.com/css/css_intro.asp" rel="noopener ugc nofollow" target="_blank">链接</a>。</li><li id="077c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">下面给出了静态文件<code class="fe na nb nc nd b">main.css </code>的代码，并附有解释。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><ul class=""><li id="1b29" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">正如我们所看到的，上面的CSS文件包含了HTML代码中使用的大多数标签的基于外观的格式和定制。</li></ul><p id="4120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">代码解释</strong></p><ul class=""><li id="cd9f" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第2行到第9行—包含针对标签<code class="fe na nb nc nd b">header</code>的样式和格式。</li><li id="38fa" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第11至25行—包含标签<code class="fe na nb nc nd b">h1.</code>的格式</li><li id="5e7a" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第28到34行——具有<code class="fe na nb nc nd b">body</code>标签的样式，以及一个名为<code class="fe na nb nc nd b">image.gif</code>的背景图像</li><li id="262d" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第35至39行——用于<code class="fe na nb nc nd b">container</code>的格式</li><li id="c720" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第41行到第47行——标记的样式，它指定了一些内容的划分</li><li id="8c8c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第49到64行—标签<code class="fe na nb nc nd b">h2</code>和<code class="fe na nb nc nd b">h3</code>的格式</li><li id="2d6a" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第68行到第77行——在标签<code class="fe na nb nc nd b">parent</code>和<code class="fe na nb nc nd b">child. </code>的帮助下，包含旨在并排放置两个文本框的格式。让我们继续用HTML代码创建前端。</li></ul><p id="3f07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi lz translated">构建HTML 的目的是提供一个结构化的令人愉快的用户界面，一个供用户输入的空间和一个显示摘要的空间。</p><ul class=""><li id="a282" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">在已经创建的名为<code class="fe na nb nc nd b">templates,</code>的文件夹中，创建一个名为<code class="fe na nb nc nd b">index.html</code>的新文件。</li><li id="cb0c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">下面给出了<code class="fe na nb nc nd b">index.html</code>的代码，并附有解释。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="97d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">代码解释</strong></p><ul class=""><li id="d307" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">第4到11行HTML的标题</li><li id="80f8" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第9行—我们添加了静态文件的源(<code class="fe na nb nc nd b">main.css</code>)。</li><li id="359a" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第10行——我们给我们的网页起了一个名为<code class="fe na nb nc nd b">Summarization Application</code>的标题。</li><li id="adc7" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第13到42行HTML的主体</li><li id="663c" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第14到19行—包含<code class="fe na nb nc nd b">header</code>标签，用于提供网页的介绍部分。在我们的例子中，我们给出了“我的摘要应用程序”</li><li id="8cbf" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第23行和第34行—创建了两个文本框并并排放置</li><li id="81c0" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第25到31行——为获取输入数据并将其发送到后端而创建的表单。我们利用<code class="fe na nb nc nd b">form action</code>指定提交的数据必须发送到<code class="fe na nb nc nd b">get_summary</code>后端编写的方法进行处理。</li><li id="47d7" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第27行——用于输入的文本框被创建，并以变量名<code class="fe na nb nc nd b">input_text</code>命名，该变量名在后端用于处理输入数据。</li><li id="2eff" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第29和30行—按钮<code class="fe na nb nc nd b">Submit </code>和<code class="fe na nb nc nd b">Clear</code>被创建。</li><li id="fbc3" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第38行——创建了一个用于显示输出的名为<code class="fe na nb nc nd b">result</code>的文本框，它在后端用于存储汇总文本。</li><li id="1e28" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">构建了web应用程序的前端之后，让我们继续构建后端。</li></ul><h2 id="280f" class="nt nu iq bd nv nw nx dn ny nz oa dp ob lf oc od oe lj of og oh ln oi oj ok ol bi translated">3.用Python Flask构建后端，并包含摘要任务。</h2><p id="7083" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf ou lh li lj ov ll lm ln ow lp lq lr ij bi translated">后端的工作是</p><ul class=""><li id="8600" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">从前端获取输入，</li><li id="88ca" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">通过将输入数据发送到摘要模型并收集其输出(摘要),利用拥抱脸的推理API</li><li id="71a7" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">将摘要发送到前端</li></ul><p id="eedc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将我们的后端python文件命名为<code class="fe na nb nc nd b">app.py,</code>，请参考下面给出的代码，后面是解释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><ul class=""><li id="4b54" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">我们要记住，前端和后端要用通用的变量名连接起来。</li><li id="1a69" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">摘要模型的输入是<br/> —要摘要的文本(从前端获得)<br/> —摘要的最小长度(初始化)<br/> —摘要的最大长度(初始化)</li></ul><p id="8c77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">代码解释</strong></p><ul class=""><li id="8789" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">首先，让我们使用命令<code class="fe na nb nc nd b">pip install flask</code>安装<code class="fe na nb nc nd b">Flask</code></li><li id="3e61" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第6行—包括静态文件的路径</li><li id="d2a9" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第7行到第9行— <code class="fe na nb nc nd b">index</code>方法来呈现<code class="fe na nb nc nd b">index.html</code>文件</li><li id="8784" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第12行到第38行— <code class="fe na nb nc nd b">get_summary</code>方法</li><li id="518a" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第15行和第16行—分别包括推理API和身份验证令牌的URL。确保在<code class="fe na nb nc nd b">Bearer</code>部分粘贴您的认证令牌。</li><li id="bc61" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第25行—使用变量<code class="fe na nb nc nd b">input_text</code>指定前端的输入</li><li id="e1f2" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第26和27行—用变量<code class="fe na nb nc nd b">min_len</code>和<code class="fe na nb nc nd b">max_len</code>指定摘要的最大和最小长度</li><li id="9c22" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第30到33行—将查询发送到模型，包括输入变量。结果存储在<code class="fe na nb nc nd b">output</code>变量中。</li><li id="9021" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">第36行——使用变量<code class="fe na nb nc nd b">result</code>将保存在<code class="fe na nb nc nd b">output[“summary_text”]</code>中的模型摘要发送到前端。</li><li id="5bcb" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">我们可以看到，连接前端和后端的常用变量名是<code class="fe na nb nc nd b">input_text, get_summary, result.</code></li><li id="ace0" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">该项目的完整代码在这个<a class="ae kv" href="https://github.com/dharini-projects/Summarization_Web_App" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a>中给出。</li></ul><h2 id="e4e2" class="nt nu iq bd nv nw nx dn ny nz oa dp ob lf oc od oe lj of og oh ln oi oj ok ol bi translated">汇总应用程序</h2><ul class=""><li id="c9fb" class="nf ng iq ky b kz om lc on lf oo lj op ln oq lr nk nl nm nn bi translated">运行<code class="fe na nb nc nd b">app.py</code> python代码时，前端(使用<code class="fe na nb nc nd b">main.css</code>和<code class="fe na nb nc nd b">index.html</code>文件创建)在本地主机<code class="fe na nb nc nd b">http://127.0.0.1:5000.</code>中呈现</li><li id="c68d" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">在浏览器中打开本地主机链接将为我们提供web应用程序。</li><li id="3a30" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">下面给出了输出的屏幕截图。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/2793adbc729f06906798a7494e058b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2Rm-CMrPotyEuKPqA0flA.jpeg"/></div></div></figure><ul class=""><li id="21e6" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">我们可以看到<code class="fe na nb nc nd b">Summarization Application</code>作为我们的页面标题，<code class="fe na nb nc nd b">MY SUMMARIZATION APP</code>作为标题内容，两个并排的文本框带有标题<code class="fe na nb nc nd b">Input Text</code>和<code class="fe na nb nc nd b">Summarized Text,</code>两个按钮<code class="fe na nb nc nd b">Submit</code>和<code class="fe na nb nc nd b">Clear.</code></li><li id="5155" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">如果在左侧框中给出一个输入文本并按下<code class="fe na nb nc nd b">Submit</code>按钮，则调用<code class="fe na nb nc nd b">get_summary</code>方法并利用摘要模型。</li><li id="97d6" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">在下面的截图中，我们可以看到输入的文本被粘贴，点击了<code class="fe na nb nc nd b">Submit</code>按钮。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/2cc70d1280201b8ab03adc32f67051dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KL3QF1pn1NeN0agkGHhXwg.jpeg"/></div></div></figure><ul class=""><li id="8049" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">结果调用了<code class="fe na nb nc nd b">get_summary</code>方法，地址栏的变化可以在下面的截图<code class="fe na nb nc nd b">(http://127.0.0.1:5000/get_summary)</code>中看到。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/4484e6fcec5a257ed79697a5c85be44b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miWaCsiU0EM-Z679517eWA.jpeg"/></div></div></figure><ul class=""><li id="b3eb" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">当调用<code class="fe na nb nc nd b">get_summary</code>方法时，使用摘要模型的推理API，输出显示在<code class="fe na nb nc nd b">Summarized Text</code>文本框中。</li></ul><p id="6fc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">万岁！！！我们已经成功地为自然语言处理中最流行的摘要任务创建了一个Web应用程序。</p><h2 id="8a38" class="nt nu iq bd nv nw nx dn ny nz oa dp ob lf oc od oe lj of og oh ln oi oj ok ol bi translated">摘要</h2><p id="1db3" class="pw-post-body-paragraph kw kx iq ky b kz om jr lb lc on ju le lf ou lh li lj ov ll lm ln ow lp lq lr ij bi translated">我们有一个关于摘要的<strong class="ky ir">介绍</strong>，我们将如何构建提取文本摘要的web应用程序，以及要使用的所有元素的要点。我们开始了解开发web应用程序的简单<strong class="ky ir"> 3步流程</strong>，从为任务从拥抱脸中选择一个<strong class="ky ir">模型</strong> <strong class="ky ir">开始。接下来，我们通过一个构建<strong class="ky ir">前端</strong>的代码示例理解了HTML和CSS的用法。接下来，我们用一个构建<strong class="ky ir">后端</strong>的代码示例来推断Flask的用法。最后，我们看到了我们努力工作的成果，有回报的<strong class="ky ir">摘要网络应用</strong>。同样的过程可以扩展到使用来自拥抱脸的模型来构建任何其他类型的<strong class="ky ir">自然语言处理任务</strong>。继续你的任务并取得成功！！！！</strong></p></div></div>    
</body>
</html>