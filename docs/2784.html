<html>
<head>
<title>How Data Science Depends on Pandas and Numpy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学如何依赖熊猫和Numpy？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-data-science-depends-on-pandas-and-numpy-377eb9c4b673?source=collection_archive---------1-----------------------#2022-05-25">https://pub.towardsai.net/how-data-science-depends-on-pandas-and-numpy-377eb9c4b673?source=collection_archive---------1-----------------------#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="61ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熊猫和Numpy在数据科学和机器学习中发挥着至关重要的作用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56122ff86c59cbe9f381d144e316bdf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7fCVUMVNUIe3gw4f"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·丘马克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简介</strong></p><p id="31c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你从网上提取数据时，获得的数据不一定总是干净的或结构化的，对吗？Python为我们提供了一个特性，使用Pandas data frames(Python中的一个包)来构造这些杂乱的数据。</p><p id="29eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论熊猫数据框之前，让我们先了解一下什么是数据框。数据帧以二维结构的形式存储数据；以由行和列组成的表格的形式。这意味着表中的每一行都可以是任何数据类型:数值、字符、空或非空。</p><p id="233b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫数据框与普通数据框相似，唯一的区别是列可以是不同的类型。一般来说，Pandas数据框架由三个主要部分组成:索引、列和数据。</p><p id="0f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过熊猫数据框架来看几个实际例子。</p><p id="ed30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>确保在使用Pandas数据框时导入以下库:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5541" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>Import pandas as  pd</span></pre><h2 id="4e54" class="ma mb it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">涵盖的主题</h2><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="84e9" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">1. Creating an Empty data frame<br/>2. Dates in Pandas dataframe while importing data<br/>3. Reshaping a dataframe<br/>4. Iterating a dataframe<br/>5. Writing a dataframe to a file</strong></span></pre><blockquote class="mx my mz"><p id="44c4" class="kz la na lb b lc ld ju le lf lg jx lh nb lj lk ll nc ln lo lp nd lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">创建空数据帧</em> </strong></p></blockquote><p id="519a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Pandas开发一个空数据框；来获取我们将来要添加的数据的结构。</p><p id="bf58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Pandas中，数据框是通过使用' data frame()'函数和传递值来创建的:数据、列和索引。</p><p id="39d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看它是如何工作的:</p><p id="56c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><p id="5f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> #1 </strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1f40" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span><span id="431d" class="ma mb it lw b gy ne md l me mf">dF = pd.DataFrame(np.nan, index=[0,1,2,3], columns=[‘Column1’])<br/>print(dF)</span></pre><p id="80b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> #2 </strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8d50" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span><span id="e829" class="ma mb it lw b gy ne md l me mf">dF=pd.DataFrame(index=range(0,5),columns=['Column1'], dtype=’str’)</span><span id="45b9" class="ma mb it lw b gy ne md l me mf">print(dF)</span></pre><p id="b155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0a04" class="ma mb it lw b gy mc md l me mf">Column1</span><span id="2f44" class="ma mb it lw b gy ne md l me mf">0 NaN<br/>1 NaN<br/>2 NaN<br/>3 NaN</span></pre><p id="e0ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="a10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个程序中，你可以看到我们正在使用' DataFrame()'函数。在函数内部，我们将值作为“np.nan”进行传递，用nan值初始化您的数据框。接下来，我们初始化索引值，并为包含NaN值的列提供一个名称。当程序运行时，您将得到一个由nan组成的数据框，输入列名和索引。</p><p id="97fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:'</strong> np.nan '默认为' float '数据类型。</p><p id="0c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个程序与第一个程序有一点不同。在某些情况下，您可能需要数据框具有特定的数据类型。在这种情况下，我们使用这种方法。这里，我们只是初始化数据框的索引、列名和数据类型。获得的输出将与第一个程序的输出相同。</p><blockquote class="mx my mz"><p id="606e" class="kz la na lb b lc ld ju le lf lg jx lh nb lj lk ll nc ln lo lp nd lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">导入数据时熊猫数据框中的日期</em> </strong></p></blockquote><p id="1ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫在导入数据时发现很难识别日期。但是有一种方法可以让它识别，那就是传递“parse_dates”参数。</p><p id="0333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例如:从CSV文件中读取数据</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fcfd" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="ee48" class="ma mb it lw b gy ne md l me mf">pd.read_csv(‘filename’, parse_dates=True)</span></pre><p id="4fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">#或此选项:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e575" class="ma mb it lw b gy mc md l me mf">pd.read_csv(‘filename’, parse_dates=[‘C_name’])</span></pre><p id="2c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的程序是为了帮助熊猫识别日期列。</p><p id="27e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有时候，即使传递了这个参数，解析器也会抛出一个错误。这主要是由于格式问题。下面的程序将告诉你解决这个问题的方法。</p><p id="63ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">节目:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8f76" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="b613" class="ma mb it lw b gy ne md l me mf">parser = lambda x: pd.datetime.strptime(x, ‘%Y-%m-%d %H:%M:%S’)</span><span id="caf7" class="ma mb it lw b gy ne md l me mf"># read command:<br/>pd.read_csv(infile, parse_dates=[‘Column1’], date_parser=parser)</span><span id="f081" class="ma mb it lw b gy ne md l me mf"># Or combine two columns to one DateTime column<br/>pd.read_csv(infile, parse_dates={‘datetime’: [‘date’, ‘time’]}, date_parser=parser)</span></pre><p id="2042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解说:</strong></p><p id="e84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在Pandas中处理日期时，检查格式是很重要的。这是因为熊猫遵循特定的格式，当我们试图读取包含日期列的CSV或excel文件时，它可能会抛出错误。但是我们可以通过创建自己的解析器来解决这个问题，也就是说，通过使用lambda函数。这里，我们创建了一个lambda函数，它将获取日期时间并使用字符串格式控制它。</p><blockquote class="mx my mz"><p id="17bc" class="kz la na lb b lc ld ju le lf lg jx lh nb lj lk ll nc ln lo lp nd lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">重塑一个数据帧</em> </strong></p></blockquote><p id="6104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对数据框进行整形，使生成的结构更易于理解，以便分析获得的数据。这一步在数据分析领域非常关键。重塑不仅仅意味着格式化；也改变了我们看待或处理数据的方式。</p><p id="d318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看一些重塑技术:</p><ul class=""><li id="7269" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">旋转数据框</strong></li></ul><p id="f73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用pivot()函数旋转数据框。此函数以一种由于大量值而导致多个索引列的方式重塑数据框。</p><p id="d851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong> pivot()函数不支持数据聚合</p><p id="4a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pivot()函数基本上有3个参数:</p><ol class=""><li id="ca45" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu no nl nm nn bi translated"><strong class="lb iu">值:</strong>您可以指定希望在数据透视表中看到的原始数据框中的值。</li><li id="cec0" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu no nl nm nn bi translated"><strong class="lb iu">列:</strong>这将是结果表中的列。</li><li id="b4a7" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu no nl nm nn bi translated"><strong class="lb iu">索引:</strong>这将是最终表格中的索引。</li></ol><p id="b2d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="537c" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span><span id="96cf" class="ma mb it lw b gy ne md l me mf"># Creating your DataFrame</span><span id="6e33" class="ma mb it lw b gy ne md l me mf">products = pd.DataFrame({</span><span id="6daf" class="ma mb it lw b gy ne md l me mf">‘category’: [‘Red’, ‘Red’, ‘Blue’, ‘Blue’, ‘White’, ‘White’],<br/>‘Shade’: [‘Dark’, ‘Light’, ‘Dark’, ‘Medium’, ‘Light’,’Dark’],<br/>‘Cost’:[11.42, 23.50, 19.99, 15.95, 55.75, 111.55]<br/>})</span><span id="25e7" class="ma mb it lw b gy ne md l me mf">pivot_products = products.pivot(index=’category’, columns=’Shade’, values=’Cost’)</span><span id="0108" class="ma mb it lw b gy ne md l me mf">print(pivot_products)</span></pre><p id="72ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6c2a" class="ma mb it lw b gy mc md l me mf">Shade        Dark     Light     Medium<br/>category</span><span id="4ede" class="ma mb it lw b gy ne md l me mf">Blue          19.99    NaN       15.95</span><span id="55a1" class="ma mb it lw b gy ne md l me mf">Red           11.42    23.50      NaN</span><span id="d023" class="ma mb it lw b gy ne md l me mf">White         111.55   55.75      NaN</span></pre><p id="3a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="9f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们首先传递所有三个参数来形成数据框。然后我们使用pivot()函数，它最终将整形后的数据显示为输出。</p><p id="5a2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:需要注意的是，你的数据不能包含重复的列值，否则你会得到一个错误信息。如果您的数据不是唯一的，那么尝试pivot_table()方法。</p><ul class=""><li id="173d" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">使用Melt()重塑数据帧</strong></li></ul><p id="1707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的数据中有多个列是标识符变量时，可以使用melting方法。</p><p id="cddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="429e" class="ma mb it lw b gy mc md l me mf"># The DataFrame</span><span id="e39d" class="ma mb it lw b gy ne md l me mf">people = pd.DataFrame({‘First Name’ : [‘Mary’, ‘Peter’],</span><span id="23aa" class="ma mb it lw b gy ne md l me mf">‘Last Name’ : [‘Tony’, ‘Pepper’],</span><span id="3f05" class="ma mb it lw b gy ne md l me mf">‘Subject’ : [‘English’, ‘Math’],</span><span id="82ae" class="ma mb it lw b gy ne md l me mf">‘Marks’ : [90, 84]})</span></pre><p id="4cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用熔化()数据帧</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="91b4" class="ma mb it lw b gy mc md l me mf">print(pd.melt(people, id_vars=[‘First Name’, ‘Last Name’], var_name=’Categories’))</span></pre><p id="6a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2c89" class="ma mb it lw b gy mc md l me mf">   First Name      Last Name     Categories    value</span><span id="f334" class="ma mb it lw b gy ne md l me mf">0    Mary           Tony           Subject     English</span><span id="a555" class="ma mb it lw b gy ne md l me mf">1    Peter          Pepper         Subject      Math</span><span id="57c2" class="ma mb it lw b gy ne md l me mf">2    Mary           Tony           Marks        90</span><span id="7f89" class="ma mb it lw b gy ne md l me mf">3    Peter          Pepper         Marks        84</span></pre><p id="290a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="640e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建数据框。接下来，我们将使用“melt”函数，其中我们将第一个参数作为“people”(创建的数据框)传递。然后是标识符变量(名、姓)，最后是所有测量值(主题、标记将在“类别”列名下)。</p><blockquote class="mx my mz"><p id="216e" class="kz la na lb b lc ld ju le lf lg jx lh nb lj lk ll nc ln lo lp nd lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">迭代数据帧</em> </strong></p></blockquote><p id="fc3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e5e0" class="ma mb it lw b gy mc md l me mf">import numpy as np</span><span id="b3a1" class="ma mb it lw b gy ne md l me mf">df = pd.DataFrame(data=np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]]), columns=[‘col1’, ‘col2’, ‘col3’])</span><span id="8b3c" class="ma mb it lw b gy ne md l me mf">for index, row in df.iterrows() :<br/>    print(row[‘col1’], row[‘col2’], row[‘col3’])</span></pre><p id="f436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="289d" class="ma mb it lw b gy mc md l me mf">10 11 12<br/>13 14 15<br/>16 17 18</span></pre><p id="f8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="a7db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的程序使用一个for循环和一个itterrows()函数的组合来迭代一系列数据。首先，我们创建了一个数据框。接下来，当调用print函数时，它首先显示“col1”中的所有值。当循环结束时，它移动到下一行，并继续打印下一列的值，直到循环结束。</p><blockquote class="mx my mz"><p id="4d5d" class="kz la na lb b lc ld ju le lf lg jx lh nb lj lk ll nc ln lo lp nd lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">将数据帧写入文件</em> </strong></p></blockquote><p id="1861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="10a9" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#1</strong></span><span id="1da0" class="ma mb it lw b gy ne md l me mf">import pandas as pd<br/>df.to_csv(‘filename.csv’)</span><span id="44ba" class="ma mb it lw b gy ne md l me mf"><strong class="lw iu">#2 — delimiting by a tab</strong></span><span id="2fe1" class="ma mb it lw b gy ne md l me mf">import pandas as pd<br/>df.to_csv(‘filename.csv’, sep=’\t’)</span><span id="fd27" class="ma mb it lw b gy ne md l me mf"><strong class="lw iu">#3 — writing a dataframe to excel</strong></span><span id="b0c2" class="ma mb it lw b gy ne md l me mf">import pandas as pd</span><span id="bedf" class="ma mb it lw b gy ne md l me mf">writer = pd.ExcelWriter(‘filename.xlsx’)<br/>df.to_excel(writer, ‘DataFrame’)<br/>writer.save()</span></pre><p id="8351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">说明:</strong></p><p id="7d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个程序向我们展示了将pandas数据帧写入CSV文件的语法。但是现在，你的数据是用CSV格式写的，没有任何分隔符。所以，如果你想添加一个分隔符，使用' sep '参数，如第二个程序所示。第三个程序是将数据框写入并保存到excel文件中。</p><blockquote class="mx my mz"><p id="6a47" class="kz la na lb b lc ld ju le lf lg jx lh nb lj lk ll nc ln lo lp nd lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">结论</em> </strong></p></blockquote><p id="de0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，本文涵盖了Pandas数据框架中的一些重要主题。我强烈建议阅读更多的文章，并使用python程序应用这些概念。</p><p id="4f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae ky" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。</p><h1 id="d80b" class="nu mb it bd mg nv nw nx mj ny nz oa mm jz ob ka mp kc oc kd ms kf od kg mv oe bi translated">推荐文章</h1><p id="8b2b" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">1.<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b">8 Python的主动学习见解收集模块</a> <br/> 2。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a>T5】3。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/pandas-dealing-with-categorical-data-7547305582ff?source=friends_link&amp;sk=11c6809f6623dd4f6dd74d43727297cf">熊猫:处理分类数据</a> <br/> 5。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/hyper-parameters-randomseachcv-and-gridsearchcv-in-machine-learning-b7d091cf56f4?source=friends_link&amp;sk=cab337083fb09601114a6e466ec59689">超参数:机器学习中的RandomSeachCV和GridSearchCV</a><br/>6。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/data-distribution-using-numpy-with-python-3b64aae6f9d6?source=friends_link&amp;sk=809e75802cbd25ddceb5f0f6496c9803">数据分发使用Numpy与Python </a> <br/> 9。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/decision-trees-vs-random-forests-in-machine-learning-be56c093b0f?source=friends_link&amp;sk=91377248a43b62fe7aeb89a69e590860">机器学习中的决策树vs随机森林</a> <br/> 10。<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/standardization-in-data-preprocessing-with-python-96ae89d2f658?source=friends_link&amp;sk=f348435582e8fbb47407e9b359787e41">用Python实现数据预处理的标准化</a></p></div></div>    
</body>
</html>