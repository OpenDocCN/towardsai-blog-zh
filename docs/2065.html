<html>
<head>
<title>An Overview of Data Preprocessing: Converting Variables — Column Transformers, OneHotEncoding, Label Binarizer, Standardization, Normalization, Robust Scaling, and more</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理概述:转换变量-列转换器、OneHotEncoding、标签二进制化、标准化、规范化、鲁棒缩放等等</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/an-overview-of-data-preprocessing-converting-variables-column-transformers-onehotencoding-9ff521362159?source=collection_archive---------2-----------------------#2021-08-05">https://pub.towardsai.net/an-overview-of-data-preprocessing-converting-variables-column-transformers-onehotencoding-9ff521362159?source=collection_archive---------2-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="294b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-analysis" rel="noopener ugc nofollow" target="_blank">数据分析</a></h2><div class=""/><div class=""><h2 id="e62d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在一个视图中用python实现有用的数据预处理方法</h2></div><p id="6864" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">数据集应该适用于机器学习中训练的数据和算法做出的预测，以产生更成功的结果。每一列都有不同的特征，如有必要，应该对每一列应用不同的方法。例如，当分类数据转换为数字数据时，可以获得更好的结果。这里要区分的是选择适合模型和项目的数据预处理方法。这篇文章包含了不同的角度来看待数据集，以使算法更容易学习数据集。使用python应用程序，所有研究都变得更容易理解。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="4fd1" class="lw lx it ls b gy ly lz l ma mb">Table of Contents (TOC)<br/>1. Categorical Variables<br/>1.1. Column Transformers, OneHotEncoding, Dummy Coding<br/>1.2. Label Encoder<br/>1.3. Ordinal Encoder<br/>1.4. Label Binarizer<br/>2. Numeric Variables<br/>2.1. Standardization<br/>2.2. Normalization<br/>2.3. L² Regularization<br/>2.4. Robust Scaler</span></pre><figure class="ln lo lp lq gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mc"><img src="../Images/cb5c0f9b9e37633882f91d00f1398940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FxKqhLyVp7eNntXG"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">由<a class="ae mo" href="https://unsplash.com/@gaellemarcel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">盖尔·马塞尔</a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2152" class="mp lx it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">1.分类变量</h1><p id="578e" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">数据集中的列准备好由算法处理，它们可以连续呈现<em class="nl">(连续特征)</em>，或者它们可以连续呈现而没有变化，例如，当我们考虑鸢尾数据集时，一种花是鸢尾、杂色鸢尾或弗吉尼亚鸢尾。在这些类型中间，它不能有任何值。这样的数据集称为<em class="nl">分类特征</em>，有必要使这些列适合算法(将分类数据转换为数字数据)。这些方法将在下面解释，并用python实现。</p><h2 id="11cf" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">1.1.列转换器、一个热编码和虚拟编码</h2><p id="3477" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">分类列和数字列的过程是不同的。使用列转换器，可以同时对数据集中的列执行多种不同的预处理操作。</p><p id="81ed" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">OneHotEncoding将每种类型的分类数据转换成一列，并使数据集成为数值。例如，在数据集中，它添加了两个新列，男性和女性，而不是性别列中的男性/女性选项，对于女性数据:男性选项分配0，女性选项分配1，反之亦然。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="88db" class="lw lx it ls b gy ly lz l ma mb">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="9403" class="lw lx it ls b gy nw lz l ma mb">IN[1]<br/>data=pd.read_csv('toy_dataset.csv')<br/>data</span></pre><figure class="ln lo lp lq gt md gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4e2df8dafc11f338c5f3934d4d0bb381.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*FD1LwcgttzxjzvmxP2BC4g.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">图一。OUT[1]，作者图片</figcaption></figure><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="d885" class="lw lx it ls b gy ly lz l ma mb">from sklearn.compose import make_column_transformer<br/>from sklearn.preprocessing import OneHotEncoder<br/>from sklearn.preprocessing import MinMaxScaler</span><span id="099c" class="lw lx it ls b gy nw lz l ma mb">IN[2]<br/>ohe=OneHotEncoder(sparse=False)<br/>scaler = MinMaxScaler()<br/>ct=make_column_transformer((ohe,['City','Gender','Illness']),<br/>                      (scaler,  ['Income']),remainder='passthrough')<br/>data_ct=ct.fit_transform(data)<br/>data_ct<br/></span></pre><figure class="ln lo lp lq gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ny"><img src="../Images/8bd3e6d5250f89dbf103b55b24d9cb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yFr5jzXLT44EGYAwp9c_oQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">图二。OUT[2]，作者图片</figcaption></figure><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9fb2" class="lw lx it ls b gy ly lz l ma mb">IN[3]<br/>ohe_True=OneHotEncoder(sparse=True)<br/>ohe_with_sparse=ohe_True.fit_transform(data['Gender'].values.reshape(-1,1)).toarray()<br/>ohe_with_sparse<br/><strong class="ls jd">OUT[3]<br/>array([[0., 1.],<br/>       [0., 1.],<br/>       [0., 1.],<br/>       ...,<br/>       [0., 1.],<br/>       [0., 1.],<br/>       [1., 0.]])</strong></span></pre><p id="e266" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对pandas中的<em class="nl"> pandas.get_dummies </em>执行相同的程序。然而，OneHotEncoder是机器学习研究的首选。因为OneHotEncoder来自transformer类，并且是用fit命令应用的。一旦应用，它可以根据所学的类别转换下一步的数据，配合管道使用也很方便。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="57e2" class="lw lx it ls b gy ly lz l ma mb">IN[4]<br/>dum=pd.get_dummies(data,columns=['Gender','City','Illness'],prefix='',prefix_sep='')</span></pre><figure class="ln lo lp lq gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nz"><img src="../Images/9bd10cc46baa5dd817a976c7633a5ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-twYy20WT4iJhqcGUr2Lbw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">图3。OUT[4]，图片由作者提供</figcaption></figure><p id="23e9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们看看OneHotEncoder超参数。</p><ul class=""><li id="b46f" class="oa ob it kt b ku kv kx ky la oc le od li oe lm of og oh oi bi translated">稀疏:由于数据集包含大量“0”值，稀疏被定义为0。但是，当设置了Sparse=False并且。toarray()后，数据集就可以读取了。</li><li id="bea2" class="oa ob it kt b ku oj kx ok la ol le om li on lm of og oh oi bi translated">Handle_unknown:当该参数设置为“ignore”并且在转换过程中遇到未知类别时，该特性的结果独热编码列将全为零。</li></ul><h2 id="0145" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">1.2.标签编码器</h2><p id="cfcc" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">分类数据从0开始转换为数字，并以算术方式递增。例如，包含红色、白色、蓝色数据的列；变化0对应红色，1对应白色，3对应蓝色。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9a05" class="lw lx it ls b gy ly lz l ma mb">IN[5]<br/>from sklearn.preprocessing import LabelEncoder<br/>le=LabelEncoder()<br/>encoded_data_city=le.fit_transform(data['City'])<br/>print("Cities",np.unique(encoded_data_city))<br/>encoded_data_gender=le.fit_transform(data['Gender'])<br/>print("Gender",np.unique(encoded_data_gender))<br/><strong class="ls jd">OUT[5]<br/>Cities [0 1 2 3 4 5 6 7]<br/>Gender [0 1]</strong></span></pre><h2 id="6bfb" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">1.3.顺序编码器</h2><p id="c81d" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">序号编码器的作用与标签编码器相同。序数编码器之间的区别用于特征，尽管标号编码器用于标号(目标),因此序数编码器用(样本数，特征数)拟合数据，而标号编码器用(样本数)</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9ac2" class="lw lx it ls b gy ly lz l ma mb">IN[6]<br/>from sklearn.preprocessing import OrdinalEncoder<br/>oe=OrdinalEncoder(categories=[dictionary])<br/>encoded_data_city=oe.fit_transform(data[['City']])<br/>print("Cities", np.unique(encoded_data_city))<br/><strong class="ls jd">OUT[6]<br/>Cities [0. 1. 2. 3. 4. 5. 6. 7.]</strong></span></pre><h2 id="ada0" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">1.4.标签二值化器</h2><p id="97ac" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">标签二进制化器具有与OneHotEncoding相同的功能。区别在于OHE用于多列数据，而LabelBinarizer仅用于单列。它用于LabelEncoder中的单个列。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="6111" class="lw lx it ls b gy ly lz l ma mb">IN[7]<br/>from sklearn import preprocessing<br/>lb = preprocessing.LabelBinarizer()<br/>label_city=lb.fit_transform(data['City'])<br/>label_city<br/><strong class="ls jd">OUT[7]<br/>array([[0, 0, 1, ..., 0, 0, 0],<br/>       [0, 0, 1, ..., 0, 0, 0],<br/>       [0, 0, 1, ..., 0, 0, 0],<br/>       ...,<br/>       [1, 0, 0, ..., 0, 0, 0],<br/>       [1, 0, 0, ..., 0, 0, 0],<br/>       [1, 0, 0, ..., 0, 0, 0]])</strong></span></pre><h1 id="daa8" class="mp lx it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">2.数字变量</h1><p id="1bd7" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">重新调整数值变量对于算法给出更准确的结果非常重要。多亏了Rescale，所有的数字数据都按照一定的规则在一定的范围内进行排序。现在我们来看看这些方法。</p><h2 id="ee32" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">2.1.标准化</h2><p id="4fb5" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">该列的平均值被赋值为0，所有其他数值被方差1包围。</p><figure class="ln lo lp lq gt md gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/86cb7a18ec40e92da9cb239dbf28bf76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*i3nuJ5jPssobgw7W3uWVzg.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">图4。<a class="ae mo" href="https://www.oreilly.com/library/view/feature-engineering-for/9781491953235/" rel="noopener ugc nofollow" target="_blank">标准化，来源</a></figcaption></figure><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="020e" class="lw lx it ls b gy ly lz l ma mb">IN[8]<br/>from sklearn.preprocessing import StandardScaler<br/>scaler = StandardScaler()<br/>data_standardscaler=scaler.fit_transform(data[['Income']])<br/>data_standardscaler<br/><strong class="ls jd">OUT[8]<br/>array([[-2.03629388],<br/>       [-1.84753398],<br/>       [-1.55144865],<br/>       ...,<br/>       [ 0.82563756],<br/>       [ 0.82535744],<br/>       [-0.16013972]])</strong></span></pre><h2 id="9f3e" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">2.2.正常化</h2><p id="a6ea" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">列中的数字数据分布在0和1之间，最小数据为0，最大数据为1。</p><figure class="ln lo lp lq gt md gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ac310308210a88941f8171ce6f8277f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*0gMwQk8vloN1fY_vDSe7JQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">图5。正常化，<a class="ae mo" href="https://www.oreilly.com/library/view/feature-engineering-for/9781491953235/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="8b76" class="lw lx it ls b gy ly lz l ma mb">IN[9]<br/>from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler()<br/>data_minmaxscaler=scaler.fit_transform(data[['Income']])<br/>data_minmaxscaler<br/><strong class="ls jd">OUT[9}<br/>array([[0.23070001],<br/>       [0.25722818],<br/>       [0.29883978],<br/>       ...,<br/>       [0.6329136 ],<br/>       [0.63287423],<br/>       [0.49437324]])</strong></span></pre><h2 id="a534" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">2.3.l正规化</h2><p id="eaf8" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">L2归一化也称为欧几里德范数。所有数据都放在-1和1之间。</p><figure class="ln lo lp lq gt md gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/bcf15e612a143ca4cf63bf679eda3fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*nVsccHNaXaTV4c880cBYIQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">图6。L2正常化，<a class="ae mo" href="https://www.oreilly.com/library/view/feature-engineering-for/9781491953235/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="cfd1" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">2.4.鲁棒定标器</h2><p id="fd43" class="pw-post-body-paragraph kr ks it kt b ku ng kd kw kx nh kg kz la ni lc ld le nj lg lh li nk lk ll lm im bi translated">计算中间值和分位数区间(IQR)。</p><p id="a9b2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">new_x(i) = [x(i) —中值]/IQR</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="36fb" class="lw lx it ls b gy ly lz l ma mb">IN[10]<br/>from sklearn.preprocessing import RobustScaler<br/>scaler = RobustScaler()<br/>data_robust=scaler.fit_transform(data[['Income']])<br/>data_robust</span><span id="15a3" class="lw lx it ls b gy nw lz l ma mb"><strong class="ls jd">OUT[10]<br/>array([[-2.2530733 ],<br/>       [-2.05363353],<br/>       [-1.74079594],<br/>       ...,<br/>       [ 0.77078379],<br/>       [ 0.77048782],<br/>       [-0.27076793]])</strong></span></pre><h2 id="0edf" class="lw lx it bd mq nm nn dn mu no np dp my la nq nr na le ns nt nc li nu nv ne iz bi translated">回到指引点击<a class="ae mo" href="https://ibrahimkovan.medium.com/machine-learning-guideline-959da5c6f73d" rel="noopener">这里</a>。</h2><div class="or os gp gr ot ou"><a href="https://ibrahimkovan.medium.com/machine-learning-guideline-959da5c6f73d" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">机器学习指南</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">本文旨在准备一个机器学习数据库，以便在一个视图中显示所有的机器学习标题。这个…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">ibrahimkovan.medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi mi ou"/></div></div></a></div></div></div>    
</body>
</html>