<html>
<head>
<title>Community Detection with Node2Vec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node2Vec进行社区检测</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/community-detection-with-node2vec-6cd5a40c7155?source=collection_archive---------0-----------------------#2022-04-26">https://pub.towardsai.net/community-detection-with-node2vec-6cd5a40c7155?source=collection_archive---------0-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Node2Vec和集群模型在Python中构建社区检测管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/983d64f91ff48422b3132cc6c7a9d592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSsJs0tBxuGTaTSVIqAjCg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@joshrh19" rel="noopener ugc nofollow" target="_blank">约书亚·罗森-哈里斯</a>从<a class="ae ky" href="https://unsplash.com/photos/KRELIShKxTM" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将是一篇关于如何使用node2vec和集群模型识别网络中的社区的教程。下面重点介绍文章的结构:</p><h2 id="ff2c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">目录</h2><ul class=""><li id="0bb9" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">什么是社区检测？<br/> -社区检测&amp;聚类</li><li id="5594" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">问题陈述</li><li id="9125" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">解决方案架构<br/> -需求</li><li id="4324" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">合成网络</li><li id="1c3d" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">应用节点2Vec</li><li id="1539" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">应用光谱聚类</li><li id="ed26" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">识别社区</li><li id="a9b4" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">结束语</li><li id="3af7" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">资源</li></ul><h1 id="6caa" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">什么是社区检测？</h1><p id="9715" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在图论中，如果您能够根据节点的边密度对节点(可能有重叠的节点)进行分组，则网络具有社区结构。这将意味着原始网络G1可以被自然地分成多个子图/社区，其中社区内的边连通性将非常密集。重叠社区也是允许的，因此在形成的社区中可以有重叠节点。这意味着独立社区中的节点具有稀疏数量的边。</p><blockquote class="ns nt nu"><p id="0fdb" class="kz la nv lb b lc ld ju le lf lg jx lh nw lj lk ll nx ln lo lp ny lr ls lt lu im bi translated"><em class="it">更一般的定义是基于这样的原则:如果节点对都是相同社区的成员，则它们更有可能被连接，而如果它们不共享社区，则它们不太可能被连接。<br/>【1】—</em><a class="ae ky" href="https://en.wikipedia.org/wiki/Community_structure" rel="noopener ugc nofollow" target="_blank"><em class="it">https://en.wikipedia.org/wiki/Community_structure</em></a></p></blockquote><p id="f7df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直观地想到这一点，就有道理了。想想你自己在Instagram这样的社交网络中。你可能与许多与你感兴趣的事物相关的不同社区有着密切的联系。你可以关注与朋友、迷因、体育、动漫等相关的账户。这些分类中的每一个都可以被解释为社区，其中你作为一个用户是一个节点，边是通过将你连接到与你有相似兴趣的其他用户而生成的。因此，在你自己的社交网络中，你会有一个非常密集的社区，而与你社区之外的其他人联系很少。</p><p id="132e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多数学公式用于识别给定网络中的社区。算法如<a class="ae ky" href="https://en.wikipedia.org/wiki/Louvain_method" rel="noopener ugc nofollow" target="_blank">卢万</a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Girvan%E2%80%93Newman_algorithm" rel="noopener ugc nofollow" target="_blank">格文-纽曼</a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank">雅各布分数</a>等。所有这些都可以在网络上应用，以解决社区检测中的问题。</p><h2 id="b01d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">社区检测和聚类</h2><p id="d6a2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有一个灰色区域表示社区检测和聚类之间的差异，许多人认为它们是相同的。一个区别是，社区检测是指基于网络结构生成节点组，而聚类侧重于基于与输入数据相关联的许多属性生成组。尽管我们将在本文中使用聚类模型，但我指的是更接近社区检测的方法。这是因为我们还将使用node2vec来生成与每个节点相关联的输入嵌入向量。Node2Vec将是实现这一工作的秘密武器，该算法旨在为每个节点生成嵌入，同时保留图的初始结构。有关Node2Vec的更多信息，您可以参考这篇文章。</p><h1 id="6ad6" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">问题陈述</h1><p id="54cb" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">给定一个网络，创建一个管道，将初始网络分割成相关的社区。</p><h1 id="2816" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">解决方案架构</h1><p id="8194" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">给定一些表格输入数据(我们将综合这些数据)，我们将开始创建一个网络。创建网络后，我们可以在其上运行node2vec来生成与每个节点相关联的节点嵌入。嵌入向量可以被传递给像<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html" rel="noopener ugc nofollow" target="_blank">谱聚类</a>这样的聚类算法，以将每个节点分割成社区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/05fe8b9a29090ec159ab94b75145dc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FtoE1nU9QX-BBr9Ii8wuw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有Node2Vec和频谱嵌入的社区检测解决方案架构。图片由作者提供。</figcaption></figure><h2 id="0f55" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">要求</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="04d1" class="lv lw it ob b gy of og l oh oi">Python=3.8.8<br/>networkx=2.5<br/>pandas=1.2.4<br/>numpy=1.20.1<br/>node2vec=0.4.4<br/>sklearn=0.24.1<br/>matplotlib=3.3.4</span></pre><p id="4882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有安装node2vec包，这里的<a class="ae ky" href="https://pypi.org/project/node2vec/" rel="noopener ugc nofollow" target="_blank">是通过命令行安装它的库文档。</a></p><h1 id="cec0" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">创建网络</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的脚本将生成一个随机图，供我们使用node2vec和后面的spectral clustering。用户将为随机生成的网络指定他们想要的节点数量和度分布。网络将通过配置模型生成。配置模型本质上通过分配边来匹配度序列来生成随机图。请注意，由于这是随机的，因此每次生成的网络都会不同。此外，这只是一个运行node2vec的示例网络，仅仅因为生成的网络是一个多图并不意味着node2vec只能在其他多图上运行。Node2Vec可以在有向、无向、加权、多重或常规网络上运行。当我为<code class="fe ol om on ob b">n = 150</code>运行上面的函数时，下面是与结果图相关的统计数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/141f3ce7db918743870a257800f6fb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*9-I-LxIztP9pFm35H6SgRA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">与生成的网络相关联的统计数据。图片由作者提供</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/07e5fb7596d2e5b1e6fdffb72ffcb5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOM99nhxJIFd1WRntsFlpg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">与生成的网络相关联的度分布。图片由作者提供。</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/28691e434c7483ae8e4356514ace88a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeITLkLvavFlmalX000imw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建的网络的可视化表示。图片由作者提供。</figcaption></figure><p id="dbeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您通常不希望将网络可视化，尤其是如果网络很大的话。渲染与具有数十万条边的网络相关联的边所花费的时间和计算能力是巨大的。我这样做只是为了让读者能够直观地理解在本文后面将节点分配给社区时，它们是如何改变颜色的。</p><h1 id="5c6d" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">应用节点2Vec</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="4289" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">应用光谱聚类</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本教程，我已经通过sklearn展示了如何使用<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html" rel="noopener ugc nofollow" target="_blank">谱聚类</a>【2】模型。这可以很容易地用其他聚类算法代替，如<a class="ae ky" href="https://towardsdatascience.com/k-means-explained-10349949bd10" rel="noopener" target="_blank"> K-means </a>、<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html" rel="noopener ugc nofollow" target="_blank">凝聚聚类</a>等。因为我们目前正在使用合成数据来编写教程，所以我不会详细介绍社区评估或选择最佳数量的社区。聚类评估中的传统指标，如<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html" rel="noopener ugc nofollow" target="_blank">轮廓得分</a>，肘方法等。可以很容易地应用到这个场景中。</p><h1 id="59ae" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">识别社区</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="ff53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经确定了每个节点属于哪个集群，我们可以将每个集群映射到颜色，并将颜色映射回我们的原始网络。这将允许我们根据每个节点所属的社区来查看网络。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5efb034560a9e8d7528daf937173bdd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W06VYDamlmpJC7MvjlGkqg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通过颜色映射到其社区的节点。图片由作者提供。</figcaption></figure><h1 id="cba6" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">结束语</h1><p id="f56c" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">概括地说，您可以在网络上使用node2vec构建一个社区检测管道。为此，只需在您选择的网络上应用node2vec算法，然后使用集群算法将节点映射到不同的集群/社区。这种方法很直观，因为Node2Vec的目的是在生成嵌入空间时保留网络结构。请注意，如果你通过一个不完整的网络，那么所发现的社区可能会产生误导。不完整的网络是基于部分观察创建的网络。如果没有一个包含所有观察结果的网络，从中产生的社区可能会产生误导。</p><p id="51d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这总结了如何使用Node2Vec在Python中实现社区检测管道的概述。你可以在我的<a class="ae ky" href="https://github.com/vatsal220" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到<a class="ae ky" href="https://github.com/vatsal220/medium_articles/blob/main/community_detection/detection.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中的代码，请随意跟随。</p><p id="1691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想转型进入数据行业，并希望得到经验丰富的导师的指导和指引，那么你可能想看看最敏锐的头脑。Sharpest Minds是一个导师平台，导师(他们是经验丰富的实践数据科学家、机器学习工程师、研究科学家、首席技术官等。)将有助于你的发展和学习在数据领域找到一份工作。点击这里查看<a class="ae ky" href="https://www.sharpestminds.com/?r=vatsal-patal" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="9416" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">资源</h1><ul class=""><li id="cc51" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">[1]<a class="ae ky" href="https://en.wikipedia.org/wiki/Community_structure" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Community_structure</a></li><li id="0fe4" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">[2]<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . cluster . spectral clustering . html</a></li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="32d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢读这篇文章，这里有一些我写的其他文章，你可能也会喜欢。</p><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/bayesian-a-b-testing-explained-344a6df88c1a" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">贝叶斯A/B测试解释</h2><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/comprehensive-guide-to-github-for-data-scientist-d3f71bd320da" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">面向数据科学家的GitHub综合指南</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">通过UI和命令行为数据科学家提供的GitHub教程</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/active-learning-in-machine-learning-explained-777c42bd52fa" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">机器学习中的主动学习解释</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">Python中主动学习管道的直觉和实现</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="ps l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/text-similarity-w-levenshtein-distance-in-python-2f7478986e75" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">Python中带Levenshtein距离的文本相似度</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">用Python构建抄袭检测管道</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pt l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/link-prediction-recommendation-engines-with-node2vec-c97c429351a8" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">使用Node2Vec的链接预测推荐引擎</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">在Python中使用节点嵌入进行链接预测</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pu l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/word2vec-explained-49c52b4ccb71" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">Word2Vec解释道</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">解释Word2Vec的直观性&amp;用Python实现它</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pv l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/recommendation-systems-explained-a42fc60591ed" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">推荐系统解释</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">用Python解释和实现基于内容的协同过滤和混合推荐系统</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pw l pm pn po pk pp ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://towardsdatascience.com/text-summarization-in-python-with-jaro-winkler-and-pagerank-72d693da94e8" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">用Jaro-Winkler和PageRank实现Python中的文本摘要</h2><div class="pq l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">用Jaro-Winkler和PageRank构建一个文本摘要器</h3></div><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="px l pm pn po pk pp ks pc"/></div></div></a></div></div></div>    
</body>
</html>