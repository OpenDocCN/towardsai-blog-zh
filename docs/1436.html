<html>
<head>
<title>How to Easily Scrape Podcast Data Using RSS Feeds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用RSS源轻松抓取播客数据</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-to-easily-scrape-podcast-data-using-rss-feeds-e864710cb62?source=collection_archive---------2-----------------------#2021-01-26">https://pub.towardsai.net/how-to-easily-scrape-podcast-data-using-rss-feeds-e864710cb62?source=collection_archive---------2-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="633f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/web-scraping" rel="noopener ugc nofollow" target="_blank">网页抓取</a></h2><div class=""/><div class=""><h2 id="7e2a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">访问RSS提要——使用R获取播客数据很简单，只需5个简单的步骤</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/80fe0c783c259ed37d2b38f82aad44dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SNLjswQTUdGFM_Ms"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@jasonrosewell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰森·罗斯韦尔</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="43e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">免责声明:</em> </strong> <em class="me">本文仅出于教育目的。我们不鼓励任何人抓取网站，尤其是那些可能有条款和条件反对此类行为的网站。</em></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="4338" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当涉及到从网站或数字平台(如播客存档)抓取或收集数据时，您通常有两种选择:</p><ol class=""><li id="97cf" class="mm mn it lk b ll lm lo lp lr mo lv mp lz mq md mr ms mt mu bi translated">使用平台提供的<strong class="lk jd">应用编程接口</strong> (API)</li><li id="41b2" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md mr ms mt mu bi translated">构建一个定制的<strong class="lk jd"> web scraper </strong>来处理特定的网站</li></ol><p id="b5f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用API通常是最简单的，因为它可以让您直接访问您想要的数据，但这种访问可能是有限的。另一方面，当您希望提取API可能不提供的特定数据(或者根本不存在API)时，构建web scraper可能是有益的。</p><p id="a6e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，编写网络抓取程序的一个主要缺点是，如果网站固有的HTML/CSS结构发生变化，它可能会过时或不再正常工作，这意味着你必须更新代码才能与网站的未来新版本一起工作。</p><p id="9b7a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我告诉你有一个<em class="me">排序的</em>快乐的中间解决方案来抓取你最喜欢的<strong class="lk jd">播客剧集描述</strong>不需要那么多定制代码，会怎么样？这种解决方案仍然需要创建一个web scraper程序，但是代码要简单得多，而且不易更改，因为它使用了简单的标准格式RSS提要。本文将通过5个步骤向您展示如何使用R <strong class="lk jd"> </strong>轻松地为数据科学和分析应用程序收集、预处理和准备播客数据。</p><p id="92cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来——你所需要的就是安装最新版本的<a class="ae lh" href="https://www.r-project.org/" rel="noopener ugc nofollow" target="_blank"> R </a>和<a class="ae lh" href="https://rstudio.com/" rel="noopener ugc nofollow" target="_blank"> R Studio </a>。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="b77d" class="na nb it bd nc nd ne dn nf ng nh dp ni lr nj nk nl lv nm nn no lz np nq nr iz bi translated"><strong class="ak">第一步:理解播客RSS提要的结构及其数据</strong></h2><p id="02fa" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">首先定义你想从播客中提取什么数据特征或元素是很重要的。出于一般分析和自然语言处理(NLP)的目的，我发现以下元素对于提取很有价值:</p><ul class=""><li id="39f6" class="mm mn it lk b ll lm lo lp lr mo lv mp lz mq md nx ms mt mu bi translated">标题</li><li id="c537" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated">出版日期</li><li id="c2d3" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated">发作持续时间</li><li id="a922" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated">描述</li></ul><p id="2dac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这次演练中，我们将收集一个最受欢迎、持续时间最长的播客，<strong class="lk jd">你应该知道的东西(SYSK)。</strong>我们将导航到页面上的“<strong class="lk jd"> RSS Feed </strong>”链接/图标，因为这是我们正在寻找的。</p><div class="ny nz gp gr oa ob"><a href="https://www.iheart.com/podcast/105-stuff-you-should-know-26940277/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">你应该知道的事情</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">如果你曾经想了解香槟，撒旦崇拜，石墙起义，混沌理论，迷幻药，厄尔尼诺，真正的犯罪…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.iheart.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op lb ob"/></div></div></a></div><p id="64e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">默认情况下，点击<a class="ae lh" href="https://feeds.megaphone.fm/stuffyoushouldknow" rel="noopener ugc nofollow" target="_blank"> RSS提要链接</a>(使用Google Chrome)将生成一个可读的树形结构的XML文件。这使得在<code class="fe oq or os ot b">&lt;item&gt;</code>节点下挑选出我们感兴趣的各种元素标签变得很容易，比如<code class="fe oq or os ot b">&lt;title&gt;</code>、<code class="fe oq or os ot b">&lt;description&gt;</code>、<code class="fe oq or os ot b">&lt;pubDate&gt;</code>、&amp;、<code class="fe oq or os ot b">&lt;itunes:duration&gt;</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/58d7e3752a8270670c3c5862c9b079f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhQsbOKKd6WhnuyhtLODXQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">你应该知道的东西的RSS提要XML文件(在谷歌浏览器中)</figcaption></figure><p id="fd4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对数据的结构有了很好的理解，接下来我们可以开始构建scraper程序。</p><p id="a1a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">注意</em> </strong> <em class="me">:大部分播客网站在各自的播客登陆页面上都有明显的RSS Feed链接。</em> <a class="ae lh" href="https://podcastaddict.com/" rel="noopener ugc nofollow" target="_blank"> <em class="me">播客Addic </em> </a> <em class="me"> t是我觉得最简单的一个。</em></p><h2 id="ea63" class="na nb it bd nc nd ne dn nf ng nh dp ni lr nj nk nl lv nm nn no lz np nq nr iz bi translated">步骤2:装入必要的R包</h2><p id="b4a0" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">让我们确保在R Studio中安装了以下R包，我们将出于各种目的需要这些包:</p><ul class=""><li id="e2b7" class="mm mn it lk b ll lm lo lp lr mo lv mp lz mq md nx ms mt mu bi translated"><strong class="lk jd"> dplyr </strong> —数据操作</li><li id="46cf" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated"><strong class="lk jd">润滑</strong> —处理日期</li><li id="f2c6" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated"><strong class="lk jd">rvest</strong>—负责网页抓取</li><li id="433e" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated"><strong class="lk jd">stringr</strong>—处理文本</li><li id="7c7c" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated"><strong class="lk jd">文本系统</strong>——用于标记化</li><li id="9b9d" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated"><strong class="lk jd">tible</strong>—帮助以表格格式存储抓取的数据</li><li id="1715" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated"><strong class="lk jd">TM</strong>—用于文本挖掘预处理</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/b28e5c9e6307ea8d867ee3d4b8ff1419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xl8X3RCtxLX0panh"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@curology?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Curology </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="5f7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您还没有安装它们，您可以通过R Studio中的控制台使用下面的命令安装它们。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="65d0" class="na nb it ot b gy pa pb l pc pd">install.packages(“rvest”)</span></pre><p id="88c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦所有都安装好了，就把它们放进去。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="4c24" class="na nb it ot b gy pa pb l pc pd">library(dplyr)<br/>library(lubridate)<br/>library(rvest)<br/>library(stringr)<br/>library(textstem)<br/>library(tibble)<br/>library(tm)</span><span id="f385" class="na nb it ot b gy pe pb l pc pd">packages &lt;- c(‘dplyr’, ‘lubridate’, ‘rvest’, ‘stringr’, <br/>              ‘textstem’,    ‘tibble’, ‘tm’)<br/>loaded_packages &lt;- sapply(packages, require, character.only = TRUE)<br/>loaded_packages</span></pre><h2 id="ecd8" class="na nb it bd nc nd ne dn nf ng nh dp ni lr nj nk nl lv nm nn no lz np nq nr iz bi translated">第三步:收集原始数据</h2><p id="967d" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">加载了正确的包后，我们现在可以构建代码来从每个播客剧集中获取数据。</p><p id="a658" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们要做的第一件事是定义指向RSS XML文件的URL，以及我们感兴趣的CSS元素。这些元素将成为我们最终数据集中的列名。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="54e6" class="na nb it ot b gy pa pb l pc pd"># define url for RSS feed XML file <br/>URL &lt;- ‘<a class="ae lh" href="http://feeds.megaphone.fm/stuffyoushouldknow.xml'" rel="noopener ugc nofollow" target="_blank">http://feeds.megaphone.fm/stuffyoushouldknow.xml'</a></span><span id="7a53" class="na nb it ot b gy pe pb l pc pd"># define XML tags of interest<br/>css_tags &lt;- c(‘title’, ‘pubDate’, <br/>              ‘description’, ‘itunes\\:duration’) </span><span id="5688" class="na nb it ot b gy pe pb l pc pd">col_names &lt;- c(‘title’, ‘date’, ‘description’, ‘duration’)</span></pre><p id="19a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们将加载XML提要并收集所有条目节点及其保存在<code class="fe oq or os ot b">items</code>中的底层元素。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="ce01" class="na nb it ot b gy pa pb l pc pd"># load XML feed and extract items nodes<br/>podcast_feed &lt;- read_xml(URL)<br/>items &lt;- xml_nodes(podcast_feed, ‘item’)</span></pre><p id="2dcb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为一个条目包含许多元素，所以我们只想提取上面定义的那些元素。一个简单的方法是创建一个助手函数来帮助我们把它们取出来，放到一个向量或列表中。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="839e" class="na nb it ot b gy pa pb l pc pd"># extracts from an item node the content defined by the css_tags<br/>extract_element &lt;- function(item, css_tags) {<br/>   element &lt;- xml_node(item, css_tags) %&gt;% xml_text<br/>   element<br/>}</span></pre><p id="6be6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们需要遍历每个条目，创建一个tibble，并将其合并到一个数据框中。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="98d9" class="na nb it ot b gy pa pb l pc pd">podcast_df &lt;- sapply(css_tags, function(x) { <br/>                 extract_element(items, x)}) %&gt;% as_tibble()</span><span id="17d8" class="na nb it ot b gy pe pb l pc pd">names(podcast_df) &lt;- col_names # set new column names<br/>View(podcast_df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/2b2c3ad5b653c6ac063934f8ea7f9613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al-BT_0QpoPmrZ3GqCEzKQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">R Studio中原始数据帧的片段</figcaption></figure><p id="8523" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开始看起来不错了。我们现在在一个数据框中有了抓取的原始数据，其中每个记录代表来自RSS提要的一个播客片段。</p><h2 id="bce2" class="na nb it bd nc nd ne dn nf ng nh dp ni lr nj nk nl lv nm nn no lz np nq nr iz bi translated">步骤4:预处理抓取的数据</h2><p id="62ea" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">尽管我们可以在这里停下来，但是我们可以在这里做一些理想的预处理步骤来最终确定我们的数据集。</p><p id="feaa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们要做的第一件事是对日期和持续时间进行一些改变。</p><ul class=""><li id="5f4b" class="mm mn it lk b ll lm lo lp lr mo lv mp lz mq md nx ms mt mu bi translated">对于<code class="fe oq or os ot b">date</code>,默认抓取的数据包括很多细节，包括星期几、时间和时区。然而，对我们来说最有用的部分只是日期本身，所以我们将更新它，只保留日期格式的那些字符。</li><li id="13b1" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated">对于<code class="fe oq or os ot b">duration</code>,我们将简单地将其转换为数字格式，因为默认情况下所有列都是字符类型。</li></ul><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="e738" class="na nb it ot b gy pa pb l pc pd">podcast_df &lt;- podcast_df %&gt;%<br/>         mutate(date = stringr::str_sub(date, 5, 16)) %&gt;% <br/>         mutate(date = lubridate::dmy(date), <br/>                duration = as.numeric(duration)) <br/>View(podcast_df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/87c154e4ce8feb7dba2a137918d8173a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtcC9I6k_fqBeOO2E8AV3A.jpeg"/></div></div></figure><p id="7794" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们有了YYYY-MM-DD格式的日期和存储为数字的持续时间值。</p><h2 id="515a" class="na nb it bd nc nd ne dn nf ng nh dp ni lr nj nk nl lv nm nn no lz np nq nr iz bi translated">步骤5:创建感兴趣的新的附加列</h2><p id="f83d" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">下一步是针对选定的播客内容和我们未来的数据分析目标或计划。<em class="me">如果你抓取了另一个播客，请记住这一点，因为你可能需要根据自己的需要进行修改。</em></p><p id="9b80" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于SYSK的播客，制作人通常会发布之前播出过的重复剧集。这些通常被标记为<em class="me">【SYSK精选】</em><em class="me">【SYSK分心播放列表】</em>。此外，他们的一些剧集是被称为<em class="me">“短片”的较短剧集。</em>所有这些标签都体现在剧集标题中。</p><p id="579d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设这些标签出现在标题中，我们可以很容易地创建两个新列，使用<code class="fe oq or os ot b">if_else </code>条件检查这些关键子字符串，将每个剧集分类为(重复/原创)和/或(短/普通)剧集。下面的突变将为我们完成这个任务。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="51ba" class="na nb it ot b gy pa pb l pc pd">podcast_df &lt;- podcast_df %&gt;%<br/>   mutate(episode_type = if_else(stringr::str_detect(title,   <br/>                         “Short Stuff”), “Short”, “Normal”),<br/>          initial_release = if_else(stringr::str_detect(title,  <br/>                            “SYSK Selects|SYSK Distraction  <br/>                             Playlist”),FALSE, TRUE ))</span></pre><p id="d03f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们要添加的最后一个附加列是一串标记，代表属于每集“描述”的重要上下文单词。换句话说，我们将对描述文本应用<strong class="lk jd">标记化</strong>，这可以让我们进行NLP和机器学习任务，如<strong class="lk jd">情感分析</strong>或<strong class="lk jd">主题建模</strong>。</p><p id="c829" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在应用标记化之前，我们需要清除文本中的任何标点符号或干扰。我们要做的第一件事是删除任何存在于每集描述结尾的普通文本，就像这样。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="c651" class="na nb it ot b gy pa pb l pc pd">generic_string = "\n Learn more about your ad-choices at <a class="ae lh" href="https://news.iheart.com/podcast-advertisers" rel="noopener ugc nofollow" target="_blank">https://news.iheart.com/podcast-advertisers</a>"</span><span id="5038" class="na nb it ot b gy pe pb l pc pd">podcast_df &lt;- podcast_df %&gt;%<br/>    mutate(description = stringr::str_remove(description,  <br/>           generic_string))</span></pre><p id="293e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们将定义一些辅助函数，以帮助确保我们删除所有非字母数字字符以及任何包含2个字符或更少字符的单词。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="8711" class="na nb it ot b gy pa pb l pc pd"># function to strip all non-alphanumeric characters<br/>removeNonAlnum &lt;- function(x){<br/>                  gsub(“[^[:alnum:]^[:space:]]”,” “, x)<br/>}</span><span id="25b6" class="na nb it ot b gy pe pb l pc pd"># function to remove any words with 2 characters or less <br/>removeShortWords &lt;- function(x){<br/>                    gsub(‘\\b\\w{1,2}\\b’,’’, x)<br/>}</span></pre><p id="72cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还想定义我们的自定义停用词。<strong class="lk jd">停用词</strong>是常用词，本身并不能提供多少有意义的上下文。这让我们可以专注于重要的单词。这个<code class="fe oq or os ot b">tm</code>包有一个广泛的标准停用词集合供我们使用，但是有时你会想要根据你正在处理的文本上下文添加你自己的额外停用词。在这种情况下，我从浏览中知道，以下单词在这个播客的描述中重复出现，并没有增加多少价值或剧集之间的区别，所以我将它们定义为这样。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="ebfa" class="na nb it ot b gy pa pb l pc pd"># define stop words including custom stop words<br/>custom_stopwords = c( “sysk”, “stuff”, “you”, “episode”, “week”,  <br/>                      “tune”, “”, “today”, “podcast”,   <br/>                      “howstuffworks”, “com”, “listen”, “should”,  <br/>                      “know”, “learn”, “josh”, “chuck”)</span></pre><p id="53dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，最后一步需要应用我们所有的助手函数、停用词和方便的文本挖掘清理函数，为整个数据集生成有用标记的语料库向量。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="bd25" class="na nb it ot b gy pa pb l pc pd"># create corpus vector of descs and apply preprocessing steps <br/>corpus &lt;- Corpus(VectorSource(podcast_df$description))<br/>corpus &lt;- tm_map(corpus, removeNumbers)<br/>corpus &lt;- tm_map(corpus, content_transformer(tolower))<br/>corpus &lt;- tm_map(corpus, content_transformer(removeNonAlnum))<br/>corpus &lt;- tm_map(corpus, content_transformer(removeShortWords))<br/>corpus &lt;- tm_map(corpus, removeWords, c(stopwords(‘english’),   <br/>                 custom_stopwords))<br/>corpus &lt;- tm_map(corpus, textstem::lemmatize_strings)<br/>corpus &lt;- tm_map(corpus, stripWhitespace)</span></pre><p id="61db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">注:</em></strong><em class="me"/><code class="fe oq or os ot b"><em class="me">lemmatize_strings</em></code><em class="me">函数对我们的单词应用词条化，这是一种通过使用单词的形态分析将单词转换成它们的词条或词典形式的方法。例如，</em> <strong class="lk jd"> <em class="me">学</em> </strong> <em class="me">，</em> <strong class="lk jd"> <em class="me">学</em> </strong> <em class="me">，</em> <strong class="lk jd"> <em class="me">学</em> </strong> <em class="me">就会转换成</em> <strong class="lk jd"> <em class="me">学</em> </strong> <em class="me">。要了解更多信息，请参考</em> <a class="ae lh" href="https://blog.bitext.com/what-is-the-difference-between-stemming-and-lemmatization/" rel="noopener ugc nofollow" target="_blank"> <em class="me">此处</em> </a> <em class="me">。</em></p><p id="d6ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了将语料库向量添加到我们的数据框架中，我们将使用<code class="fe oq or os ot b">sapply</code>并创建一个<code class="fe oq or os ot b">tokens</code>列。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="5ff7" class="na nb it ot b gy pa pb l pc pd">podcast_df &lt;- podcast_df %&gt;%<br/>                   mutate(tokens = sapply(corpus, identity))<br/>View(podcast_df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/b2d7c0517ea2244a0e1041672a547a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*um_QTgxrRakmbvaqRitC9Q.jpeg"/></div></div></figure><p id="d3d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们做到了！我们现在有了一个完整的预处理数据集，包括令牌和其他有用的信息。👌</p><p id="97f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将CSV文件保存到这个文件中，以便将来对预处理后的数据进行任何分析或工作。</p><pre class="ks kt ku kv gt ow ot ox oy aw oz bi"><span id="0431" class="na nb it ot b gy pa pb l pc pd">write.csv(podcast_df,”preprocessed_podcast_episodes.csv”, <br/>          row.names = FALSE, fileEncoding = “UTF-8”)</span></pre><p id="7d96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/bicachu/podcast-scraper/blob/master/podcast_scraper_notebook.Rmd" rel="noopener ugc nofollow" target="_blank">完成刮刀笔记本代码</a></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="3ccc" class="pi nb it bd nc pj pk pl nf pm pn po ni ki pp kj nl kl pq km no ko pr kp nr ps bi translated">摘要</h1><p id="f39f" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如图所示，访问RSS提要使得只需几个简单的步骤就可以非常容易地抓取播客数据。</p><p id="be06" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望这个演练是有用的和令人愉快的。就使用scraper而言，只要您能够找到关键的标准RSS提要XML文件，您应该能够运行它来为您选择的任何播客收集数据。对于接下来的步骤和未来的应用，这里有一些想法，我可能会在以后的文章中发布，敬请关注:</p><ul class=""><li id="715b" class="mm mn it lk b ll lm lo lp lr mo lv mp lz mq md nx ms mt mu bi translated">应用各种主题建模机器学习算法</li></ul><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/tweet-topic-modeling-part-3-using-short-text-topic-modeling-on-tweets-bc969a827fef"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">Tweet主题建模第3部分:在tweet上使用短文本主题建模</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">这是一个多部分的系列，展示了如何为任何集合抓取、预处理、应用和可视化短文本主题建模…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">pub.towardsai.net</p></div></div><div class="ok l"><div class="pt l om on oo ok op lb ob"/></div></div></a></div><ul class=""><li id="a92e" class="mm mn it lk b ll lm lo lp lr mo lv mp lz mq md nx ms mt mu bi translated">执行情感分析</li></ul><h1 id="dee2" class="pi nb it bd nc pj pu pl nf pm pv po ni ki pw kj nl kl px km no ko py kp nr ps bi translated">资源</h1><ul class=""><li id="9fc8" class="mm mn it lk b ll ns lo nt lr pz lv qa lz qb md nx ms mt mu bi translated">RSS如何工作—【https://rss.com/blog/how-do-rss-feeds-work/ T2】</li><li id="5a4d" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated">XML文档结构如何工作—【https://www.w3schools.com/xml/xml_tree.asp T4】</li><li id="d174" class="mm mn it lk b ll mv lo mw lr mx lv my lz mz md nx ms mt mu bi translated">播客上瘾平台(包括RSS源)——<a class="ae lh" href="https://podcastaddict.com/" rel="noopener ugc nofollow" target="_blank">https://podcastaddict.com/</a></li></ul></div></div>    
</body>
</html>