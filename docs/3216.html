<html>
<head>
<title>Airflow Production Tips — Proper Task (Not DAG) Catchup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流生成技巧—正确的任务(非DAG)追赶</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/airflow-production-tips-proper-task-not-dag-catchup-c6c8ef1f6ba7?source=collection_archive---------0-----------------------#2022-10-15">https://pub.towardsai.net/airflow-production-tips-proper-task-not-dag-catchup-c6c8ef1f6ba7?source=collection_archive---------0-----------------------#2022-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/283fa17c28e406cb9126e74fb16cd1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KxKOzk5QI2GQ4btu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@simmerdownjpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克森煨</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="b5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apache Airflow已经成为数据编排的事实标准<em class="lb">de</em><em class="lb"/>。然而，随着时间的推移和版本的变化，它积累了一系列的细微差别和错误，这可能会阻碍它在生产中的使用。</p><p id="dfe4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一系列文章旨在引导Apache Airflow用户克服这些问题，也就是我所面临的问题。</p><blockquote class="lc ld le"><p id="b639" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">注意:像往常一样，所有的代码都可以在我的GitHub资源库中获得，这里的<a class="ae kc" href="https://github.com/Guilherme-B/airflow-utils" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a>。</p></blockquote><h1 id="4ca2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">正确的任务(非DAG)追赶</h1><blockquote class="lc ld le"><p id="cf65" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir"> TLDR </strong> : Airflow获取上一个成功的TaskInstance的日期的能力并没有像预期的那样工作，而是返回上一个成功的DAG的运行日期，这使得您无法准确和正确地获取缺失/失败的信息。在这篇文章中，你会发现如何绕过它。<a class="ae kc" href="https://github.com/apache/airflow/issues/18116" rel="noopener ugc nofollow" target="_blank">见原bug报告</a>。</p><p id="13d2" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir"> TLDR #2 </strong> : <a class="ae kc" href="#7cbe" rel="noopener ugc nofollow">点击这里直接跳到解决方案</a></p></blockquote><h1 id="9442" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题陈述</h1><p id="7b64" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Apache Airflow最有趣和最有帮助的特性之一是它能够在任务失败时跟踪过去的情况。不，我指的不是可以在DAG中定义的<em class="lb"> catchup </em>参数，而是赋予任务包含之前失败的TaskInstances(及其执行日期)的能力，使用</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e3ac" class="mu lj iq mq b gy mv mw l mx my">{{ prev_execution_date_success }} </span></pre><p id="7d50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JINJA模板，或者直接访问状态为成功的前一个TaskInstance:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="581d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您想要确保您的数据在摄取中保持最新，或者您的ETL消耗当前和失败的过去任务实例的所有信息时，这尤其有用，例如:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">extract_from_db、transform_data和load_target_db任务的任务配置</figcaption></figure><p id="11b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个更实际的例子中，考虑到下面的图像，您会期望如果在使用上述配置时任务<em class="lb"> transform_data </em>的第一次运行失败，那么失败/丢失的数据将在下一个小时的<em class="lb"> transform_data </em>的下一次运行中被捕获，对吗？</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/d901924faeff6a4f87c009b71ef873a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEpE_W5BhzJhLv--ve3YZQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">简单的类似ETL的DAG由三个线性相关的任务组成</figcaption></figure><p id="b2d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预期的事件循环:</p><ul class=""><li id="10b8" class="nc nd iq kf b kg kh kk kl ko ne ks nf kw ng la nh ni nj nk bi translated">循环1<br/>–运行任务<em class="lb">提取_自_数据库，</em>捕获<strong class="kf ir">一个</strong>小时的数据，<em class="lb">状态</em> : <strong class="kf ir">成功</strong><br/>–运行任务<em class="lb">转换_数据，</em>转换<strong class="kf ir">一个</strong>小时的数据，<em class="lb">状态</em> : <strong class="kf ir">失败</strong><br/>–运行任务<em class="lb">加载_目标_数据库，</em>加载<strong class="kf ir">一个【1</strong></li><li id="7a95" class="nc nd iq kf b kg nl kk nm ko nn ks no kw np la nh ni nj nk bi translated">循环2<br/>–运行任务<em class="lb"> extract_from_db，</em> capture <strong class="kf ir">一个</strong>小时的数据，<em class="lb">状态</em> : <strong class="kf ir">成功</strong><br/>–运行任务<em class="lb">transform _ data，</em>转换<strong class="kf ir">两个</strong>小时的数据(当前和先前失败)，<em class="lb">状态</em> : <strong class="kf ir">成功</strong><br/>–运行任务<em class="lb">load _ target _ data</em></li></ul><blockquote class="lc ld le"><p id="c5fb" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">不幸的是，这是不正确的。虽然这是显而易见的预期行为，但Airflow的遗留代码阻止了这种情况的发生。<a class="ae kc" href="https://github.com/apache/airflow/issues/18116" rel="noopener ugc nofollow" target="_blank">见原bug报告</a>。</p></blockquote><p id="2417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面分别是任务<em class="lb"> transform_data </em>第一次和第二次运行的相应渲染模板:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第一次运行<em class="nq"> transform_data </em>任务时实际呈现的模板——失败的任务</figcaption></figure><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第二次运行<em class="nq"> transform_data </em>任务时实际呈现的模板——不选择失败任务的执行日期时间</figcaption></figure><p id="2527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，第二个任务不会补偿前面的失败。而是只传递自己之前的执行日期param，<strong class="kf ir"><em class="lb">20221013t 010000</em></strong>而不包括之前的成功运行，全补<strong class="kf ir"><em class="lb">20221013t 000000</em></strong>。</p><h2 id="ed0b" class="mu lj iq bd lk nr ns dn lo nt nu dp ls ko nv nw lw ks nx ny ma kw nz oa me ob bi translated">为什么会这样？</h2><p id="fd54" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当之前的执行日期成功时，Apache Airflow的默认行为是查看之前DAG的成功执行日期，而不是TaskInstance的成功执行日期，这实际上使您的DAG无法自动跟上，除非整个DAG失败。</p><p id="d6cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们期待会发生什么呢？我们希望第二次运行时呈现的模板是:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="lc ld le"><p id="4d05" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">你可以在StackOverflow上看到<a class="ae kc" href="https://github.com/apache/airflow/issues/18116" rel="noopener ugc nofollow" target="_blank">关于问题的原始bug报告</a>，可以追溯到2021年甚至更久。</p></blockquote><h1 id="7cbe" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">解决方案</h1><p id="1252" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">像许多其他Python框架一样，Apache Airflow使用ORM(对象关系映射器)来抽象对其后端数据库的访问。具体来说，通常的<a class="ae kc" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQL Alchemy </a>项目已经被用来加速Apache气流。这允许我们直接访问元数据数据库，并根据我们的需求操作它。</p><p id="89b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们问题的解决方案分为四个简单的步骤:</p><ol class=""><li id="5af4" class="nc nd iq kf b kg kh kk kl ko ne ks nf kw ng la oc ni nj nk bi translated">根据指定的状态检索<em class="lb"> TaskInstance </em>对象</li><li id="39a0" class="nc nd iq kf b kg nl kk nm ko nn ks no kw np la oc ni nj nk bi translated">为提供的<em class="lb">任务</em>检索最后一个成功的<em class="lb">任务实例</em>实例</li><li id="b1b8" class="nc nd iq kf b kg nl kk nm ko nn ks no kw np la oc ni nj nk bi translated">为所提供的任务检索与最后一个成功的<em class="lb"> TaskInstance </em>实例相关联的<em class="lb"> DAGRun </em></li><li id="3717" class="nc nd iq kf b kg nl kk nm ko nn ks no kw np la oc ni nj nk bi translated">用使用这些信息的能力武装我们的DAG！</li></ol><p id="64b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，添加了一个实际的部分示例来说明目标！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h2 id="18c2" class="mu lj iq bd lk nr ns dn lo nt nu dp ls ko nv nw lw ks nx ny ma kw nz oa me ob bi translated">步骤1:根据指定的状态检索TaskInstance对象</h2><p id="0e76" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">第一步对应于能够查询ORM以检索数据库，从而检索对应于特定状态的最后一次<em class="lb"> TaskInstance </em>运行:</p><blockquote class="lc ld le"><p id="f8a0" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">注意:该函数是一个一般化的函数，允许您选择您可能需要的任何特定状态</p></blockquote><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a2ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数是不言自明的，查询<em class="lb"> TaskInstance </em> ORM对象并通过两个参数对其进行过滤:所需的查找状态和<em class="lb"> TaskInstance </em>实例。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h2 id="30ba" class="mu lj iq bd lk nr ns dn lo nt nu dp ls ko nv nw lw ks nx ny ma kw nz oa me ob bi translated">步骤2:检索所提供任务的最后一个成功的TaskInstance实例</h2><p id="f39e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">利用前面定义的泛化，我们现在可以查询ORM，只检索状态为Success的最后一次运行。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h2 id="40fe" class="mu lj iq bd lk nr ns dn lo nt nu dp ls ko nv nw lw ks nx ny ma kw nz oa me ob bi translated">步骤3:为所提供的任务检索与最后一个成功的TaskInstance实例关联的DAGRun。</h2><p id="b32d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">追踪到最后一个成功的<em class="lb"> TaskInstance </em>实例后，我们现在可以检索与所述<em class="lb"> TaskInstance </em>实例相关联的<a class="ae kc" href="https://github.com/apache/airflow/blob/main/airflow/models/dagrun.py" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> DAGRun </em> </a>对象。<a class="ae kc" href="https://github.com/apache/airflow/blob/main/airflow/models/dagrun.py" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> DAGRun </em> </a>模型包含关于ran <em class="lb"> TaskInstance </em>实例的信息以及大量有用的信息:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d0c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些知识，我们现在可以检索与我们检索到的最后一个成功的<em class="lb"> TaskInstance </em>实例相关联的<em class="lb"> DAGRun </em>实例，过程与前面类似:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h2 id="e7c4" class="mu lj iq bd lk nr ns dn lo nt nu dp ls ko nv nw lw ks nx ny ma kw nz oa me ob bi translated">步骤4:让我们的DAG具备使用这些信息的能力！</h2><p id="d8f3" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">最后，我们必须确保Apache Airflow知道我们的新功能，并可以将它们注入到JINJA引擎中。</p><p id="171b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过导入函数并将用户定义的函数直接传递给DAG的构造函数来实现这一点，在本例中，通过上下文管理器:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="90c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以在JINJA中自由地直接调用该函数，并将其作为参数传递给您的提取、ETL或任何其他进程！</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><blockquote class="lc ld le"><p id="c40a" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">如果你觉得这些资源有用，请在评论中告诉我，像往常一样，你可以在我的<a class="ae kc" href="https://github.com/Guilherme-B/airflow-utils" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到这些代码！</p></blockquote></div></div>    
</body>
</html>