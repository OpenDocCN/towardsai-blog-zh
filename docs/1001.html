<html>
<head>
<title>GOOG 10,000 Monte Carlo, Discovering VaR (Value at Risk)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌10，000蒙特卡洛，发现风险价值</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/goog-10-000-monte-carlo-discovering-var-value-at-risk-b15325a71262?source=collection_archive---------1-----------------------#2020-10-04">https://pub.towardsai.net/goog-10-000-monte-carlo-discovering-var-value-at-risk-b15325a71262?source=collection_archive---------1-----------------------#2020-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a5b2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">金融，<a class="ae ep" href="https://towardsai.net/p/category/probability" rel="noopener ugc nofollow" target="_blank">概率</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="9ee7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用去年的APPL回报率进行数百次模拟，以发现风险价值。全部代码可在我的Github repo 获得<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20200906_GOOG_Monte-Carlo" rel="noopener ugc nofollow" target="_blank">。</a></h2></div><p id="bd54" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在本文中，我将对谷歌股票去年的历史数据的RoR执行一个被称为蒙特卡罗模拟的随机过程。在10，000次模拟后，我将根据我选择输入的信心水平，估计我在GOOG上分配的投资组合有多少处于风险之中。</p><h1 id="3965" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">用Alpha Vantage下载股票价格</h1><p id="d185" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">为了下载历史股票价格，我将使用一款名为Alpha Vantage的软件。你需要什么:</p><ul class=""><li id="d2d5" class="ml mm it ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated"><a class="ae kr" href="https://www.alphavantage.co/" rel="noopener ugc nofollow" target="_blank">您的API密钥</a></li><li id="8499" class="ml mm it ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">运行代码的笔记本(如果您是专家，可以放在本地机器上)</li></ul><p id="9637" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">下载限制是可管理的:每分钟5个请求，每天500个请求。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="af1c" class="ni lp it ne b gy nj nk l nl nm">!pip install alpha_vantage</span><span id="8852" class="ni lp it ne b gy nn nk l nl nm">from alpha_vantage.timeseries import TimeSeries<br/>import pandas as pd</span><span id="d37e" class="ni lp it ne b gy nn nk l nl nm">#credenziali<br/>def download_stock(tag):<br/>  key = 'your key'<br/>  ts = TimeSeries(key)<br/>  stock, meta = ts.get_daily(symbol=tag, outputsize='full')<br/>  return stock, meta</span><span id="2993" class="ni lp it ne b gy nn nk l nl nm">import time</span><span id="5f8b" class="ni lp it ne b gy nn nk l nl nm">def get_index(tag):<br/>  df_, _ = download_stock(tag)<br/>  df_ = pd.DataFrame(df_)<br/>  df_ = df_.transpose()<br/>  df_ = df_.loc['2020-09-10':'2019-09-10']<br/>  df_ = df_['1. open']<br/>  df_ = pd.DataFrame(df_)</span><span id="b9d9" class="ni lp it ne b gy nn nk l nl nm">#extract index and return it as series<br/>  df_ = df_.reset_index()<br/>  return df_['index']</span><span id="61b1" class="ni lp it ne b gy nn nk l nl nm">#moduli di download<br/>def stock(tag, df_to_add):<br/>  #passimo come df_to_add il database di stock già creato<br/>  try:<br/>    df_, _ = download_stock(tag)<br/>    df_ = pd.DataFrame(df_)<br/>    df_ = df_.transpose()<br/>    df_ = df_.loc['2020-09-10':'2019-09-10']<br/>    df_ = df_['1. open']<br/>    df_ = pd.DataFrame(df_)<br/>    df_.columns = [tag]<br/>    df_ = df_[tag].values.astype(float)<br/>    df_ = pd.concat([df_to_add, pd.DataFrame(df_)], axis=1)<br/>    return df_, 'Successful'<br/>  except:<br/>    return df_to_add, 'Error'</span><span id="ef67" class="ni lp it ne b gy nn nk l nl nm">##Stock Downloader</span><span id="280d" class="ni lp it ne b gy nn nk l nl nm">#se lo volgiamo in più tranches, invece di utilizzare timers lo spezziamo<br/>tag_list = ['Skip', 'GOOG']</span><span id="c678" class="ni lp it ne b gy nn nk l nl nm">#questo scarica il giusto index, OVVERO IL TIMESTAMP<br/>index = get_index(tag_list[1])<br/>index = pd.DataFrame(index) #conta come 1 richiesta<br/>index</span><span id="3193" class="ni lp it ne b gy nn nk l nl nm">#csv of remaining stocks<br/>empty = pd.DataFrame()<br/>df, _ = stock(tag_list[0], empty) #solo per la prima si utilizza empty<br/>for k in range(1, len(tag_list)):<br/>  <br/>  #print stock you are ATTEMPTING to download now<br/>  print('Iteration:', k, 'Trying to download:', tag_list[k])<br/>  <br/>  #diciamo di aggiungere al database creato il nuovo download<br/>  #se ci sono problemi da None e non viene aggiunto nulla<br/>  df, result = stock(tag_list[k], df)<br/>  print('Iteration:', k, result)</span><span id="4bf5" class="ni lp it ne b gy nn nk l nl nm">  #every 4 stock pause 70 seconds<br/>  if k%4 == 0:<br/>    time.sleep(70)</span><span id="7dcc" class="ni lp it ne b gy nn nk l nl nm">#renaming the columns with tag_list<br/>df.columns = tag_list[1:]<br/>df</span><span id="3d7f" class="ni lp it ne b gy nn nk l nl nm">df1 = df.copy()</span><span id="aa2b" class="ni lp it ne b gy nn nk l nl nm">#reattach index<br/>total = pd.concat([index, df1], axis=1)<br/>total = total.set_index('index')<br/>total</span><span id="5361" class="ni lp it ne b gy nn nk l nl nm">total.to_csv('GOOG.csv')</span></pre><p id="f5b9" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">对于本教程，我将只需要GOOG股票。当然，我可以对不同的股票进行多次模拟，以模拟投资组合的表现(假设模拟股票之间的相关性保持不变)。</p><h1 id="b858" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">准备模拟</h1><p id="ab6f" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">下载了GOOG股票后。csv文件，我用熊猫导入。我现在能够利用这些数据进行任何类型的分析。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1af5" class="ni lp it ne b gy nj nk l nl nm">import pandas as pd</span><span id="5b8c" class="ni lp it ne b gy nn nk l nl nm">df = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Projects/20200906_GOOG_Monte_Carlo/GOOG.csv')<br/>df.index = df.pop('index')<br/>df = df.iloc[::-1]<br/>df</span><span id="415a" class="ni lp it ne b gy nn nk l nl nm">from scipy.stats import skewnorm<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><h2 id="a5de" class="ni lp it bd lq no np dn lu nq nr dp ly lb ns nt ma lf nu nv mc lj nw nx me iz bi translated">绘图功能</h2><p id="45e1" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">我将创建两个不同的函数:第一个函数允许我将股票绘制成时间序列图(以了解价格变动)，第二个函数检查柱状图中的回报。<strong class="ku jd"> graph_stock </strong>函数允许我一次绘制多只股票的图形。我将使用这个函数一次绘制不同的模拟图。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0725" class="ni lp it ne b gy nj nk l nl nm">#graphing timeseries<br/>def graph_stocks(stock):<br/>  #graph all stocks<br/>  plt.figure(figsize=(14, 7))<br/>  for c in stock.columns.values:<br/>    #print(c)<br/>    fig = plt.plot(stock.index, stock[c], lw=1, alpha=1)<br/>  #plt.legend(loc='upper left', fontsize=12)<br/>  #plt.ylabel('price in $')</span><span id="768c" class="ni lp it ne b gy nn nk l nl nm">  #remove axis labels<br/>  plt.gca().axes.get_yaxis().set_visible(False)</span><span id="4bfb" class="ni lp it ne b gy nn nk l nl nm">def graph_returns(df):<br/>  fig = plt.figure(figsize = (14,7))<br/>  ax = fig.gca()<br/>  df.hist(ax=ax, bins=100)</span><span id="0658" class="ni lp it ne b gy nn nk l nl nm">returns = df.pct_change()<br/>returns</span></pre><h2 id="29b8" class="ni lp it bd lq no np dn lu nq nr dp ly lb ns nt ma lf nu nv mc lj nw nx me iz bi translated">图形结果</h2><p id="ca69" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">在研究蒙特卡洛之前，我只想分析一下我目前持有的谷歌股票:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="73a7" class="ni lp it ne b gy nj nk l nl nm">#graphing prices<br/>graph_stocks(df)</span></pre><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ny"><img src="../Images/3de323afe0cc5537aa4b265a3bbd0d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kBU_yXNYHTW_jwHmQT2zg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">谷歌的价格，1年</figcaption></figure><p id="ac55" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">不仅仅是时间上的价格变动，我更感兴趣的是知道哪些是股票的回报。我将从所有的RoR(回报率)中随机选取一个来创建一个模拟，而不是在回报分布中生成随机数。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1890" class="ni lp it ne b gy nj nk l nl nm">#graphing returns<br/>graph_returns(returns)</span></pre><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ok"><img src="../Images/9aff4b6155ea129c8a0dbd2095f45cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmQUSUndsu0O27bwiJHlbg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">谷歌的回报，1年</figcaption></figure><h2 id="3e4c" class="ni lp it bd lq no np dn lu nq nr dp ly lb ns nt ma lf nu nv mc lj nw nx me iz bi translated">创建单个模拟</h2><p id="4ebe" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">我将使用下面的函数来创建一只股票的模拟。创建一个模拟只需要三个输入:</p><ul class=""><li id="b6cc" class="ml mm it ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">模拟股票的初始价格</li><li id="b8de" class="ml mm it ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">天数</li><li id="593c" class="ml mm it ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">收益的概率分布函数</li></ul><p id="f522" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">有了这些参数，你就可以很好地控制整个模拟，这要归功于pdf以及它的方向和波动性。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="59ff" class="ni lp it ne b gy nj nk l nl nm">def simulate_stock(initial_price, days, pdf):</span><span id="28a0" class="ni lp it ne b gy nn nk l nl nm">  def create_empty_df(days):<br/>    #creare un empty DataFrame con le date<br/>    empty = pd.Series(<br/>        pd.date_range("2020-09-10", periods=days, freq="D")<br/>    )<br/>    empty = pd.DataFrame(empty)<br/>    #si tagliano ore, minuti, secondi<br/>    empty</span><span id="d3b3" class="ni lp it ne b gy nn nk l nl nm">    #si tagliano ore, minuti, secondi<br/>    empty.index = [str(x)[0:empty.shape[0]] for x in     list(empty.pop(0))]<br/>    empty</span><span id="60a3" class="ni lp it ne b gy nn nk l nl nm">    #final dataset con values<br/>    stock = pd.DataFrame([x for x in range(0, empty.shape[0])])<br/>    stock.index = empty.index<br/>    return stock</span><span id="f4ad" class="ni lp it ne b gy nn nk l nl nm">  #skeleton<br/>  stock = create_empty_df(100)</span><span id="0401" class="ni lp it ne b gy nn nk l nl nm">  #initial price<br/>  stock[0][0] = initial_price</span><span id="9b55" class="ni lp it ne b gy nn nk l nl nm">  #create entire stock DataFrame<br/>  for _ in range(1, stock.shape[0]):<br/>    stock.iloc[_] = stock.iloc[_-1]*(1+float(pdf.sample(n=1)))</span><span id="6bb6" class="ni lp it ne b gy nn nk l nl nm">return stock</span></pre><h2 id="2477" class="ni lp it bd lq no np dn lu nq nr dp ly lb ns nt ma lf nu nv mc lj nw nx me iz bi translated">创建模拟数据集</h2><p id="d584" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">使用蒙特卡罗方法的真正价值不在于进行随机模拟，而在于进行成千上万次模拟。使用函数<strong class="ku jd"> create_simulation，</strong>我可以创建任意多的模拟。我将传递pdf _ probabilty分布函数作为参数，因为它将被传递给<strong class="ku jd"> simulate_stock </strong>函数。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="713e" class="ni lp it ne b gy nj nk l nl nm">def create_simulation(n_iter, pdf):<br/>  #create multiple stocks<br/>  stock_list = list()<br/>  column_name = list()</span><span id="53ad" class="ni lp it ne b gy nn nk l nl nm">  for _ in range(n_iter):<br/>    print(_)<br/>    text = '_'<br/>    column_name.append(text + str(_))<br/>    stock_list.append(simulate_stock(df.iloc[252][0], 252, pdf))</span><span id="8214" class="ni lp it ne b gy nn nk l nl nm">  #join the stocks together<br/>  stock = pd.concat([x for x in stock_list], axis=1)<br/>  stock.columns = column_name<br/>  stock</span></pre><p id="fbd3" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在同一个数据集中，我将添加一个基准:一只股票的初始价格在其整个生命周期中保持不变(绘制时是一条水平线)。我将用它作为其他股票的比较。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2170" class="ni lp it ne b gy nj nk l nl nm">  #adding benchmark<br/>  stock['benchmark'] = df.iloc[252][0]<br/>  return stock</span></pre><h1 id="cc1b" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">具有可用回报的蒙特卡洛</h1><p id="9dd8" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">为了模拟每个分布，我将使用GOOG股票去年的RoR回报率。这将作为我的pdf _概率分布函数。<strong class="ku jd">我将简单地从分布中选取随机值，而不是使用GOOG股票参数(均值、标准差、alpha) </strong>重新创建高斯函数。此外，这是一种有效的概率方法。我将进一步解释我为什么做这个决定。</p><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ok"><img src="../Images/9aff4b6155ea129c8a0dbd2095f45cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmQUSUndsu0O27bwiJHlbg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">谷歌的回报，1年</figcaption></figure><p id="86e1" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">因为我已经准备好了函数，所以我将简单地调用<strong class="ku jd"> create_simulation </strong>函数来创建n个模拟。在这种情况下，如果您查看<strong class="ku jd"> create_simulation </strong>函数的参数:</p><ul class=""><li id="15e8" class="ml mm it ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">100代表我希望在数据集+ 1基准中的模拟总数</li><li id="b75b" class="ml mm it ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">概率分布函数是GOOG的回报，我会从中随机挑选</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e81a" class="ni lp it ne b gy nj nk l nl nm">returns['GOOG'].dropna().sample(n=1)[0]</span><span id="3857" class="ni lp it ne b gy nn nk l nl nm">simulation_real = create_simulation(100, returns['GOOG'].dropna())<br/>simulation_real</span></pre><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ol"><img src="../Images/a45437e87a6187298fd836efb252d575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkGQ3_d7mD29RH2SH0vwew.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">已创建的数据集的快照</figcaption></figure><h1 id="322f" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">重建正态分布的蒙特卡罗</h1><p id="8383" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">对于实验的第二部分，我将使用GOOG股票参数(均值、标准差、阿尔法)重新创建一个数学上完美的分布，而不是从GOOG股票的RoR中挑选。然后，我将从这个分布中挑选回报率，看看蒙特卡罗与之前的实验有何不同。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="4612" class="ni lp it ne b gy nj nk l nl nm">mean = returns['GOOG'].mean()<br/>sd = returns['GOOG'].std()<br/>alfa = returns['GOOG'].skew()</span><span id="0281" class="ni lp it ne b gy nn nk l nl nm">print(mean, sd, alfa)</span><span id="d922" class="ni lp it ne b gy nn nk l nl nm">#simulated probability distribution of one stock<br/>from scipy.stats import skewnorm<br/>import matplotlib.pyplot as plt<br/>sd, mean, alfa = sd, mean, alfa</span><span id="d2e8" class="ni lp it ne b gy nn nk l nl nm">#invertire il segno di alfa<br/>x = skewnorm.rvs(-alfa, size=100000) <br/>def calc(k, sd, mean):<br/>  return (k*sd)+mean<br/>x = calc(x, sd, mean) #standard distribution<br/>x = pd.DataFrame(x)<br/>x</span></pre><p id="053b" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">用这段代码，我创建了一个GOOG股票的模拟RoR发行版。我用了10万个样本:</p><figure class="mz na nb nc gt nz gh gi paragraph-image"><div class="gh gi om"><img src="../Images/55ad6b3afa29bc28d5b3d68c7eeeed8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*Wl4YOeK9YdhxSfjehh1aJw.png"/></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">模拟正态分布数据集</figcaption></figure><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="adb9" class="ni lp it ne b gy nj nk l nl nm">graph_returns(x)</span></pre><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi on"><img src="../Images/86681c6c319714368ec1be6fc1ed637c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqCJxwQpGVG-g7rHtevM8A.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">模拟谷歌股票RoR pdf我刚刚创建</figcaption></figure><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="736f" class="ni lp it ne b gy nj nk l nl nm">#pick one random number from the distribution<br/>#formally I would use cdf, but I just have to pick randomly from the 1000000 samples<br/>float(x[0].sample(n=1))</span><span id="8af6" class="ni lp it ne b gy nn nk l nl nm">simulation_gen = create_simulation(100, x[0])<br/>simulation_gen</span></pre><p id="ce0a" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我将遵循第一次实验的相同步骤。我将创建100个蒙特卡洛模拟，并将使用x[0]作为pdf，软件将从中随机选择RoR。</p><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi oo"><img src="../Images/a24be7c36970d169c1af9cc5983c4002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTzMlb8vBXn-2tVocLPSTw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">已创建的数据集的快照</figcaption></figure><h1 id="e081" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">比较结果</h1><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ca4a" class="ni lp it ne b gy nj nk l nl nm">graph_stocks(simulation_real)</span></pre><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi op"><img src="../Images/36ab6bbb38b1cc8b4839e86bce9e428f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYjoEnt2tqpQGvRX0Rucsg.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">使用GOOG股票的RoR进行模拟</figcaption></figure><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1a7b" class="ni lp it ne b gy nj nk l nl nm">graph_stocks(simulation_gen)</span></pre><figure class="mz na nb nc gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi oq"><img src="../Images/01b1d449c5ab73c3b0583212c5ed08e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjDR1HeuAWnVYPbWTZ7BDA.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">使用正态分布中再现的RoR进行模拟</figcaption></figure><p id="aaed" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">结果很有趣。虽然第一个实验通过模拟完美分布产生了一组非常现实的场景，但总是有正的股票(这是完全不现实的)。我只能用第一组模拟的数据作为有效数据。</p><h1 id="947a" class="lo lp it bd lq lr ls lt lu lv lw lx ly ki lz kj ma kl mb km mc ko md kp me mf bi translated">定义变量</h1><p id="a23e" class="pw-post-body-paragraph ks kt it ku b kv mg kd kx ky mh kg la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">为了找到风险VaR值，或者我确信在一定程度上我会损失的整个投资组合的最大百分比，我将使用收益总体的百分位数。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="28fb" class="ni lp it ne b gy nj nk l nl nm">import numpy as np</span><span id="e01a" class="ni lp it ne b gy nn nk l nl nm">print('VaR')</span><span id="2e12" class="ni lp it ne b gy nn nk l nl nm">#VaR at 90%<br/>price = np.quantile(sorted(simulation_real.loc['2020-12-18 00:00:00']), 1-.90)<br/>print('.90:', (price/1557)-1)</span><span id="6de6" class="ni lp it ne b gy nn nk l nl nm">#VaR at 95%<br/>price = np.quantile(sorted(simulation_real.loc['2020-12-18 00:00:00']), 1-.95)<br/>print('.95:', (price/1557)-1)</span><span id="a151" class="ni lp it ne b gy nn nk l nl nm">#VaR at 99%<br/>price = np.quantile(sorted(simulation_real.loc['2020-12-18 00:00:00']), 1-.99)<br/>print('.99:', (price/1557)-1)</span></pre><p id="386c" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">例如，我有90%的信心，我可以在100天内损失最多16%的股票。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="06bc" class="ni lp it ne b gy nj nk l nl nm">VaR <br/>.90: -0.16419445994801085 <br/>.95: -0.19257895372980727 <br/>.99: -0.3062363704067327</span></pre></div></div>    
</body>
</html>