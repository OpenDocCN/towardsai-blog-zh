<html>
<head>
<title>Create a Boolean Image Classifier Fast With Any Data Set, With a Brief Explanation of the Convolutional Neural Network (CNN) With Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个布尔图像分类器快速与任何数据集，与卷积神经网络(CNN)与代码的简要说明</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/create-a-boolean-image-classifier-fast-with-any-data-set-with-a-brief-explanation-of-the-4b1265b5b33f?source=collection_archive---------1-----------------------#2022-11-28">https://pub.towardsai.net/create-a-boolean-image-classifier-fast-with-any-data-set-with-a-brief-explanation-of-the-4b1265b5b33f?source=collection_archive---------1-----------------------#2022-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a3edd09f2246874232af59d9a9d62eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0szq0HU1Iem9ptvs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@ray30?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷锐</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="b845" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">大家好</strong>，在本帖中，我们将探讨一种叫做卷积神经网络的神经网络。在这里，我们将详细了解它是如何工作的，以及在构建它时应该考虑什么。为了让事情变得有趣，我们将训练一个机器学习模型，并实时做出预测。</p><p id="380c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">目录</strong></p><ul class=""><li id="e6be" class="li lj iq km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated"><a class="ae kc" href="#0ea3" rel="noopener ugc nofollow"> CNN概述</a></li><li id="f952" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><a class="ae kc" href="#6c68" rel="noopener ugc nofollow">先决条件</a></li><li id="dfb6" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><a class="ae kc" href="#7613" rel="noopener ugc nofollow"> CNN架构</a></li><li id="5316" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated"><a class="ae kc" href="#f64e" rel="noopener ugc nofollow">实施</a></li></ul><p id="53ea" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">你将学到什么</strong></p><ul class=""><li id="13a6" class="li lj iq km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated">CNN如何工作</li><li id="dcb5" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">如何为培训准备图像</li><li id="175a" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">如何实现一个CNN</li></ul></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="0ea3" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak"> CNN </strong>概述</h2><p id="c0ee" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">卷积神经网络，也称为<strong class="km ir"> ConvNet </strong>，是一种深度神经网络，旨在寻找图像中的模式，图像识别和计算机视觉任务。虽然CNN是专门为处理图像而设计的，但它们也可以用于分类非图像数据，如音频数据。然而，在这篇文章中，我们将重点关注用CNN处理图像</p><h2 id="6c68" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak">深入CNN之前你应该熟悉的事情</strong></h2><p id="042a" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated"><strong class="km ir"> 1。批量大小<br/> </strong>批量大小是将通过网络传播的样本数量。假设你有160个训练样本，你的批量是32。在这种情况下，网络从训练数据集(第1个到第31个)中获取前32个样本，并将训练网络。接下来，它将从训练数据集中获取下一组样本(第33到65个),并训练网络。这个过程一直持续到所有批次都被处理和训练</p><p id="8db1" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> 2。输入_形状<br/> </strong>输入形状包含4个参数；这些是批量大小，高度，宽度和渠道。批量大小、高度和宽度是在图像处理阶段选择的，在这个阶段，我们调整图像的大小，并对数据集提出一些其他必要的要求。第四个参数“通道”取决于我们使用的图像类型。如果我们使用灰度图像，通道是1，对于RGB图像，通道是3，因为RGB图像被表示为3D张量。<br/> <strong class="km ir">想象一下</strong>你使用的是RGB图像，预处理图像的大小是256，那么input_shape应该是这样的input_shape=(256，256，3)，正如你所看到的，我们没有指定batch_size，所以我们可以在训练模型时使用任何batch_size。我们将在稍后构建模型并浏览模型摘要时讨论这一点。</p><p id="6f94" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> 3。滤镜<br/> </strong>所谓的特征检测器是一个网格矩阵，它在图像像素上移动，从输入图像中提取特征，创建输出特征图。该特征地图是下一个池层的输入。(当我们讨论架构时，我们将深入了解关于池层的更多细节。)一个卷积层可以有多个滤波器，滤波器的大小在每一层都有规定，滤波器的移动用<strong class="km ir"> Stride </strong>描述。</p><p id="bd3f" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> 4。步幅</strong> <br/>是滤波器为了提取特征而在输入图像上采取的步骤数<br/> <strong class="km ir">示例:<br/> </strong>假设我们有一个6×6的输入图像，我们选择滤波器大小为3×3，步幅为1。这意味着3×3滤波器将在6×6图像上逐个像素地移动，以形成输出特征图。让我们想象一下:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/ead7c5d4ff3b5c482f94ea33ef7c1aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*zrBQc3N8EsTcSFyhYcBBFA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="972e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个例子基于灰度图像。如果图像是RGB图像，则过滤器应该具有3个通道，因为RGB图像有3个通道深，并且每个过滤器将通过其对应的通道，并且将通过将其全部加到一个通道来创建输出特征图。</p><p id="6d59" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> 5。填充<br/> </strong>将零像素的附加外层添加到输出特征图的每一侧，以保持特征图与输入图像相同。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c686d7d9f93c70fe6c0b81758beac52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*hle6OsE2fKCt6waqymJNJg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="292c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="na">我们</em> <strong class="km ir"> <em class="na">在实现我们的模型时不会使用填充，但是让我们看看如何给卷积层添加填充。添加填充最简单的方法是使用“有效”和“相同”，</em> <strong class="km ir"> <em class="na">有效</em> </strong> <em class="na">表示没有填充，</em> <strong class="km ir"> <em class="na">相同</em> </strong> <em class="na">表示添加填充。</em></strong></p><p id="cb0c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> 6。Sigmoid激活函数</strong><br/>sigmoid激活函数用于向ML模型添加非线性，简单来说，它获取实际输出数字，并将其转换为0到1之间的范围。</p><p id="f537" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> 7。Relu激活功能</strong></p><p id="cd1c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">被称为<strong class="km ir"> Relu </strong>的整流线性单元，是深度学习神经网络中最常用的非线性激活函数。这是通过将所有负输出值转换为默认值0并保留所有正值来克服消失梯度问题，这也允许模型更快地学习。</p><h2 id="7613" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak"> CNN架构</strong></h2><p id="2a0f" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">让我们从创建CNN时所涉及的图层类型开始；通常，一个简单的CNN有3层:卷积层、汇集层和完全连接层，紧接着是致密层之前的平坦层，以及添加到每个卷积和致密层的激活层。让我们看看每一层都做了什么…</p><p id="4602" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">卷积层</strong></p><p id="b332" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是CNN的主要组成部分。CNN中可以有多个卷积层。CNN的第一层必须是卷积层。该层将图像作为输入来开始该过程。在实现这一层时，我们应该考虑的要点是:输入图像的形状、滤波器和步长。我们已经在这篇文章的先决条件部分讨论过这个问题，但是不管怎样，让我们重温一下。</p><ol class=""><li id="bbf8" class="li lj iq km b kn ko kr ks kv lk kz ll ld lm lh nb lo lp lq bi translated"><strong class="km ir">输入图像形状:<br/> </strong>此处您应考虑图像的批量大小、宽度、高度和深度，因为图像的深度会根据我们使用的图像类型而变化。因此，该参数取决于我们使用的图像类型..<a class="ae kc" href="#8db1" rel="noopener ugc nofollow"> <strong class="km ir">向上滚动查看更多</strong> </a></li><li id="4fd1" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh nb lo lp lq bi translated"><strong class="km ir">滤镜<br/> </strong>在一个卷积层中可以有多个滤镜/内核，因此，你应该描述滤镜的数量、每个滤镜的大小以及每个滤镜的<strong class="km ir">步距</strong>。过滤器用于扫描图像并提取重要特征。<a class="ae kc" href="#6f94" rel="noopener ugc nofollow"> <strong class="km ir">向上滚动查看更多</strong> </a></li></ol><p id="7eef" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">简而言之，该卷积层的目的是从图像中提取重要的特征，并创建需要输入到汇集层的输出特征地图</p><h2 id="3fec" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak">汇集层</strong></h2><p id="c405" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">CNN中使用的第二个最重要的层，汇集层，获取<strong class="km ir">特征图</strong>并将其通过另一个<strong class="km ir">过滤器</strong>以减少特征图的维度，并在从输入特征图中提取最重要的特征后生成<strong class="km ir">汇集特征图</strong>。</p><p id="e52d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">两种类型的池层:</strong></p><p id="1d5b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">最大池:</strong> <br/>在最大池中，过滤器将从过滤器覆盖的输入特征地图中获取最大元素</p><p id="a1a3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">平均池:</strong> <br/>在平均池中，过滤器将计算过滤器覆盖的输入特征图的平均值</p><p id="1b46" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">示例:</strong>假设输入特征图为4x4，池过滤器的大小为2x2(默认),默认步幅的输出如下:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/099d66ea3f2dab6582d94e107485f371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*yNsuRYrLOnjJuJNLfmBKCA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><h2 id="3a43" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak">展平图层</strong></h2><p id="15a3" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">该图层将最终汇集的要素地图转换为一维地图。为了准备下一个密集层的输入</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/878f1fbebc26561e5d6e01de99e8bead.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*y29n0OV5xPiWAhjxZnoAuA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><h2 id="28fe" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak">致密层</strong></h2><p id="3db2" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">CNN中可以有密集的多层。该图层使用展平的要素地图从中提取检测到的要素。<strong class="km ir"> Relu </strong>激活功能将用于除最后一层之外的每个密集层，因为它是进行最终分类的层。</p><h2 id="9da3" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak">连接圆点</strong></h2><p id="60df" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">CNN从卷积层开始。事实上，CNN可以有多个卷积层，每个卷积层后面都有一个汇集层。第一个卷积层将图像作为输入，当该过程开始时，卷积和池层的工作是从图像中提取重要的特征。接下来是展平层，这是完全连接层开始的地方。来自最后一个汇集层的输出将被馈送到该层，以将最后一个汇集的特征地图转换成一维数据，该数据然后将通过密集层，以便对图像进行分类。CNN中可以有多个密集层，Relu激活也用于每个卷积和密集层，除了最后一个密集层，其中softmax(或其他)激活函数将根据我们的需要使用。</p><h2 id="f64e" class="lw lx iq bd ly lz ma dn mb mc md dp me kv mf mg mh kz mi mj mk ld ml mm mn mo bi translated"><strong class="ak">实施</strong></h2><p id="339e" class="pw-post-body-paragraph kk kl iq km b kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh ij bi translated">为了演示，我们将使用Kaggle的性别分类数据集，您可以从这里获得:<a class="ae kc" href="https://www.kaggle.com/datasets/cashutosh/gender-classification-dataset" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/datasets/cashutosh/gender-classification-dataset</a></p><p id="9386" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下载并解压缩工作目录中的archive.zip文件。这个数据集有两个文件夹，培训和验证；在每个文件夹中，还有两个名为“男性”和“女性”的文件夹，其中有许多符合正确性别的图像。</p><p id="a9d1" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这里，我们将使用python编程的强大功能来获取这些图像，处理它们，并创建和训练我们的模型。</p><p id="8602" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们开始吧。</p><p id="cc89" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">导入所需的库</strong></p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="c449" class="nj lx iq nf b be nk nl l nm nn">import tensorflow as tf<br/>import numpy as np<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Dropout</span></pre><p id="3ab5" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">加载数据和处理图像</strong></p><p id="224e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了使事情变得快速简单，我们将使用TensorFlow的ImageDataGenerator API来加载和设置用于训练的数据集。</p><p id="67d9" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">将批量设置为32 — <strong class="km ir">这里解释了</strong></p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="3092" class="nj lx iq nf b be nk nl l nm nn">BATCH_SIZE = 32</span></pre><p id="03ce" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">初始化ImageDataGenerator API。在训练数据集生成器中，我们将验证拆分设置为2%，稍后我们将使用它作为测试数据集。</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="b551" class="nj lx iq nf b be nk nl l nm nn">TrainTest_Datagen = ImageDataGenerator(<br/>      rescale=1./255,<br/>      validation_split=0.2 # we will use this as test data<br/>)<br/>Validation_datagen = ImageDataGenerator(<br/>    rescale=1./255,<br/>) </span></pre><p id="393e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用所需的信息调用API，比如数据目录、图像大小、batch_size和类模式。<br/>设置图像尺寸为256x256，class_mode为二进制。让我们看看代码。</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="eda6" class="nj lx iq nf b be nk nl l nm nn">train_data = TrainTest_Datagen.flow_from_directory(<br/>    './Training',<br/>    target_size=(256,256),<br/>    batch_size=BATCH_SIZE,<br/>    class_mode='binary',<br/>    subset='training'<br/>)<br/>Test_data = TrainTest_Datagen.flow_from_directory(<br/>    './Training', <br/>    target_size=(256,256),<br/>    batch_size=BATCH_SIZE,<br/>    class_mode='binary',<br/>    subset='validation'# set as test data<br/>) <br/>Val_data = Validation_datagen.flow_from_directory(<br/>    './Validation',<br/>    target_size=(256,256),<br/>    batch_size=BATCH_SIZE,<br/>    class_mode='binary',<br/>)</span></pre><p id="f915" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">检查图像生成器生成的目标变量</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="c89a" class="nj lx iq nf b be nk nl l nm nn">train_data.class_indices</span></pre><p id="aead" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">建模与培训</strong></p><p id="98be" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将使用TensorFlow sequential API来创建我们的模型，在我们构建它之前，让我们讨论一下它的架构。</p><ul class=""><li id="bc4d" class="li lj iq km b kn ko kr ks kv lk kz ll ld lm lh ln lo lp lq bi translated">三个卷积层，过滤器的数量从16、32增加到64，并且在每个卷积层之后，每个层都应用了Relu激活函数，然后是最大池层。三个卷积层和三个汇集层。</li><li id="599b" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">接下来，展平图层。</li><li id="cf75" class="li lj iq km b kn lr kr ls kv lt kz lu ld lv lh ln lo lp lq bi translated">两个致密层。首先，一个具有应用了Relu激活函数的256个神经元，第二个具有应用了sigmoid激活函数的1个神经元</li></ul><p id="b0f1" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们看看代码。</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="2f54" class="nj lx iq nf b be nk nl l nm nn">model = Sequential([<br/>    Conv2D(16, (3,3), 1, activation='relu', input_shape = (256,256,3)),<br/>    MaxPooling2D(),<br/><br/>    Conv2D(32, (3,3), 1,  activation='relu'),<br/>    MaxPooling2D(),<br/><br/>    Conv2D(64, (3,3), 1,activation='relu'),<br/>    MaxPooling2D(),<br/><br/>    Flatten(),<br/>    Dense(256, activation='relu'),<br/>    Dense(1, activation='sigmoid')<br/>])</span></pre><p id="52dd" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">编译模型并查看摘要。</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="b208" class="nj lx iq nf b be nk nl l nm nn">model.compile(optimizer="adam",loss='binary_crossentropy',metrics = ['accuracy'])<br/>model.summary()</span></pre><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/15e294f63990ddf54622e826f4c06745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*vGhERiKsa7l5qny8IsogSQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="195e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">训练模型对于训练数据集，我们将在20个时期和每个时期1175个步骤下训练我们的模型，对于验证数据集，我们将在每个时期364个步骤下训练我们的模型。此外，我们将使用早期停止来避免在训练模型时过度拟合。</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="aedb" class="nj lx iq nf b be nk nl l nm nn">es = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=5, verbose=1)<br/>history = model.fit(<br/>      train_data,<br/>      steps_per_epoch=1175,<br/>      epochs=20,<br/>      validation_data = Val_data,<br/>      validation_steps=364,<br/>      callbacks=[es]<br/>)</span></pre><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/e53ca24d782b8c48ca95eb24250b4346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgTMcmlHWmvSBU2nIdKNrg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="db51" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这里，我们可以看到，我们的模型已经停止训练，一旦它达到第8纪元。</p><p id="934c" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">评估我们的模型</strong></p><p id="804a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这里，我们将使用我们的测试数据集来评估我们的模型，并检查其准确性。下一段代码就是这样做的</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="4e18" class="nj lx iq nf b be nk nl l nm nn">test_loss, test_acc = model.evaluate(Test_data, verbose=0)<br/>print('\nTest accuracy:', np.round(test_acc * 100,3))</span></pre><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c112987014cb4c6629ac500ba3d152f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*eemgaHjq_xf84B2dzvfL7g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="c37e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们有94.7%的准确率，这太棒了。但是等等，我们怎样才能实时使用这个模型呢？</p><p id="3d2d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">实时预测</strong></p><p id="56d7" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">首先，让我们编写一个函数来处理我们的图像，调用模型并打印出结果。</p><pre class="mv mw mx my gt ne nf ng bn nh ni bi"><span id="b9c3" class="nj lx iq nf b be nk nl l nm nn">def RealPredict(img_path):<br/>  img_test = tf.io.read_file(img_path)<br/>  img_test = tf.io.decode_jpeg(img_test , channels = 3)<br/>  img_test = tf.image.resize(img_test , [256 , 256] , method="nearest")<br/>  yhat = model.predict(np.expand_dims(img_test, 0))<br/>  if yhat &lt; 0.5: <br/>    print(f'Predicted the person a female')<br/>  else:<br/>      print(f'Predicted the person a male')</span></pre><p id="a66e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们运行这个函数，看看我们是否得到正确的结果。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f6d23931d14ac48461b19e2481f21a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*Sgcm1TLr09k3kZHQDqWcnw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="b83a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir"> <em class="na">耶，万岁</em> </strong>，<em class="na">我们的模型完美地工作着..干得好</em></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="6783" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好了，关于CNN和图像分类的教程到此结束，希望你喜欢。别忘了关注我，因为我将发布关于机器学习和全栈开发的精彩指导教程。</p><p id="ad56" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">链接到Github回购</strong>:<a class="ae kc" href="https://github.com/nafiu-dev/boolean_image_classifier_FAST-" rel="noopener ugc nofollow" target="_blank">https://github.com/nafiu-dev/boolean_image_classifier_FAST-</a></p><p id="469d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">你可以在这里和我联系:</p><p id="3a9d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae kc" href="https://www.instagram.com/nafiu.dev" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/nafiu.dev</a></p><p id="8fa4" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">Linkedin</strong>:【https://www.linkedin.com/in/nafiu-nizar-93a16720b T2】</p><p id="2e13" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="km ir">我的其他帖子:</strong></p><div class="ns nt gp gr nu nv"><a href="https://medium.com/@nafiu.dev/end-to-end-full-stack-project-from-backend-frontend-and-machine-learning-to-ethical-hacking-series-3e53779e5aff" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">从后端、前端和机器学习到道德黑客的端到端全栈项目…</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">嗨，欢迎大家参加这个从后端开发、前端开发到构建端到端项目的系列</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jw nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://medium.com/@nafiu.dev/stock-market-prediction-using-lstm-will-the-price-go-up-tomorrow-practical-guide-d1df2d54a517" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">用LSTM预测股票市场:明天价格会上涨吗？实用指南</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">本教程的目标是创建一个机器学习模型来预测股票交易的未来价值</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj jw nv"/></div></div></a></div></div></div>    
</body>
</html>