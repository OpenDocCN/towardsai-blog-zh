<html>
<head>
<title>How to Identify Objects at Pixel Level using Deep Learning in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中使用深度学习识别像素级别的对象</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-to-identify-objects-at-pixel-level-using-deep-learning-in-java-907dc482835e?source=collection_archive---------5-----------------------#2022-12-26">https://pub.towardsai.net/how-to-identify-objects-at-pixel-level-using-deep-learning-in-java-907dc482835e?source=collection_archive---------5-----------------------#2022-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="59da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">拥有深度Java库</strong></p><p id="091f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">语义分割是深度学习中的一种强大技术，允许在像素级别识别图像中的对象。语义分割的目标是用相应的类别来标记图像的每个像素。在这篇博文中，我们将探讨如何在Java中使用语义分割来识别图像中的对象。</p><p id="e236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，语义分段不同于实例分段，实例分段能够区分属于同一个类的几个实例。因此，如果我们在输入图像中有两个相同类别的对象，分割图将为这两个对象给出相同的标签。要区分同一个类的单独实例，请参考<a class="ae kl" href="https://en.wikipedia.org/wiki/Image_segmentation#Groups_of_image_segmentation" rel="noopener ugc nofollow" target="_blank">实例分割</a>。</p><p id="5835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">语义分割可以应用于广泛的用例，如自动驾驶汽车、视觉图像搜索、医学成像等。例如，语义分割可用于准确识别和分类环境中的不同对象，如行人、车辆、交通标志和建筑物。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/572f9c34fc929703bb01d22431e4bcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*M3me_dupP2D415qTxzgx_A.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">自动驾驶汽车的语义分割(<a class="ae kl" href="https://www.youtube.com/watch?v=ATlcEDSPWXY" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="8951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/deepjavalibrary" rel="noopener ugc nofollow" target="_blank">深度Java库(DJL) </a>是一个基于Java的深度学习(DL)框架。它可以用来创建和训练模型，以及运行推理。DJL提供了丰富的功能来将语义分段应用到用例中。在本帖中，我们将演示如何利用这些功能来实现一些常见的用例。</p><h1 id="e916" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">先决条件</h1><p id="e050" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先，我们需要在模块的<code class="fe mb mc md me b">build.gradle</code>文件中声明DJL依赖关系:</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="793f" class="mj kz iq me b be mk ml l mm mn">dependencies {<br/>    implementation "ai.djl:api:0.20.0"<br/>    runtimeOnly "ai.djl.pytorch:pytorch-engine:0.20.0"<br/>    runtimeOnly "ai.djl.android:pytorch-native:0.20.0"<br/>}</span></pre><h1 id="4711" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">运行推理</h1><p id="f21f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一旦我们建立了依赖关系，我们就可以开始编写代码来运行推理。在这个例子中，我们将使用<a class="ae kl" href="https://paperswithcode.com/paper/rethinking-atrous-convolution-for-semantic" rel="noopener ugc nofollow" target="_blank"> DeepLabV3 </a>模型，这是一个最先进的语义分割模型。</p><p id="8a80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要运行语义分割的推理，首先要加载语义分割模型。然后用给定的<code class="fe mb mc md me b">Model</code>和<code class="fe mb mc md me b">Translator</code>创建一个预测器。在这种情况下，将使用<code class="fe mb mc md me b">SemanticSegmentationTranslator</code>。</p><p id="459f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加载模型后，向模型提供一个图像，并接收一个“分割图”作为输出。这可以通过调用<code class="fe mb mc md me b">Predictor.predict()</code>来完成。预测器将一个<code class="fe mb mc md me b">Image</code>作为输入，并返回一个<code class="fe mb mc md me b">CategoryMask</code>作为输出。<code class="fe mb mc md me b">CategoryMask</code>包含一个代表原始图像中每个像素类别的2D数组。我们可以使用下面的代码来做到这一点:</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="7fca" class="mj kz iq me b be mk ml l mm mn">String url = "https://mlrepo.djl.ai/model/cv/semantic_segmentation/ai/djl/pytorch/deeplabv3/0.0.1/deeplabv3.zip";<br/>Criteria&lt;Image, CategoryMask&gt; criteria =<br/>        Criteria.builder()<br/>                .setTypes(Image.class, CategoryMask.class)<br/>                .optModelUrls(url)<br/>                .optTranslatorFactory(new SemanticSegmentationTranslatorFactory())<br/>                .optEngine("PyTorch")<br/>                .optProgress(new ProgressBar())<br/>                .build();<br/>try (ZooModel&lt;Image, CategoryMask&gt; model = criteria.loadModel();<br/>        Predictor&lt;Image, CategoryMask&gt; predictor = model.newPredictor()) {<br/>    CategoryMask mask = predictor.predict(img);<br/>    // Do something with `mask`<br/>}</span></pre><p id="9751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设我们有一个600x800x3的RGB彩色图像:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/f408f26f484ea424edc3b33efec36f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dv4rj6BgnPZ9M62e2BEuZg.jpeg"/></div></div></figure><p id="8b19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出<code class="fe mb mc md me b">CategoryMask</code>包含一个600×800×1的掩码数组，将类标签表示为整数。下面是缩减采样蒙版阵列:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/c286d8f0e411a2e1a331888f68a7156d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oekWK5E_h3hn0sX5vxMpVg.png"/></div></div></figure><p id="4742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DJL还提供了可视化语义分割结果的工具，例如在原始图像上覆盖分割图的能力，以突出显示模型分类为属于特定类别的区域。这些对于各种用例都很有用。</p><h1 id="09b7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用例</h1><h2 id="cbb0" class="mu kz iq bd la mv mw dn le mx my dp li jy mz na lm kc nb nc lq kg nd ne lu nf bi translated">用例1:自动驾驶汽车</h2><p id="cac7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">语义分割的一个用例是让自动驾驶汽车能够感知和理解周围的环境。例如，通过准确识别道路上其他车辆的位置，自动驾驶汽车可以就如何在交通中导航做出明智的决定。同样，通过准确识别行人和其他障碍物，自动驾驶汽车可以采取适当的行动来避免碰撞。</p><p id="96a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要识别图像中的物体，调用<code class="fe mb mc md me b">Predictor.predict()</code>将下面的图像输入模型:</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="cf37" class="mj kz iq me b be mk ml l mm mn">CategoryMask mask = predictor.predict(img);</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ng"><img src="../Images/3cfd5e99e23b54c2885cca0968556049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuJfTiRStFp0RvZM994UJw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">街景(<a class="ae kl" href="https://www.flickr.com/photos/icanchangethisright/4711334546" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="c2f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，为了可视化结果，调用<code class="fe mb mc md me b">CategoryMask.drawMask()</code>在图像上高亮显示检测到的对象。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="0360" class="mj kz iq me b be mk ml l mm mn">mask.drawMask(img, 180, 0);</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ng"><img src="../Images/24b60a46be5fa6be3a8c028421a4e477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee7Sbp2wiQ7q1wTZxXtF9g.png"/></div></div></figure><h2 id="d70e" class="mu kz iq bd la mv mw dn le mx my dp li jy mz na lm kc nb nc lq kg nd ne lu nf bi translated">用例2:从照片中提取对象</h2><p id="6c75" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">语义分割的另一个用例是从护照应用程序的照片中提取对象的过程。例如，考虑这样一个场景，个人需要提交一张护照风格的照片作为其申请的一部分。在这种情况下，目标可能是使用语义分割从照片中提取个人的面部，并使用它来生成符合所需规范的护照风格的照片。</p><p id="7c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要提取图像中的人脸，调用<code class="fe mb mc md me b">Predictor.predict()</code>将下图输入模型:</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="153f" class="mj kz iq me b be mk ml l mm mn">CategoryMask mask = predictor.predict(img);</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nh"><img src="../Images/0ab273fefcaa2b17606c05e2bcbcdb55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GuYwuppP8iDQN13d0RXmQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">肖像图像(<a class="ae kl" href="https://flickr.com/photos/86454466@N05/49985832511" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="1c04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后调用<code class="fe mb mc md me b">CategoryMask.getMaskImage()</code>方法。注意15是这个人的职业ID。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="0d12" class="mj kz iq me b be mk ml l mm mn">Image person = mask.getMaskImage(img, 15);<br/>person = person.resize(img.getWidth(), img.getHeight(), true);</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nh"><img src="../Images/eb51e7382c6b12e4bf7a02cdba182d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0wELQFBUJBeQZKCGUEJKA.png"/></div></div></figure><h2 id="6f96" class="mu kz iq bd la mv mw dn le mx my dp li jy mz na lm kc nb nc lq kg nd ne lu nf bi translated">用例3:替换视频会议的背景</h2><p id="4ba4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">语义分割的第三个用例是在视频会议中替换图像背景的过程中。例如，考虑一个场景，其中一个人正在参加视频会议，并希望用更专业或更吸引人的图像替换他们身后的背景。在这种情况下，我们可以使用语义分割从图像的背景中自动提取他们的前景(例如，他们的身体和他们拿着的任何物体)。</p><p id="de5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们可以从图像的背景中提取出个人的前景。然后，提取的前景可以合成到新的背景图像上。这允许个人用更专业或更吸引人的图像替换图像中的背景，这对于个人想要呈现更优雅的外观的视频会议是有用的。</p><p id="f456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要提取图像中的前景，调用<code class="fe mb mc md me b">Predictor.predict()</code>将下面的图像输入模型:</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="2138" class="mj kz iq me b be mk ml l mm mn">CategoryMask mask = predictor.predict(img);</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ni"><img src="../Images/0d720249c3e25ce10e278b3c2a8ee766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDoYHUduAlAAU70_n4X8aQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">视频会议现场(<a class="ae kl" href="https://www.flickr.com/photos/docsearls/49953501352" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="8419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后用另一个图像替换背景:</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="2897" class="mj kz iq me b be mk ml l mm mn">Image background = ImageFactory.getInstance().fromFile(Paths.get("image_path"));<br/>Image person = mask.getMaskImage(img, 15);<br/>person = person.resize(img.getWidth(), img.getHeight(), true);<br/>background.drawImage(person, true);</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ni"><img src="../Images/247f3565acbb6d78207e205ae3361cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HK6JUHEePtDcKDhunvxEAg.png"/></div></div></figure><p id="bead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到更多DJL示例代码<a class="ae kl" href="https://github.com/deepjavalibrary/djl/blob/master/examples/src/main/java/ai/djl/examples/inference/SemanticSegmentation.java" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DJL还提供了一款带有语义分割功能的安卓应用<a class="ae kl" href="https://github.com/deepjavalibrary/djl-demo/tree/master/android/pytorch_android/semantic_segmentation" rel="noopener ugc nofollow" target="_blank"/>，它可以拍照并运行语义分割，有多种选项。</p><h1 id="6551" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="ede5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">总之，使用Deep Java库，很容易加载深度学习模型进行语义分割，并使用它在像素级别识别图像中的对象。这对于自动驾驶汽车等应用非常有用，在这些应用中，准确检测和识别环境中的物体非常重要。有了Deep Java库，你就可以快速轻松地用Java运行深度学习模型，让它成为任何在计算机视觉领域工作的Java开发者的一个有价值的工具。</p></div></div>    
</body>
</html>