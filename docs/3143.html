<html>
<head>
<title>Introduction to Confusion Matrix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混淆矩阵介绍</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/introduction-to-confusion-matrix-50676f2756ee?source=collection_archive---------0-----------------------#2022-09-23">https://pub.towardsai.net/introduction-to-confusion-matrix-50676f2756ee?source=collection_archive---------0-----------------------#2022-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="7d7b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">模型评估</h2><div class=""/><div class=""><h2 id="2065" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">混淆矩阵是什么，如何用Python绘图？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/01033ca597ca321e32c5d5319211babf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fem8KLN2yaUSjIjoVlckeQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><p id="9645" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">混淆矩阵是实际值与预测值的直观表示。它是分类算法的性能评估工具，也称为<strong class="lg ja">误差矩阵</strong>。</p><p id="0bea" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有多少预测的类或类别被正确预测以及有多少没有被正确预测的二维表格布局允许算法性能的可视化，通常在监督学习中。</p><p id="4b43" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在预测分析中，用于二进制分类的<strong class="lg ja">混淆矩阵</strong>是一个两行两列的表格，报告了<em class="ma">真阳性</em>、<em class="ma">假阴性</em>、<em class="ma">假阳性</em>和<em class="ma">真阴性</em>的数量。这允许进行比简单观察准确性更详细的分析。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/61915221067ab8d689e36385b24aa586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2qdlYkVDzJ-jn4Rg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><h1 id="3f94" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">为什么混淆矩阵多于准确度？</h1><p id="4022" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln mw lp lq lr mx lt lu lv my lx ly lz ij bi translated">当不同类中的观测值数量相差很大时，如果用于不平衡数据集，精度度量可能会产生误导。而混淆矩阵提供了正面和负面之间的详细比较。</p><p id="dd8c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">混淆矩阵由四个重要指标组成<strong class="lg ja">真阳性(TP)、真阴性(TN)、假阳性(FP)、假阴性(FN) </strong>。</p><p id="a296" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们用一个类比来理解它们，算法必须对一个人是健康的还是生病的进行分类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a5fba74efa651a1833b5179adeb291b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XVKih_Q7xaMzWudj.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">二元分类的混淆矩阵|作者图片</figcaption></figure><p id="55e0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> (1)真阳性(TP) </strong></p><p id="4dbc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该算法预测了一个生病的“人生病了”。这表明该算法已经正确地将阳性分类。它是实际类为正时的正确预测数。</p><p id="44d5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> (2)真阴性(TN) </strong></p><p id="da88" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该算法预测一个健康的“人是健康的”。这就得出结论，该算法已经正确地对否定进行了分类。它是实际类为负时的正确预测数。</p><p id="404d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> (3)假阳性(FP) </strong></p><p id="afa4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该算法预测了一个健康的“病人”。这里的算法给出了一个错误的警报，将它误分类为阳性而不是阴性。它是实际类为正时的错误预测数，也称为<strong class="lg ja">I型误差</strong>。</p><p id="a42f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> (4)假阴性(FN) </strong></p><p id="7c00" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该算法预测一个生病的“人是健康的”。在这里，算法通过将病人归类为健康人而遗漏了病人。它是实际类别为负时的错误预测数，也称为<strong class="lg ja">第二类错误</strong>。</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="985c" class="ne md iq na b gy nf ng l nh ni">from sklearn.datasets import load_breast_cancer<br/>from sklearn.model_selection import train_test_split <br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import confusion_matrix</span><span id="7230" class="ne md iq na b gy nj ng l nh ni">X, y = load_breast_cancer(return_X_y=True)<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,                                          <br/>                                                    test_size=0.33,<br/>                                                    random_state=42)<br/>lr= LogisticRegression() <br/>lr.fit(X_train,y_train) <br/>y_pred=lr.predict(X_test)<br/>confusion_matrix(y_test, y_pred)</span><span id="1278" class="ne md iq na b gy nj ng l nh ni"><strong class="na ja">Output:<br/></strong>array([[ 63,   4],<br/>       [  3, 118]])</span></pre><p id="5445" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">sklearn中的confusion_matrix API提供了一个数组作为输出，该数组分别具有TN、FP、FN和TP，并且可以使用任何可视化库的ConfusionMatrixDisplay API或Heatmap API绘制该数组。</p><p id="1a68" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">下面是评估和绘制混淆矩阵的python方法。它将给出一个包含tn、fp、fn和tp的数组作为返回类型，并打印seaborn主题中由创建的混淆矩阵。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="865c" class="ne md iq na b gy nf ng l nh ni">from sklearn.datasets import load_breast_cancer<br/>from sklearn.model_selection import train_test_split <br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.metrics import confusion_matrix</span><span id="4288" class="ne md iq na b gy nj ng l nh ni">X, y = load_breast_cancer(return_X_y=True)<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,                                          <br/>                                                    test_size=0.33,<br/>                                                    random_state=42)<br/>lr= LogisticRegression() <br/>lr.fit(X_train,y_train) <br/>y_pred=lr.predict(X_test)<br/>conf_mat, ax = confusion_matrix(y_test, y_pred)</span></pre><p id="a46e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">下面是代码</em>的输出</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/14570ffe31eafa2b8b78d91065579b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/0*0sCD-ZRo2G9JGcWw.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">困惑矩阵|作者图片</figcaption></figure><p id="4f19" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">目标是保持尽可能多的总磷和总氮值。</strong></p><p id="e0c1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这篇博客中，我们了解了什么是混淆矩阵，以及如何用Python绘制它。对真阳性(TP)、真阴性(TN)、假阳性(FP)和假阴性(FN)的解释是混淆矩阵的构建度量。</p><p id="4ada" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，可以从混淆矩阵中导出多个度量，如准确度、精确度、召回率、ROC等等。详见<a class="ae nn" rel="noopener ugc nofollow" target="_blank" href="/deep-dive-into-confusion-matrix-6b8111d5c3f7"> <strong class="lg ja">深潜困惑矩阵</strong> </a>。</p><p id="cb95" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">参考文献:</strong></p><p id="6dcc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[1] sklearn混淆矩阵API。<a class="ae nn" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html#sklearn.metrics.confusion_matrix" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . metrics .混淆_matrix.html#sklearn.metrics .混淆_matrix </a></p><p id="651e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[2] sklearn混淆矩阵显示API。<a class="ae nn" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.ConfusionMatrixDisplay.html#sklearn.metrics.ConfusionMatrixDisplay" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . metrics . confusionmatrix display . html # sk learn . metrics . confusionmatrix display</a></p><p id="3506" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[3] seaborn热图API。<a class="ae nn" href="https://seaborn.pydata.org/generated/seaborn.heatmap.html" rel="noopener ugc nofollow" target="_blank">https://seaborn.pydata.org/generated/seaborn.heatmap.html</a></p></div></div>    
</body>
</html>