<html>
<head>
<title>This Is How You Can Build a Churn Prediction Model Using Apache Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是如何使用Apache Spark构建客户流失预测模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/this-is-how-you-can-build-a-churn-prediction-model-using-spark-e187b7eca339?source=collection_archive---------3-----------------------#2022-09-20">https://pub.towardsai.net/this-is-how-you-can-build-a-churn-prediction-model-using-spark-e187b7eca339?source=collection_archive---------3-----------------------#2022-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个关于如何仅使用Apache Spark构建流失预测管道的端到端教程。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb5e1d0b78864e5fe131be095b303b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C4Y021-8olff8beq.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建的图像具有稳定的扩散性。</figcaption></figure><p id="3fe7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是关于如何使用来自<strong class="la iu"> Spark </strong>的ML栈<strong class="la iu">构建流失预测分类器</strong>的<strong class="la iu">教程</strong>。</p><p id="0f5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用来自一家名为<strong class="la iu"> Sparkify </strong>的<strong class="la iu">虚拟公司</strong>的<strong class="la iu">数据，这是一家音乐流媒体公司。数据集包含与平台交互的用户创建的各种事件。</strong></p><p id="09a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将仔细查看这些数据。但是，我要感谢<em class="lu"> Udacity </em>公开了这些数据。没有他们，我做不出这个教程。</p><p id="d4dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lv" href="https://udacity-dsnd.s3.amazonaws.com/sparkify/mini_sparkify_event_data.json" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以<strong class="la iu">下载</strong>数据集的迷你版本，在这里<a class="ae lv" href="https://udacity-dsnd.s3.amazonaws.com/sparkify/sparkify_event_data.json" rel="noopener ugc nofollow" target="_blank">下载</a>整个数据集。</p><h2 id="b04f" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">什么是客户流失？</h2><p id="5b45" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">客户流失是指有人选择停止使用你的产品或服务。</p><h2 id="659a" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">这样的模型为什么有用？</h2><p id="7f7b" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">通过建立这样一个模型，我们可以理解用户离开公司的原因。因此，这是一种基于用户活动数据改善客户体验和保留的方法。</p><h1 id="8550" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">目录</h1><ol class=""><li id="8cfe" class="nf ng it la b lb mp le mq lh nh ll ni lp nj lt nk nl nm nn bi translated">定义Spark会话</li><li id="95bf" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">加载数据集</li><li id="2aed" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">清理数据集</li><li id="47d5" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">定义客户流失标签</li><li id="e84d" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">探索性数据分析</li><li id="f8a8" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">特征工程</li><li id="8a44" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">建模</li><li id="231a" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">结果</li><li id="3122" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">结论</li></ol><p id="7b59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lu">注:</em> </strong> <em class="lu">我们把所有的代码都记在一个笔记本上。</em></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="fda7" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">1️⃣定义了一个火花会话</h1><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="9b9d" class="lw lx it og b gy ok ol l om on">spark = SparkSession.\<br/>    builder.\<br/>    appName("Sparkify Churn Prediction").\<br/>    getOrCreate()</span></pre><p id="70a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建了一个名为<strong class="la iu"> Sparkify流失预测</strong>的spark会话。通过这个会话，我们可以加载并运行所有的计算。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="6d85" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">2️⃣加载数据集</h1><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="ee16" class="lw lx it og b gy ok ol l om on">EVENT_DATA_LINK = "mini_sparkify_event_data.json"</span><span id="8d8c" class="lw lx it og b gy oo ol l om on">df = spark.read.json(EVENT_DATA_LINK)<br/>df.persist()</span></pre><p id="f124" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<strong class="la iu">mini _ Spark ify _ event _ data . JSON</strong>文件下载到与笔记本相同的目录下，并借助Spark会话加载到内存中。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="657c" class="lw lx it og b gy ok ol l om on">df.printSchema()</span><span id="427b" class="lw lx it og b gy oo ol l om on"><br/>|-- artist: string (nullable = true)<br/>|-- auth: string (nullable = true)<br/>|-- firstName: string (nullable = true)<br/>|-- gender: string (nullable = true)<br/>|-- itemInSession: long (nullable = true)<br/>|-- lastName: string (nullable = true)<br/>|-- length: double (nullable = true)<br/>|-- level: string (nullable = true)<br/>|-- location: string (nullable = true)<br/>|-- method: string (nullable = true)<br/>|-- page: string (nullable = true)<br/>|-- registration: long (nullable = true)<br/>|-- sessionId: long (nullable = true)<br/>|-- song: string (nullable = true)<br/>|-- status: long (nullable = true)<br/>|-- ts: long (nullable = true)<br/>|-- userAgent: string (nullable = true)<br/>|-- userId: string (nullable = true)</span></pre><p id="d4db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文中使用的最重要的列如下:</p><ul class=""><li id="8c76" class="nf ng it la b lb lc le lf lh op ll oq lp or lt os nl nm nn bi translated"><em class="lu">艺术家:</em>当前正在播放的歌曲的艺术家。</li><li id="6fda" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">级别:</em>分类变量，可以<em class="lu">付费</em>或<em class="lu">免费</em>。</li><li id="b6e7" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">页面:</em>用户在应用程序中的位置(例如，登录页面，在</li><li id="2ff2" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">注册</em>:注册的UTC时间戳。</li><li id="0cd1" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu"> sessionId: </em>用户当前会话的Id。</li><li id="f4e2" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">歌曲:</em>当前正在播放的歌曲。</li><li id="43dc" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">状态</em>:事件的HTTP状态。(例如，200、307、404)。</li><li id="0efd" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu"> ts </em>:事件的UTC时间戳。</li><li id="2624" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">用户Id: </em>用户的Id。</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="51fd" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">3️⃣清理数据集</h1><p id="f0e9" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">在实际的笔记本中，我们对要清理的内容做了更广泛的检查，但为了保持简洁，我们将只显示最重要的内容。</p><h2 id="fcb2" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">检查NaNs/空值</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="df4c" class="lw lx it og b gy ok ol l om on">df.select([<br/>    F.count(F.when(F.isnull(c), c)).alias(c) for c in df.columns<br/>]).show()<br/></span><span id="2e76" class="lw lx it og b gy oo ol l om on">+------+----+---------+------+-------------+--------+------+-----+--------+------+----+------------+---------+-----+------+---+---------+------+<br/>|artist|auth|firstName|gender|itemInSession|lastName|length|level|location|method|page|registration|sessionId| song|status| ts|userAgent|userId|<br/>+------+----+---------+------+-------------+--------+------+-----+--------+------+----+------------+---------+-----+------+---+---------+------+<br/>| 58392|   0|     8346|  8346|            0|    8346| 58392|    0|    8346|     0|   0|        8346|        0|58392|     0|  0|     8346|     0|<br/>+------+----+---------+------+-------------+--------+------+-----+--------+------+----+------------+---------+-----+------+---+---------+------+</span></pre><p id="a754" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集中的大多数空值都用<strong class="la iu"> None表示。</strong></p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="3288" class="lw lx it og b gy ok ol l om on">df.select([<br/>     F.count(F.when(F.col(c) == "", c)).alias(c) for c in df.columns<br/>]).show()</span><span id="a988" class="lw lx it og b gy oo ol l om on"><br/>+------+----+---------+------+-------------+--------+------+-----+--------+------+----+------------+---------+----+------+---+---------+------+<br/>|artist|auth|firstName|gender|itemInSession|lastName|length|level|location|method|page|registration|sessionId|song|status| ts|userAgent|userId|<br/>+------+----+---------+------+-------------+--------+------+-----+--------+------+----+------------+---------+----+------+---+---------+------+<br/>|     0|   0|        0|     0|            0|       0|     0|    0|       0|     0|   0|           0|        0|   0|     0|  0|        0|  8346|<br/>+------+----+---------+------+-------------+--------+------+-----+--------+------+----+------------+---------+----+------+---+---------+------+</span></pre><p id="fe97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<strong class="la iu"> userId </strong>列上有一个例外，空值用一个空字符串表示。</p><h2 id="c9ac" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">未注册的用户</h2><p id="6db3" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">字符串为空的用户是未注册的用户；因此，平台不能给他们分配任何ID。</p><p id="84fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">查看未注册用户页面分布</strong></p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="2662" class="lw lx it og b gy ok ol l om on">df.filter(F.col("userId") == "").select("page").groupby("page").count().show()</span><span id="dfd4" class="lw lx it og b gy oo ol l om on"><br/>+-------------------+-----+<br/>|               page|count|<br/>+-------------------+-----+<br/>|               Home| 4375|<br/>|              About|  429|<br/>|              Login| 3241|<br/>|               Help|  272|<br/>|              Error|    6|<br/>|           Register|   18|<br/>|Submit Registration|    5|<br/>+-------------------+-----+</span></pre><p id="365c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用未注册的用户数据不能帮助我们预测客户流失。因此，我们将把这些行从Spark数据帧中删除。</p><p id="5b7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">删除未注册用户</strong></p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="737a" class="lw lx it og b gy ok ol l om on">cleaned_df = df.filter(F.col("userId") != "")</span></pre><h2 id="3d43" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">空艺术家行</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="296b" class="lw lx it og b gy ok ol l om on">df.filter(<br/>    F.isnull(F.col("artist"))<br/>).select(<br/>    ["artist", "song", "userId", "page"]<br/>).groupby("page").count().show()</span><span id="f1be" class="lw lx it og b gy oo ol l om on"><br/>+--------------------+-----+<br/>|                page|count|<br/>+--------------------+-----+<br/>|              Cancel|   52|<br/>|    Submit Downgrade|   63|<br/>|         Thumbs Down| 2546|<br/>|                Home|14457|<br/>|           Downgrade| 2055|<br/>|         Roll Advert| 3933|<br/>|              Logout| 3226|<br/>|       Save Settings|  310|<br/>|Cancellation Conf...|   52|<br/>|               About|  924|<br/>|            Settings| 1514|<br/>|               Login| 3241|<br/>|     Add to Playlist| 6526|<br/>|          Add Friend| 4277|<br/>|           Thumbs Up|12551|<br/>|                Help| 1726|<br/>|             Upgrade|  499|<br/>|               Error|  258|<br/>|      Submit Upgrade|  159|<br/>|            Register|   18|<br/>+--------------------+-----+</span></pre><p id="f768" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当艺术家为空时，用户花在其他页面上的时间比听音乐的时间还多。在这种情况下，这些信息对于理解注册用户的行为是有价值的。</p><h2 id="2274" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">填充空值</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1766" class="lw lx it og b gy ok ol l om on">cleaned_df = cleaned_df.fillna({<br/>    "length": 0,<br/>    "artist": "unknown",<br/>    "song": "unknown"<br/>})</span></pre><p id="35ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一步，我们想用<strong class="la iu"> None </strong>值填充这些行。此时，当用户没有在听任何东西时，空行只出现在与歌曲相关的字段中。这些行中的信息很有价值，我们不建议删除它们。</p><p id="11a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们将<strong class="la iu">歌曲的长度</strong>设置为<strong class="la iu"> 0 </strong>，将<strong class="la iu">艺人</strong>和<strong class="la iu">歌曲</strong>设置为<strong class="la iu">未知</strong>。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="c8b5" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">4️⃣定义客户流失标签</h1><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="74f8" class="lw lx it og b gy ok ol l om on">cleaned_df.select(<br/>    F.count(<br/>        F.when(F.col("page") == "Cancellation Confirmation", "page")<br/>    ).alias("Cancellation Confirmation")<br/>).show()</span><span id="2a5a" class="lw lx it og b gy oo ol l om on"><br/>+-------------------------+<br/>|Cancellation Confirmation|<br/>+-------------------------+<br/>|                       52|<br/>+-------------------------+</span></pre><p id="73df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当订阅被取消时，我们将认为用户被“<strong class="la iu">搅动”</strong>。</p><p id="0921" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lu">注意:</em> </strong> <em class="lu">如果我们想进入下一个级别，我们也可以使用</em> <strong class="la iu"> <em class="lu">降级</em> </strong> <em class="lu">事件来表示客户流失事件。</em></p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="ec09" class="lw lx it og b gy ok ol l om on">labeled_df = cleaned_df.withColumn(<br/>    "churnEvent", <br/>    F.when(<br/>       F.col("page") == "Cancellation Confirmation",<br/>       1<br/>    ).otherwise(0)<br/>)</span></pre><p id="a1de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为中间步骤，我们将创建<strong class="la iu"> churnEvent </strong>列，这是一个检查“<strong class="la iu">取消确认”</strong>事件的标志。我们在<strong class="la iu">事件</strong>级别设计了<strong class="la iu">变化</strong>列<strong class="la iu"> </strong>。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="fe26" class="lw lx it og b gy ok ol l om on">user.labeled_df = labeled_df.withColumn(<br/>    "churn", <br/>    F.sum("churnEvent").over(Window.partitionBy("userId"))<br/>)<br/>labeled_df = labeled_df.withColumn(<br/>    "churn", <br/>    F.when(F.col("churn") &gt;= 1, 1).otherwise(0)<br/>)</span></pre><p id="389f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<strong class="la iu"> churnEvent </strong>标志聚合到用户级别，并将其裁剪为0或1。因此，用户在所有事件中都有一个<strong class="la iu"> churn = 1 </strong>或<strong class="la iu"> no-churn = 0 </strong>标志。</p><p id="2013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，最终，我们要建立一个预测用户流失，而不是事件流失的分类器。这就是为什么用户要么是<strong class="la iu">流失= 1 </strong>要么是<strong class="la iu">无流失= 0 </strong>。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="d0eb" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">5️⃣探索性数据分析</h1><p id="42fd" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated"><strong class="la iu">注意:</strong>为了保持文章简短，我们将只展示那些帮助我们设计有价值特性的情节。你可以<em class="lu">在这里看到所有的图表</em>和<em class="lu">这些图表是如何绘制的</em> <a class="ae lv" href="https://github.com/IusztinPaul/distributed-churn-prediction" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="b7c1" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">用户流失分布</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/13f5c9219921d957ec850ff58a9ac00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zMpBvjZ8VzB6QY0_.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ly">流失</strong>和<strong class="bd ly">未流失</strong>用户数量之间的柱状图。[图片由作者提供]</figcaption></figure><p id="d25d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分布高度偏向于<strong class="la iu">无流失</strong>用户。我们将使用<strong class="la iu"> F1分数</strong>在交叉验证步骤中找到最佳模型，以考虑这一因素。</p><h2 id="5af9" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">可能的页面</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="e9fb" class="lw lx it og b gy ok ol l om on">eda_df.select("page").distinct().show()</span><span id="fde8" class="lw lx it og b gy oo ol l om on"><br/>+--------------------+<br/>|                page|<br/>+--------------------+<br/>|              Cancel|<br/>|    Submit Downgrade|<br/>|         Thumbs Down|<br/>|                Home|<br/>|           Downgrade|<br/>|         Roll Advert|<br/>|              Logout|<br/>|       Save Settings|<br/>|Cancellation Conf...|<br/>|               About|<br/>|            Settings|<br/>|     Add to Playlist|<br/>|          Add Friend|<br/>|            NextSong|<br/>|           Thumbs Up|<br/>|                Help|<br/>|             Upgrade|<br/>|               Error|<br/>|      Submit Upgrade|<br/>+--------------------+</span><span id="89bf" class="lw lx it og b gy oo ol l om on">eda_df.filter(<br/>    F.col("artist") != "unknown"<br/>).select("page").distinct().show()</span><span id="ae00" class="lw lx it og b gy oo ol l om on">+--------+<br/>|    page|<br/>+--------+<br/>|NextSong|<br/>+--------+</span></pre><p id="1312" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一播放音乐的页面叫做<strong class="la iu"> NextSong </strong>。</p><h2 id="bf29" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">每个用户平均访问页面数的分布</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/a06702563887e4e51870277ba7b2f830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uybiN_TDKKIsvpPS.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">柱状图显示了<strong class="bd ly">流失</strong>和<strong class="bd ly">未流失</strong>用户之间的平均访问页面数。图片由作者提供。</figcaption></figure><p id="b318" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">留在平台上的用户平均访问了更多的页面。</p><h2 id="5e54" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">每个用户收听的平均歌曲数量的分布</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/de5952899c4feaf7029277e7703830a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uTlT1mO4d2BlvIzh.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">柱状图显示了在<strong class="bd ly">流失用户</strong>和<strong class="bd ly">未流失用户</strong>之间播放歌曲的平均数量。[图片由作者提供]</figcaption></figure><p id="4d81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">平均而言，留在平台上的用户听了更多的歌曲。</p><h2 id="99d7" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">每个用户收听的艺术家平均数量的分布</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/353930c4b887dc8373cdfe7bbaed0d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BUgqfzKaZ0l4W2Td.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">柱状图显示了在<strong class="bd ly">流失用户</strong>和<strong class="bd ly">未流失用户</strong>之间被收听艺术家的平均数量。[图片由作者提供]</figcaption></figure><p id="869f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">平均而言，留在平台上的用户在听更广泛的艺术家的音乐。</p><h2 id="3fba" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">自注册分布以来的时间增量</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/6e36b48c5150c082147b245484d91ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5-7i-hBh1_yQCSG2.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">直方图显示了<strong class="bd ly">流失</strong>和<strong class="bd ly">未流失</strong>用户自注册以来经过的时间分布。[图片由作者提供]</figcaption></figure><p id="5d02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lu">【时间δ=</em></strong><em class="lu">用户在平台注册后的秒数。</em></p><p id="cb74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<strong class="la iu">流失</strong>用户来说，注册后的时间增量看起来像是<em class="lu">右偏</em>。同时<strong class="la iu">无流失</strong>分布呈正态分布。因此，时间增量的<strong class="la iu">平均值是一个很好的预测值。</strong></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="450b" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">6️⃣特色工程</h1><p id="c00a" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated"><strong class="la iu">流失分类</strong>将在<strong class="la iu">用户级别</strong>执行。因此，我们需要将每个用户的数据聚集在一行中。</p><h2 id="3a14" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">为什么要在用户级别汇总数据？</h2><p id="78ea" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">最终预测应该用于预测特定用户是否倾向于离开公司，而不是用户将退订的事件。因此，一个单独的事件对我们来说是无用的，但是它的集合是极其有价值的。</p><h2 id="3d28" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">定义一些效用函数:</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="02ef" class="lw lx it og b gy ok ol l om on">def count_with_condition(condition):<br/>    """Utility function to count only specific rows based on the 'condition'."""<br/>    return F.count(F.when(condition, True))<br/></span><span id="67fa" class="lw lx it og b gy oo ol l om on">def count_distinct_with_condition(condition, values):<br/>    """Utility function to count only distinct &amp; specific rows based on the 'condition'."""<br/>    return F.count_distinct(F.when(condition, values))</span></pre><h2 id="67a1" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated"><strong class="ak">创建特征工程Spark数据框架</strong></h2><p id="a8a2" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">概括地说，我们将使用EDA步骤中提供的功能。在<a class="ae lv" href="https://github.com/IusztinPaul/distributed-churn-prediction" rel="noopener ugc nofollow" target="_blank">笔记本</a>中，我们调查了更多的潜在功能，但这四个功能在<strong class="la iu">流失用户</strong>和<strong class="la iu">未流失用户</strong>之间显示出最强的预测能力:</p><ul class=""><li id="bb43" class="nf ng it la b lb lc le lf lh op ll oq lp or lt os nl nm nn bi translated"><em class="lu">访问过的页面总数</em>。</li><li id="6c95" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">播放的<em class="lu">首歌曲总数</em>。</li><li id="cec8" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">总艺人总数</em>。</li><li id="70fc" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated"><em class="lu">自<em class="lu">注册</em>以来的时间戳</em>(秒)。</li></ul><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="3058" class="lw lx it og b gy ok ol l om on">aggregated_df = labeled_df.groupby("userId").agg(<br/>    F.count("page").alias("pages"),<br/>    count_with_condition(<br/>        F.col("page") == "NextSong"<br/>    ).alias("plays"),<br/>    count_distinct_with_condition(<br/>        F.col("artist") != "unknown", F.col("artist")<br/>    ).alias("artists"),<br/>    F.max(F.col("ts") - F.col("registration")).alias("delta"),<br/>    F.max("churn").alias("churn")<br/>)<br/>aggregated_df.show(n=5)</span><span id="1deb" class="lw lx it og b gy oo ol l om on"><br/>+------+-----+-----+-------+-----------+-----+<br/>|userId|pages|plays|artists|      delta|churn|<br/>+------+-----+-----+-------+-----------+-----+<br/>|100010|  381|  275|    252| 4807612000|    0|<br/>|100014|  310|  257|    233| 7351206000|    1|<br/>|100021|  319|  230|    207| 5593438000|    1|<br/>|   101| 2149| 1797|   1241| 4662657000|    1|<br/>|    11|  848|  647|    534|10754921000|    0|<br/>+------+-----+-----+-------+-----------+-----+</span></pre><h2 id="791f" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">将数据帧映射到火花矢量</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="2ceb" class="lw lx it og b gy ok ol l om on">assembler = VectorAssembler(<br/>    inputCols=[<br/>        "pages", "plays", "artists", "delta"<br/>], outputCol="unscaled_features")<br/>engineered_df = assembler.transform(aggregated_df)<br/>engineered_df = engineered_df.select(<br/>    F.col("unscaled_features"),<br/>    F.col("churn").alias("label")<br/>)</span></pre><p id="3de0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">火花模型</strong>期望在输入端有一个火花矢量。同样，默认情况下，他们期望<strong class="la iu">输入</strong>特性位于名为<strong class="la iu">特性</strong>的列中，而<strong class="la iu">目标</strong>位于名为<strong class="la iu">标签</strong>的列中。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="6b3d" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">7️⃣造型</h1><p id="a660" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">我们将训练和测试三个模型:</p><ol class=""><li id="7678" class="nf ng it la b lb lc le lf lh op ll oq lp or lt nk nl nm nn bi translated">逻辑回归</li><li id="86f7" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">朴素贝叶斯</li><li id="538d" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">梯度推进树</li></ol><p id="cea2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用三重交叉验证来寻找最佳超参数。</p><p id="bcc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在列车分割中使用<strong class="la iu"> 80% </strong>的数据，在测试分割中使用<strong class="la iu"> 20% </strong>的数据。</p><p id="dd4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用标准定标器将特征标准化。</p><p id="0cf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为标签高度不平衡，我们将使用<strong class="la iu"> F1分数</strong>来评估模型。<strong class="la iu"> F1得分</strong>指标在考虑不平衡分配问题的<strong class="la iu">精度</strong>和<strong class="la iu">召回</strong>下运行。</p><h2 id="1e70" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">定义一些效用函数:</h2><p id="10f1" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">如果你只对结果感兴趣，跳过它们。</p><p id="764f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">Spark ML语法与Sklearn中使用的语法非常相似。</em></p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="4fd6" class="lw lx it og b gy ok ol l om on">def run(pipeline, paramGrid, train_df, test_df):<br/>    """<br/>    Main function used to train &amp; test a given model.<br/>    The training step uses cross-validation to find the best hyper-parameters for the model.</span><span id="90b7" class="lw lx it og b gy oo ol l om on">    :param pipeline: Model pipeline.<br/>    :param paramGrid: Parameter grid used for cross-validation.<br/>    :param train_df: Training dataframe.<br/>    :param test_df: Testing dataframe.<br/>    :return: the best model from cross-validation.<br/>    """</span><span id="573c" class="lw lx it og b gy oo ol l om on">    fitted_model = fit_model(paramGrid, pipeline, train_df)<br/>    evaluate_model(fitted_model, test_df)</span><span id="c479" class="lw lx it og b gy oo ol l om on">    return fitted_model<br/></span><span id="af55" class="lw lx it og b gy oo ol l om on">def fit_model(paramGrid, pipeline, train_df):<br/>    """<br/>    Function that trains the model using cross-validation.<br/>    Also, it prints the best validation results and hyper-parameters.</span><span id="6548" class="lw lx it og b gy oo ol l om on">    :param paramGrid: Parameter grid used for cross-validation.<br/>    :param pipeline: Model pipeline.<br/>    :param train_df: Training dataframe.<br/>    :return: the best model from cross-validation.<br/>    """</span><span id="4e0a" class="lw lx it og b gy oo ol l om on">    crossval = CrossValidator(<br/>        estimator=pipeline,<br/>        estimatorParamMaps=paramGrid,<br/>        evaluator = MulticlassClassificationEvaluator(<br/>              metricName="f1", <br/>              beta=1.0<br/>        ),<br/>        parallelism=3,<br/>        numFolds=3<br/>    )</span><span id="e7bd" class="lw lx it og b gy oo ol l om on">    fitted_model = crossval.fit(train_df)<br/>    print_best_validation_score(fitted_model)<br/>    print_best_parameters(fitted_model)</span><span id="d8fc" class="lw lx it og b gy oo ol l om on">    return fitted_model<br/></span><span id="b575" class="lw lx it og b gy oo ol l om on">def create_pipeline(model):<br/>    """<br/>    Create a pipeline based on a model.</span><span id="04da" class="lw lx it og b gy oo ol l om on">    :param model: The end model that will be used for training.<br/>    :return: the built pipeline.<br/>    """</span><span id="610e" class="lw lx it og b gy oo ol l om on">    scaler = StandardScaler(<br/>        inputCol="unscaled_features", <br/>        outputCol="features"<br/>    )<br/>    pipeline = Pipeline(stages=[scaler, model])</span><span id="8be1" class="lw lx it og b gy oo ol l om on">    return pipeline<br/></span><span id="14e7" class="lw lx it og b gy oo ol l om on">def print_best_validation_score(cross_validation_model):<br/>    """Prints the best validation score based on the results from the cross-validation model."""<br/>    print()<br/>    print("-" * 60)<br/>    print(f"F1 score, on the validation split, for the best model: {np.max(cross_validation_model.avgMetrics) * 100:.2f}%")<br/>    print("-" * 60)<br/></span><span id="9a56" class="lw lx it og b gy oo ol l om on">def print_best_parameters(cross_validation_model):<br/>    """Prints the best hyper-parameters based on the results from the cross-validation model."""</span><span id="2277" class="lw lx it og b gy oo ol l om on">    parameters = cross_validation_model \<br/>       .getEstimatorParamMaps() [np.argmax(cross_validation_model.avgMetrics)]</span><span id="fe7f" class="lw lx it og b gy oo ol l om on">    print()<br/>    print("-" * 60)<br/>    print("Best model hyper-parameters:")<br/>    for param, value in parameters.items():<br/>        print(f"{param}: {value}")<br/>    print("-" * 60)<br/></span><span id="df76" class="lw lx it og b gy oo ol l om on">def evaluate_model(model, test_df):<br/>    """Evaluate the model on the test set using F1 score and print the results."""</span><span id="f9a4" class="lw lx it og b gy oo ol l om on">    predictions = model.transform(test_df)<br/>    evaluator =  MulticlassClassificationEvaluator(<br/>            metricName="f1", <br/>            beta=1.0<br/>          )<br/>    metric = evaluator.evaluate(predictions)</span><span id="88a1" class="lw lx it og b gy oo ol l om on">    print()<br/>    print("-" * 60)<br/>    print(f"F1 score, on the test set is: {metric*100:.2f}%")<br/>    print("-" * 60)</span><span id="1aeb" class="lw lx it og b gy oo ol l om on">    return metric</span></pre><h2 id="5878" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">拆分数据</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d67b" class="lw lx it og b gy ok ol l om on">train_df, test_df = engineered_df.randomSplit([0.8, 0.2], seed=42)</span></pre><h2 id="06d7" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">逻辑回归</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="6acc" class="lw lx it og b gy ok ol l om on">lr = LogisticRegression()<br/>pipeline = create_pipeline(lr)</span><span id="6911" class="lw lx it og b gy oo ol l om on">paramGrid = ParamGridBuilder() \<br/>    .addGrid(lr.maxIter, [10, 25, 50])  \<br/>    .addGrid(lr.regParam, [0.05, 0.1, 0.2]) \<br/>    .addGrid(lr.elasticNetParam, [0.05, 0.1, 0.2]) \<br/>    .build()run(<br/>   pipeline,<br/>   paramGrid,<br/>   train_df.alias("train_df_lr"),<br/>   test_df.alias("test_df_lr")<br/>);</span></pre><h2 id="148f" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">朴素贝叶斯</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8736" class="lw lx it og b gy ok ol l om on">nb = NaiveBayes()<br/>pipeline = create_pipeline(nb)</span><span id="5cda" class="lw lx it og b gy oo ol l om on">paramGrid = ParamGridBuilder() \<br/>    .addGrid(nb.smoothing, [0.5, 1, 2])  \<br/>    .build()run(<br/>   pipeline,<br/>   paramGrid,<br/>   train_df.alias("train_df_nb"),<br/>   test_df.alias("test_df_nb")<br/>);</span></pre><h2 id="6122" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">梯度推进</h2><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="a7a0" class="lw lx it og b gy ok ol l om on">gbt = GBTClassifier()<br/>pipeline = create_pipeline(gbt)</span><span id="f4bf" class="lw lx it og b gy oo ol l om on">paramGrid = ParamGridBuilder() \<br/>    .addGrid(gbt.maxIter, [10, 20, 30]) \<br/>    .addGrid(gbt.stepSize, [0.05, 0.1]) \<br/>    .build()run(<br/>   pipeline,<br/>   paramGrid, <br/>   train_df.alias("train_df_gbt"),<br/>   test_df.alias("test_df_gbt")<br/>);</span></pre><p id="90ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">训练&amp;测试代码的三个片段</strong>都有<em class="lu">相同的结构</em>。</p><p id="71f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将<strong class="la iu">管道</strong>定义为<em class="lu">缩放步骤</em>和<em class="lu">实际模型</em>。此外，我们定义了超参数的<strong class="la iu">交叉验证网格</strong>。最后，我们将所有这些对象传递给<strong class="la iu"> run </strong>函数。其在给定的数据分割和配置上训练和评估模型。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="1ac5" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">8️⃣结果</h1><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="5508" class="lw lx it og b gy ok ol l om on">|        Model        | Validation |   Test   |<br/>|:-------------------:|:----------:|:--------:|<br/>| Logistic Regression |   0.6958   |  0.5952  |<br/>|     Naive Bayes     |   0.6672   |  0.5952  |<br/>|  Gradient Boosting  |  *0.7333*  | *0.8473* |</span></pre><p id="b7a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与逻辑回归和Naive Bay相比，<strong class="la iu"> GBT </strong>模型具有更好的<strong class="la iu"/><strong class="la iu">F1得分</strong>，这是因为<strong class="la iu"> GBT </strong>模型更复杂，能够更好地理解非线性关系。</p><p id="509c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，在不考虑两个变量之间的<strong class="la iu">相关性</strong>或<strong class="la iu">非线性关系</strong>等因素的情况下，梯度推进方法比其他方法如<strong class="la iu"> LR </strong>或<strong class="la iu"> NB </strong>表现得更好。基于树的模型对这些问题不敏感，因为它们独立地创建叶子并支持多维关系。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="2235" class="mu lx it bd ly mv oa mx mb my ob na me jz oc ka mh kc od kd mk kf oe kg mn ne bi translated">9️⃣结论</h1><p id="2db2" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">太好了！我们设法只用<strong class="la iu"> Spark </strong>训练一个像样的<strong class="la iu">分类器</strong>。</p><p id="95f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们<strong class="la iu">加载</strong>数据集，<strong class="la iu">清理</strong>它，<strong class="la iu">分析</strong>它，最后，我们<strong class="la iu">创建了</strong>一套有用的<strong class="la iu">特征</strong>来预测<strong class="la iu">客户流失</strong>。</p><p id="9cf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了工程数据，我们<strong class="la iu">训练</strong>和<strong class="la iu">测试</strong>三个流失预测模型。通过使用<strong class="la iu">交叉验证</strong>，我们找到了以下型号的<strong class="la iu">最佳超参数</strong>:</p><ul class=""><li id="0896" class="nf ng it la b lb lc le lf lh op ll oq lp or lt os nl nm nn bi translated">逻辑回归</li><li id="5c8e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">朴素贝叶斯</li><li id="dbf8" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">梯度推进</li></ul><p id="67e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们比较了结果，发现<strong class="la iu"> GBT </strong>车型在验证和测试分割中的<strong class="la iu"> F1得分最高</strong>。</p><p id="615c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进一步改进模型，我们可以做以下工作:</p><ul class=""><li id="4b2f" class="nf ng it la b lb lc le lf lh op ll oq lp or lt os nl nm nn bi translated">添加更多功能</li><li id="21b3" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">解决标签失衡</li><li id="9328" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">使用<strong class="la iu">降级</strong>事件生成更多<strong class="la iu">流失</strong>标签</li><li id="8784" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">更多超参数调整</li><li id="336d" class="nf ng it la b lb no le np lh nq ll nr lp ns lt os nl nm nn bi translated">使用XGBoost或LightGBM</li></ul><blockquote class="ow"><p id="10e1" class="ox oy it bd oz pa pb pc pd pe pf lt dk translated">你还有什么进一步改进模型的建议？</p></blockquote><p id="b6cc" class="pw-post-body-paragraph ky kz it la b lb pg ju ld le ph jx lg lh pi lj lk ll pj ln lo lp pk lr ls lt im bi translated"><strong class="la iu"> <em class="lu">注:</em> </strong> <em class="lu">你可以在这里</em>  <em class="lu">访问GitHub库</em> <a class="ae lv" href="https://github.com/IusztinPaul/distributed-churn-prediction" rel="noopener ugc nofollow" target="_blank"> <em class="lu">。</em></a></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="e913" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">🎉谢谢你看我的文章！</p><p id="1588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">📢如果你喜欢这篇文章，并且想分享我进入AI、ML和MLOps的学习之旅，你也可以关注我的<a class="ae lv" href="https://www.linkedin.com/in/pauliusztin/" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">LinkedIn</strong></a><strong class="la iu">。</strong></p></div></div>    
</body>
</html>