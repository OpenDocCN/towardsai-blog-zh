<html>
<head>
<title>Databricks MLflow Tracking For Linear Regression Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性回归模型的数据块ml流跟踪</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/databricks-mlflow-tracking-for-linear-regression-model-8585d5f5f8a2?source=collection_archive---------1-----------------------#2022-06-06">https://pub.towardsai.net/databricks-mlflow-tracking-for-linear-regression-model-8585d5f5f8a2?source=collection_archive---------1-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="760c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何使用MLflow跟踪不同的模型版本，检索实验信息？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/27a4fa6046250609a0a252924ae2c6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uarrLj51a4kxXBTE"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Solen Feyissa 在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="35a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">MLflow是一个用于机器学习生命周期管理的开源平台。Databricks上的MLflow提供了运行、跟踪和服务机器学习模型的集成体验。在本教程中，我们将涵盖:</p><ul class=""><li id="0170" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">如何使用MLflow跟踪不同的模型版本？</li><li id="f3dd" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何编程检索MLflow实验信息？</li><li id="73aa" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何使用Databricks UI检索MLflow信息？</li></ul><p id="5071" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">本帖资源:</strong></p><ul class=""><li id="2e8b" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">YouTube<a class="ae le" href="https://www.youtube.com/watch?v=yHDVYpEupHU&amp;list=PLVppujud2yJrb5CCEu0gqgI_W0YuCygIc&amp;index=8" rel="noopener ugc nofollow" target="_blank">上这篇文章的视频教程</a></li><li id="2e97" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">带代码的笔记本</li><li id="3b60" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">关于<a class="ae le" href="https://www.youtube.com/playlist?list=PLVppujud2yJrb5CCEu0gqgI_W0YuCygIc" rel="noopener ugc nofollow" target="_blank"> Databricks和PySpark的更多视频教程</a></li><li id="4247" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">更多关于<a class="ae le" href="https://medium.com/@AmyGrabNGoInfo/list/databricks-and-pyspark-7b59768e202d" rel="noopener"> Databricks和PySpark的博客文章</a></li></ul><p id="1c86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧！</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="1a46" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤1:导入库</h1><p id="301b" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在步骤1中，我们将导入库。<code class="fe nd ne nf ng b">pandas</code>、<code class="fe nd ne nf ng b">numpy</code>和pyspark SQL函数用于数据处理。</p><p id="9f30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf ng b">matplotlib</code>是为了形象化。</p><p id="8c5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf ng b">make_regression</code>用于创建合成建模数据集。</p><p id="66a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从<code class="fe nd ne nf ng b">pyspark.ml</code>库中，我们导入了用于特征格式化的<code class="fe nd ne nf ng b">VectorAssembler</code>，用于模型训练的<code class="fe nd ne nf ng b">LinearRegression</code>，用于模型评估的<code class="fe nd ne nf ng b">RegressionEvaluator</code>，以及用于管道创建和加载的<code class="fe nd ne nf ng b">Pipeline</code>。</p><p id="c765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还导入了<code class="fe nd ne nf ng b">mlflow</code>、<code class="fe nd ne nf ng b">mlflow.spark</code>用于spark flavor、<code class="fe nd ne nf ng b">MlflowClient</code>用于查询型号信息。如果使用Databricks运行时进行机器学习，则安装MLflow。否则，可以从PyPI安装MLflow包。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="8a46" class="nl mb it ng b gy nm nn l no np"># Data processing<br/>import pandas as pd<br/>import numpy as np<br/>from pyspark.sql.functions import log, col, exp</span><span id="9549" class="nl mb it ng b gy nq nn l no np"># Visulaization<br/>import matplotlib.pyplot as plt</span><span id="b362" class="nl mb it ng b gy nq nn l no np"># Create synthetic dataset<br/>from sklearn.datasets import make_regression</span><span id="7c99" class="nl mb it ng b gy nq nn l no np"># Modeling<br/>from pyspark.ml.feature import VectorAssembler<br/>from pyspark.ml.regression import LinearRegression<br/>from pyspark.ml.evaluation import RegressionEvaluator<br/>from pyspark.ml import Pipeline</span><span id="5839" class="nl mb it ng b gy nq nn l no np"># MLflow<br/>import mlflow<br/>import mlflow.spark<br/>from mlflow.tracking import MlflowClient</span></pre><h1 id="5810" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">步骤2:为线性回归创建数据集</h1><p id="b8b2" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在步骤2中，我们将为线性回归模型创建一个合成数据集。</p><p id="d70a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nd ne nf ng b">make_regression</code>，创建了一个包含一百万条记录的数据集。该数据集有两个特征，并且这两个特征都是信息性的。它的噪声为10，偏差为2。<code class="fe nd ne nf ng b">random_state</code>确保随机创建的数据集可重现。随机状态不一定是42。它可以是任何数字。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="3815" class="nl mb it ng b gy nm nn l no np"># Create a synthetic dataset<br/>X, y = make_regression(n_samples=1000000, <br/>                       n_features=2, <br/>                       n_informative=2,<br/>                       noise=10, <br/>                       bias=2, <br/>                       random_state=42)</span></pre><p id="d53a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建数据集后，我们可以将值调整到所需的范围。在此示例中，第一个要素的值被缩放到1到100之间，第二个要素的值被缩放到1000到5000之间，目标的值被缩放到3000到80，000之间。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="9234" class="nl mb it ng b gy nm nn l no np"># Scale feature 1 to values between 1 and 100<br/>X[:, 0] = np.interp(X[:, 0], (X[:, 0].min(), X[:, 0].max()), (1, 100))</span><span id="79bb" class="nl mb it ng b gy nq nn l no np"># Scale feature 2 to values between 1000 and 5000<br/>X[:, 1] = np.interp(X[:, 1], (X[:, 1].min(), X[:, 1].max()), (1000, 5000))</span><span id="0743" class="nl mb it ng b gy nq nn l no np"># Scale dependent variable to values between 3000 and 80000<br/>y = np.interp(y, (y.min(), y.max()), (3000, 80000))</span></pre><p id="b73a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf ng b">make_regression</code>的输出是数组格式。我们将其转换成熊猫数据帧，然后熊猫数据帧被转换成火花数据帧。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="471d" class="nl mb it ng b gy nm nn l no np"># Convert the data from numpy array to a pandas dataframe<br/>pdf = pd.DataFrame({'feature1': X[:, 0], 'feature2': X[:, 1], 'dependent_variable': y})</span><span id="a19a" class="nl mb it ng b gy nq nn l no np"># Convert pandas dataframe to spark dataframe<br/>sdf = spark.createDataFrame(pdf)</span><span id="da68" class="nl mb it ng b gy nq nn l no np"># Check data summary statistics<br/>display(sdf.summary())</span></pre><p id="1ad4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf ng b">summary()</code>给出了数据集的汇总统计数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/d99f417bcaadb5a1cc22e114e1716abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-fqVXq8GFl5_YWRM.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">线性回归的合成数据—来自GrabNGoInfo.com的图像</figcaption></figure><p id="c422" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们检查特征和因变量之间的散点图。可视化是使用Databricks笔记本内置功能创建的。要了解更多信息，请查看我之前关于大数据<a class="ae le" href="https://grabngoinfo.com/databricks-dashboard-for-big-data/" rel="noopener ugc nofollow" target="_blank">Data bricks Dashboard</a>的教程。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="ba53" class="nl mb it ng b gy nm nn l no np">display(sdf.select('dependent_variable', 'feature1'))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/42fe2e9e1313556925c26499e147ab36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ilDcFsoEXfXL7hiX.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">特征1和因变量之间的散点图—来自GrabNGoInfo.com的图像</figcaption></figure><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="91e8" class="nl mb it ng b gy nm nn l no np">display(sdf.select('dependent_variable', 'feature2'))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/675833ac8298c3ae70af0fc22115767a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QqAv3Wppm3V9_1tx.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">特征2和因变量之间的散点图—来自GrabNGoInfo.com的图像</figcaption></figure><p id="8f07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，两种功能的散点图都显示出积极的趋势，但它们的形状和斜率不同。</p><h1 id="019d" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">步骤3:训练测试分割</h1><p id="acb5" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在创建建模数据集之后，在步骤3中，我们将进行训练测试分割。</p><p id="de6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nd ne nf ng b">randomSplit</code>，我们将数据集分成80%的训练和20%的验证。<code class="fe nd ne nf ng b">seed=42</code>使随机分割结果可重复。但是，我们需要确保在复制分割时使用相同的集群和分区号。</p><p id="5a75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分割后，我们在训练数据集中得到800，299，在测试数据集中得到199，701。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="6518" class="nl mb it ng b gy nm nn l no np"># Train test split<br/>trainDF, testDF = sdf.randomSplit([.8, .2], seed=42)</span><span id="c959" class="nl mb it ng b gy nq nn l no np"># Print the number of records<br/>print(f'There are {trainDF.cache().count()} records in the training dataset.')<br/>print(f'There are {testDF.cache().count()} records in the testing dataset.')</span></pre><h1 id="6f16" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">步骤4:原始数据的线性回归—模型1</h1><p id="0765" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在第4步中，我们将使用线性回归创建第一个模型。在此模型中，将直接使用合成数据集中创建的要素和因变量。所以我们给它起个运行名<code class="fe nd ne nf ng b">LR-Raw-Data</code>。</p><p id="bbf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，使用spark ML训练线性回归模型。要了解更多细节，请查看我之前关于使用Spark ML 的<a class="ae le" href="https://grabngoinfo.com/databricks-linear-regression-with-spark-ml/" rel="noopener ugc nofollow" target="_blank"> Databricks线性回归的教程。</a></p><p id="c16b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后记录模型的参数。对于这个实验，我们计划创建两个版本的模型，一个使用原始因变量，另一个使用因变量的对数。模型1使用原始因变量。为了记录这些信息，我们将因变量的名称保存到一个名为<code class="fe nd ne nf ng b">target_variable</code>的参数中。</p><p id="3764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还记录了弹性网的参数。0.5表示50%的拉索(L1)正则化和50%的岭(L2)正则化。要了解更多关于正则化，请查看我以前的教程<a class="ae le" href="https://grabngoinfo.com/lasso-l1-vs-ridge-l2-vs-elastic-net-regularization-for-classification-model/" rel="noopener ugc nofollow" target="_blank">拉索(L1) Vs山脊(L2) Vs弹性网正则化</a>。</p><p id="6ed6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们为这次运行记录了模型，对测试数据集进行了预测，并将预测CSV文件保存为工件。</p><p id="d340" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在进行模型性能评估时，我们计算了RMSE、R平方、MSE和MAE。并且它们被记录为实验度量。</p><p id="a40e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，创建因变量分布图，并将其记录为工件。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="f616" class="nl mb it ng b gy nm nn l no np">with mlflow.start_run(run_name="LR-Raw-Data") as run:<br/>    # Define pipeline<br/>    vecAssembler = VectorAssembler(inputCols=["feature1", "feature2"], outputCol="features")<br/>    lr = LinearRegression(featuresCol="features", labelCol="dependent_variable", predictionCol="prediction",elasticNetParam=0.5)<br/>    pipeline = Pipeline(stages=[vecAssembler, lr])<br/>    pipelineModel = pipeline.fit(trainDF)</span><span id="8ced" class="nl mb it ng b gy nq nn l no np">    # Log parameters<br/>    mlflow.log_param("target_variable", "dependent_variable")<br/>    mlflow.log_param("elasticNetParam", 0.5)</span><span id="bdb8" class="nl mb it ng b gy nq nn l no np">    # Log the model for this run<br/>    mlflow.spark.log_model(pipelineModel, "SparkML-linear-regression")</span><span id="fc9d" class="nl mb it ng b gy nq nn l no np">    # Make predictions<br/>    predDF = pipelineModel.transform(testDF)    <br/>    <br/>    # Save the prediction as csv<br/>    predDF.toPandas().to_csv('predictions.csv', index=False)<br/>    <br/>    # Log the saved prediction as artifact<br/>    mlflow.log_artifact("predictions.csv")<br/>    <br/>    # Evaluate predictions<br/>    regressionEvaluator = RegressionEvaluator(predictionCol="prediction", labelCol="dependent_variable")<br/>    rmse = regressionEvaluator.setMetricName("rmse").evaluate(predDF)<br/>    r2 = regressionEvaluator.setMetricName("r2").evaluate(predDF)<br/>    mse = regressionEvaluator.setMetricName("mse").evaluate(predDF)<br/>    mae = regressionEvaluator.setMetricName("mae").evaluate(predDF)<br/>    <br/>    # Log metrics<br/>    mlflow.log_metric("rmse", rmse)<br/>    mlflow.log_metric("r2", r2)    <br/>    mlflow.log_metric("mse", mse)    <br/>    mlflow.log_metric("mae", mae)    </span><span id="124d" class="nl mb it ng b gy nq nn l no np">    # Create a plot for the testing dataset<br/>    testDF.toPandas().hist(column="dependent_variable", bins=100)<br/>    <br/>    # Log artifact<br/>    plt.savefig("dependent_variable.png")<br/>    mlflow.log_artifact("dependent_variable.png")</span></pre><h1 id="ef6b" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">步骤5:使用对数目标的线性回归—模型2</h1><p id="c6b0" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">取对数是一种常用的数据转换技术。它通常用于将非正态分布数据转换为正态分布。我们的合成数据已经是正态分布，所以它不需要对数。但是为了便于说明，我们想创建一个带有对数转换的模型版本。</p><p id="97be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将运行命名为<code class="fe nd ne nf ng b">LR-Log-Target</code>，表明目标变量是原始数据的对数变换。</p><p id="c685" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，为训练数据集和测试数据集创建因变量的对数。</p><p id="dbeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码的其余部分与前面的模型非常相似，除了三处变化。第一个变化是与因变量相关的信息更新为对数版本。第二个变化是elasticNetParam从0.5变为0.8。第三个变化与模型预测有关。因为模型训练的目标标签是对数形式的，所以预测值也是对数形式的。因此，在进行模型性能评估之前，我们需要计算预测的指数。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="3228" class="nl mb it ng b gy nm nn l no np">with mlflow.start_run(run_name="LR-Log-Target") as run:<br/>    # Take the log of the target variable<br/>    logTrainDF = trainDF.withColumn("log_dv", log(col("dependent_variable")))<br/>    logTestDF = testDF.withColumn("log_dv", log(col("dependent_variable")))</span><span id="85cb" class="nl mb it ng b gy nq nn l no np">    # Define pipeline<br/>    vecAssembler = VectorAssembler(inputCols=["feature1", "feature2"], outputCol="features")<br/>    lr = LinearRegression(featuresCol="features", labelCol="log_dv", predictionCol="log_prediction", elasticNetParam=0.8)<br/>    pipeline = Pipeline(stages=[vecAssembler, lr])<br/>    pipelineModel = pipeline.fit(logTrainDF)</span><span id="2522" class="nl mb it ng b gy nq nn l no np">    # Log parameters<br/>    mlflow.log_param("target_variable", "log_dv")<br/>    mlflow.log_param("elasticNetParam", 0.8)</span><span id="e753" class="nl mb it ng b gy nq nn l no np">    # Log model<br/>    mlflow.spark.log_model(pipelineModel, "SparkML-linear-regression")</span><span id="49c3" class="nl mb it ng b gy nq nn l no np">    # Make predictions<br/>    predDF = pipelineModel.transform(logTestDF)<br/>    expDF = predDF.withColumn("prediction", exp(col("log_prediction")))<br/>    <br/>    # Save the prediction as csv<br/>    predDF.toPandas().to_csv('predictions.csv', index=False)<br/>    <br/>    # Log the samved prediction as artifact<br/>    mlflow.log_artifact("predictions.csv")<br/>    <br/>    # Evaluate predictions<br/>    regressionEvaluator = RegressionEvaluator(predictionCol="prediction", labelCol="dependent_variable")<br/>    rmse = regressionEvaluator.setMetricName("rmse").evaluate(expDF)<br/>    r2 = regressionEvaluator.setMetricName("r2").evaluate(expDF)<br/>    mse = regressionEvaluator.setMetricName("mse").evaluate(expDF)<br/>    mae = regressionEvaluator.setMetricName("mae").evaluate(expDF)<br/>    <br/>    # Log metrics<br/>    mlflow.log_metric("rmse", rmse)<br/>    mlflow.log_metric("r2", r2)    <br/>    mlflow.log_metric("mse", mse)    <br/>    mlflow.log_metric("mae", mae)    <br/>    <br/>    # Create a plot for the testing dataset<br/>    logTestDF.toPandas().hist(column="log_dv", bins=100)<br/>    <br/>    # Log artifact<br/>    figPath = 'grabngoinfo_' + "logDv.png" <br/>    plt.savefig("log_dependent_variable.png")<br/>    mlflow.log_artifact("log_dependent_variable.png")</span></pre><h1 id="ae60" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">步骤6:以编程方式获取模型实验信息</h1><p id="9b5d" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在步骤6中，我们将通过编程获得模型实验信息。</p><p id="d7b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf ng b">MlflowClient()</code>中的<code class="fe nd ne nf ng b">list_experiments()</code>列出了所有的实验及其id。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="f22f" class="nl mb it ng b gy nm nn l no np"># List MLflow experiments<br/>MlflowClient().list_experiments()</span></pre><p id="68b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实验有两种，工作空间实验和笔记本实验。</p><ul class=""><li id="e056" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">工作空间实验是从Databricks机器学习UI或MLflow API创建的。任何笔记本都可以通过实验ID或实验名称将运行记录到工作区实验中。我们可以从工作区菜单访问工作区实验。</li><li id="ceaf" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">笔记本实验与特定的笔记本相关联。实验是由Databricks自动创建的。我们可以从笔记本上访问笔记本实验。</li></ul><p id="95dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程中的实验是一个笔记本实验。</p><p id="b6d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获得一个实验的所有运行，使用<code class="fe nd ne nf ng b">mlflow.search_runs</code>并传入<code class="fe nd ne nf ng b">experiment_id</code>。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="f728" class="nl mb it ng b gy nm nn l no np"># Get all runs for a given experiment<br/>experiment_id = run.info.experiment_id<br/>runs_df = mlflow.search_runs(experiment_id)</span><span id="e57d" class="nl mb it ng b gy nq nn l no np"># Display information<br/>runs_df.T</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/1778185aad1ffdbee0b7097ea43af465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l90iVe8vR86x9ON-.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">数据块获取MLflow实验的所有运行结果—图片来自GrabNGoInfoc.om</figcaption></figure><p id="539b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，具有原始数据的模型比数据的日志版本具有更好的性能。</p><p id="11cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个实验中有很多次运行时，我们可能希望按时间降序排列这些运行，并获取最新运行的信息。<code class="fe nd ne nf ng b">max_results</code>控制要保持的运行次数。</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="2818" class="nl mb it ng b gy nm nn l no np"># Get the the latest run<br/>runs = MlflowClient().search_runs(experiment_id, order_by=["attributes.start_time desc"], max_results=1)</span><span id="68b6" class="nl mb it ng b gy nq nn l no np"># Get the metrics from the latest run<br/>runs[0].data.metrics</span></pre><p id="6a7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出</p><pre class="kp kq kr ks gt nh ng ni nj aw nk bi"><span id="2c3c" class="nl mb it ng b gy nm nn l no np">Out[33]: {'mae': 1166.6333634351645,<br/> 'mse': 2702618.876696308,<br/> 'r2': 0.9609755978839164,<br/> 'rmse': 1643.9643781713485}</span></pre><h1 id="061b" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">步骤7:使用用户界面获取模型实验信息</h1><p id="a8a1" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在第7步中，我们将讨论如何使用Databricks UI来检索实验信息。</p><h2 id="7d78" class="nl mb it bd mc nz oa dn mg ob oc dp mk kb od oe mo kf of og ms kj oh oi mw oj bi translated">步骤7.1:访问笔记本中的实验信息</h2><p id="0db8" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">要查看笔记本内的实验信息，我们可以点击笔记本右上角的<strong class="js iu">实验</strong>图标。笔记本右侧边栏显示了这两种型号。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1b21bd65533c7cb19c9f0bdfcbeadd25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*4qwJdj4Xm61uw5Fe.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">访问Databricks笔记本中的实验信息—图片来自GrabNGoInfo.com</figcaption></figure><h2 id="017a" class="nl mb it bd mc nz oa dn mg ob oc dp mk kb od oe mo kf of og ms kj oh oi mw oj bi translated">步骤7.2:进入实验界面</h2><p id="f109" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">要在新页面上打开完整的实验UI，请点击侧边栏底部的蓝色<strong class="js iu">实验UI </strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/8baa29c2bfaca581cfdbc06a4525e4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zc8WxH0bORC2UMKC.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">访问Databricks笔记本中的实验信息—图片来自GrabNGoInfo.com</figcaption></figure><h2 id="a01c" class="nl mb it bd mc nz oa dn mg ob oc dp mk kb od oe mo kf of og ms kj oh oi mw oj bi translated">步骤7.3:访问实验运行信息</h2><p id="3636" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">要查看跑步详情，请点击蓝色的<strong class="js iu">开始时间</strong>(本例中为6小时前)或跑步的<strong class="js iu">型号</strong>下的蓝色火花。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/3c3228cfb109b2e42ad29c1fef792e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0wwFMFKShEilCEde.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Databricks MLflow实验运行界面—图片来自GrabNGoInfo.com</figcaption></figure><p id="cb7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过单击UI左侧的选项列表，我们可以获得关于这次运行的详细信息。它还提供了使用Spark和pandas dataframe进行预测的代码。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="576f" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">摘要</h1><p id="97af" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在本教程中，我们讨论了如何使用MLflow来跟踪spark ML线性回归模型。我们涵盖了:</p><ul class=""><li id="44fc" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">如何使用MLflow跟踪不同的模型版本？</li><li id="664c" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何编程检索MLflow实验信息？</li><li id="6124" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何使用Databricks UI检索MLflow信息？</li></ul><p id="f584" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多教程可在GrabNGoInfo <a class="ae le" href="https://www.youtube.com/channel/UCmbA7XB6Wb7bLwJw9ARPcYg" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>和<a class="ae le" href="https://grabngoinfo.com/tutorials/" rel="noopener ugc nofollow" target="_blank">GrabNGoInfo.com</a>获得</p><h1 id="591a" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">推荐给你</h1><ul class=""><li id="f176" class="lf lg it js b jt my jx mz kb ol kf om kj on kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/grabngoinfo/grabngoinfo-machine-learning-tutorials-inventory-9b9d78ebdd67" rel="noopener"> GrabNGoInfo机器学习教程盘点</a></li><li id="4ea5" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/p/one-class-svm-for-anomaly-detection-6c97fdd6d8af" rel="noopener">用于异常检测的单级SVM</a></li><li id="7889" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/p/multivariate-time-series-forecasting-with-seasonality-and-holiday-effect-using-prophet-in-python-d5d4150eeb57" rel="noopener">利用Python中的Prophet进行具有季节性和假日效应的多元时间序列预测</a></li><li id="79fc" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/p/hyperparameter-tuning-for-xgboost-91449869c57e" rel="noopener">XGBoost</a>的超参数调谐</li><li id="210f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/p/recommendation-system-user-based-collaborative-filtering-a2e76e3e15c4" rel="noopener">推荐系统:基于用户的协同过滤</a></li><li id="5747" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/p/four-oversampling-and-under-sampling-methods-for-imbalanced-classification-using-python-7304aedf9037" rel="noopener">使用Python实现不平衡分类的四种过采样和欠采样方法</a></li><li id="4410" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/p/how-to-detect-outliers-data-science-interview-questions-and-answers-1e400284f6b4" rel="noopener">如何检测离群值|数据科学面试问答</a></li><li id="37a7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://medium.com/@AmyGrabNGoInfo/lasso-l1-vs-ridge-l2-vs-elastic-net-regularization-for-classification-model-409c3d86f6e9" rel="noopener"> LASSO (L1) Vs Ridge (L2) Vs分类模型的弹性网正则化</a></li></ul><h1 id="caa5" class="ma mb it bd mc md nr mf mg mh ns mj mk ml nt mn mo mp nu mr ms mt nv mv mw mx bi translated">参考</h1><ul class=""><li id="abf0" class="lf lg it js b jt my jx mz kb ol kf om kj on kn lk ll lm ln bi translated"><a class="ae le" href="https://mlflow.org/docs/latest/index.html" rel="noopener ugc nofollow" target="_blank"> MLflow文档</a></li><li id="f55b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://docs.databricks.com/applications/mlflow/index.html" rel="noopener ugc nofollow" target="_blank">数据块上的ml流动指南</a></li><li id="3b59" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://docs.databricks.com/applications/mlflow/quick-start-python.html#language-PySpark" rel="noopener ugc nofollow" target="_blank"> MLflow快速启动</a></li><li id="f60d" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://spark.apache.org/docs/latest/ml-classification-regression.html" rel="noopener ugc nofollow" target="_blank"> Apache Spark MLlib分类和回归文档</a></li><li id="f4ab" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.regression.LinearRegression.html#pyspark.ml.regression.LinearRegression" rel="noopener ugc nofollow" target="_blank"> MLlib线性回归Python API文档</a></li><li id="2816" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://docs.databricks.com/applications/mlflow/tracking.html#view-notebook-experiment" rel="noopener ugc nofollow" target="_blank">跟踪机器学习训练运行文档</a></li></ul><div class="oo op gp gr oq or"><a href="https://medium.com/@AmyGrabNGoInfo/membership" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">通过我的推荐链接加入媒体-艾米GrabNGoInfo</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ky or"/></div></div></a></div></div></div>    
</body>
</html>