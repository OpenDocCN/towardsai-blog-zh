<html>
<head>
<title>Getting Started with Apache Kafka — Beginners Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Kafka入门—初学者教程</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/getting-started-with-apache-kafka-beginners-tutorial-d38e3634706c?source=collection_archive---------2-----------------------#2020-07-27">https://pub.towardsai.net/getting-started-with-apache-kafka-beginners-tutorial-d38e3634706c?source=collection_archive---------2-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="83ea" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><p id="d366" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">本文的目的是建立对什么是卡夫卡，为什么是卡夫卡，卡夫卡建筑，生产者，消费者，经纪人，以及卡夫卡生态系统的不同组成部分的理解。以及Python-Kafka的一个小编码练习。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/1bf84ca8dd8681bb1619a239ace4ac2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*H-jctAhDgYK6bNoo-6vSLg.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">卡夫卡生态系统</figcaption></figure><h1 id="2c77" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">1.卡夫卡是什么？</h1><p id="4a20" class="pw-post-body-paragraph jw jx iq jy b jz me kb kc kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt ij bi translated">Apache Kafka是一个分布式的、基于发布-订阅的持久消息传递系统，在进程、应用程序和服务器之间交换数据。换句话说，它是一个高度可伸缩、容错和敏捷的企业消息传递系统。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/b4caa78318b94a8a4e0c4928aee3b69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoJMv3eRZZtXejU52fym_A.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">卡夫卡信息系统</figcaption></figure><p id="1d48" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">不同的应用程序可以连接到Kafka系统，并向主题推送消息/记录。消息/记录可以是从数据库表记录到应用程序事件或web服务器日志的任何内容。消息或记录具有由关键字、强制属性的值以及可选的时间戳和报头组成的格式。简单地说，主题可以理解为保存记录或消息的数据库表。</p><h1 id="77f5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">2.卡夫卡建筑</h1><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mo"><img src="../Images/306d92bce6c78de2c5b2f2411ede61dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jj8Y-HnyoS71L2TK_eHhNg.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">体系结构</figcaption></figure><p id="e762" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">Apache Kafka架构的故事围绕着四个核心API:生产者、消费者、流和连接器。集群基本上是一个或多个Kafka服务器或代理的集合，是分布式消息传递系统的一部分。让我们更详细地了解它们。</p><p id="1488" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> Producer API: </strong>支持应用程序连接到Kafka Brokers，并发布一个或多个Kafka主题的记录或消息流。</p><p id="8942" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">消费者API: </strong>支持应用程序连接到Kafka代理，并消费来自一个或多个Kafka主题的记录或消息流。</p><p id="7c2c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> Streams API: </strong>使应用程序能够消费来自一个或多个主题的输入流，并为一个或多个主题生成输出流，从而允许输入和输出流的转换。</p><p id="5e1c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">连接器API: </strong>允许编写可重用的消费者和生产者代码，例如，从数据库读取数据并发布到Kafka主题，从Kafka主题消费数据并写入数据库。</p><h2 id="7926" class="mp lh iq bd li mq mr dn lm ms mt dp lq kh mu mv lu kl mw mx ly kp my mz mc iw bi translated">什么是经纪人？</h2><p id="d004" class="pw-post-body-paragraph jw jx iq jy b jz me kb kc kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt ij bi translated">代理是Kafka集群的一个实例或单个服务器。Kafka Broker存储关于一个或多个主题的消息。我们为了访问消息或记录而连接的代理实例称为引导服务器。一个集群可以有数百个代理。</p><h2 id="dd61" class="mp lh iq bd li mq mr dn lm ms mt dp lq kh mu mv lu kl mw mx ly kp my mz mc iw bi translated">什么是动物园管理员？</h2><p id="5dd4" class="pw-post-body-paragraph jw jx iq jy b jz me kb kc kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt ij bi translated">动物园管理员可以理解为整个生态系统的资源管理部分。它保存关于系统中运行的进程的元数据，执行健康检查和代理领导者选择等。</p><h2 id="9610" class="mp lh iq bd li mq mr dn lm ms mt dp lq kh mu mv lu kl mw mx ly kp my mz mc iw bi translated">什么是话题？</h2><p id="b667" class="pw-post-body-paragraph jw jx iq jy b jz me kb kc kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt ij bi translated">主题是保存发布给Kafka代理的消息或记录的结构。在内部，一个主题被划分为多个分区，分区就是数据发布的确切位置。这些分区分布在集群中的代理上。主题由名称标识，就像数据库中的表一样。特应性是分区的。主题的每个分区都有一个引导读/写操作的leader。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi na"><img src="../Images/83b11fbb9e01098e32e30c2f35e9195b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*hnbEUJKvpQRZO5OS0aZtVg.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">分区主题</figcaption></figure><p id="aca8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这就是关于卡夫卡的理论部分，还有其他一些概念，我们将在接下来的博客中涉及。</p><h1 id="ed3b" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">3.用例及编码:</h1><p id="ec7c" class="pw-post-body-paragraph jw jx iq jy b jz me kb kc kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt ij bi translated">在一个非常基本的Python代码的帮助下，我们将以键-值对格式向Kafka Broker发布一些消息，并从Broker消费这些消息。但在此之前，需要启动并运行一些服务来访问Kafka集群。</p><p id="021a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">第一步:启动动物园管理员</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="d378" class="mp lh iq nc b gy ng nh l ni nj">D:\Kafka_setup\kafka_2.12–2.5.0\bin\windows\zookeeper-server-start.bat D:\Kafka_setup\kafka_2.12–2.5.0\config\zookeeper.properties</span></pre><p id="3a03" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">第二步:</strong>启动卡夫卡经纪人</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="a9ba" class="mp lh iq nc b gy ng nh l ni nj">D:\Kafka_setup\kafka_2.12–2.5.0\bin\windows\kafka-server-start.bat D:\Kafka_setup\kafka_2.12–2.5.0\config\server.properties</span></pre><p id="5b05" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">第三步:</strong>创造话题</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="47b2" class="mp lh iq nc b gy ng nh l ni nj">D:\Kafka_setup\kafka_2.12–2.5.0\bin\windows\kafka-topics.bat — zookeeper localhost:2181 — create — topic demo1 — partitions 2 — replication-factor 2</span></pre><p id="daa8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我创建了一个包含两个分区的主题，复制因子为2。在这种情况下，因为集群有两个以上的代理，所以分区是均匀分布的，每个分区的副本都被复制到另一个代理。由于复制因子为2，因此即使代理宕机，也不会有数据丢失。为了实现弹性，复制因子应该大于1并且小于集群中代理的数量。</p><p id="bbbd" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">步骤4: </strong>启动消费者控制台</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="aaf3" class="mp lh iq nc b gy ng nh l ni nj">D:\Kafka_setup\kafka_2.12–2.5.0\bin\windows\kafka-console-consumer.bat — bootstrap-server localhost:9092 —-topic demo1</span></pre><p id="6440" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">步骤5: </strong>运行生产者代码，将消息推送给Kafka Broker</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="bcc6" class="mp lh iq nc b gy ng nh l ni nj">#producer.py<br/>from json import dumps<br/>import json<br/>from kafka import KafkaProducer</span><span id="d0f9" class="mp lh iq nc b gy nk nh l ni nj">producer = KafkaProducer(bootstrap_servers=['localhost:9092'],<br/>                         value_serializer=lambda x:json.dumps(x).encode('utf-8'))</span><span id="d517" class="mp lh iq nc b gy nk nh l ni nj">try:<br/>    for num in range(1,5):<br/>        msg={'num': num}<br/>        producer.send('demo1',value=msg)<br/>    producer.send('demo1', {'name': 'vivek'})<br/>    producer.send('demo1', {'name': 'vishakha'})<br/>except Exception as e:<br/>    print(e)</span><span id="9913" class="mp lh iq nc b gy nk nh l ni nj">print('Message sent to kafka demo1')</span></pre><p id="7275" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">步骤6:检查消费者控制台上的消息</strong></p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/11c034dde82fef1cb82825e2929e803a.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*7yIErqzTyB6DQ_1ZBt9Lcw.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">代理消息</figcaption></figure><p id="2d93" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">步骤7: </strong>运行消费者代码来订阅消息</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="6cfd" class="mp lh iq nc b gy ng nh l ni nj">#consumer.py<br/>from kafka import KafkaConsumer<br/>from json import loads<br/>import json</span><span id="41b6" class="mp lh iq nc b gy nk nh l ni nj">consumer = KafkaConsumer(‘demo1’,<br/> bootstrap_servers=[‘localhost:9092’],<br/> auto_offset_reset=’earliest’,<br/> enable_auto_commit=True,<br/> group_id=’my-group’,<br/> value_deserializer=lambda x: loads(x.decode(‘utf-8’)))</span><span id="6488" class="mp lh iq nc b gy nk nh l ni nj">for message in consumer:<br/> msg = message.value<br/> print(msg)<br/>consumer.close()</span><span id="f72d" class="mp lh iq nc b gy nk nh l ni nj">#subscribed messages:<br/>{"num": 1}<br/>{"num": 2}<br/>{"num": 3}<br/>{"num": 4}<br/>{"name": "vivek"}<br/>{"name": "vishakha"}</span></pre><p id="e5e0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">让我们了解一下我们在生产者和消费者代码中使用的属性:</p><p id="029a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> bootstrap_servers </strong>:设置生产者应该联系的主机和端口，以引导初始集群元数据。因为默认值是localhost:9092，所以没有必要在这里进行设置。</p><p id="f66e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> value_serializer </strong>:数据在发送给代理之前应该如何序列化的函数。这里，我们将数据转换为JSON文件，并将其编码为utf-8。</p><p id="1681" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> enable_auto_commit </strong>:确保消费者每隔一段时间提交一次其读取的偏移量。</p><p id="c2f2" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> auto_offset_reset </strong>:最重要的论点之一。它处理消费者在中断或关闭后重新开始阅读的位置，可以设置为最早或最晚。当设置为<em class="nm">最新</em>时，用户从日志末尾开始读取。当设置为<em class="nm"> earliest </em>时，消费者从最新提交的偏移量开始读取，这正是我们在这种情况下想要的。</p><p id="20b6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> value_deserializer: </strong>在消费端执行，是序列化的逆向操作，将数据从字节数组转换成JSON格式。</p><p id="b3aa" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">万岁，我们学习了一些关于Apache Kafka消息系统的基础知识。这个博客有助于对Kafka系统和生产者/消费者代码的基本理解。</p><h1 id="c9b7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">总结:</h1><p id="0c8b" class="pw-post-body-paragraph jw jx iq jy b jz me kb kc kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt ij bi translated">基于Kafka的分布式发布-订阅消息系统。</p><p id="788e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">卡夫卡建筑和不同的组成部分。</p><p id="7846" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">卡夫卡的概念，如生产者，消费者，经纪人，主题，分区，动物园管理员等。</p><p id="2667" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">与卡夫卡生态系统相关的服务。</p><p id="8296" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">主题创建、划分和复制因素。</p><p id="7594" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">python语言中的简单编码练习、生产者和消费者。</p><p id="670b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">感谢所有人阅读我的博客，如果你喜欢我的内容和解释，请在medium上关注我并分享你的反馈，这将永远帮助我们所有人提高我们的知识。</p></div></div>    
</body>
</html>