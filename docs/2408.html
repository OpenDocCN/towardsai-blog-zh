<html>
<head>
<title>A Practical Strategy to Share the Code among Different Notebooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不同笔记本之间共享代码的实用策略</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-practical-strategy-to-share-the-code-among-different-notebooks-9f9bd78aa3a7?source=collection_archive---------0-----------------------#2021-12-09">https://pub.towardsai.net/a-practical-strategy-to-share-the-code-among-different-notebooks-9f9bd78aa3a7?source=collection_archive---------0-----------------------#2021-12-09</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="aae5" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/devops" rel="noopener ugc nofollow" target="_blank">德沃普斯</a></h2><div class=""/><div class=""><h2 id="2556" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">关于如何通过结合Jupyter笔记本和Visual Studio代码来提高编码效率的一些提示</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/240db50fa59bc3a1544c6b520ed5658e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gOKGlVtay5gPIdb1"/></div></div><figcaption class="lg lh gk gi gj li lj bd b be z dk translated">照片由<a class="ae lk" href="https://unsplash.com/@leekos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kostiantyn李</a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e6ab" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">程序员肯定会面临的问题之一是重用编写的代码。这个问题可以通过编写包含重用代码的类和函数来轻松解决。<strong class="ln jg">但是在使用笔记本的时候，你是如何重用代码的呢？</strong></p><p id="a995" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在这篇文章中，我试图描述一种在不同笔记本之间共享代码的策略。</p><p id="c8e7" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">文章组织如下:</p><ul class=""><li id="5e2a" class="mh mi iw ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">动机</li><li id="ec43" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">一个可能的策略</li><li id="c2cc" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">实际例子。</li></ul><h1 id="3b11" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">动机</h1><p id="ba70" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">在编写Jupyter笔记本时，您可能需要重用以前的笔记本中编写的代码。显然，最快的策略可能是<strong class="ln jg">将代码从一个笔记本复制并粘贴到另一个</strong>。</p><p id="4ae9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然而，从长远来看，这种策略可能会适得其反。事实上，如果您更新笔记本中的代码，那么您应该在复制该代码的所有其他笔记本中更新它。</p><p id="25f8" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><strong class="ln jg">结果是管理和维护更新代码的时间过载。😧</strong></p><p id="b2b8" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">因此，问题是:</p><blockquote class="ns"><p id="e578" class="nt nu iw bd nv nw nx ny nz oa ob mg dk translated">如何只写一次代码，然后在不同的笔记本之间共享？</p></blockquote><figure class="od oe of og oh kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oc"><img src="../Images/8fd4078daa363e37c3d1613d563ebcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mk8wZoiS9E7tyk7M"/></div></div><figcaption class="lg lh gk gi gj li lj bd b be z dk translated">由<a class="ae lk" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Towfiqu barbhuiya </a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5a53" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">一个可能的策略</h1><p id="2924" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">前一个问题的可能答案是Jupyter笔记本和Visual Studio Code (VSC)或任何其他Python IDE的组合。</p><p id="a91b" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在实践中，<strong class="ln jg"> VSC被用来编写核心函数或类，这些函数或类可以在不同的笔记本上重用。</strong></p><p id="5da7" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">要使这一策略奏效，您需要采取两项预防措施:</p><ul class=""><li id="4c77" class="mh mi iw ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">将类或函数转换成包；</li><li id="f08e" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">告诉Jupyter在运行每个单元时重新加载包。</li></ul><p id="22d5" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">要将类或函数转换成可以由其他Python脚本导入的包，应该在类和函数所在的目录下创建一个名为<code class="fe oi oj ok ol b">__init__.py</code>的空文件。然后，如果所有的类都包含在与Jupyter笔记本相同的文件夹中，您可以简单地在Jupyter单元格中导入包，如下所示:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="a9e0" class="oq mw iw ol b gz or os l ot ou">from file_directory.file_name import class_name</span></pre><p id="ab31" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然后，您可以像通常对其他Python包那样使用它。</p><p id="5603" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">其次，您应该告诉Jupyter在运行每个单元时重新加载您的包。这可以通过在第一个Jupyter单元格中写下以下魔字来实现:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="3e93" class="oq mw iw ol b gz or os l ot ou">%autoreload 2</span></pre><p id="f218" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">所描述的策略允许你保持你的代码是最新的和有序的。😃</p><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ov"><img src="../Images/c932aed1e59b1022991508f156b4f7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AgLmfpWRp_HnGohb"/></div></div><figcaption class="lg lh gk gi gj li lj bd b be z dk translated">照片由<a class="ae lk" href="https://unsplash.com/@molliedefibaugh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mollie Defibaugh </a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="efed" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">实际例子</h1><p id="8e6b" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">作为一个实际的例子，我实现了一个scraper，它从任何HTML页面中提取列表元素，然后将它们转换成Pandas数据帧。刮刀利用了<code class="fe oi oj ok ol b">selenium</code>包。在我之前的文章中，我描述了如何通过selenium从零开始提取数据，因此您可以参考它进行<code class="fe oi oj ok ol b">selenium</code>安装和配置。</p><p id="5716" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我假设具有以下目录结构:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="ae49" class="oq mw iw ol b gz or os l ot ou">data_extraction<br/>|__ Web_Site1.ipynb<br/>|__ Web_Site2.pynb<br/>|__ extractor<br/>   |__ scraper.py<br/>   |__ _init__.py</span></pre><p id="8321" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在主目录(<code class="fe oi oj ok ol b">data_extraction</code>)中，有两个笔记本，它们利用scraper从两个不同的网站提取数据。scraper主函数位于<code class="fe oi oj ok ol b">extractor</code>目录中，在那里我还创建了一个名为<code class="fe oi oj ok ol b">__init__.py</code>的空文件。</p><h2 id="6a1b" class="oq mw iw bd mx ow ox dn nb oy oz dp nf lu pa pb nh ly pc pd nj mc pe pf nl jc bi translated">scraper.py</h2><p id="8d25" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">现在，我用VSC打开<code class="fe oi oj ok ol b">scraper.py</code>，并在其中创建了一个类，实现了scraper。构造函数接收URL作为输入。在构造函数中，我将驱动程序配置为在无头设备中工作。或者，我可以添加另一个输入参数来指定选项。然而，在这个例子中，我定义了一个预配置的选项。</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="1dd9" class="oq mw iw ol b gz or os l ot ou">import pandas as pd<br/>from selenium import webdriver<br/>from selenium.webdriver.chrome.options import Options</span><span id="8ea5" class="oq mw iw ol b gz pg os l ot ou">class Scraper:<br/>   def __init__(self,url):<br/>       self.options = Options()<br/>       self.options.add_argument("--headless")<br/>       self.options.add_argument("--lang=it");<br/>       self.driver = webdriver.Chrome(options=self.options)<br/>       self.url = url<br/>       self.driver.get(url)</span></pre><p id="9316" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然后，我定义了另外两个函数，分别返回和关闭驱动程序:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="2aa8" class="oq mw iw ol b gz or os l ot ou">def get_driver(self):<br/>   return self.driver</span><span id="df5b" class="oq mw iw ol b gz pg os l ot ou">def close(self):<br/>   self.driver.close()</span></pre><p id="7b84" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">这些是铲运机非常基本的功能。我可以通过添加任意多的功能来定制它😃</p><h2 id="8a2d" class="oq mw iw bd mx ow ox dn nb oy oz dp nf lu pa pb nh ly pc pd nj mc pe pf nl jc bi translated">网站1.ipynb和网站2.ipynb</h2><p id="7a5e" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">现在，我可以利用我的刮板在两个笔记本如下。首先，设置自动重新加载模式:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="8363" class="oq mw iw ol b gz or os l ot ou">%autoreload 2</span></pre><p id="2d67" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然后，我导入包:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="4914" class="oq mw iw ol b gz or os l ot ou">from extractor.scraper import Scraper</span></pre><p id="7818" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最后，我开发了我的刮刀:</p><pre class="kv kw kx ky gu om ol on oo aw op bi"><span id="9ea6" class="oq mw iw ol b gz or os l ot ou">url = '<a class="ae lk" href="https://myjewishitaly.it/'" rel="noopener ugc nofollow" target="_blank">http://www.myexample.com'</a><br/>scraper = Scraper(url)</span></pre><p id="1b58" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">请注意，如果我需要向scraper添加一个新函数，我可以直接在VSC中完成，保存更改并在Jupyter单元格中调用该函数😎</p><h1 id="4377" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">摘要</h1><p id="65a3" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">恭喜你！现在你已经学会了如何在不同的Jupyter笔记本之间共享代码！这可以通过简单的预防措施来实现。快乐编码😄</p><p id="6a4b" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果你已经走了这么远来阅读，对我来说今天已经很多了。谢谢！你可以在<a class="ae lk" href="https://alod83.medium.com/which-topics-would-you-like-to-read-c68314dc6813" rel="noopener">这篇文章</a>中读到更多关于我的信息。</p><h1 id="3a25" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">相关文章</h1><div class="ph pi gq gs pj pk"><a href="https://towardsdatascience.com/how-to-run-r-scripts-in-jupyter-15527148d2a" rel="noopener follow" target="_blank"><div class="pl ab fp"><div class="pm ab pn cl cj po"><h2 class="bd jg gz z fq pp fs ft pq fv fx jf bi translated">如何在Jupyter中运行R脚本</h2><div class="pr l"><h3 class="bd b gz z fq pp fs ft pq fv fx dk translated">关于如何在Jupyter中安装并运行R内核的简短教程</h3></div><div class="ps l"><p class="bd b dl z fq pp fs ft pq fv fx dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py le pk"/></div></div></a></div><div class="ph pi gq gs pj pk"><a href="https://towardsdatascience.com/scraping-data-from-nested-html-pages-with-python-selenium-c5f23065841f" rel="noopener follow" target="_blank"><div class="pl ab fp"><div class="pm ab pn cl cj po"><h2 class="bd jg gz z fq pp fs ft pq fv fx jf bi translated">用Python Selenium从嵌套的HTML页面中抓取数据</h2><div class="ps l"><p class="bd b dl z fq pp fs ft pq fv fx dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pz l pv pw px pt py le pk"/></div></div></a></div><div class="ph pi gq gs pj pk"><a href="https://towardsdatascience.com/have-you-ever-thought-about-using-python-virtualenv-fc419d8b0785" rel="noopener follow" target="_blank"><div class="pl ab fp"><div class="pm ab pn cl cj po"><h2 class="bd jg gz z fq pp fs ft pq fv fx jf bi translated">有没有想过用Python virtualenv？</h2><div class="pr l"><h3 class="bd b gz z fq pp fs ft pq fv fx dk translated">在终端和Jupyter笔记本上安装和使用Python virtualenv的实用指南。</h3></div><div class="ps l"><p class="bd b dl z fq pp fs ft pq fv fx dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qa l pv pw px pt py le pk"/></div></div></a></div></div></div>    
</body>
</html>