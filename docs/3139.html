<html>
<head>
<title>The Parameters of Your Model Are Correlated. Now, What?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的模型的参数是相关的。现在怎么办？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-parameters-of-your-model-are-correlated-now-what-3d053f3633f9?source=collection_archive---------2-----------------------#2022-09-21">https://pub.towardsai.net/the-parameters-of-your-model-are-correlated-now-what-3d053f3633f9?source=collection_archive---------2-----------------------#2022-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d3a42010fd7f52e711c1e9c302740568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*rPOmWRMET0-vL1qPrKfFnQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在<a class="ae jy" href="https://huggingface.co/spaces/stabilityai/stable-diffusion" rel="noopener ugc nofollow" target="_blank">稳定扩散</a>上使用标题作为提示生成的图像</figcaption></figure><p id="9d76" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">你刚刚得到了一组很好的数据，例如，具有房屋特征的房地产价格。你可以问自己一个问题:我如何根据房子的特点预测它的价格？</p><p id="45fa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">想到的第一个模型是以特征为输入的线性模型。假设我们可以访问以下特征:</p><ul class=""><li id="856a" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">房子的平方英尺</li><li id="b1c8" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">卧室数量</li><li id="8b3c" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">本地化</li><li id="1b38" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">建造年份</li></ul><p id="90d2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">用这样的数据集预测房价的问题已经被深入研究(<a class="ae jy" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/c/house-prices-advanced-regression-techniques</a>)，并且有可能获得精确的模型。我将这个框架作为一个玩具模型来强调参数在一个模型中是多么容易关联。房子的大小和卧室的数量是相关的，但是在估计中，它们中的任何一个都不能真正用来代替另一个，因此，模型参数的估计可能变得困难。特别地，当参数的目标分布未知时，诸如马尔可夫链蒙特卡罗的采样方法可能是低效的。如果这是一个在估计房价时可能不会出现的问题，那么在拟合更复杂的模型时就有必要将它考虑在内。</p><p id="4064" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这篇文章中，我将描述最常用的抽样方法——马尔可夫链蒙特卡罗(MCMC ),并强调当参数相关时这种方法无效的潜在原因。在第二部分，我将描述一种不受参数间相关性影响的新采样算法，差分进化MCMC (DE-MCMC)。此外，我将为这两种方法提供一些Python代码示例。</p><h1 id="e31d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">马尔可夫链蒙特卡罗</h1><p id="1145" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">MCMC是一种广泛用于贝叶斯统计的抽样方法，尤其是在估计后验先验时。一句话，MCMC可以被认为是用于估计目标分布(参数的分布)的随机行走过程。Metropolis-Hastings是MCMC类中使用最多的算法[1]。</p><p id="38da" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们<strong class="kb ir"> P </strong> = (p1，p2，…)我们模型的参数向量。然后，该算法挑选参数的初始值<strong class="kb ir"> P1 </strong>，并使用建议分布<em class="mo">P = * K(</em><strong class="kb ir"><em class="mo">【P1】</em></strong><em class="mo">)</em>对候选值<strong class="kb ir"> P </strong> *进行采样。一个典型的建议分布通常是以<strong class="kb ir"> P1 </strong>为中心的高斯分布。之后，候选人<strong class="kb ir"> P </strong> *以如下概率被接受:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/93a32de97f5dd477cafdc86dd9c1ba6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*rq6fr9gZwotPBeWKs_bqwA.png"/></div></figure><p id="2427" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们分解这个公式。<em class="mo">M(</em><strong class="kb ir"><em class="mo">P</em></strong><em class="mo">*)</em>代表目标分布。例如，在模型拟合的情况下，目标分布可以是误差函数的指数。使用指数函数可以实现从误差函数到概率分布的转换。<em class="mo">q(</em><strong class="kb ir"><em class="mo">Pt</em></strong><em class="mo">|</em><strong class="kb ir"><em class="mo">P</em></strong><em class="mo">*)</em>代表在<strong class="kb ir"> Pt </strong>用参数<strong class="kb ir"> P </strong> *评估的提案分布密度。换句话说，它表示如果我们从<strong class="kb ir"> P </strong> *中取样，选择<strong class="kb ir"> Pt </strong>的可能性有多大。这一项对于算法的平稳性是必要的。</p><p id="568a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果建议被接受，那么链的新起点是<strong class="kb ir"> P </strong> *。否则，链条不会移动。这个过程一直持续到达到指定的样本数。该过程可以被解释为收敛到对目标分布进行采样的过程，并且因此估计参数<strong class="kb ir"> P </strong>。</p><p id="7a5f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">下面是一个Python代码示例，使用包<a class="ae jy" href="https://mc3.readthedocs.io/en/latest/mcmc_tutorial.html" rel="noopener ugc nofollow" target="_blank"> mc3 </a>(根据他们的教程修改)来模拟MCMC算法，以拟合二次模型的参数:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7c87" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在，如果我们回到一些参数相关的情况。如果建议分布没有明确考虑参数间的相关性，那么许多候选值将不会位于目标分布内。例如，在下图中，灰色云表示两个参数的虚构分布。圆圈代表建议分布。圆的很大一部分位于灰色分布之外。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/8d552f50a47115f9e394239ea80a3221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHNxSvFqEduT1467hEm0fg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">MCMC的时间步长。圆圈代表候选分布。(图片由我提供)</figcaption></figure><p id="9507" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这将导致大量的拒绝率，MCMC将是非常耗时的。因此，使用这种贝叶斯技术来拟合你的模型并不总是合适的。好消息是，有一类算法可以处理高维、高度相关的问题:基于人口的MCMC。</p><h1 id="947e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">扩散演化马尔可夫链蒙特卡罗</h1><p id="e809" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">差分进化在2006年被引入到MCMC算法中[2]。该方法背后的思想如下。它不是为了产生下一步而将噪声添加到当前候选值，而是使用多个交互链来产生候选值。当链具有不同的状态时，它们将被用于为其他链生成新的提议。或者换句话说，一个链的候选值基于其他链的值的某种加权组合。</p><p id="9368" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这些值的组合按以下方式执行。<strong class="kb ir"> P_k </strong>表示链k的当前状态。然后，使用随机选取的两个链的状态之间的差异<strong class="kb ir"> P_m </strong>和<strong class="kb ir"> P_n </strong>来生成候选值<strong class="kb ir"> P </strong> *。总之，该过程如下:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/515bd98029390f770e93653766fd3fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*aw0xyzrjXPZ55SnqY0OQsw.png"/></div></figure><p id="85ad" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">其中因子ɣ代表跳跃率。新候选的接受率类似于MCMC算法，例如使用Metropolis-Hastings规则。使用跳跃率的经验法则是:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/57800da6067dcfc96a1b09754fd0ebae.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*qTrKbFEmvWHkH-Rjulu3kA.png"/></div></figure><p id="783d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">其中d是参数的维数。DE-MCMC算法如下图所示:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/c654c0289276759cc46c2b66b5b05a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggjfVuisH54-bhYZMPdMqg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">去MCMC步骤示例(图片由我提供)</figcaption></figure><p id="b807" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">为什么DE-MCMC在对相关参数进行采样时效率很高？</strong></p><p id="7a5c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">不同的MCMC链被用于通知一个链中的状态。因此，链之间的相关性(因此样本之间的相关性)被直接用于通知链的状态。使用链之间的差异来生成新的候选值允许以自然的方式考虑参数之间的相关性。此外，链的参数的默认值对于各种问题都很有效，这使得它成为高维问题的良好算法。</p><p id="8a07" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">通过指定“<strong class="kb ir">demc”</strong>作为MCMC的采样算法，可以使用<a class="ae jy" href="https://mc3.readthedocs.io/en/latest/mcmc_tutorial.html#sampler-algorithm" rel="noopener ugc nofollow" target="_blank"> MC3 </a>包实现DE-MCMC算法，其样本代码与前一个类似。这导致先前二次模型的以下拟合:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/733252c108b3b1beb248d7bc4642194d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*M6MYJhuCYtR23uXU_GaUIQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">用DE-MCMC拟合二次模型</figcaption></figure><p id="0b27" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">使用前面的包来执行MCMC算法，可以很容易地获得参数的后验分布、成对相关以及更多信息。如果你想更深入地了解它，你可以在<a class="ae jy" href="https://mc3.readthedocs.io/en/latest/mcmc_tutorial.html#sampler-algorithm" rel="noopener ugc nofollow" target="_blank">https://mc3 . readthedocs . io/en/latest/MCMC _ tutorial . html # sampler-algorithm</a>阅读他们的教程</p><p id="dd23" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">总之，如果MCMC和贝叶斯算法在拟合各种模型的参数方面确实有效，那么高维度和相关性会导致无限的计算时间。这就是进化算法派上用场的时候。利用差分进化MCMC算法，不同的链可以相互通知参数相关性，从而使算法的收敛速度更快。所以，下一次当你在你的模型参数之间有关联时，试着把DE-MCMC添加到你的贝叶斯工具集中。</p><h1 id="f774" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">参考</h1><p id="1d8d" class="pw-post-body-paragraph jz ka iq kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ij bi translated">[1] Nedelman，J.R .书评:“贝叶斯数据分析”，第二版，作者A. Gelman、J.B. Carlin、H.S. Stern和D.B. Rubin Chapman &amp; Hall/CRC，2004年。<em class="mo">计算统计</em> <strong class="kb ir"> 20 </strong>，655–657(2005)。<a class="ae jy" href="https://doi.org/10.1007/BF02741321" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1007/BF02741321</a></p><p id="65bc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">[2]布拉克.."遗传算法差分进化的马尔可夫链蒙特卡罗版本:实参数空间的简单贝叶斯计算."<em class="mo">统计与计算</em>16(2006):239–249。</p></div></div>    
</body>
</html>