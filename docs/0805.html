<html>
<head>
<title>Submodularity in Sensor Placement Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传感器放置问题中的子模</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/submodularity-in-sensor-placement-problems-a82e9fecf3f5?source=collection_archive---------4-----------------------#2020-08-15">https://pub.towardsai.net/submodularity-in-sensor-placement-problems-a82e9fecf3f5?source=collection_archive---------4-----------------------#2020-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b424" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/artificial-intelligence" rel="noopener ugc nofollow" target="_blank">人工智能</a></h2><div class=""/><div class=""><h2 id="3e16" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">更多的是相对的</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/cbe71ee507333d4dc9bc88171a7aaca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykTm0lHHphPK73xnYfULsw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@giggiux?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Luigi Frunzio </a>在<a class="ae lh" href="https://unsplash.com/s/photos/sensor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="52f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总的来说，人工智能和计算机科学中的许多问题很难解决。这实际上意味着，计算机可能需要数百/数千/数百万年的计算才能解决这个问题。因此，许多科学家倾向于创建近似解决困难问题的算法，但在合理的时间范围内，即秒/分/小时。这是关于用准确性换取速度的问题。</p><p id="829a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">像这样的问题就是<em class="me">传感器放置问题</em>。这里的关键问题是</p><blockquote class="mf"><p id="3545" class="mg mh it bd mi mj mk ml mm mn mo md dk translated"><em class="mp">在一些空间中找到一些位置来放置一些传感器，以便更好地覆盖感兴趣的区域</em>。</p></blockquote><p id="ae89" class="pw-post-body-paragraph li lj it lk b ll mq kd ln lo mr kg lq lr ms lt lu lv mt lx ly lz mu mb mc md im bi translated">具体的应用领域在这一点上并不是很重要。它可以是空气污染监测，可以是wifi信号的覆盖范围或任何其他形式的信号。</p><p id="fc50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了最佳地解决这个问题，计算机必须评估将传感器放置在所有不同位置的所有可能组合。抛出一些数字，在空间中有5个传感器和100个可能的位置；人们必须尝试75287520种组合才能找到最佳排列。想象一下，当问题是在一个城市放置数百个传感器时会发生什么，例如，那里有数千个或更多的选项。</p><p id="6621" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这样的问题中，<em class="me">子模性</em>的性质就派上了用场。这个定理描述了适用于这类问题的函数的行为。特别是，主要观点是</p><blockquote class="mf"><p id="f24d" class="mg mh it bd mi mj mk ml mm mn mo md dk translated"><strong class="ak">一个小集合的增加比一个大集合的增加有更高的回报/效用/价值</strong>。</p></blockquote><p id="dbbb" class="pw-post-body-paragraph li lj it lk b ll mq kd ln lo mr kg lq lr ms lt lu lv mt lx ly lz mu mb mc md im bi translated">这可以用一个例子来更好的理解。想象一下，有10000个传感器分散在一个室内区域，每2小时测量一次温度。现在想象一下，在那个房间里再增加一个传感器。我们这样做真的收获很大吗？</p><p id="13bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，假设同一个房间只有一个传感器。多加1可以让我们更好地了解可能的某个角落区域，或者只是更好地估计房间的真实平均温度。因此，这个传感器比前一个案例更有价值。这正是我们的意思，即后来有了更高的效用。</p><p id="817c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实证明，这一特性在数学、计算机科学，尤其是人工智能领域非常有用，因为它允许我们构建具有理论保证的算法。已经证明，就性能而言，贪婪算法达到最优算法的63%。这一点最初由Nemhauser在纯数学背景下证明，后来由Krause等人证明。特别是用于如上所述的传感器放置问题。下图用图形和数学符号显示了该属性。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/9a5521910f995fcce53cf8e0194bb9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*orFuqOKYYrwe6i9Z"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">子模块性(摘自Meliou等人的PowerPoint演示文稿)</figcaption></figure><p id="2eb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">贪婪算法会迭代地将一个传感器添加到已经选择的传感器集合中，使得效用在每一步最大化地增加。然而，一旦放置了传感器，我们就不能撤销该操作，即使进一步的不同配置会更好。尽管如此，这在某些应用中也足够好了，而且知道它有性能保证是绝对值得的。</p><p id="7924" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于那些想了解更多这方面知识的人，我肯定会推荐这篇论文:<a class="ae lh" href="https://www.jmlr.org/papers/volume9/krause08a/krause08a.pdf" rel="noopener ugc nofollow" target="_blank">https://www.jmlr.org/papers/volume9/krause08a/krause08a.pdf</a></p><p id="bb94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关于子模性的更多理论，这一个:【https://las.inf.ethz.ch/files/krause12survey.pdfT2】</p></div></div>    
</body>
</html>