<html>
<head>
<title>LogBERT Explained In Depth: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LogBERT深入解释:第二部分</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/logbert-explained-in-depth-part-ii-f659abde9ebf?source=collection_archive---------2-----------------------#2022-10-09">https://pub.towardsai.net/logbert-explained-in-depth-part-ii-f659abde9ebf?source=collection_archive---------2-----------------------#2022-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/501c4a6be250fb67a45c0366f51d310c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dlr48jSdYoqT53AQ"/></div></div></figure><p id="4975" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇文章中，我介绍了注意力机制的基础知识，一般来说，我介绍了transformer块。在本系列的这一部分，我将介绍LogBERT如何训练，以及我们如何使用它来检测日志序列中的异常。</p><p id="e021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们进入洛波特的本质细节。</p><p id="f331" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在论文中(链接:<a class="ae kw" href="https://arxiv.org/pdf/2103.04475.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/2103.04475.pdf</a>)一个对数序列被定义为:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/01e8fb8bd78e9650ecf631ce956395a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*jXdrO-64QrPME9wvOIm2hw.png"/></div></figure><p id="6a07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中S是对数序列中的一系列关键字(单词)。注意我们的日志关键字是如何用上标j来表示它们所属的序列，用k上的下标来表示单词序列中的索引。</p><p id="3d42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像往常一样，当训练一个变压器时，我们要添加一个标记来标记序列的开始，该标记将是文中提到的“DIST”。我们将添加的另一个特殊令牌是“MASK”令牌。掩码标记将用于覆盖句子中的单词。</p><p id="4822" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你看一下最后一部分，你会记得我们运行的例子:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/2d26e53f4c6cb7e68a67ec3755b0dff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*mbDcu3RjdYBNfXp9qkK4Qg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">预处理我们的日志序列</figcaption></figure><p id="c94e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们的日志序列经过预处理，以包含不同的特殊标记。</p><p id="742e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> DIST </strong> —句子的开始</p><p id="8eff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">屏蔽</strong> —掩盖序列中的一个键</p><p id="d55b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> EOS </strong> —一句话的结尾(虽然文中没有提到，但是在GitHub上的代码中使用了。)</p><p id="796a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我澄清关于特殊令牌的一切之前，我想回顾一下LogBERT的训练阶段。</p><p id="ede2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回想一下LogBERT架构的不同部分:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/2a9419b46f435c560b4da3c8a9f19351.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*HaliEr8aYzoCsdKKw1-iPQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">注意使用Q、K和V矩阵</figcaption></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi li"><img src="../Images/6232d0b230b60a671d8c031e88173ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*GRw4dIqy2RR4hX4__lq3KA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">多头注意力连接不同的注意力头</figcaption></figure><p id="68b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的函数只是对多头注意力的数学描述:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/9ea7816f4335fe4637811c892c200c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/0*mYfZj0LLNmLLaWgd.png"/></div></figure><p id="8507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，这一切都归结于变压器模块的数学描述:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/896c39f20f74d91a2979c1fe83ea2bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*Avt6n1Tc0hPHuhcSM5Menw.png"/></div></figure><p id="76c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是整个变压器模块:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/9ace5115fe40797c310c0e671c4bb3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*xAeHDzjlt7cMdoeailMpog.png"/></div></figure><p id="733b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，现在我们把它们绑在一起了。通常，变压器有多个变压器层，这意味着我们可以分配一个通用的变压器功能，这只是一系列变压器块。这在论文中被描述为:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/fec7dae26c3dde7c96187a3fc78c56bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*mFtm9H9ZRZD3bQlmwQwLuA.png"/></div></figure><p id="5485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<strong class="ka ir"> h </strong>是Transformer函数的输出，这个输出本质上应该只是一个向量，它对定义为x的对数序列的所有信息进行编码。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/3be961eeae5ea05e7c2a58ccdd376c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3UA4to1M8feWYGAL2ROXg.png"/></div></div></figure><p id="a52a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为上面的图片总结了这一切。只是一般的洛波特架构。注意输出层是如何决定词汇表的大小的。在分类案例中，特别是在我们的案例中，我们通常需要对掩码标记下的单词进行分类。这让我想到了最终LogBERT模型的损失函数。</p><p id="6f26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，所有日志序列都经过预处理，以包含一个屏蔽词。该模型将尝试预测被屏蔽的单词。这是一个模型必须完成的自我监督的任务。这个任务的损失函数是:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/94420d2a8e68f1d2b840080dd036d108.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*zwkwDzbrrrhWklAzTU0fqA.png"/></div></figure><p id="c357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<strong class="ka ir"> y </strong>是掩码下的真实单词，而<strong class="ka ir"> y hat </strong>是为掩码下的真实单词分配的概率。我们可以看到，损失本质上是一个类别交叉熵损失函数，其中类别实际上是单词。注意求和是如何超过N和M的，N是对数序列的数量，M是句子中选择的掩码总数。</p><p id="cc6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每个日志序列，我们选择一个概率为0.15的随机单词进行屏蔽。我们实际上选择多个单词来屏蔽，对于每个日志，我们计算句子中屏蔽预测的总损失。将每个序列的最终损失相加，然后除以对数序列的数量。</p><p id="d65e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">LogBERT需要最小化的另一个任务(损失函数)是超球损失函数的体积。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/beec4d969d4a2dfb59c38378186907bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*0t0P_XTwZIbPwPcGAucNwg.png"/></div></figure><p id="7924" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个损失函数使用如上所述的<strong class="ka ir"> h — </strong>。h是对数序列的表示(特别是h-dist)，这个损失函数的目标是最小化每个对数的表示和它们的中心之间的距离。该中心随着每个历元而更新，并被计算为平均总体对数表示。</p><p id="d8ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，两个损失函数都用于更新模型权重。最终损失函数由两个损失函数的加权和组成。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/20f7234ae2ecad1303aa5f0c8c3df5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*Srvtb612dup4Fyhjir8N0A.png"/></div></figure><p id="69b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们如何使用LogBERT来查找异常日志？正如论文中提出的，我们检查一个日志序列，并计算每个屏蔽词的预测。我们定义了一个超参数<strong class="ka ir"> g </strong>，它是位于掩码之外的前g个最可能的单词。如果实际的单词不在前g个单词中，我们将该单词视为异常。现在，我们定义r，另一个超参数，作为我们计数一个日志异常与否的阈值。如果存在多于r个字的异常，则该日志序列被定义为异常日志。</p><p id="dcb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想提出另一种定位异常日志的方法。只需使用最终损失函数并定义阈值z，如果测井记录得分高于z，则该测井记录为异常测井记录。</p><p id="8177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，我希望你喜欢你的阅读。我强烈推荐阅读原始论文，并跳到GitHub上查看代码本身。</p></div></div>    
</body>
</html>