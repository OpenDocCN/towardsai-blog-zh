<html>
<head>
<title>Steps to Build an Input Data Pipeline using tf.data for Structured Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用tf.data为结构化数据构建输入数据管道的步骤</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/steps-to-build-an-input-data-pipeline-using-tf-data-for-structured-data-9bdca1bae117?source=collection_archive---------1-----------------------#2020-09-23">https://pub.towardsai.net/steps-to-build-an-input-data-pipeline-using-tf-data-for-structured-data-9bdca1bae117?source=collection_archive---------1-----------------------#2020-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e475" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><p id="7e80" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="kx">在这篇文章中，您将学习如何使用</em><strong class="kb jd"><em class="kx">TF . data . dataset</em></strong><em class="kx">为使用特性列的结构化数据集创建高效的数据输入管道。</em></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/f1c5af7226cb11ab4c4a896174d133df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezRDyg7GNriwBKt580UZ6Q.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">马库斯·温克勒在<a class="ae lo" href="https://unsplash.com/s/photos/structured-data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="acb5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">使用的数据集是<a class="ae lo" href="https://www.kaggle.com/annettecatherinepaul/online-shoppers-behavior-prediction" rel="noopener ugc nofollow" target="_blank">在线购物者行为预测</a>。</p><p id="1940" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">该数据集将使用在线客户的行为洞察进行有针对性的广告宣传，以增加销售额，从而增加收入。</p><h2 id="d345" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">数据集描述</h2><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/4b92824b18859fc2e07ec5919be0b9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*SfvyGo9rFFvuqutKr25g8Q.png"/></div></figure><p id="55f4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">机器学习的输入数据管道包括提取数据、转换数据，然后加载数据以供模型训练和预测(ETL)。</p><ul class=""><li id="ef61" class="mi mj it kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated"><strong class="kb jd">从数据源提取数据</strong></li><li id="8199" class="mi mj it kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated"><strong class="kb jd">将数据转换或处理成模型使用的格式</strong></li><li id="328d" class="mi mj it kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated"><strong class="kb jd">加载模型数据进行训练和预测</strong></li></ul><h2 id="5d9b" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">从数据源中提取数据</h2><p id="0e57" class="pw-post-body-paragraph jz ka it kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">我们将CSV文件中的数据读入熊猫数据帧。</p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="e63e" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd">import tensorflow as tf<br/>import pandas as pd<br/>import numpy as np</strong></span><span id="4d93" class="lp lq it nc b gy nk nh l ni nj"><strong class="nc jd">df = pd.read_csv('online_shoppers_intention.csv', index_col=None)</strong></span></pre><h2 id="e379" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">转换数据</h2><p id="bcda" class="pw-post-body-paragraph jz ka it kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">这里，我们将布尔数据转换为数字数据，因为机器学习模型只能理解数字数据。</p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="3875" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd">df['Weekend']=df['Weekend'].astype(int)<br/>df['Revenue']=df['Revenue'].astype(int)</strong></span></pre><p id="20ca" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在这里，您将使用特性列</p><blockquote class="nl"><p id="739f" class="nm nn it bd no np nq nr ns nt nu kw dk translated">要素列是将Pandas数据框中的列映射到模型可用于训练的要素的桥梁。</p></blockquote><p id="e24a" class="pw-post-body-paragraph jz ka it kb b kc nv ke kf kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw im bi translated">Tensorflow有多种类型的要素列</p><ul class=""><li id="79bc" class="mi mj it kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated"><strong class="kb jd">数字列</strong>:表示实值特征。模型将从数据框中接收列值并保持不变。</li></ul><p id="bec4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="kx">将数据集中的实值特征转换为数值列</em> </strong></p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="d519" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd">feature_columns = []</strong></span><span id="7f64" class="lp lq it nc b gy nk nh l ni nj"># numeric cols<br/><strong class="nc jd">for header in ['Administrative', 'Administrative_Duration', 'Informational', 'Informational_Duration', 'ProductRelated', 'ProductRelated_Duration', 'BounceRates', 'ExitRates', 'PageValues', 'SpecialDay']:<br/>  feature_columns.append(feature_column.numeric_column(header))</strong></span></pre><ul class=""><li id="4570" class="mi mj it kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated"><strong class="kb jd">分类列</strong>:表示字符串特征或类别。这些特征不能直接提供给模型，而应该转换成数值。<strong class="kb jd"> <em class="kx">分类词汇列</em> </strong>帮助将字符串表示为一个热向量，并使用<a class="ae lo" href="https://www.tensorflow.org/api_docs/python/tf/feature_column/categorical_column_with_vocabulary_list" rel="noopener ugc nofollow" target="_blank"> <strong class="kb jd"> <em class="kx">分类_列_带_词汇_列表</em> </strong> </a>作为列表传递，或者使用<a class="ae lo" href="https://www.tensorflow.org/api_docs/python/tf/feature_column/categorical_column_with_vocabulary_file" rel="noopener ugc nofollow" target="_blank"> <strong class="kb jd"> <em class="kx">分类_列_带_词汇_文件</em> </strong> </a>从文件加载。</li></ul><p id="c400" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="kx">根据词汇表将分类数据转换为数值</em> </strong></p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="eb08" class="lp lq it nc b gy ng nh l ni nj"># categorical columns<br/><strong class="nc jd">indicator_column_names = [ 'Month', 'OperatingSystems', 'Browser', 'Region', 'TrafficType', 'VisitorType', 'Weekend' ]</strong><br/>for col_name in indicator_column_names:<br/>  <strong class="nc jd">categorical_column = feature_column.<em class="kx">categorical_column_with_vocabulary_list</em>(<br/>      col_name, df[col_name].unique())</strong><br/>  <strong class="nc jd">indicator_column = feature_column.indicator_column(categorical_column)<br/>  feature_columns.append(indicator_column)</strong></span></pre><ul class=""><li id="ad77" class="mi mj it kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated"><strong class="kb jd">散列特征列</strong>:也代表<strong class="kb jd">字符串特征或类别，但类别中有大量的值</strong>。特性列<strong class="kb jd">计算类别值的哈希值，以编码字符串</strong>。您不需要提供词汇表，但是可以提供哈希桶的数量</li><li id="d62f" class="mi mj it kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated"><strong class="kb jd">分桶列</strong>:可使用<strong class="kb jd">根据数值范围将数值分成不同的类别。例如，年龄可以分为不同的范围。</strong></li><li id="580f" class="mi mj it kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated"><strong class="kb jd">嵌入列</strong>:它也用于<strong class="kb jd">处理类别</strong>中有数千个值的分类数据。当一个类别有一千多个值时，创建一个独热编码向量是一个挑战；解决方法是生成<strong class="kb jd">编码列。这些编码列是一个较低维度的密集向量，包含一个不一定是0或1的数字，也可以是一个数字。</strong></li><li id="a5de" class="mi mj it kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated"><strong class="kb jd">交叉特征栏</strong>:也称为<strong class="kb jd">特征交叉</strong>，其中y <strong class="kb jd"> ou可以将一个或多个特征组合成一个特征</strong>。<em class="kx">举个例子，在预测房子</em> <strong class="kb jd"> <em class="kx">的价格时，可以将纬度和经度组合成一个单一的特征。</em> </strong>特征交叉不为源列的所有可能组合创建数据；但是，您可以根据<strong class="kb jd"><em class="kx">hashed _ column</em></strong>参数指定大小。<strong class="kb jd">特征十字表示非线性关系</strong>。</li></ul><p id="ab67" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">使用<strong class="kb jd"> <em class="kx">密集特征</em> </strong>层为特征列创建一个特征层，该特征层将用作我们的Keras模型的密集层的输入。</p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="d6c6" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd">feature_layer = tf.keras.layers.DenseFeatures(feature_columns)</strong></span></pre><h2 id="d344" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">加载数据集</h2><p id="5b6b" class="pw-post-body-paragraph jz ka it kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">通过将数据帧作为字典<strong class="kb jd"> <em class="kx">、</em> </strong>发送，使用<strong class="kb jd"><em class="kx">from _ tensor _ slice</em></strong>为输入张量的每一行创建数据集，混洗数据集，然后创建批次。</p><p id="deaa" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">Shuffle()将创建一个指定大小的缓冲区，然后根据batch_size将数据集的连续元素批处理为单个元素。</p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="7a5f" class="lp lq it nc b gy ng nh l ni nj"># A utility method to create a tf.data dataset from a Pandas Dataframe<br/><strong class="nc jd">def df_to_dataset(dataframe, label,shuffle=True, batch_size=32, ):<br/>  df = dataframe.copy()<br/>  labels = df.pop(label)<br/>  ds = tf.data.Dataset.from_tensor_slices((dict(df), labels))<br/>  if shuffle:<br/>    ds = ds.shuffle(buffer_size=len(df)-100)<br/>  ds = ds.batch(batch_size)<br/>  return ds</strong></span></pre><p id="1078" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">创建训练、测试和验证数据集</p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="48cd" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd">train, test = train_test_split(df, test_size=0.2)<br/>train, val = train_test_split(train, test_size=0.2)</strong></span></pre><p id="2ecc" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">根据pandas数据框创建tf.data数据集</p><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="4c91" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd">batch_size = 32<br/>train_ds = df_to_dataset(train,'Revenue', batch_size=batch_size)<br/>val_ds = df_to_dataset(val, 'Revenue', shuffle=False, batch_size=batch_size)<br/>test_ds = df_to_dataset(test, 'Revenue',shuffle=False, batch_size=batch_size)</strong></span></pre><h2 id="45c2" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">创建深度学习模型并进行训练</h2><pre class="kz la lb lc gt nb nc nd ne aw nf bi"><span id="a5a8" class="lp lq it nc b gy ng nh l ni nj"><strong class="nc jd"># create the model<br/>model = tf.keras.Sequential([<br/>  <em class="kx">feature_layer</em>,<br/>  layers.Dense(128, activation='relu'),<br/>  layers.Dense(256, activation='relu'),<br/>  layers.Dropout(.3),<br/>  layers.Dense(64, activation='relu'),<br/>  layers.Dropout(.3),<br/>  layers.Dense(1)<br/>])</strong></span><span id="0e93" class="lp lq it nc b gy nk nh l ni nj">#Compile the model<br/><strong class="nc jd">optimizer = optimizers.Adam(lr=0.0005, beta_1=0.7, beta_2=0.999, amsgrad=True)<br/>model.compile(optimizer=optimizer,<br/>              loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),<br/>              metrics=['accuracy'])</strong></span><span id="8875" class="lp lq it nc b gy nk nh l ni nj">#Train the model</span><span id="c1b4" class="lp lq it nc b gy nk nh l ni nj"><strong class="nc jd">model.fit(train_ds,<br/>          validation_data=val_ds,<br/>          epochs=50)</strong></span></pre><h2 id="83aa" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">结论:</h2><p id="b994" class="pw-post-body-paragraph jz ka it kb b kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw im bi translated">提取数据，使用tf.data中可用的不同特征列将不同类型的数据转换为数值，然后加载数据，洗牌并创建批处理，以针对任何结构化数据训练深度学习模型</p><h2 id="39e4" class="lp lq it bd lr ls lt dn lu lv lw dp lx kk ly lz ma ko mb mc md ks me mf mg iz bi translated">参考资料:</h2><div class="oa ob gp gr oc od"><a href="https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/structured_data/feature_columns.ipynb#scrollTo=DJ6QnSHkPtOC" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jd gy z fp oi fr fs oj fu fw jc bi translated">谷歌联合实验室</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">编辑描述</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">colab.research.google.com</p></div></div><div class="om l"><div class="on l oo op oq om or li od"/></div></div></a></div><p id="256c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><a class="ae lo" href="https://www.tensorflow.org/guide/data#simple_batching" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/guide/data#simple_batching</a></p></div></div>    
</body>
</html>