<html>
<head>
<title>Utilization of Dask ML Framework for Fraud Detection —End-to-end Data Analytics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Dask ML框架进行欺诈检测—端到端数据分析</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/utilization-of-dask-ml-framework-for-fraud-detection-end-to-end-data-analytics-310b2f94d897?source=collection_archive---------2-----------------------#2020-07-24">https://pub.towardsai.net/utilization-of-dask-ml-framework-for-fraud-detection-end-to-end-data-analytics-310b2f94d897?source=collection_archive---------2-----------------------#2020-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0094" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-analytics" rel="noopener ugc nofollow" target="_blank">数据分析</a>，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/38b6135eb170938aa3aba30e8cab7cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLUbDpWE7Fe3jB6E5UsQnw.jpeg"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@f7photo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·朗米尔</a>在<a class="ae kl" href="https://unsplash.com/s/photos/finance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="66f4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">介绍</h1><p id="3aec" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">欺诈活动已经成为一种猖獗的活动，引起了金融界的许多好奇。这给帮助该部门有效管理其客户带来了许多问题。在本教程中，我们将使用Dask机器学习框架来直观地检测金融行业中的欺诈交易。该模型的结果是，我们可以在任何类型的银行中高效部署，通过提醒账户所有人和银行团队来减少欺诈手段。此代码的链接在<a class="ae kl" href="https://github.com/elishatofunmi/Medium-Intelligence/tree/master/Introduction%20to%20dask" rel="noopener ugc nofollow" target="_blank"> Github </a>上提供。</p><p id="df27" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">首先也是最重要的，既然这是一个机器学习问题，既然我们有像pandas、bumpy和scikit-learn这样著名的框架来完成工作，我们为什么还要使用dask呢？我想说的是，dask已经被证明是一个用最少的代码高效地扩展pandas、bumpy和scikit-learn工作流的框架。有了dask，你可以执行各种numpy、pandas和scikit-learn操作。</p><blockquote class="mn mo mp"><p id="da7b" class="lk ll mq lm b ln mi lp lq lr mj lt lu mr mk lx ly ms ml mb mc mt mm mf mg mh ij bi translated">Dask已经被证明是一个用最少的代码高效扩展pandas、numpy和scikit-learn工作流的框架</p></blockquote><p id="0a35" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在本教程中，我们希望根据银行A从其客户数据库中提供的一组信息建立一个模型；识别欺诈交易和非欺诈交易。这家银行拥有帐户卷入欺诈行为的客户和帐户没有欺诈历史的客户的数据。我们将利用这些信息根据某些特征来预测欺诈账户。</p><p id="dc4e" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">好的，首先，我将使用kaggle <a class="ae kl" href="https://www.kaggle.com/c/frauddetectionchallenge" rel="noopener ugc nofollow" target="_blank">上的一个数据集。我们将通过以下步骤来解决此问题:</a></p><ul class=""><li id="7c4f" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh mz na nb nc bi translated">了解我们的数据</li><li id="9df2" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">使用dask pandas和numpy框架进行数据分析/预处理。</li><li id="eca6" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">用seaborn和matplotlib实现数据可视化。</li><li id="afa6" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">特征工程</li><li id="f959" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">使用Dask ML框架的预测模型。</li></ul><blockquote class="mn mo mp"><p id="f202" class="lk ll mq lm b ln mi lp lq lr mj lt lu mr mk lx ly ms ml mb mc mt mm mf mg mh ij bi translated">有了dask，你可以进行各种各样的numpy，pandas和scikit-learn操作。</p></blockquote><h1 id="4300" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">数据分析</h1><p id="759a" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在本节中，我们将开始了解我们的数据，并使用dask执行基本的数据预处理和清理，同时决定哪个特性与问题建模相关。首先，让我们导入所有库并通过以下方式加载数据集:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cf29" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">您可以使用<strong class="lm ja"> read_csv </strong>方法将数据读入dask中的数据帧，然后传入csv文件。您可以使用<strong class="lm ja">查看数据中的前5个条目。数据帧的头</strong>属性。我们接下来要做的是了解我们正在使用的功能。在dask中，要做到这一点，可以运行dataframe和column属性。下面的代码说明了这一点。</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi no"><img src="../Images/f45355ba18ccb55e09440d452c609284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5Sm6YjU359VwKH91z7Iig.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">关口</figcaption></figure><p id="d69a" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">有了这个，我们可以说我们对我们的数据有了一个概念。因此，我们的数据包含交易时间、当前银行金额、上次银行金额、处理交易所需的时间、账户类型、婚姻状况等信息，以及银行每位用户提供的其他信息。更重要的是，我们试图预测或理解的特征与其他特征相比是欺诈性的；这是我们的目标功能。我们仍然需要更多地了解我们的数据，以便我们能够知道如何分析、选择最佳特征和转换以实现完美的建模。下一件你可能想做的事情是看看我们数据中数字条目的描述性分析。Dask通过运行下面的代码帮助我们高效地完成这项工作，我们将得到相应的输出。</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">计算</figcaption></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi np"><img src="../Images/869cbc49e8f1e2e9934c85bba016b885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOlVhGOcmRSeat2F"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">结果</figcaption></figure><p id="6876" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">dask dataframe的<code class="fe nq nr ns nt b">describe()</code>方法通过告诉我们每个特征中有效条目的数量(计数)、平均值、中值、众数、最小值、最大值、标准偏差、下百分位、上百分位以及每个相应条目的其他信息，为我们提供了对数据数字特征的统计洞察。这实际上揭示了我们数据中的一些东西，但是让我们注意，这只是针对我们数据中的数字信息。那么非数字信息呢，我们仍然需要将它们转换成数字，以便为算法学习它们做准备。首先，让我们通过了解哪些数据是数值型的，哪些不是来看一看我们的数据。下面的代码帮助我们在dask中做到这一点。</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">计算</figcaption></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi nu"><img src="../Images/198921f8177507b4117c19e477fc2a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WxSl5Wx9fSWtssqN"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">结果</figcaption></figure><p id="6cdc" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">从上面的代码中，我们可以看到我们有3个布尔特征(账户来源验证、交易来源方法和账户目的地验证)、6个数字数据和6个文本数据(字符串)。现在，我们已经对我们试图建模的信息有了一个概念，现在让我们通过使用dask深入了解每个特性来一步一步地深入这个概念。先说<strong class="lm ja">婚姻状况</strong>。下面的代码让我们了解了婚姻状况所包含的内容。</p><h2 id="bc70" class="nv kn iq bd ko nw nx dn ks ny nz dp kw lv oa ob la lz oc od le md oe of li iw bi translated">婚姻状况</h2><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi og"><img src="../Images/7ff2863b21363d38101ec948020d6e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W6j6WANBcnaRrzcs"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">婚姻状况</figcaption></figure><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">密码</figcaption></figure><p id="42ff" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">婚姻状况功能生动地告诉我们，这个数据库中的客户大多已婚，有些是单身，有些没有透露他们的婚姻状况。这可能是确定欺诈行为的一个独特特征吗？可能会，也可能不会。下面是一个直方图，显示了婚姻状况中每个唯一条目出现的频率。</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ba5563363447a68cc88142fee689bfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*RGIwSgORAf2tYT_FZ9o3Gg.png"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/bc979f6a3cc822548c90af74cbf3ece5.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*rI3V8wGcyGVHcinnJLjuog.png"/></div></figure><p id="50fb" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">从上图可以看出，许多已婚客户的账户中没有欺诈记录，这也对应于单身和未知客户的相同比例。从上图可以看出，欺诈性账户与非欺诈性账户的比例几乎相同(已婚、单身和未知)。我们可以说，婚姻状况和我们的目标之间存在着正比关系，具有欺骗性。我们将保留它，因为它是我们模型的有效条目。</p><p id="3f1f" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">让我们继续下一组功能，它们是:</p><ul class=""><li id="2f7d" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh mz na nb nc bi translated">身份</li><li id="5876" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">当前银行金额</li><li id="660d" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">最后的银行金额，以及</li><li id="d8e6" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated">最近的银行金额。</li></ul><p id="b9db" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">我们放弃它们是因为我们想假设它们不能成为确定欺诈交易的唯一决定因素。下面的代码(在dask中)帮助我们执行这个。</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cb54" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">现在我们只剩下更少的信息需要处理。我们可以在婚姻状况和欺诈之间做同样的事情，对于欺诈的其他特征，我们可以有以下视觉效果。</p><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/90550bf9e006676819adc37635e098e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/0*qJ83M5HmOnen6-Ej"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b4e58d03fec474ddb69d2b1c9e2ad081.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/0*vnfK0OJVYCrMP1ly"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bce51171502fcb02556548c669217691.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/0*LYSphcub8ZSh7T9B"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/1c3085abfd057d9f4d40f76cc81fe8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/0*TqNJdL6G09W8AZ6t"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cfe75e3a43424877508e285df5fb6ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/0*PXXt0jZOpkU_qUp0"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0ee721bfdf8196d70d9f64312fba539e.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/0*grg9JUbof6rWFGxN"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d94cebd2000a13f53393a9610cc04914.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*_--sz-HUERfjfCa2"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/16c1a48222821e107fb35d5642fe710a.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/0*PMstYw2__5WcKL-R"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi op"><img src="../Images/282dce0d8f237a23e9cdf96abc3c7c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*7MgQqYvq3j8g-QnP"/></div></figure><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0824c30c388515a7111dae624912efef.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/0*8XhzbDelvY1DFuLL"/></div></figure><p id="ab01" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">让我们采取一些其他的特征，分析和转换。首先，让我们研究一下交易时间。由于这与时间有关，我们将需要使用python中的时间、日期库来处理它。下面的代码有助于我们高效地做到这一点:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8318" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">上面所做的是让我们应用基本的字符串操作，将时间分成年、月、日、小时、分钟和秒，用于该特性中的每个条目(事务时间)。完成这些后，我们将它们转换成数据框架的新特性，然后删除原始的事务时间列。下一步是我们将数据分成X和y，这样X包含我们想要使用的所有特征，y是目标特征。为此，我们有:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">x和Y</figcaption></figure><h1 id="0f29" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">特征工程</h1><p id="28d3" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">现在我们已经有了一些关于数据的想法，让我们继续做一些特性工程。在数据中生成更多要素有两种主要方式:</p><ul class=""><li id="89b8" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh mz na nb nc bi translated"><strong class="lm ja">标签编码器</strong> —此处，特征参数或条目按优先级顺序编码。</li><li id="5965" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated"><strong class="lm ja">一键编码器</strong> —这里，特征参数或条目通过赋予所有条目相同的优先级进行编码。更有甚者，这种编码器倾向于通过特定特征中有效条目的数量来增加数据的维度。</li><li id="75aa" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh mz na nb nc bi translated"><strong class="lm ja">多项式— </strong>对数据中存在的输入特征进行数据扩展的聚合方法。</li></ul><p id="1870" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">但是为了这个教程，我们将把重点放在<strong class="lm ja">标签编码和一键</strong>上。Dask支持标签编码和一键编码。首先，这里有一些我们已经研究过的特性，我们想把它们从一个物体编码成数字。这是因为我们的算法处理数字，而不是字符串，所以如果与数据相关，它们需要被编码。我们正在使用标签编码对以下功能进行编码:</p><ol class=""><li id="84ff" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh or na nb nc bi translated">帐户来源验证。</li><li id="615d" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated">帐户目的地验证。</li><li id="f9a5" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated">交易来源方法。</li></ol><p id="acc5" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用dask对它们进行编码的方法如下，使用下面的代码:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0574" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">有些特征在确定欺诈交易时不太重要，如处理交易所需的时间、年龄和Id。因此，为了将它们从我们的数据中删除，我们执行以下操作:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1f8d" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">现在，我们只剩下6个特征来构建一个模型，该模型将有效地确定交易是否是欺诈性的。为了证实这一点，你可以使用<strong class="lm ja">。要查看的数据帧的head </strong>属性。为此，我们有:</p><figure class="ni nj nk nl gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi os"><img src="../Images/fd2a4b5ab5209ef0141e8c5f9183579c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0IM2Ex80a4yObUx8"/></div></div></figure><p id="6b85" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">由于我们所有的特征现在都是数字，我们可以使用以下任何一种技术来标准化和减少每个特征的差异:</p><ol class=""><li id="755c" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh or na nb nc bi translated"><strong class="lm ja">标准缩放器</strong> —一种基于标准差重新缩放数据的方法。</li><li id="777c" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated"><strong class="lm ja">规格化器</strong> —一种将特定特征的所有输入规格化为1的方法</li><li id="39e1" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated"><strong class="lm ja">最小-最大缩放器</strong> —一种通过相应的最大数字重新缩放每一列的所有相应条目来减少各种特征差异的方法。</li></ol><p id="8e1a" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">这些技术是在建模之前用于数据科学和ML任务的缩放技术。Dask对此有支持，要导入它们，请执行以下操作:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1164" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">完成缩放和数据标准化后，我们可以继续建模。Dask确实在帮助我们建模数据方面提供了支持，上面的代码向我们展示了如何导入高效建模数据所需的必要库。这包括<strong class="lm ja"> train_test_split </strong>，将我们的数据分成训练和测试数据，用于建模和测试模型性能。更重要的是，您可以使用dask导入如上所示的逻辑回归算法(这将是为我们的数据建模的算法)。最后，我们可以继续使用dask导入指标，即<strong class="lm ja">准确性得分</strong>和<strong class="lm ja"> log_loss </strong>，它们是用于在desk中分类的可用指标。首先，让我们将我们的训练数据分成两部分，一部分用于<strong class="lm ja">建模</strong>，另一部分用于<strong class="lm ja">测试</strong>，为此，我们有以下内容:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><blockquote class="mn mo mp"><p id="96b0" class="lk ll mq lm b ln mi lp lq lr mj lt lu mr mk lx ly ms ml mb mc mt mm mf mg mh ij bi translated">Dask确实在帮助我们建立数据模型方面提供了支持，</p></blockquote><p id="5de9" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">既然我们已经能够分成建模数据和测试数据，我们可以继续将建模数据输入到我们的算法中，以使用dask进行学习，并最终在训练时评估模型。下面的代码向我们展示了如何做到这一点:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6911" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在训练时，该模型大约72%准确，这表明该模型学习了。让我们继续对测试数据进行预测，并评估它在以前没有见过的数据上的性能。下面的代码帮助我们做到这一点:</p><figure class="ni nj nk nl gt ka"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ol class=""><li id="621a" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh or na nb nc bi translated">如何用dask进行数据预处理和清洗？</li></ol><blockquote class="mn mo mp"><p id="b852" class="lk ll mq lm b ln mi lp lq lr mj lt lu mr mk lx ly ms ml mb mc mt mm mf mg mh ij bi translated">Dask为我们提供了端到端的数据分析和建模灵活性。</p></blockquote><p id="83db" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">如何用dask进行数据预处理和清洗？</p><ol class=""><li id="c671" class="mu mv iq lm b ln mi lr mj lv mw lz mx md my mh or na nb nc bi translated">用dask进行数据建模和预测。</li></ol><p id="9f64" class="pw-post-body-paragraph lk ll iq lm b ln mi lp lq lr mj lt lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">我希望你已经学到了很多，如果你真的喜欢这个教程，请与朋友分享。谢了。</p><h1 id="30bb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">链接和参考</h1><ol class=""><li id="3c05" class="mu mv iq lm b ln lo lr ls lv ot lz ou md ov mh or na nb nc bi translated"><a class="ae kl" href="https://github.com/elishatofunmi/Medium-Intelligence/tree/master/Introduction%20to%20dask" rel="noopener ugc nofollow" target="_blank">https://github . com/elishatofunmi/Medium-Intelligence/tree/master/Introduction % 20 to % 20 task</a>(本作笔记本)。</li><li id="45c1" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated">https://dask.org<a class="ae kl" href="https://dask.org" rel="noopener ugc nofollow" target="_blank"/></li><li id="e314" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated"><a class="ae kl" href="https://colab.research.google.com/drive/1uvRpOp9L1Hge2GNniJ5fJ0H7VL0LQmbZ?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1 uvrpop 9 l 1 hge 2 gnnij 5 FJ 0h 7 VL 0 lqmbz？usp =分享</a>(合作笔记本)。</li><li id="6287" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated">https://docs.dask.org/en/latest/(dask文档)。</li><li id="2796" class="mu mv iq lm b ln nd lr ne lv nf lz ng md nh mh or na nb nc bi translated"><a class="ae kl" href="https://github.com/dask/dask-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/dask/dask-tutorial</a>(dask教程)。</li></ol></div></div>    
</body>
</html>