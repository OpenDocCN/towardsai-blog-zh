<html>
<head>
<title>Image Processing: Morphological Operations with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像处理:用Python进行形态学运算</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/image-processing-morphological-operations-with-python-7e0f8d1983eb?source=collection_archive---------0-----------------------#2021-07-29">https://pub.towardsai.net/image-processing-morphological-operations-with-python-7e0f8d1983eb?source=collection_archive---------0-----------------------#2021-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="16ef" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="65a9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为了从图像中去除噪声</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/41320836709d365815a814bff81a1b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*D6obVAvF4X8YksE6FWY-sQ.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">作者的照片</figcaption></figure><blockquote class="ld le lf"><p id="85ad" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">形态学方法</em> </strong></p></blockquote><p id="0b49" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">当对图像进行预处理以进行增强和性能操作(如阈值处理)时，图像可能会有一些噪声。结果，图像中存在像素信息的不适当平衡。</p><p id="d3fb" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">形态学的运算是去除主要影响图像形状和信息的噪声。形态学运算在图像分割中非常有用，可以得到无噪声的二值图像。</p><p id="7d11" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">基本的形态学操作是腐蚀和膨胀。下面讨论这两种操作的解释:</p><blockquote class="ld le lf"><p id="80da" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">膨胀</em> </strong></p></blockquote><p id="a35c" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">在膨胀操作中，如果对象是白色的，则白色像素周围的像素会增长。它增加的区域取决于对象像素的形状。膨胀过程增加了对象的像素数量，并减少了非对象的像素数量。</p><p id="2aa7" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">不同内核大小和迭代的膨胀Python代码</p><pre class="ks kt ku kv gt mg mh mi mj aw mk bi"><span id="3bb9" class="ml mm it mh b gy mn mo l mp mq">import numpy as np<br/>import imutils<br/>import cv2</span><span id="084c" class="ml mm it mh b gy mr mo l mp mq">#reading the input image<br/>img = cv2.imread('thumb.png') #reads the image</span><span id="5c59" class="ml mm it mh b gy mr mo l mp mq">#cv2.imwrite('Input_image.jpg',image)</span><span id="c435" class="ml mm it mh b gy mr mo l mp mq">#Resizing the image<br/>scale_percent = 70<br/>width = int(img.shape[1] * scale_percent / 100)<br/>height = int(img.shape[0] * scale_percent / 100)<br/>dim = (width, height)<br/>  <br/># resize the input image<br/>image = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)</span><span id="a39d" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((1,1), dtype = "uint8")/9<br/>dilation = cv2.dilate(image,kernel,iterations = 1)<br/>cv2.imwrite('dilation.jpg', dilation)</span><span id="2dd6" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((2,2), dtype = "uint8")/9<br/>dilation = cv2.dilate(image,kernel,iterations = 1)<br/>cv2.imwrite('dilation.jpg', dilation)</span><span id="a628" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((2,2), dtype = "uint8")/9<br/>dilation = cv2.dilate(image,kernel,iterations = 3)<br/>cv2.imwrite('dilation.jpg', dilation)</span><span id="11a8" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((2,2), dtype = "uint8")/9<br/>dilation = cv2.dilate(image,kernel,iterations = 5)<br/>cv2.imwrite('dilation.jpg', dilation)</span><span id="e84a" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((3,3), dtype = "uint8")/9<br/>dilation = cv2.dilate(image,kernel,iterations = 2)<br/>cv2.imwrite('dilation.jpg', dilation)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/df3bd155161fdce9ae65496c2660a3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9NTDXhqg0Jk9j-nKqm6FQ.png"/></div></div></figure><div class="mx my gp gr mz na"><a rel="noopener  ugc nofollow" target="_blank" href="/latest-programming-languages-for-ai-5252d39e1c51"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">最新的人工智能编程语言</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">人工智能未来娱乐它的语言</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">pub.towardsai.net</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no kx na"/></div></div></a></div><blockquote class="ld le lf"><p id="29ad" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">侵蚀</em> </strong></p></blockquote><p id="84cd" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">侵蚀函数正好是膨胀功函数的逆函数。侵蚀功能使对象的尺寸变小。侵蚀过程增加了非目标像素，减少了目标像素。</p><p id="6966" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">不同内核大小和迭代的Python代码</p><pre class="ks kt ku kv gt mg mh mi mj aw mk bi"><span id="eb08" class="ml mm it mh b gy mn mo l mp mq">import numpy as np<br/>import imutils<br/>import cv2</span><span id="c0eb" class="ml mm it mh b gy mr mo l mp mq">#reading the input image<br/>img = cv2.imread('thumb.png')</span><span id="25fd" class="ml mm it mh b gy mr mo l mp mq">#cv2.imwrite('Input_image.jpg',image)</span><span id="828c" class="ml mm it mh b gy mr mo l mp mq">#Resizing the image<br/>scale_percent = 70<br/>width = int(img.shape[1] * scale_percent / 100)<br/>height = int(img.shape[0] * scale_percent / 100)<br/>dim = (width, height)<br/>  <br/># resize the input image<br/>image = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)</span><span id="ecf0" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((1,1), dtype = "uint8")/9<br/>erosion = cv2.erode(image, kernel, iterations = 1)<br/>cv2.imwrite('erosion.jpg', erosion)</span><span id="c561" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((2,2), dtype = "uint8")/9<br/>erosion = cv2.erode(image, kernel, iterations = 2)<br/>cv2.imwrite('erosion.jpg', erosion)</span><span id="156f" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((2,2), dtype = "uint8")/9<br/>erosion = cv2.erode(image, kernel, iterations = 3)<br/>cv2.imwrite('erosion.jpg', erosion)</span><span id="d619" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((2,2), dtype = "uint8")/9<br/>erosion = cv2.erode(image, kernel, iterations = 5)<br/>cv2.imwrite('erosion.jpg', erosion)</span><span id="7a7a" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((5,5), dtype = "uint8")/9<br/>erosion = cv2.erode(image, kernel, iterations = 2)<br/>cv2.imwrite('erosion.jpg', erosion)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi np"><img src="../Images/94a23d281ad6eeda777a15d04307ac04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjWOfgT1C26Qh_WZosVEPA.png"/></div></div></figure><div class="mx my gp gr mz na"><a href="https://medium.com/pythoneers/opencv-count-of-objects-in-blood-image-with-python-3d82de1c83a9" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jc bi translated">OpenCV:使用Python对血液图像中的对象进行计数</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">OpenCV库的图像处理概念</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nq l nl nm nn nj no kx na"/></div></div></a></div><blockquote class="ld le lf"><p id="2c1d" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">开场</em> </strong></p></blockquote><p id="9ada" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这种方法有助于去除图像中的噪声。该方法的作用是先腐蚀再膨胀，以保持目标像素的原始性，并去除背景中的小噪声。</p><p id="7683" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">Python代码用于打开</p><pre class="ks kt ku kv gt mg mh mi mj aw mk bi"><span id="b620" class="ml mm it mh b gy mn mo l mp mq">import numpy as np<br/>import imutils<br/>import cv2</span><span id="39b1" class="ml mm it mh b gy mr mo l mp mq">#reading the input image<br/>img = cv2.imread('11.png')</span><span id="3f51" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((5,5), dtype = "uint8")/9<br/>opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)<br/>cv2.imwrite('opening.jpg', opening)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6496f25f9c00aef9d8cb7766224471f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*RsJXEMaQTcNR8rVwJX-bNg.png"/></div></figure><blockquote class="ld le lf"><p id="2ed1" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">关闭</em> </strong></p></blockquote><p id="81ad" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这种方法有助于去除图像中的噪声。该方法的工作原理是先进行膨胀，然后进行腐蚀，以保持目标像素的原始性，并去除拇指内部的小噪声。</p><p id="5f03" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">关闭的Python代码</p><pre class="ks kt ku kv gt mg mh mi mj aw mk bi"><span id="c2aa" class="ml mm it mh b gy mn mo l mp mq">import numpy as np<br/>import imutils<br/>import cv2</span><span id="de95" class="ml mm it mh b gy mr mo l mp mq">#reading the input image<br/>img = cv2.imread('thumb.png')</span><span id="5913" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((9,9), dtype = "uint8")/9<br/>closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)<br/>cv2.imwrite('closing.jpg', closing)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e367cf854a11b9cc67d3b8e14e1e86a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*6cAexS0c1YemGtTjafb_CA.png"/></div></figure><blockquote class="ld le lf"><p id="d71e" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">形态渐变</em> </strong></p></blockquote><p id="7645" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这种方法不同于膨胀技术和腐蚀技术。</p><p id="f295" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">形态学梯度的Python代码</p><pre class="ks kt ku kv gt mg mh mi mj aw mk bi"><span id="2aef" class="ml mm it mh b gy mn mo l mp mq">import numpy as np<br/>import imutils<br/>import cv2</span><span id="57b6" class="ml mm it mh b gy mr mo l mp mq">#reading the input image<br/>img = cv2.imread('g1.png')</span><span id="1aae" class="ml mm it mh b gy mr mo l mp mq">kernel = np.ones((6,6), dtype = "uint8")/9<br/>gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)<br/>cv2.imwrite('gradient.jpg', gradient)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c2fa92dc61917002f618746a1a0a2daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*8EE2IB9VoKLjsRlceC_XsQ.png"/></div></figure><blockquote class="ld le lf"><p id="9286" class="lg lh li lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="it">结论</em> </strong></p></blockquote><p id="b337" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">这些操作是处理二值图像的一种非常简单的方法，也是图像处理应用程序中预处理的一部分。</p><p id="ac65" class="pw-post-body-paragraph lg lh it lj b lk ll kd lm ln lo kg lp md lr ls lt me lv lw lx mf lz ma mb mc im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae nu" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae nu" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="8672" class="nv mm it bd nw nx ny nz oa ob oc od oe ki of kj og kl oh km oi ko oj kp ok ol bi translated">推荐文章</h1><p id="e446" class="pw-post-body-paragraph lg lh it lj b lk om kd lm ln on kg lp md oo ls lt me op lw lx mf oq ma mb mc im bi translated"><a class="ae nu" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄用Python </a> <br/> 2。<a class="ae nu" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a> <br/> 3。<a class="ae nu" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae nu" rel="noopener ugc nofollow" target="_blank" href="/principal-component-analysis-in-dimensionality-reduction-with-python-1a613006d531?source=friends_link&amp;sk=3ed0671fdc04ba395dd36478bcea8a55">用Python进行主成分分析降维</a> <br/> 5。<a class="ae nu" href="https://medium.com/towards-artificial-intelligence/fully-explained-k-means-clustering-with-python-e7caa573176a?source=friends_link&amp;sk=9c5c613ceb10f2d203712634f3b6fb28" rel="noopener">用Python全面讲解K-means聚类</a> <br/> 6。<a class="ae nu" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python充分解释了线性回归</a> <br/> 7。<a class="ae nu" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae nu" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/> 9的区别。<a class="ae nu" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae nu" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>