<html>
<head>
<title>Data Mining Without Being Discourteous</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">毫不客气地进行数据挖掘</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/data-mining-without-being-discourteous-e6dc431c206c?source=collection_archive---------2-----------------------#2020-06-15">https://pub.towardsai.net/data-mining-without-being-discourteous-e6dc431c206c?source=collection_archive---------2-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3573" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-mining" rel="noopener ugc nofollow" target="_blank">数据挖掘</a></h2><div class=""/><div class=""><h2 id="d1ea" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从Xtrawine.com网上搜集酒单</h2></div><p id="9342" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ln" href="https://github.com/arditoibryan/Projects/tree/master/20200613_Wine_Price_Estimator" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> <em class="lo">完整代码可在我的Github repo获得。</em> </strong> </a></p><p id="2c71" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文的第一部分，我将重点介绍一种称为web抓取的数据挖掘技术。这组算法允许程序员访问页面的HTML代码，以从页面中提取信息。如果你能够在同一个网站的数百个页面中迭代，你可以下载大量的信息。</p><h2 id="932a" class="lp lq it bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg iz bi translated">网页抓取是如何工作的？</h2><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/cd4a88f9a4898079113d535b79197e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X85zg3Nsb_mgW9xoo9qgGA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">4步程序</figcaption></figure><p id="f752" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">网页抓取可以总结为以下步骤:</p><ol class=""><li id="b3d4" class="mx my it kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">隔离网站中存储信息的区块</li><li id="1b20" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">连接到执行URL请求的网站</li><li id="d68d" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">下载HTML代码</li><li id="fe41" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">提取方块</li><li id="8688" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">为每个块提取单个信息</li><li id="9b0d" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">遍历每个网页</li><li id="bb24" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">创建数据集</li><li id="da3b" class="mx my it kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">导出数据集</li></ol><h1 id="30c1" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">1.隔离块</h1><p id="389d" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">第一部分实际上比看起来更复杂。没有技术规则来识别源代码中的主要块。如果你想建立一个成功的网络抓取算法，你必须从一开始就假设信息在整个网站中以一种模式组织(至少在你想从中提取信息的集合页面中)。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ob"><img src="../Images/69587387b1c8bef714c320227016d208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWg_spfXFieXdNEGr_99iA.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">www.xtrawine.com</figcaption></figure><h1 id="3810" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">2.连接到网站</h1><p id="57ac" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">现在我们已经确切地知道了我们想要什么，并且知道在哪里可以找到它，我们可以使用请求模块进行第一次连接。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="c9d7" class="lp lq it od b gy oh oi l oj ok">import requests<br/>from bs4 import BeautifulSoup</span><span id="d1e8" class="lp lq it od b gy ol oi l oj ok">URL = '<a class="ae ln" href="https://www.xtrawine.com/en/wines/red/195?p=7'" rel="noopener ugc nofollow" target="_blank">https://www.xtrawine.com/en/wines/red/195?p=7'</a><br/>page = requests.get(URL)</span></pre><h1 id="db44" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">3.下载HTML代码</h1><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="fad0" class="lp lq it od b gy oh oi l oj ok">soup = BeautifulSoup(page.content, 'html.parser')<br/>soup</span></pre><p id="2e62" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">建立连接后，我就可以下载HTML代码了。为此，我将使用一个名为美丽的汤的模块。</p><p id="1211" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我看看我刚刚下载的内容:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi om"><img src="../Images/e38be73efc75158ddda5fed55fce7dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCyfCwA6NbtLEbbeLzscvQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">汤产量的样本</figcaption></figure><p id="dc19" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在下面的步骤中，我将从大量的代码中分离出我需要的数据，并逐段提取。</p><h1 id="cfc9" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">4.提取方块</h1><p id="f6c3" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">这是事情开始变得具有挑战性的部分。您需要调整自己的算法以适应包含您想要下载的所有信息的代码。每个网页的结构都不一样，有的很乱，有的把每个对象都存储在同一个类下，有的按id存储…</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="6b55" class="lp lq it od b gy oh oi l oj ok">def request_(URL):<br/>  page = requests.get(URL)<br/>  soup = BeautifulSoup(page.content, 'html.parser')</span><span id="1713" class="lp lq it od b gy ol oi l oj ok">#finding elements by class name<br/>  job_elems = soup.find_all(class_='product-item')<br/>  job_elems</span></pre><p id="2be2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从上图可以看出，每个葡萄酒部分(带有附加信息)都存储在类<strong class="kt jd"> product_item </strong>下。我将隔离所有项目，并将其命名为job_elems。job_elems中的每个元素都是一个部分，包含页面上一种葡萄酒的所有信息。</p><h1 id="dfff" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">5.为每个块提取单个信息</h1><p id="2058" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">我现在将浏览每个块，提取每个相关信息，将它们收集到一个列表中。大多数葡萄酒信息(生产商、葡萄酒种类、地区……)都存储在类别<strong class="kt jd">右</strong>下(我必须研究网页代码才能找到这些信息)。</p><h2 id="7441" class="lp lq it bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg iz bi translated">例子</h2><p id="d4a4" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">* * *下面是一个例子，不包括在主代码中:这是搜索所有<strong class="kt jd">右</strong>类的样子。它们包含在一个列表中，所以我们可以通过调用list_[n]来访问我们想要提取的第n行。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="4b31" class="lp lq it od b gy oh oi l oj ok">all_wines = list()<br/>job_elems[0]<br/>list_ = job_elems[0].find_all(class_='right')<br/>list_<br/>[<br/>&lt;td class="right"&gt;&lt;a alt="De loach wines" href="/en/producers/de-loach/1687" title="De loach wines"&gt;De Loach&lt;/a&gt;&lt;/td&gt;,<br/> &lt;td class="right"&gt;Red organic still&lt;/td&gt;,<br/> &lt;td class="right"&gt;2016&lt;/td&gt;,<br/> &lt;td class="right"&gt;<br/> &lt;div id="RootLayout_PageLayout_WhiteZoneTopRight_Frame1648_Module1648_repProducts_ctl00_pnlAppl"&gt;<br/> &lt;a href="/en/appellations/sonoma-valley/721"&gt;AVA Russian River Pinot Noir&lt;/a&gt;<br/> &lt;/div&gt;<br/> &lt;/td&gt;,<br/> &lt;td class="right"&gt;&lt;a href="/en/zones/california/59"&gt;California&lt;/a&gt;&lt;/td&gt;,<br/> &lt;td class="right"&gt;100% &lt;a class="simpleLnk" href="/en/grape-varieties/pinot-nero/111"&gt;Pinot Nero&lt;/a&gt;&lt;/td&gt;,<br/> &lt;td class="right"&gt;13.50% by volume&lt;/td&gt;,<br/> &lt;td class="right"&gt;0,75 l Standard&lt;/td&gt;,<br/> &lt;td class="right xw-item-properties"&gt;<br/> &lt;i class="filter-small xwi-promo" title="Special discount"&gt;&lt;/i&gt;<br/> &lt;i class="filter-small xwi-award" title="Most awarded"&gt;&lt;/i&gt;<br/> &lt;i class="filter-small xwi-bio" title="Organic or Biodynamic"&gt;&lt;/i&gt;<br/> &lt;/td&gt;<br/>]</span></pre><p id="df27" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，如果我想提取葡萄酒的生产商，我会查看第一行代码。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="bc39" class="lp lq it od b gy oh oi l oj ok">&lt;td class="right"&gt;&lt;a alt="De loach wines" href="/en/producers/de-loach/1687" title="De loach wines"&gt;De Loach&lt;/a&gt;&lt;/td&gt;</span></pre><p id="2e96" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了提取它，我需要使用方法<code class="fe on oo op od b">find</code>:</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="2624" class="lp lq it od b gy oh oi l oj ok">list_[0].find('a').find_all(text=True, recursive=False)<br/>['De Loach']</span></pre><h2 id="3332" class="lp lq it bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg iz bi translated">回到真正的代码</h2><p id="b3f6" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">为了恢复这个功能，我编写了从网页中提取每一个葡萄酒信息的所有规范。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="2456" class="lp lq it od b gy oh oi l oj ok">  all_wines = list()<br/>  for job_elem in job_elems:<br/>    single_wine = list()</span><span id="f467" class="lp lq it od b gy ol oi l oj ok">list_ = job_elem.find_all(class_='right')<br/>    single_wine.append(list_[0].find('a').find_all(text=True, recursive=False))<br/>    single_wine.append(list_[1].find_all(text=True, recursive=False))<br/>    single_wine.append(list_[2].find_all(text=True, recursive=False))<br/>    single_wine.append(list_[3].find_all(text=True, recursive=False))<br/>    single_wine.append(list_[4].find('a').find_all(text=True, recursive=False))<br/>    single_wine.append(list_[5].find_all(text=True, recursive=False))<br/>    single_wine.append(list_[6].find_all(text=True, recursive=False))<br/>    single_wine.append(list_[7].find_all(text=True, recursive=False))</span></pre><p id="ab4f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不幸的是，价格有点难以提取。在这个网站上，有两个关于葡萄酒价格的可能字符串:</p><ul class=""><li id="0613" class="mx my it kt b ku kv kx ky la mz le na li nb lm oq nd ne nf bi translated">原价</li><li id="4124" class="mx my it kt b ku ng kx nh la ni le nj li nk lm oq nd ne nf bi translated">当前价格</li></ul><p id="9045" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不是所有的葡萄酒都有原价，如果他们提供折扣，他们会保留原价和现价。此外，一些页面的代码中仍然存储着一些旧的价格。鉴于这些数据之间的不一致性，我决定保留我在价格列表中找到的第一个原始价格和第一个当前价格。</p><p id="fc77" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将使用try语句来防止崩溃，以防算法返回None。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="d773" class="lp lq it od b gy oh oi l oj ok">  try:<br/>      price_ = job_elem.find_all(class_='origPrice')<br/>      single_wine.append(price_[0].find_all(text=True, recursive=False))<br/>    except:<br/>      single_wine.append(None)</span><span id="8e73" class="lp lq it od b gy ol oi l oj ok">  try:<br/>      price_ = job_elem.find_all(class_='currPrice')<br/>      single_wine.append(price_[0].find_all(text=True, recursive=False))<br/>    except:<br/>      single_wine.append(None)<br/>    <br/>    print(single_wine)<br/>    all_wines.append(single_wine)<br/>  <br/>  return all_wines</span></pre><h1 id="bece" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">6.遍历每个网页</h1><p id="8815" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">艰难的部分已经完成。我们可以有效地从单个网页中提取所有的葡萄酒信息。我们需要做的就是遍历数百个页面来填充数据集。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi or"><img src="../Images/20e9bfe9a2ddebde9e1343da6722b8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*ExudV9tKAHApeHfKLjzUJQ.png"/></div></figure><p id="40b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在网页中，我们可以选择要查看的页面。如果我们查看URL，从一个页面到另一个页面的唯一变化是最后一个数字:</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="0156" class="lp lq it od b gy oh oi l oj ok">#For page 7<a class="ae ln" href="https://www.xtrawine.com/en/wines/red/195?p=7" rel="noopener ugc nofollow" target="_blank"><br/>https://www.xtrawine.com/en/wines/red/195?p=7<br/></a>#For page 8<br/><a class="ae ln" href="https://www.xtrawine.com/en/wines/red/195?p=7" rel="noopener ugc nofollow" target="_blank">https://www.xtrawine.com/en/wines/red/195?p=</a>8<br/>#...</span></pre><p id="b62d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以每次编辑URL来遍历每个页面。这就是我们下载整个数据集的方式。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="0c96" class="lp lq it od b gy oh oi l oj ok">import time</span><span id="874f" class="lp lq it od b gy ol oi l oj ok">list3 = list()<br/>for _ in range(0, 40):<br/>  print(_)<br/>  try:<br/>    time.sleep(40)<br/>    list3.append(request_('<a class="ae ln" href="https://www.xtrawine.com/en/wines/red/195?p='+str(_)))" rel="noopener ugc nofollow" target="_blank">https://www.xtrawine.com/en/wines/red/195?p='+str(_)))</a><br/>  except:<br/>    pass<br/>  #empty = pd.concat([empty, request_], axis=0)</span></pre><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi os"><img src="../Images/b82c137860e6fd481e31c78be632ecf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGK18EOgnXdC0Ay9ZOCd4g.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">输出的一瞥</figcaption></figure><p id="d449" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该算法将连接到一个页面，运行网页抓取算法提取页面中的代码，然后将它们存储到每页的单个列表中。列表3将收集所有这些列表。</p><p id="307a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">完成每个请求后，算法将等待40秒，然后开始下一个请求。通过这样做，我们不会在网站上产生过多的流量需求:我们不需要失礼…</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ot"><img src="../Images/b792767f25b2e4e3d7b5262dac62d924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIYuHPcga9nQlG7kAYjTgQ.jpeg"/></div></div></figure><blockquote class="ou ov ow"><p id="98c9" class="kr ks lo kt b ku kv kd kw kx ky kg kz ox lb lc ld oy lf lg lh oz lj lk ll lm im bi translated">…因为无礼对我来说是无法形容的丑陋。汉尼拔·莱克特</p></blockquote><h1 id="f59e" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">7.创建数据集</h1><p id="8c99" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">在收集了存储在list3中的相当于40页的内容后，我们可以将其转换为数据集:</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="7aec" class="lp lq it od b gy oh oi l oj ok">wines = list()<br/>for _1 in list3:<br/>  print(len(_1))<br/>  for _2 in _1:<br/>    wines.append(_2)</span><span id="014d" class="lp lq it od b gy ol oi l oj ok">len(wines)<br/>...<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>25<br/>975</span></pre><p id="977e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们总共存储了975行葡萄酒信息。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="0676" class="lp lq it od b gy oh oi l oj ok">import pandas as pd<br/>wines = pd.DataFrame(wines)<br/>wines</span></pre><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi pa"><img src="../Images/1d798686af915e0d05a696b19f5a624f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kx7zguP1y8OCgV2hDHrcw.png"/></div></div></figure><p id="c280" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">精彩结果！我们已经刮了39页了。</p><h1 id="9b43" class="nl lq it bd lr nm nn no lu np nq nr lx ki ns kj ma kl nt km md ko nu kp mg nv bi translated">8.导出数据集</h1><p id="8bff" class="pw-post-body-paragraph kr ks it kt b ku nw kd kw kx nx kg kz la ny lc ld le nz lg lh li oa lk ll lm im bi translated">现在我们必须将它导出到我们的文件中，这样我们就可以在其他会话中使用它，而不必从头开始。</p><pre class="mi mj mk ml gt oc od oe of aw og bi"><span id="4918" class="lp lq it od b gy oh oi l oj ok">wines.to_csv('wines.csv')</span></pre></div></div>    
</body>
</html>