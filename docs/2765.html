<html>
<head>
<title>Backtesting Strategy for ML Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ML模型的回测策略</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/backtesting-of-ml-models-e558dbbea5c8?source=collection_archive---------0-----------------------#2022-05-15">https://pub.towardsai.net/backtesting-of-ml-models-e558dbbea5c8?source=collection_archive---------0-----------------------#2022-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="184e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种跨时间的交叉验证</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c417eb5615ba3651d88e23d4a1ae28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0IuLTyLZ4MxGWJY2Pt-YQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:corporatefinanceinstitute.com</figcaption></figure><p id="549d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">模型性能</strong>对任何业务流程都至关重要，必须定期进行验证。为了建立模型性能的功效，商业组织经常求助于诸如<strong class="kx ir">交叉验证</strong>之类的技术。在这种情况下，广泛使用留一法和k倍交叉验证。除此之外，企业经常需要确定模型随时间的性能，即基于时间的交叉验证。</p><p id="d872" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们的目的是讨论基于时间的交叉验证方法，这些方法可以很容易地用来测量和确认模型的性能。它被称为<strong class="kx ir">回溯测试</strong>。广泛用于<strong class="kx ir">股市分析</strong>预测未来股票价值。但是，并不局限于此。它可以用于任何基于时间的交叉验证目的。下面简要介绍适合这一目的的方法或策略。基于业务上下文和数据，可以采用适当的回溯测试。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="eecc" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">回溯测试策略</h1><p id="af28" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">有三种简单的方法来回溯测试和验证机器学习(ML)模型的性能。与交叉验证方法类似，回测也将数据集分为训练集和验证集(也称为保留数据)。因此，在某种程度上，回溯测试可以被认为是交叉验证的扩展。<br/>为了验证ML模型的性能，可以如下所示确定验证集。这些方法中的每一种都有一定的优点和局限性。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9d30" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">简单采样策略</strong></h1><p id="8b80" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在这种采样策略中，训练和测试数据集是互斥的，即使在迭代中也是如此。这种方法的好处是在实现和解释方面的简单性。此外，对于大型数据集，它可以在最短的时间内验证ML模型的性能。然而，ML模型的训练可能由于缺乏较小数据集的大量数据而受到影响。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/c63113c9b21859884598ff244934601c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uA3vYBPHvIF2aKIGqneWg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">训练和测试数据集的简单采样</figcaption></figure><p id="de97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来提供了用于简单采样的python代码。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e00d" class="nb lz iq mx b gy nc nd l ne nf">def simple_batch(batch_start='2021-01-01', batch_end='2022-12-31', train_days = 30, test_days = 15 ):<br/>    <br/>    batch = []<br/>    <br/>    while True:<br/>        a = pd.to_datetime(batch_start) - pd.DateOffset(days=train_days)<br/>        b = pd.to_datetime(batch_start)<br/>        c = pd.to_datetime(batch_start) + pd.DateOffset(days=test_days)</span><span id="e9b3" class="nb lz iq mx b gy ng nd l ne nf">        batch.append([a, b, c])<br/>    <br/>        if  b + pd.DateOffset(days=train_days+2*test_days) &gt; pd.to_datetime(batch_end):<br/>            break<br/>        else:<br/>            batch_start = b + pd.DateOffset(days=test_days+train_days)<br/>            <br/>    return batch</span></pre><p id="4e45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nh">注:</em>在python代码中，b代表训练停止和测试/验证开始的日期。因此，训练数据和测试/验证日期分别是从a到b和b到c。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="f99c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">重叠策略</strong></h1><p id="ea00" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在这种采样策略中，训练和测试数据集仅在当前迭代中是互斥的。这种方法的好处是在实现和解释方面的简单性。此外，对于大型数据集，它可以在合理的时间内验证ML模型的性能。然而，对于小数据集，ML模型的训练可能由于缺乏数据量而受到影响。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/6681d5b7b503771ce3e4cb9a3fc5db9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APrBEUygQ0RGunw1S2kyTA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">训练和测试数据集的重叠采样</figcaption></figure><p id="006c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来提供了重叠采样的python代码。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6b14" class="nb lz iq mx b gy nc nd l ne nf">def overlap_batch(batch_start='2021-01-01', batch_end='2022-12-31', train_days = 30, test_days = 15 ):<br/>    batch = []<br/>    <br/>    while True:<br/>        a = pd.to_datetime(batch_start) - pd.DateOffset(days=train_days)<br/>        b = pd.to_datetime(batch_start)<br/>        c = pd.to_datetime(batch_start) + pd.DateOffset(days=test_days)</span><span id="0fe7" class="nb lz iq mx b gy ng nd l ne nf">        batch.append([a, b, c])<br/>    <br/>        if  b + pd.DateOffset(days=train_days+test_days) &gt; pd.to_datetime(batch_end):<br/>            break<br/>        else:<br/>            batch_start = b + pd.DateOffset(days=train_days)<br/>            <br/>    return batch</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9cdb" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">聚合策略</strong></h1><p id="26e0" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在这种采样策略中，训练和测试数据集仅在当前迭代中是互斥的。此外，连续迭代的训练数据集包括来自先前迭代的所有训练数据。这种方法的好处是它能够为ML模型训练提供足够的数据量。对于小规模问题，可以采用它来验证ML模型的性能。但是，对于大型数据集，这种方法会导致计算时间更长。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/b5bb18df3c5b601e92819d7e0510b42c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cpjFl_qE7yafZzmcE5BOA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">训练和测试数据集的聚合采样</figcaption></figure><p id="4aad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来提供了用于聚集采样的python代码。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="82ad" class="nb lz iq mx b gy nc nd l ne nf">def aggregate_batch(batch_start='2021-01-01', batch_end='2022-12-31', train_days = 30, test_days = 15, initial_date='2020-01-01' ):<br/>    batch = []<br/>    <br/>    a = pd.to_datetime(initial_date)<br/>    while True:<br/>        b = pd.to_datetime(batch_start)<br/>        c = pd.to_datetime(batch_start) + pd.DateOffset(days=test_days)</span><span id="d683" class="nb lz iq mx b gy ng nd l ne nf">        batch.append([a, b, c])<br/>    <br/>        if  b + pd.DateOffset(days=train_days+test_days) &gt; pd.to_datetime(batch_end):<br/>            break<br/>        else:<br/>            batch_start = b + pd.DateOffset(days=train_days)<br/>            <br/>    return batch</span></pre><p id="fd2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nh">注</em>:模特培训的开始日期是固定的(用a表示)。此后，类似于先前的采样方法，训练数据在每次迭代中增加。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="2e84" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">注意</h1><p id="6587" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">为了更好地理解回溯测试，建议读者下载任何时间序列或类似问题，并执行上述策略。上述代码将提供一个训练和测试集，需要与机器学习模型配对，以训练和生成预测。如果没有业务问题的指导，培训和测试的进展步骤最好超过30天。此外，对于集合采样，机器学习模型的性能可能会提高。然而，对于其他策略来说，这并不是强制性的——简单的和重叠的，其中某些偏差可能是可见的。</p></div></div>    
</body>
</html>