<html>
<head>
<title>Deep-Learning-Based Automatic CAPTCHA Solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于深度学习的自动验证码求解器</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/deep-learning-based-automatic-captcha-solver-12cd49191c58?source=collection_archive---------0-----------------------#2020-09-26">https://pub.towardsai.net/deep-learning-based-automatic-captcha-solver-12cd49191c58?source=collection_archive---------0-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="baaa" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>、<a class="ae ep" href="https://towardsai.net/p/category/cybersecurity" rel="noopener ugc nofollow" target="_blank">网络安全</a>、<a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a></h2><div class=""/><div class=""><h2 id="443f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">处理复杂的10字符验证码(带代码)</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e5d9c392c4d0dd1873a14e51418d7419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dl0F36mQqB_LNtA_dKd3ug.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lh" href="https://unsplash.com/s/photos/cybersecurity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</figcaption></figure><p id="5b39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">免责声明</strong>:以下作品为学术项目创作。该作品未被用于也无意用于任何有害或恶意的目的。尽情享受吧！</p><h1 id="b744" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">介绍</h1><p id="807b" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">CAPTCHAs(区分计算机和人类的完全自动化的公共图灵测试)是几乎每个互联网用户都经历过的事情。在登录或创建帐户、进行在线购买、甚至发表评论的过程中，许多人会遇到看起来奇怪、拉伸、模糊、颜色和形状扭曲的图像，这些图像更像达利的画，而不是英文文本。</p><p id="9075" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在很长一段时间里，10个字符的模糊文本验证码被用于部署，因为当代的计算机视觉方法很难在不均匀的背景下识别字母，而人类在这方面没有问题。直到今天，这仍然是字符识别领域中的一个重要问题。</p><p id="2835" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，为了开发一个能够在这种复杂的光学字符识别任务中读取字符的程序，我们将开发一个针对该问题的定制解决方案。在这篇文章中，我们将从头至尾为一个特定类别的验证码开发一个验证码求解器。</p><h1 id="5e68" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">数据</h1><p id="09e0" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">10，000张验证码图片来自kaggle数据集(由Aadhav Vignesh在<a class="ae lh" href="https://www.kaggle.com/aadhavvignesh/captcha-images" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/aadhavvignesh/captcha-images</a>搜集)。每张图片都有NAME.jpg的名字，名字是谜题的答案。换句话说，该名称包含图像正确序列中的正确字母，例如5OfaXDfpue。</p><p id="e0ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让计算机程序读取图像中的字符是一个巨大的挑战。开源OCR软件，如PyTesseract，在验证码上测试时失败，通常甚至不能从整个图像中提取一个字符。将原始图像作为输入，将解决方案作为输出来训练神经网络，这可能会在数千万的数据集上取得成功，但在10，000幅图像的数据集上不太可能取得成功。必须开发一种新方法。</p><p id="2513" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过一次分析一个字符，而不是一次分析整个图像，这个问题可以大大简化。如果可以获得字母数字及其相应标签的数据集，就可以训练一个简单的类似MNIST的神经网络来识别字符。因此，我们的管道看起来像这样:</p><ol class=""><li id="268c" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated">反转验证码，分割字符，并将每个字母数字字符单独保存到磁盘(带标签)。</li><li id="ae55" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">训练一个神经网络来识别每个类的字符。</li><li id="d9f0" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">要使用我们的模型，输入任何验证码，反转图像，并分割字符。对每个字符应用机器学习模型，获得预测，并将它们连接成一个字符串。瞧。</li></ol></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="1b52" class="me mf it bd mg mh nw mj mk ml nx mn mo ki ny kj mq kl nz km ms ko oa kp mu mv bi translated">预处理</h1><p id="34b7" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于那些在ka ggle(<a class="ae lh" href="https://www.kaggle.com/sergei416" rel="noopener ugc nofollow" target="_blank">https://github.com/sergeiissaev/kaggle_notebooks</a>)上关注我的代码的人来说，下面的部分是指标题为captchas_eda.ipynb的笔记本。我们首先从数据集中加载一个随机图像，然后绘制它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/29e00a467b3313896f9efbeeb116e155.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*vLCKofCXdzzonRh7v-Pwnw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">这是从我们的数据集中随机选择的验证码。</figcaption></figure><p id="27f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，使用OpenCV(Python和C++中非常有用的计算机视觉库)将图像转换为灰度，然后应用二进制阈值。这有助于将复杂的彩色图像转换为更简单的黑白图像。这是非常关键的一步——当文本背景不均匀时，现代OCR技术往往会失败。这个步骤解决了这个问题。然而，我们还没有做好OCR的准备。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6c8776b326e2aa2b62fbb131395c6ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*lcxDVb9iPQ7ut76H6muDcw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">阈值和彩色倒置验证码图像。</figcaption></figure><p id="4ae5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下一步是定位图像的轮廓。我们希望将验证码分成10个独立的图像，每个图像包含一个字母数字，而不是将验证码作为一个整体来处理。因此，我们使用OpenCV的findContours函数来定位字母的轮廓。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bcf0eae3f2bd9f44e9cfc4447d7158f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*UrHQZ0KV1yAdZ7sZM6uyOg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">选中轮廓的图像。请注意图像顶部和底部边缘周围的绿色小点，它们被添加到我们的轮廓列表中。</figcaption></figure><p id="b78a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不幸的是，尽管我们知道每个验证码精确地包含10个字母数字，但大多数图像最终都有超过20个轮廓。那么剩下的轮廓是什么呢？</p><p id="8fb8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">答案是它们大多是方格背景的碎片。根据这些文件，“轮廓可以简单地解释为连接所有连续点(沿着边界)的曲线，具有相同的颜色或强度”。背景中的一些斑点符合这个定义。为了解析轮廓并只保留我们想要的字符，我们必须发挥创造力。</p><p id="b5e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于背景斑点比字母数字小得多，我确定了10个最大的轮廓(同样，每个验证码在图像中正好有10个字母数字)，并丢弃了其余的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e1fc61692fddbde1f9dcc2af8f0313a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*QkwGhaf1e7lEthuPixUOWA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">单独选择的字母数字。选择最大的10个轮廓，以便去除小的背景轮廓。注意字母数字的顺序不正确。</figcaption></figure><p id="a4cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，有一个新的问题。我有10个轮廓按大小排序。当然，在求解验证码时，顺序很重要。我需要从左到右组织轮廓。因此，我对包含与轮廓编号相关联的每个轮廓的右下角的字典进行了排序，这允许我从左到右将轮廓绘制为一个图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/3cef7f82220f584654abf8aba804f14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Z5vfeEcAB4AP8gKxJHs0pw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">字母数字，每个都有自己的图像，而且顺序正确。正确的顺序使我们可以在每个图像上显示标签(真实类),以及白色像素占图像的百分比。</figcaption></figure><p id="966c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我注意到许多输出是无意义的——图像与标签不符。更糟糕的是，由于一个图像与它的标签不对应，它经常会打乱所有下游字母的顺序，这意味着不是一个而是许多字母显示了错误的标签。这对训练神经网络可能是灾难性的，因为错误标记的数据会使学习更容易出错。想象一下，给4岁的孩子看字母，但偶尔会念错那个字母的音——这对孩子来说是一个巨大的挑战。</p><p id="ff78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我实现了两个错误检查。第一个是完全没有意义的轮廓，我注意到它的黑白像素比例与普通字母非常不同。这里有一个例子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e465ea23d77f61827d679babc41ad358.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*F1dB269EJOZt16Cc0dnljg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">第一行中的第三个轮廓是我的第一个错误检查算法将跳过的图像示例。</figcaption></figure><p id="1999" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顶行第三个轮廓其实是前面“O”的内圆。请注意，所有下游的字母现在都被错误地标注了。我们不能让这些错误标记的图像附加到我们的训练数据中。因此，我写了一个规则，说任何黑白比例高于63%或低于29%的字母数字都将被跳过。</p><p id="b1e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是我的第二个错误检查的例子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/1ec1b827f7b94fb92eac773a7659cde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*F-GmL_qsWqKNVNP1oBDNVA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">顶行最右边的图像以及底行中间的图像是错误类型#2的例子。</figcaption></figure><p id="f0ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，单独的字母数字彼此轻微接触，并作为一个字母数字被拾取。这是一个大问题，因为就像错误检查#1一样，所有下游的字母数字都会受到影响。为了解决这个问题，我检查了每个图像是否明显宽于长。大多数字母数字都比较高，或者至少是正方形，很少有比高宽得多的，除非它们包含类型2的错误，这意味着它们包含不止一个字母数字。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/092d95d708491e6f88b971a2f9b051bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*rbei3P9xRR_N8baRoGCs5A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">这和上面的验证码是一样的，只是这次使用了错误检查。</figcaption></figure><p id="bcd7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">似乎错误检查工作很棒！即使是非常困难的验证码图片也能被成功标记。然而，现在出现了一个新的问题:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/db2272a5fb3d6c55f1eb41688ca9c928.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*Lx9Gk59tL7LWjBoSYpJmOQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">错误检查#2获得的误报示例。</figcaption></figure><p id="70ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，顶行中的“w”符合错误检查#2标准——它非常宽，所以程序分割了图像。我花了很长时间尝试不同的超参数设置，其中宽“w”和“m”图像不会被分割，但一个图像中两个字母数字的真实情况会被分割。然而，我发现这是一个不可能完成的任务。一些“w”字母非常宽，而一些包含两个字母数字的图像轮廓可能非常窄。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8782c9cf175ad90d6a4818050a2091da.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*oyb8jls6FCoXRsbNQYb66A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在最下面一行的中间图像中可以看到一个非常窄的错误案例#2。</figcaption></figure><p id="4f54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有秘密的公式来得到我想要做的事情，所以我(可耻地)不得不做一些我并不真正自豪的事情——手动处理事情。</p><h1 id="0a24" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">获取训练数据</h1><p id="079c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于那些关注Kaggle的人来说，这是第二个文件，名为captchas_save.ipynb。我将数据从Kaggle传输到我的本地计算机，建立一个循环，从头到尾进行所有的预处理步骤。在每个循环结束时，评估者被提示对数据和标签进行安全检查(“y”表示保留，“n”表示丢弃)。这通常不是作者喜欢的做事方式，但是在花了足够多的时间尝试自动化这个过程之后，效率天平开始向自动化和人工平衡倾斜。</p><p id="c2b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在观看《社交网络》的过程中，我评估了1000个验证码(因此创建了一个大约有10000个字母数字的数据集)，在我和我的朋友之间切换，我付给他一瓶啤酒的薪水来换取他的帮助。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/b3b1615618bbd72e8af70331c74c3981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUm-Us1N6nUxsV7pX22Oxw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">提示用户确认数据集的示例。</figcaption></figure><p id="1798" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有获得及格分数的文件都被附加到一个列表中。预处理管道遍历列表中的所有文件，将所有字母数字保存到各自的文件夹中，从而创建了训练集。这是最终的目录结构，我在https://www.kaggle.com/sergei416/captchas-segmented上传并发布了一个数据集。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/e404f61529b9f59201f719c4e1432c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epvWzPn4XNqHUt6sNWw-7A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">每一个字母数字都有“上”或“下”的后缀。所有的数字都以“lower”为后缀。</figcaption></figure><p id="8533" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终，我的训练数据集中只剩下62个目录和总共5，854个图像(意味着10，000–5854 = 4146个字母数字被丢弃)。</p><p id="3568" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们开始流水线的机器学习部分！让我们回到Kaggle，在那里我们将根据我们在训练集中收到的分段字母数字训练一个手写数字识别软件。同样，现有的开源OCR库无法处理我们目前获得的图像。</p><h1 id="8846" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">训练模型</h1><p id="326a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">为了构建机器学习系统，我们使用了一个普通的PyTorch神经网络。完整的代码可以在https://www.kaggle.com/sergei416/captcha-ml的Kaggle上找到。为了简洁起见，本文中我将只讨论机器学习代码中有趣/具有挑战性的部分。</p><p id="e79d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于PyTorch的ImageFolder功能，这些数据可以轻松地加载到作者的笔记本中。有62个可能的类别，这意味着预测完全随机标签的基线准确度是1/62，或1.61%的准确度。作者设置了200幅图像的测试和验证大小。所有图像都被调整为128 x 128像素，随后应用了通道标准化。特别是对于训练数据，随机应用RandomCrop、ColorJitter、RandomRotation和RandomHorizontalFlip来扩充训练数据集。这是一批训练数据的可视化:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/bf0f736f1fcb807a7672cd52960d056d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9onlnec6fvyPslfROcY01A.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">一批训练数据。</figcaption></figure><p id="d45b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用了wide_resnet101的迁移学习，使用Kaggle的免费GPU进行训练。使用超参数搜索来识别最佳超参数，这导致99.61%的验证准确性。模型被保存，结果被可视化:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b46cfa81cc15bff1bd532cd766afecee.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*jik523MnByFWESnRoCilDQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">损失与历元数。</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a38abfc99e753c49eb8de812a98669e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*KT9toaxy_Fzks4e1iOUREw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">精度与历元数。</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f0fa66aadef626d62ad9dd782dd6b855.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*8G9BJgwMIUw3TqeWCxfpBQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">学习率调度程序的可视化。</figcaption></figure><p id="d73e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终结果表明验证准确率为99.6%，测试准确率为98.8%。老实说，这超出了我的预期，因为许多二进制的像素化图像甚至连人类都难以正确解读。快速浏览一下上面的一批训练图像，会发现至少有几个有问题的图像。</p><h1 id="f024" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">我们模型的评估</h1><p id="9c9a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这条管道的最后一步是测试我们现成的机器学习模型的准确性。我们以前为我们的分类器导出了模型权重，现在该模型可以应用于任何新的、看不见的验证码(与我们原始数据集中的验证码类型相同)。为了完整起见，作者建立了一个代码来评估模型的准确性。</p><p id="a9b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果在求解验证码时，即使有一个字符不正确，整个验证码都会失败。换句话说，所有10个预测的字母数字必须完全匹配验证码的解决方案才能被认为是已解决的。为从数据集中随机获取的500幅图像设置一个简单的循环，比较解与预测的相等性，并检查预测是否与解相等。代码在第四个(也是最后一个)笔记本里，可以在<a class="ae lh" href="https://www.kaggle.com/sergei416/captchas-test/output" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/sergei416/captchas-test/</a>找到。</p><p id="4bff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种等效性适用于125/500个测试的CAPTCHA图像，即25%的测试集*。虽然这个数字似乎很低，但重要的是要记住，与许多其他机器学习任务不同，如果一个案例失败了，另一个案例会立即可用。我们的程序只需要成功一次，但可能会无限期地失败。由于我们的程序对于任何给定的尝试都有1–0.25 = 0.75的失败概率，那么给定n次尝试，只要我们不使所有n次尝试失败，我们将通过验证码。那么n次尝试内通过的可能性有多大？它是</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2a509598f52f196801a5d27b098d06f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*mlKUbPbovJHuOHx-yoycFQ.png"/></div></figure><p id="9c1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，n次尝试的可能性如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2db7d71364433e868d57c3d0db74f375.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*__S9nkVYkVzHmpR83JC0Bg.png"/></div></figure><p id="5a56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">*编辑:kaggle链接的准确率为0.3，或任何单个验证码的30%(n = 10时为97.1%)。</p><h1 id="eae5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="eaa3" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">总的来说，建立一个能够解决10个字符验证码的机器学习模型的尝试是成功的。最终的模型可以以30%的准确率解决这些难题，这意味着有97.1%的概率可以在前10次尝试中解决验证码图像。</p><p id="35d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢所有坚持到本教程结束的人！这个项目表明，10个字符的验证码不适合区分人类和非人类用户，其他类别的验证码应该在生产中使用。</p><p id="03bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">链接:</p><p id="6555" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">领英:【https://www.linkedin.com/in/sergei-issaev/ T2】</p><p id="599b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">推特:【https://twitter.com/realSergAI T4】</p><p id="7983" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">github:<a class="ae lh" href="https://github.com/sergeiissaev" rel="noopener ugc nofollow" target="_blank">https://github.com/sergeiissaev</a></p><p id="f094" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">https://www.kaggle.com/sergei416</p><p id="f2a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">威风凛凛:<a class="ae lh" href="https://jovian.ml/sergeiissaev/wildlife" rel="noopener ugc nofollow" target="_blank">https://jovian.ml/sergeiissaev/</a></p><p id="ddc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">中:<a class="ae lh" href="https://medium.com/@sergei740" rel="noopener">https://medium.com/@sergei740</a></p></div></div>    
</body>
</html>