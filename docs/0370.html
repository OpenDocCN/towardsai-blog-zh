<html>
<head>
<title>A Beginner’s Guide To Optimizing Julia Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Julia代码的初学者指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-beginners-guide-to-optimizing-julia-code-148e3f2d69bd?source=collection_archive---------0-----------------------#2020-03-22">https://pub.towardsai.net/a-beginners-guide-to-optimizing-julia-code-148e3f2d69bd?source=collection_archive---------0-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="796c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何找到并修复性能瓶颈</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/033037f358f6b9a4265c556a1a4df54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*8GdSlZ1LFLJjJk5pzrWVgQ.png"/></div></div></figure><h1 id="6148" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="3938" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我将分享一些帮助加速Julia代码的技巧。目标是帮助这门语言的新手熟悉常用的工具和技术，他们可以使用这些工具和技术来帮助优化他们的Julia代码。</p><p id="804c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我假设读者能够阅读Julia代码，并且已经安装了<a class="ae mn" href="https://junolab.org/" rel="noopener ugc nofollow" target="_blank"> Juno IDE </a>。可以在这个<a class="ae mn" href="https://github.com/hsm207/optimize_julia_code/blob/master/notebooks/solutions.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>中找到重现本文中呈现的结果的代码。</p><h1 id="c948" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">动机</h1><p id="dce7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本文是上一篇文章[1]的后续，在上一篇文章中，我提出了以下问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f48de56025416b4833a7795bb8cfbf5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Y0Gn5v6Fc07_q3EX6jvMDQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图1:问题陈述</figcaption></figure><p id="1ff8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我介绍了两个基于Julia的解决方案。第一个版本可以在14秒内处理600万行数据帧，而第二个版本只需要218毫秒。</p><p id="d5d4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">本文将解释我优化代码的步骤，以及我在这一过程中得到的中间结果。</p><h1 id="7b3f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">解决方法</h1><h2 id="d6f4" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">解决方案1:天真的解决方案</h2><p id="7c19" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是解决方案的第一次尝试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ba2bf1f970ce8770b56741cee07b3b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*ioWSk0eqk7ULg6kS18G92A.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图2:第一次尝试解决方案</figcaption></figure><p id="607f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们创建一个名为<code class="fe ng nh ni nj b">results</code>的变量，在迭代数据帧以更新其中的值之前，存储第1列和第2列之间所有可能的值对的计数(第5行)。这需要11秒。</p><p id="3561" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">关于图2中的代码，需要注意的重要一点是:</p><ul class=""><li id="1342" class="nk nl it lo b lp mi ls mj lv nm lz nn md no mh np nq nr ns bi translated">我们可以使用<a class="ae mn" href="https://github.com/JuliaCI/BenchmarkTools.jl" rel="noopener ugc nofollow" target="_blank">基准工具</a>包中的<code class="fe ng nh ni nj b">@btime</code>宏进行时间编码。</li><li id="3fa9" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh np nq nr ns bi translated">我们在<code class="fe ng nh ni nj b">df</code>前面放了一个<code class="fe ng nh ni nj b">$</code>，因为我们不想让这个表达式的求值成为我们想要计时的代码的一部分。</li></ul><p id="b07c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们能做些什么来改善执行时间？最简单的方法是参考Julia手册中的<a class="ae mn" href="https://docs.julialang.org/en/v1/manual/performance-tips/" rel="noopener ugc nofollow" target="_blank">性能提示</a>页。本页列出了许多让Julia代码尽可能快地运行的技术。</p><h2 id="7c90" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">解决方案2:使用性能提示</h2><p id="aa1d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">以下提示似乎与我们的代码相关:<a class="ae mn" href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables-1" rel="noopener ugc nofollow" target="_blank">避免全局变量</a>和<a class="ae mn" href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs-1" rel="noopener ugc nofollow" target="_blank">预分配输出</a>。让我们尝试一下，看看它们对我们的代码有什么影响。</p><p id="7f9c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">避免全局变量</strong></p><p id="7faa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">从我们正在计时的代码的角度来看,<code class="fe ng nh ni nj b">results</code>变量是一个全局变量。为了解决这个问题，我们可以将与我们的逻辑相关的所有机制封装到一个函数中，该函数只将数据帧作为一个参数。</p><p id="32b0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这给出了以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bcf8eaa49f55c43f1b2bd51dd59a6784.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*wxsklj37X3sywqSNC6xBLg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图3:避免全局变量</figcaption></figure><p id="ebdc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">几乎没有什么不同，但至少代码组织得更好了。让我们试试下一个技巧。</p><p id="0464" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">预分配输出</strong></p><p id="aad4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这种情况下，我们知道第1列和第2列中的值分别只在“A”到“Z”和“A”到“Z”之间。因此，我们可以在<code class="fe ng nh ni nj b">results</code>中创建键，并将其初始化为0，而不是动态创建。</p><p id="7d43" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9bd4224c27de2f36d7e05901f6f4ed43.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*dMANMo4svuZiRySpBC2bew.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图4:预分配输出</figcaption></figure><p id="9d27" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">预分配在图4中的第4行到第7行完成。不幸的是，这并没有带来任何显著的改进。</p><p id="4d93" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">看来我们别无选择只能拿出一个侧写器潜入Julia的内部。</p><h2 id="92c9" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">解决方案3:使用分析器</h2><p id="fbad" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Juno IDE附带了一个<a class="ae mn" href="http://docs.junolab.org/stable/man/juno_frontend/index.html#Profiler-1" rel="noopener ugc nofollow" target="_blank">分析器</a>，这使得分析Julia代码变得非常容易。你所需要做的就是在你想要分析的代码段上调用<code class="fe ng nh ni nj b">Juno.@profiler</code>，Juno会为你生成一个交互式火焰图来分析。</p><p id="1191" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如，在朱诺的朱莉娅·REPL内部运行以下脚本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f15c6217e66768f5033c14d9f911ba13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F9xt81kB7f9Au5s9.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图5:演示Juno中代码剖析的示例脚本</figcaption></figure><p id="93f5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/abe5a4ea863a0d709026959ebaa8fdff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*RhyWLtuJzz7AKHtL.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图6:执行图5中代码的输出</figcaption></figure><p id="d3ec" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我鼓励读者阅读Julia手册中的<a class="ae mn" href="https://docs.julialang.org/en/v1/manual/profile/" rel="noopener ugc nofollow" target="_blank">剖析</a>部分，以理解图6中的图表是如何构建的。</p><p id="95bf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">出于本文的目的，关于图6，您需要知道的只是:</p><ul class=""><li id="29b1" class="nk nl it lo b lp mi ls mj lv nm lz nn md no mh np nq nr ns bi translated">每个矩形代表一行代码</li><li id="9581" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh np nq nr ns bi translated">将鼠标悬停在矩形上，将在Profiler窗格的顶部显示代码的详细信息，如注释所示</li><li id="a73d" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh np nq nr ns bi translated">点击矩形可以跳转到相应的代码</li><li id="83ce" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh np nq nr ns bi translated">每个矩形的大小与您正在分析的函数所花费的时间成比例</li></ul><p id="769b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">图6显示了<code class="fe ng nh ni nj b">f</code>中执行时间最长的部分。这是<code class="fe ng nh ni nj b">scratch.jl</code>脚本中的第21行，对应于第<code class="fe ng nh ni nj b"><strong class="lo iu">for</strong> (c1, c2, c3) <strong class="lo iu">in</strong> eachrow(data)</code>行。注意，该矩形之前的矩形，即其上方的矩形与<code class="fe ng nh ni nj b">f</code>无关，因此可以忽略。</p><p id="b16c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">图6中的结果表明，迭代数据帧的行代价很高。所以让我们试着不使用数据帧重写<code class="fe ng nh ni nj b">f</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/047cbdc7e95e7c381677ad57d69aed10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*0H_nTBzm1Q_5SVKYioezqg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图7:无数据框解决方案</figcaption></figure><p id="e27a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">执行时间从大约11秒下降到仅仅188毫秒！</p><p id="49e2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们能做得更好吗？好了，我们来看看这个版本<code class="fe ng nh ni nj b">f</code>的火焰图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0dd36eb2fbac204e3f194e40daee4c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bXo4DTrLXwuFTeA6.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图8:无数据帧解决方案的火焰图</figcaption></figure><p id="e4d6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意，与图6相比，对应于第21行的矩形的大小并不明显。执行时间最长的一行现在是第23行，它涉及更新存储在<code class="fe ng nh ni nj b">results </code>即<code class="fe ng nh ni nj b">results[key] <strong class="lo iu">=</strong> results[key] <strong class="lo iu">+</strong> val</code>中的值。</p><p id="4c01" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">本节已经展示了使用更简单的数据结构，例如从数据帧切换到元组的迭代器，可以显著提高速度。所以让我们试着把<code class="fe ng nh ni nj b">results </code>的类型从<code class="fe ng nh ni nj b">Accumulator</code>型换成更简单的。</p><p id="a0c7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还有什么比一维数组更简单的呢？</p><h2 id="67fc" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">解决方案4:更简单的数据结构</h2><p id="0a7e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe ng nh ni nj b">Accumulator </code>类型的好处是它允许我们使用来自列1和列2的一对值作为键来存储它的计数。我们失去了数组的灵活性，因为数组的索引必须是整数。</p><p id="6181" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">克服这种限制的一种方法是将一对值编码为16位序列:第一个字节是第1列的值，而第二个字节是第2列的值。这是可行的，因为任何字母都可以表示为8位序列。</p><p id="3d73" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如，为了对“A”和“b”对的值进行编码，我们注意到“A”的8位值是0x41，而“b”的值是0x62。请注意，0x前缀表示十六进制形式的数字。</p><p id="d0b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因此，对应于对“A”和“b”的索引将是0x4162。下面是实现这种编码方案的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/51ee17c1826e0af52660d5857c344d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*lBHVt5s75QaF31QEVRlYmw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图9:将一对字符转换成整数的函数</figcaption></figure><p id="3212" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是如何在<code class="fe ng nh ni nj b">f</code>中使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/4d7e158e0653c16b87878d79d8c6441b.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*iPJTwWEKdz15LCRvr2dTgg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图10:使用数组代替累加器跟踪计数</figcaption></figure><p id="e7d7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">既然要最大化速度，那就撒点<a class="ae mn" href="https://docs.julialang.org/en/v1/manual/performance-tips/index.html#man-performance-annotations-1" rel="noopener ugc nofollow" target="_blank">性能注解</a>吧。特别是，我们将在第6行使用<code class="fe ng nh ni nj b">@inbounds</code>宏告诉Julia跳过数组边界检查:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/06c7a6433ec6745661e5cae7acb30071.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*iMqXVhRcqhMZFijLk5e_Eg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图11:与图10相同，但是去掉了数组边界检查</figcaption></figure><p id="d211" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这给出了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/fbd3ce8b6fde6d923a02e201730b633d.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*_ECj2jxz3LPJ1mlt-qfUtA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图12:图11的时序</figcaption></figure><p id="17e7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">没有<code class="fe ng nh ni nj b">@inbounds</code>宏，时间是37.476 ms。</p><p id="d078" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">再来一轮优化。</p><p id="9323" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是最新版<code class="fe ng nh ni nj b">f</code>的火焰图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/c19d09eb01f2882f656c5e2ab5adb31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B_8G07P12BCkeOPO.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图13:图11中f的火焰图</figcaption></figure><p id="e606" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">图13中的结论与图8中的结论相同:更新<code class="fe ng nh ni nj b">results</code>中的值的行相对于<code class="fe ng nh ni nj b">f</code>中的其他行花费的时间最多。</p><p id="6edc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于<code class="fe ng nh ni nj b">results</code>是一个数组，所以像<code class="fe ng nh ni nj b">results[key] = results[key] + val</code>这样的一行应该只涉及调用<code class="fe ng nh ni nj b">getindex</code>、<code class="fe ng nh ni nj b">setindex!</code>和<code class="fe ng nh ni nj b">+</code>函数。然而，图13显示在调用<code class="fe ng nh ni nj b">getindex</code>之前，对<code class="fe ng nh ni nj b">iterators.jl</code>脚本中的一些函数有一些调用。这似乎没有必要。</p><h2 id="f685" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">解决方案5:没有迭代器</h2><p id="136f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe ng nh ni nj b">f</code>中唯一的迭代器是<code class="fe ng nh ni nj b">data</code>。让我们把它转换成一个数组，看看会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/bc742ec7ec77d6949ce9fe3e0742f869.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*2Nezi5s85mvSQFUNY3Lk8g.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图14:无迭代器解决方案</figcaption></figure><p id="08c5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个解决方案比前一个解决方案快了大约7 ms。</p><p id="125b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是它的火焰图的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d9a3a156d2bc2dbbb6f920bf4de07a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-fxS3ZkXegeDeNzQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图15:无迭代器解决方案的火焰图</figcaption></figure><p id="9ff7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意，对<code class="fe ng nh ni nj b">getindex </code>的调用紧接在更新结果行之后(图14中的第6行)。</p><h1 id="3818" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">其他方法</h1><p id="1b62" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">上一节中的解决方案是基于对分析器的输出进行分析，以识别瓶颈并设计出绕过瓶颈的方法。本节将介绍另外两种优化代码的方法。</p><h2 id="1294" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">重新表述这个问题</h2><p id="7d0c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">后退一步，从不同的角度思考这个问题会有所帮助。这可能会产生更有效的解决问题的方法。</p><p id="870e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这种情况下，问题可以用group by和aggregate运算来表示。这可以在Julia中用一句台词来实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/93881b04ac14195cbbcb5421ff3ae09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*A1sJCdqRD5wEvGIDbYNCBg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图16:数据框解决方案</figcaption></figure><p id="a368" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这比前一节中的最佳解决方案慢10倍，但在速度和清晰度方面肯定比简单的解决方案好得多。</p><h2 id="3671" class="mt kv it bd kw mu mv dn la mw mx dp le lv my mz lg lz na nb li md nc nd lk ne bi translated">并行解决方案</h2><p id="a12a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如今，大多数现代计算机都配备了多个CPUs内核，因此跳过分析/思考方法，直接重写代码来利用多余的资源是很有诱惑力的。</p><p id="3236" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Julia(从版本1.3.0开始)提供了便利的工具，使得使用多线程并行化代码变得非常容易。这被称为任务并行性，你可以参考[2]了解更多细节。</p><p id="d817" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里尝试用它来解决我们的问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/9bd537ab1102b631dddf794b030cde34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZAxC5WYavbg84SdIZSngYQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图17:使用任务并行的解决方案</figcaption></figure><p id="cf0f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">图17中的代码将<code class="fe ng nh ni nj b">df</code>分割成<code class="fe ng nh ni nj b">n</code>块。每个数据块将被传递给一个单独的线程进行并行计数，每个线程的结果将被顺序合并。</p><p id="0ddb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">将数据帧分割成4个或2个数据块的结果比完全不分割稍差。这表明每个线程中完成的工作并不复杂，不足以抵消管理线程的开销。</p><p id="d0d5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">随附笔记本中的附录部分显示了一个示例，在该示例中，这种方法可以实现线性加速。</p><h1 id="3215" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="67a9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本文介绍了几种重写Julia代码以使其运行更快的方法，即:</p><ol class=""><li id="8f7a" class="nk nl it lo b lp mi ls mj lv nm lz nn md no mh om nq nr ns bi translated">阅读Julia手册的性能提示部分</li><li id="a515" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh om nq nr ns bi translated">使用分析器来识别瓶颈</li><li id="f16c" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh om nq nr ns bi translated">重新思考你解决问题的方法</li><li id="a86f" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh om nq nr ns bi translated">并行化您的代码</li></ol><p id="ad24" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">显然，编写快速代码需要在速度、便利性和可读性之间进行权衡。例如，解决方案5非常快，但是与将结果存储在字典中相比，编写代码来查找结果很麻烦。</p><p id="d837" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我希望你已经发现这是有用的。</p><h1 id="a2d6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">承认</h1><p id="8c5b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我要感谢来自<a class="ae mn" href="https://slackinvite.julialang.org/" rel="noopener ugc nofollow" target="_blank"> Julia slack频道</a>的以下人员，他们帮助我诊断了这个幼稚解决方案的问题:</p><ul class=""><li id="6ea0" class="nk nl it lo b lp mi ls mj lv nm lz nn md no mh np nq nr ns bi translated">安德烈·奥斯金</li><li id="1d95" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh np nq nr ns bi translated">安德烈斯·里德曼</li><li id="daf4" class="nk nl it lo b lp nt ls nu lv nv lz nw md nx mh np nq nr ns bi translated">弗雷德里克·埃克雷</li></ul><p id="7725" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">特别感谢Andrey Oskin分享了快速编写Julia代码的所有惊人且有时疯狂的方法。</p><h1 id="0dd5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><p id="0cf2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">[1]<a class="ae mn" href="https://medium.com/towards-artificial-intelligence/how-practical-is-python-for-prototyping-data-science-projects-at-scale-88d345fa849d" rel="noopener">Python对于大规模数据科学项目的原型开发有多实用？</a><em class="on">。2020年</em></p><p id="4cb3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">[2] <a class="ae mn" href="https://julialang.org/blog/2019/07/multithreading/" rel="noopener ugc nofollow" target="_blank">在Julia </a>中宣布可组合多线程并行。贝赞森，纳什和帕姆纳尼。2019</p></div></div>    
</body>
</html>