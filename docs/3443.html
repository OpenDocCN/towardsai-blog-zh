<html>
<head>
<title>Git Rebase, Merge, Stash, Revert and Reset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git重置、合并、隐藏、还原和重置</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/git-rebase-merge-and-stash-763fcf3ec060?source=collection_archive---------0-----------------------#2022-12-24">https://pub.towardsai.net/git-rebase-merge-and-stash-763fcf3ec060?source=collection_archive---------0-----------------------#2022-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="e7ee" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">Git rebase是Git中的一个高级特性，当我们处理多个分支时，它可以帮助我们。重设基础稍微高级一点，但是在你需要的时候非常有用。当您执行基础变更时，您正在变更分支的基础。本质上，rebase将查看您的分支上的每个提交，并更新代码，使其看起来好像您一直在新的基础上工作。虽然它们有相似的用途，但是rebase与merge的不同之处在于rebase通过调整每个提交来更新您的分支，而merge通过在您的分支顶端创建一个新的提交来更新您的分支。</p></blockquote><p id="8cc1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这是关于Git系列文章的第三篇——<br/>完整的Git初学者教程，带示例。下面有链接—</p><div class="ks kt gp gr ku kv"><a href="https://muttinenisairohith.medium.com/complete-git-tutorial-for-beginners-with-examples-4ebd90e76bfc" rel="noopener follow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">完整的Git初学者教程，带示例</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">Git是一个版本控制系统，它可以让我们跟踪随着时间的推移我们对文件所做的更改。</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">muttinenisairohith.medium.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj lk kv"/></div></div></a></div><p id="4e7e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">第二篇文章是关于Git分支……以及Git pull vs fetch… <br/>下面的链接—</p><div class="ks kt gp gr ku kv"><a href="https://muttinenisairohith.medium.com/all-about-git-branches-and-git-pull-vs-fetch-5b961c13ead" rel="noopener follow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">关于Git分支的所有内容...Git pull vs fetch</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">使用Git中的分支，我们可以创建我们想要处理的文件的副本，而不会弄乱原始文件…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">muttinenisairohith.medium.com</p></div></div><div class="le l"><div class="ll l lg lh li le lj lk kv"/></div></div></a></div><p id="fe62" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">所以回到理解Git Rebase，让我们从头开始，用Git开发新代码。让我们创建branch1并向其中添加一些新代码。</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="4efe" class="lv lw iq lr b be lx ly l lz ma">git checkout -b branch1</span></pre><p id="d80d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这里我们在代码中添加了add函数-</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="b717" class="lv lw iq lr b be lx ly l lz ma">def add(a,b):<br/>    return a+b<br/> <br/>a,b = 5,6<br/>print(add(a,b))</span></pre><p id="2355" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在让我们将代码推送到我们的分支1</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="ba8f" class="lv lw iq lr b be lx ly l lz ma">git add .<br/>git commit -m “adding calculator1 code”<br/>git push origin branch1</span></pre><p id="09e9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在让我们假设另一个开发人员(developer2)正在处理这段代码，他基于branch1创建branch2，并在您在branch1中实现更多功能的同时更改特性</p><p id="daaf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">假设developer2通过添加input()函数和向branch2中的add函数添加offset +5，向代码添加了两次提交</p><p id="0f5e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">同时，您在branch1中添加了两个commits sub()函数和mul()函数</p><p id="c429" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在branch1中提交两次之后，代码看起来像这样—</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="3834" class="lv lw iq lr b be lx ly l lz ma">def add(a,b):<br/>    return a+b<br/> <br/>def sub(a,b):<br/>    return a-b<br/> <br/>def mul(a,b):<br/>    return a*b<br/> <br/>a,b = 5,6<br/>print(add(a,b))<br/>print(sub(a,b))<br/>print(mul(a,b))</span></pre><p id="5c43" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在Branch2中提交两次之后，代码看起来像这样—</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="dce0" class="lv lw iq lr b be lx ly l lz ma">def add(a,b):<br/>    return a+b+10<br/> <br/>a = int(input())<br/>b = int(input())<br/>print(add(a,b))</span></pre><p id="2dc4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们的回购分支流程看起来像这样-</p><figure class="lm ln lo lp gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mb"><img src="../Images/8600b7533e1bce545c49f18b8a987db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8wCvqro9PhENv9-_"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">支流</figcaption></figure><p id="2303" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在让我们假设developer2想要将他的分支branch2与branch1合并，这样他就可以与现有的项目保持同步，那么在这种情况下，使用merge函数将要求我们隐藏我们的更改，因为从branch1中提取代码将覆盖我们的更改。因此，我们可以简单地使用rebase并合并分支，而不是使用stashing、pull和merge。</p><p id="55ab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">语法:</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="4ca5" class="lv lw iq lr b be lx ly l lz ma">git rebase branch1</span></pre><p id="4f51" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">从本地branch2执行上述命令后，如果存在合并冲突，请手动接受更改，一旦更改完成</p><p id="dfe3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">添加代码并提交代码。</p><p id="765e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">一旦你觉得重设基础完成了，我们可以发出下面的命令来完成重设基础-</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="3523" class="lv lw iq lr b be lx ly l lz ma">git rebase --continue</span></pre><p id="31be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">如果没有现有的合并冲突，那么rebase将被完成，然后我们可以推送代码。</p><p id="6587" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">现在我们的分支2流看起来像这样-</p><figure class="lm ln lo lp gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mm"><img src="../Images/a4efd40ec71767e79af1b4c6c9be992f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sZEwn2rv-uAsAxOk"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">支流</figcaption></figure><p id="1382" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这就是git rebase的用处。</p><p id="b124" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> Git藏匿点</strong></p><p id="f52c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">假设developer2在Branch2中做了一些更改，他知道代码是由developer1在Branch1中更改的，Developer2有一个想法，他可以在Branch1中添加一些小代码块，然后将代码从Branch1拉到Branch2，然后提交他的代码，以避免合并冲突。</p><p id="679a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在这种情况下，如果您试图将Branch2中未提交的更改签出到Branch1，Git将不允许我们这样做</p><p id="07f1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在这种情况下，Git stash会帮助我们-</p><p id="4990" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Stashing允许您保存当前未被Stashing的更改，并将您的分支带回到未被修改的状态。当你存储时，你的改变被压入堆栈。如果您需要快速切换到另一个分支，而不必提交未完成的更改，这将非常有用。</p><p id="8e18" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以使用命令将代码保存在Branch2中</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="fdd3" class="lv lw iq lr b be lx ly l lz ma">git stash</span></pre><figure class="lm ln lo lp gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mn"><img src="../Images/1924c9ca46fe0077d41e950b93a72933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iCWKxVuf0KHB7Phf"/></div></div></figure><p id="0754" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">之后，我们的工作在branch1中完成。我们可以签出到branch2，并使用stash来应用命令以取回我们的更改。</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="0824" class="lv lw iq lr b be lx ly l lz ma">git stash apply</span></pre><p id="9d68" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">稍后，我们可以使用添加、提交和推送命令来推送我们的更改。</p><p id="a5d3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> Git stash应用与Git stash弹出</strong></p><p id="6eac" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Git stash pop将在应用更改后从堆栈中移除更改。</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="1b18" class="lv lw iq lr b be lx ly l lz ma">Git stash pop = Git stash apply + Git stash drop</span></pre><p id="4a23" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> Git恢复与Git重置</strong></p><p id="c08b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Git重置:</p><p id="2517" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">当我们想要卸载一个文件并把我们的更改带回工作目录时，就使用Git reset。它还可以用于从本地存储库中删除提交。</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="b19c" class="lv lw iq lr b be lx ly l lz ma">git reset --soft branch2~1</span></pre><figure class="lm ln lo lp gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mo"><img src="../Images/fcd766c28f1434e69d5175caf0fa48fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y6aJ5wIb6GelInG_"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">输出</figcaption></figure><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="b0f7" class="lv lw iq lr b be lx ly l lz ma">git reset –soft HEAD~1</span></pre><p id="aefd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">此命令将删除提交，但不会卸载文件。我们的更改仍然在准备区。</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="8d3a" class="lv lw iq lr b be lx ly l lz ma">git reset –mixed HEAD~1 or git reset HEAD~1</span></pre><p id="8a7d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这是我们将使用的默认命令，该命令删除提交并取消文件的存放，我们的更改存储在工作目录中。</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="d026" class="lv lw iq lr b be lx ly l lz ma">git reset –hard HEAD~1</span></pre><p id="9097" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">该命令从您的工作目录中删除提交和更改。这个命令也可以称为破坏性命令，因为我们将无法恢复更改，所以使用这个命令时要小心。</p><p id="4539" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">注意:Git重置只有在远程存储库中没有推送提交时才起作用。</p><p id="5205" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir"> Git回复:</strong></p><p id="79f9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">类似于git reset，但是唯一的区别是当我们想要从远程存储库恢复提交时，可以使用Git revert，而Git reset只适用于本地存储库。</p><p id="de18" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Git revert将创建一个新的提交，它与给定提交中的所有内容相反。</p><p id="f73f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以通过使用head别名来恢复最新提交，如下所示:</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="e23b" class="lv lw iq lr b be lx ly l lz ma">git revert HEAD</span></pre><p id="6a3f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">与git reset不同，我们可以回滚最近n次本地提交，我们可以使用commit-id并使用git revert命令从远程存储库中恢复任何提交</p><pre class="lm ln lo lp gt lq lr ls bn lt lu bi"><span id="83f7" class="lv lw iq lr b be lx ly l lz ma">git revert HEAD commit-id-here</span></pre><p id="f504" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我希望在这个关于Git的系列文章中，我们已经涵盖了关于Git的所有主题。</p><p id="aa2b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">你可以在这里  <strong class="jt ir">找到参考Git cheatsheet <a class="ae mp" href="https://www.freecodecamp.org/news/git-cheat-sheet/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">。</strong></a></strong></p><p id="46a5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">希望这有帮助。</p><p id="65ca" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">快乐学习…</p></div></div>    
</body>
</html>