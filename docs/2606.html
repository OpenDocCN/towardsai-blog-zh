<html>
<head>
<title>Original Research to Predict Prime Numbers — Error Convergence Using Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测素数的原始研究——使用数据科学的误差收敛</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/predict-prime-numbers-error-convergence-using-data-science-da9360d2d4eb?source=collection_archive---------2-----------------------#2022-03-12">https://pub.towardsai.net/predict-prime-numbers-error-convergence-using-data-science-da9360d2d4eb?source=collection_archive---------2-----------------------#2022-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python解锁素数模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d567893f2a08a654e808f9d801be071e.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*2ckmS1glB1T1rrkUyrCRlw.png"/></div></figure><h2 id="9148" class="kq kr it bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">目录</h2><p id="df69" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kz lv lw lx ld ly lz ma lh mb mc md me im bi translated">I到103之间的素数样本(不包括)</p><p id="4592" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">二。模块化索引赔率和事件，以创建一个等式</p><p id="8c77" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">三。逐步增加到0到50023之间的素数(不包括)</p><p id="0f3a" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">四。0到12000000之间素数的误差消失法</p><p id="9fcf" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">不及物动词使用n素数的Python测试</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="be83" class="kq kr it bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">一.样本</h2><p id="4c57" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kz lv lw lx ld ly lz ma lh mb mc md me im bi translated">打开Python并输入以下代码。这个代码会给你从0到103的素数，不包括在内。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="9f0c" class="kq kr it ms b gy mw mx l my mz">import sympy<br/>c=list(sympy.sieve.primerange(0, 103))</span></pre><p id="2c08" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">这是质数。这些将在变量c下保存的列表中。</p><p id="a448" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi">2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101</p><h2 id="ef15" class="kq kr it bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">二。索引赔率和事件以创建一个等式</h2><p id="ca32" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kz lv lw lx ld ly lz ma lh mb mc md me im bi translated">为了索引素数，让我们首先创建一个数据帧并存储素数。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4a7b" class="kq kr it ms b gy mw mx l my mz">import pandas as pd</span><span id="7ad7" class="kq kr it ms b gy na mx l my mz">df = pd.DataFrame(c)</span></pre><p id="f572" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在我们必须创建一个索引:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="2835" class="kq kr it ms b gy mw mx l my mz">import numpy as np<br/>df['row_num'] = np.arange(len(df))+1</span></pre><p id="d096" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在让我们使用mod创建一个列来检测索引是奇数还是偶数。这种情况下的索引列称为<strong class="lo iu"> row_num </strong>。<strong class="lo iu"> <em class="nb">如果我们将这一列除以2，余数为0，则表示该指数为偶数，否则为奇数。</em> </strong></p><blockquote class="nc nd ne"><p id="6701" class="lm ln nb lo b lp mf ju lr ls mg jx lu nf mh lw lx ng mi lz ma nh mj mc md me im bi translated">如果我们将这一列除以2，余数为0，这意味着索引为偶数，否则为奇数。T9】</p></blockquote><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="7388" class="kq kr it ms b gy mw mx l my mz">df = df.assign(ODDEVEN = lambda x: (x['row_num']%2!=0))</span></pre><p id="6c6d" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">接下来，我想把这个数据框分成两部分。我将把我的第一列重命名为ODD_Index_Primes，然后分割数据帧，因为我将首先分离出奇数索引素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="b827" class="kq kr it ms b gy mw mx l my mz">df=df.rename(columns={df.columns[0]: 'ODD_INDEX_PRIMES'})</span></pre><p id="863b" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，我将创建一个新的数据帧，第一列将是奇数索引的素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="f8a6" class="kq kr it ms b gy mw mx l my mz">#ODD Index Primes<br/>df1 = df.query('ODDEVEN==True')</span><span id="346d" class="kq kr it ms b gy na mx l my mz">df1=df1['ODD_INDEX_PRIMES']</span><span id="c811" class="kq kr it ms b gy na mx l my mz">df1=pd.DataFrame(df1)<br/>df1=df1.reset_index(drop=True)</span></pre><p id="283f" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，我将创建另一个新的数据帧，第一列将是具有偶数索引的素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="fdfe" class="kq kr it ms b gy mw mx l my mz">df2 = df.query('ODDEVEN==False')<br/>df2=df2.rename(columns={df.columns[0]: 'EVEN_INDEX_PRIMES'})<br/>df2=df2['EVEN_INDEX_PRIMES']<br/>df2=pd.DataFrame(df2)<br/>df2=df2.reset_index(drop=True)</span></pre><p id="2d51" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，我将把数据框放在一起:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4834" class="kq kr it ms b gy mw mx l my mz">df3=pd.concat([df1, df2], axis=1)<br/>df3=df3.apply(pd.to_numeric, errors='coerce')</span></pre><p id="bbf0" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，我想将第一列视为x，将第二列视为y，并创建一条最佳拟合线。请从这里了解更多关于最佳拟合线的代码:</p><p id="e6f2" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated"><a class="ae ni" href="https://www.statology.org/line-of-best-fit-python/#:~:text=You%20can%20use%20the%20following%20basic%20syntax%20to,Plot%20Basic%20Line%20of%20Best%20Fit%20in%20Python" rel="noopener ugc nofollow" target="_blank">如何用Python绘制最佳拟合线(附实例)—统计学</a></p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="aeae" class="kq kr it ms b gy mw mx l my mz">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="ca58" class="kq kr it ms b gy na mx l my mz">#define data<br/>x = np.array(df3['ODD_INDEX_PRIMES'])<br/>y = np.array(df3['EVEN_INDEX_PRIMES'])</span><span id="18aa" class="kq kr it ms b gy na mx l my mz">#find line of best fit<br/>a, b = np.polyfit(x, y, 1)</span><span id="f92a" class="kq kr it ms b gy na mx l my mz">#add points to plot<br/>plt.scatter(x, y, color='purple')</span><span id="b97b" class="kq kr it ms b gy na mx l my mz">#add line of best fit to plot<br/>plt.plot(x, a*x+b, color='steelblue', linestyle='--', linewidth=2)</span><span id="a647" class="kq kr it ms b gy na mx l my mz">#add fitted regression equation to plot<br/>plt.text(1, 17, 'y = ' + '{:.2f}'.format(b) + ' + {:.2f}'.format(a) + 'x', size=14)</span></pre><p id="3186" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">运行代码后，您将得到一条最佳拟合线。你可以检查你的图，你会发现这个图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6bbbe90121a1303342e2c1604c67f0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*49hE-MUT5qzoArVuA6AsaA.png"/></div></figure><p id="d59d" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">如你所见，最适合0到100之间的质数的等式是</p><p id="9ea1" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">y = 2.41 + 1.03x，<strong class="lo iu">其中x是奇数索引的素数，y是偶数索引的素数。</strong></p><blockquote class="nc nd ne"><p id="67b7" class="lm ln nb lo b lp mf ju lr ls mg jx lu nf mh lw lx ng mi lz ma nh mj mc md me im bi translated">如你所见，最适合0到100之间的质数的等式是</p><p id="c40b" class="lm ln nb lo b lp mf ju lr ls mg jx lu nf mh lw lx ng mi lz ma nh mj mc md me im bi translated">y = 2.41 + 1.03x，<strong class="lo iu">其中x是奇数索引的素数，y是偶数索引的素数。</strong></p></blockquote></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="e661" class="kq kr it bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">三。逐步增加到0到50k之间的质数</h2><p id="2d34" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kz lv lw lx ld ly lz ma lh mb mc md me im bi translated">是时候对0到50，000之间的质数使用这个等式了。</p><p id="60d9" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">首先，让我们得到素数，并使用模索引得到奇数和偶数索引:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="ba39" class="kq kr it ms b gy mw mx l my mz">#Test<br/>d=list(sympy.sieve.primerange(0, 50023)) <br/>df_test = pd.DataFrame(d)<br/>df_test['row_num'] = np.arange(len(df_test))+1</span><span id="d3d7" class="kq kr it ms b gy na mx l my mz">df_test = df_test.assign(ODDEVEN = lambda x: (x['row_num']%2!=0))</span></pre><p id="70c0" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">让我们将该列重命名为ODD_INDEX_PRIMES，因为我们将首先分离出这些素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="8a31" class="kq kr it ms b gy mw mx l my mz">df_test=df_test.rename(columns={df_test.columns[0]: 'ODD_INDEX_PRIMES'})</span></pre><p id="db96" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">制作一个新的数据帧并存储奇数索引素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4c46" class="kq kr it ms b gy mw mx l my mz">#ODD Index Primes<br/>df_test_1 = df_test.query('ODDEVEN==True')</span><span id="00af" class="kq kr it ms b gy na mx l my mz">df_test_1=df_test_1['ODD_INDEX_PRIMES']</span><span id="36bb" class="kq kr it ms b gy na mx l my mz">df_test_1=pd.DataFrame(df_test_1)<br/>df_test_1=df_test_1.reset_index(drop=True)</span></pre><p id="c175" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在制作另一个新的数据帧并存储偶数索引素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="8d50" class="kq kr it ms b gy mw mx l my mz">df2_test = df_test.query('ODDEVEN==False')<br/>df2_test=df2_test.rename(columns={df2_test.columns[0]: 'EVEN_INDEX_PRIMES'})<br/>df2_test=df2_test['EVEN_INDEX_PRIMES']<br/>df2_test=pd.DataFrame(df2_test)<br/>df2_test=df2_test.reset_index(drop=True)</span></pre><p id="6fc7" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">将数据帧放在一起，这样我们就有两列，第一列是奇数索引素数，第二列是偶数索引素数:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="e0df" class="kq kr it ms b gy mw mx l my mz">df3_test=pd.concat([df_test_1, df2_test], axis=1)<br/>df3_test=df3_test.apply(pd.to_numeric, errors='coerce')</span></pre><p id="32c2" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在让我们创建一个预测列，看看我们是否能接近:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4107" class="kq kr it ms b gy mw mx l my mz">df3_test['predicted']=df3_test['ODD_INDEX_PRIMES'].apply(lambda x: 2.41+(x*1.03))</span></pre><p id="fbe2" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，让我们创建一个差异%列来检测错误百分比:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4df0" class="kq kr it ms b gy mw mx l my mz">df3_test['difference%']=(df3_test.EVEN_INDEX_PRIMES - df3_test.predicted) / df3_test.predicted * 100</span></pre><p id="eeb2" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">请记住，误差百分比需要是预测的百分比，而不是实际的百分比。我们将使用误差百分比来改变我们的预测。</p><p id="82a1" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，让我们看看错误。为此，我们可以通过对数据帧进行行索引来创建快速错误图，并查看错误率是否收敛:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="fc30" class="kq kr it ms b gy mw mx l my mz">#plot of error<br/>df3_test['row_num'] = np.arange(len(df3_test))+1<br/>df3_test.plot.scatter(x='row_num',y='difference%')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ddaecdcc4bed42a4687176d84c70d223.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*eX55-dhPFdZocqOitU8huA.png"/></div></figure><p id="da1f" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">如你所见，错误率确实收敛到0%到-5%之间。</p><p id="7f11" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">如果我们看看变量explorer，我们可以看到它收敛到2.9左右。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/4278dba01ea932ef79a387cf6dcc0a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGvA2-MRMkbhui7Ny_6JQg.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="e3a3" class="kq kr it bd ks kt ku dn kv kw kx dp ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">四。0到12000000之间素数的误差消失法</h2><p id="ede6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu kz lv lw lx ld ly lz ma lh mb mc md me im bi translated">让我们首先以同样的方式进行预处理:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4cfd" class="kq kr it ms b gy mw mx l my mz">e=list(sympy.sieve.primerange(0, 12000000)) <br/>df_final = pd.DataFrame(e)<br/>df_final['row_num'] = np.arange(len(df_final))+1</span><span id="2c54" class="kq kr it ms b gy na mx l my mz">df_final = df_final.assign(ODDEVEN = lambda x: (x['row_num']%2!=0))<br/>df_final=df_final.rename(columns={df_final.columns[0]: 'ODD_INDEX_PRIMES'})</span><span id="0385" class="kq kr it ms b gy na mx l my mz">#ODD Index Primes<br/>df_final_1 = df_final.query('ODDEVEN==True')</span><span id="e7d5" class="kq kr it ms b gy na mx l my mz">df_final_1=df_final_1['ODD_INDEX_PRIMES']</span><span id="0142" class="kq kr it ms b gy na mx l my mz">df_final_1=pd.DataFrame(df_final_1)<br/>df_final_1=df_final_1.reset_index(drop=True)</span><span id="8433" class="kq kr it ms b gy na mx l my mz">df2_final = df_final.query('ODDEVEN==False')<br/>df2_final=df2_final.rename(columns={df2_final.columns[0]: 'EVEN_INDEX_PRIMES'})<br/>df2_final=df2_final['EVEN_INDEX_PRIMES']<br/>df2_final=pd.DataFrame(df2_final)<br/>df2_final=df2_final.reset_index(drop=True)</span><span id="adfb" class="kq kr it ms b gy na mx l my mz">df3_final=pd.concat([df_final_1, df2_final], axis=1)<br/>df3_final=df3_final.apply(pd.to_numeric, errors='coerce')<br/>df3_final.dtypes</span></pre><p id="29e2" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，我们可以将原始方程乘以0.97，因为上次的误差率约为2.9%或3%。</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="7982" class="kq kr it ms b gy mw mx l my mz">(2.41+(x*1.03))*.97)</span></pre><p id="88f7" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">让我们这样做:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="2a84" class="kq kr it ms b gy mw mx l my mz">df3_final['predicted']=df3_final['ODD_INDEX_PRIMES'].apply(lambda x: (2.41+(x*1.03))*.97)</span></pre><p id="0c85" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">现在，让我们计算误差:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="a3ad" class="kq kr it ms b gy mw mx l my mz">df3_final['difference%']=(df3_final.EVEN_INDEX_PRIMES - df3_final.predicted) / df3_final.predicted * 100</span></pre><p id="17ea" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">让我们画出误差:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="eea1" class="kq kr it ms b gy mw mx l my mz">#plot of error<br/>df3_final['row_num'] = np.arange(len(df3_final))+1<br/>df3_final.plot.scatter(x='row_num',y='difference%')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7f42bcf8c8404cf96cc9f2abbd58547c.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*lz1E3wHwRvY8a8yDj-rkGQ.png"/></div></figure><p id="6987" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">这一次错误率收敛到非常接近0。让我们看看变量资源管理器来检查一下:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="c586" class="kq kr it ms b gy mw mx l my mz">#print tail<br/>print(df3_final.tail(n=20))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nr"><img src="../Images/0bb83e7bae6f6af4d16e4653481bef49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W43EKmEn_oI5G7UJP8s6cA.png"/></div></div></figure><p id="b262" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">正如您在打印尾部时看到的，差异%收敛到大约0.09%。</p><p id="1132" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">这意味着，只要你有一个奇数索引的素数，你就可以通过使用下面的等式在大约0.09%的误差范围内预测它之后的下一个素数</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="8ec0" class="kq kr it ms b gy mw mx l my mz"><strong class="ms iu">(2.41+(x*1.03))*.97)</strong></span></pre><p id="7a68" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">其中x是奇数索引的素数。</p><p id="455a" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">如果我们再次运行代码，并上升到6841648个素数，错误率仍然在该值附近徘徊…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ns"><img src="../Images/e9194449f10f3efcd2b41131cbed5006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nSyB15es1PYKJxdbOA6rw.png"/></div></div></figure><p id="3860" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">感谢阅读，</p><p id="34dc" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">灰</p><p id="3d23" class="pw-post-body-paragraph lm ln it lo b lp mf ju lr ls mg jx lu kz mh lw lx ld mi lz ma lh mj mc md me im bi translated">以下是我另一篇文章的链接:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/heart-disease-prediction-with-machine-learning-52eaf239cf05"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">基于机器学习的心脏病预测</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">I .下载数据集</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">pub.towardsai.net</p></div></div><div class="of l"><div class="og l oh oi oj of ok ko nw"/></div></div></a></div></div></div>    
</body>
</html>