<html>
<head>
<title>How Practical Is Python For Prototyping Data Science Projects At Scale?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python对于大规模数据科学项目的原型开发有多实用？</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/how-practical-is-python-for-prototyping-data-science-projects-at-scale-88d345fa849d?source=collection_archive---------0-----------------------#2020-02-03">https://pub.towardsai.net/how-practical-is-python-for-prototyping-data-science-projects-at-scale-88d345fa849d?source=collection_archive---------0-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/591256fb5c098fbbdb1e1581b3e42df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYNPsFe2OuF2EwP3UF8TPg.png"/></div></div></figure><h1 id="3efb" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="7384" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文中，我将分享我对使用Python进行计算密集型数据科学项目的实用性的想法。本文的主要读者是行业中的数据科学家，其次是依靠计算方法来回答研究问题的研究人员。</p><p id="29e4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">可以在这个<a class="ae mc" href="https://github.com/hsm207/python_no_prototype" rel="noopener ugc nofollow" target="_blank">报告</a>中找到重现本文中描述的结果的代码。</p><h1 id="82a4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">动机</h1><blockquote class="md me mf"><p id="9b01" class="kz la mg lb b lc lx le lf lg ly li lj mh lz lm ln mi ma lq lr mj mb lu lv lw im bi translated">因此，在学术环境中出现的大多数情况下，用普通Python开发、识别计算瓶颈并使用Numba消除它们是有意义的。</p></blockquote><p id="a520" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面的引文来自[1]的摘要。对于上下文，作者认为尽管Python是一种缓慢的编程语言，但由于其表达能力和丰富的库，它是科学计算的理想选择。性能问题可以通过重写Numba中较慢的部分来解决，这通常只需要应用一些函数装饰器。</p><p id="45bc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这句话让我思考:这个建议在工业界会有多好？</p><p id="1dc7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我将尝试通过解决一个问题来回答这个问题。这个问题故意保持简单，以免分散我们对本文要点的注意力。</p><h1 id="9d96" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">问题陈述</h1><p id="232f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将使用在我之前的文章[2]中提出的相同问题，所以我将在这里做一个简单的回顾:</p><p id="ae2b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">给定如下所示的数据帧:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/548843aee213a30f86f9f68f72acfe91.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/0*ex6GQovX606Dyz4R.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图1:样本数据帧</figcaption></figure><p id="afb1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们希望迭代数据框的每一行，以生成如下所示的字典:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e00ee6792693c53834f7fb0b1e28cf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:134/format:webp/0*2yNdViH_m9ww6dYV.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图2:示例输出</figcaption></figure><h1 id="961b" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Python解决方案</h1><h2 id="ead3" class="mu kc it bd kd mv mw dn kh mx my dp kl lk mz na kp lo nb nc kt ls nd ne kx nf bi translated">天真的解决方案</h2><p id="e094" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因为我们处于原型阶段，所以我们希望快速地得到一些东西，然后再考虑性能。因此，将问题陈述逐字翻译成代码将如下所示:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f1bbfb861f26b015fcad4e8ba13d67ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*gUfsgnk9dLND4XfarXc-NA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图3:将问题陈述直译成Python代码</figcaption></figure><p id="2a40" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">图3显示了600万行数据帧的执行时间。代码可读性很强，但速度很慢。</p><p id="203d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">假设代码足够慢，阻碍了我们快速迭代的能力。我们能做些什么来加速它？按照[1]的建议，我们可以尝试研究Numba。</p><h2 id="8ae9" class="mu kc it bd kd mv mw dn kh mx my dp kl lk mz na kp lo nb nc kt ls nd ne kx nf bi translated">Numba解决方案</h2><p id="4797" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是Numba文档对其与熊猫兼容性的描述(在撰写本文时):</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/56545a563a5ea3858b16dd4830a058ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGWDMKmHS-Ks-DGPVkrMdA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图4: Numba对熊猫的支持。来源:https://bit.ly/31nCVwG<a class="ae mc" href="https://bit.ly/31nCVwG" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="5705" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">看起来如果我们想使用Numba，我们必须重写我们的代码，使它不依赖于熊猫。我们可以尝试使用NumPy数组重写它，但这会使代码不太直观，这是我们希望尽可能避免的。有其他选择吗？</p><p id="7442" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您是那种紧跟Python数据科学社区最新发展的数据科学家，您将会知道有一个名为Dask的库，它使分布式计算变得很容易。所以让我们来看看。</p><h2 id="82b0" class="mu kc it bd kd mv mw dn kh mx my dp kl lk mz na kp lo nb nc kt ls nd ne kx nf bi translated">Dask解决方案</h2><p id="0d63" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是我用Dask想出的解决方案:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e990b12f4c0ce6c01792cc5c2c3a7417.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*eu9Pm0azgMBfd6dWNJG09Q.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图5:使用map-reduce范式的Dask解决方案</figcaption></figure><p id="eb59" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">与我们的第一个解决方案相比，该解决方案几乎快了4倍。但是，如果我们打算多次重复这个计算，4分钟是很长的等待时间。</p><p id="1960" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们能做得更好吗？是的，如果你了解Python的内部或者知道如何分析你的代码。</p><h2 id="ed20" class="mu kc it bd kd mv mw dn kh mx my dp kl lk mz na kp lo nb nc kt ls nd ne kx nf bi translated">定制解决方案</h2><p id="45a6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是我在Python中能想到的最快的解决方案(参考[2]了解我如何得到这个解决方案的细节):</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ca69c39fad9539ce29b83a40af86cf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*boYi8OoCg6PX3eyuEAtONg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图6:我在Python中的最佳解决方案</figcaption></figure><p id="d05d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这是一个显著的加速。现在重复运行这段代码变得可行了。这不是我们问题陈述的直接翻译，但是不用花太多时间就能看出它是等价的。</p><p id="7334" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在让我们考虑一下达到这一步需要什么。</p><h1 id="d55e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">观察</h1><p id="3332" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们开始写代码来解决一个问题，却发现我们写的代码太慢了。我认识的大多数数据科学家会立即考虑并行化他们的代码，例如，当他们无法让代码在单核上运行得更快时，就使用Dask。因为这通常是可行的，所以他们决定采用这种策略，而错过了更快的定制解决方案。</p><p id="a70b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">要想想出像定制解决方案这样的东西，需要有人了解Python如何工作，或者如何分析和调试代码。这是一个罕见的特征，因为数据科学家不是软件工程师，许多人没有深入研究任何编程语言。更确切地说，他们只知道足够的程序来做好他们的工作。</p><p id="992c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了最大限度地发挥数据科学家重复其想法的能力，他们必须能够以他们思考想法的相同方式进行编码，并使代码自动优化以尽可能快地运行，从而避免数据科学家重写代码以符合某些性能增强API的需要，或者思考重新表达其想法的聪明方法，以便与他们的编程语言的内部更加一致。</p><p id="a8a4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这样的编程语言存在吗？就算有，又有多适合数据科学工作呢？</p><h1 id="9c56" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">朱莉娅上场了</h1><p id="f283" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我认为在写作的时候，Julia是做数据科学的最佳语言。让我来说明为什么。这是Python中朴素解决方案的Julia版本:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9013ca82cc6d7937f3df25722f8e798a.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*-ayG0H2VM6RwcdayJn3UXw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图Julia中的简单解决方案</figcaption></figure><p id="68a3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">代码与Python版本非常相似，但是速度快了几个数量级。我认为这也足够好，可以重复运行，因为13秒仍然是很短的等待时间。对于第一次尝试来说还不错。</p><p id="3eca" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">但是，如果你花时间学习这门语言，你能得到什么样的表现呢？看看这个:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/82d3c880a4f49f824111704cce4d281b.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*R5Q9XiXzSHFQWCbHlCGzmA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图Julia中最快的解决方案</figcaption></figure><p id="03ff" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">图7和图8中的代码几乎相同。然而图8要快几个数量级！另外，请注意，它比Python中的自定义解决方案快几个数量级。</p><h1 id="0537" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">经验教训</h1><p id="1064" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了能在合理的时间内完成我的分析，我不得不重写我的Python代码，这些是我学到的经验:</p><ol class=""><li id="0012" class="nm nn it lb b lc lx lg ly lk no lo np ls nq lw nr ns nt nu bi translated">如果您的数据仍然可以轻松地存储在一台机器的RAM中，那么采用分布式计算可能是矫枉过正。</li><li id="17ae" class="nm nn it lb b lc nv lg nw lk nx lo ny ls nz lw nr ns nt nu bi translated">学习你的编程语言的习惯用法和性能技巧，这样你就可以马上写出高性能的代码。</li><li id="0bef" class="nm nn it lb b lc nv lg nw lk nx lo ny ls nz lw nr ns nt nu bi translated">跟上你所在领域的最新发展，而不仅仅是你使用的工具。</li></ol><h1 id="0d0e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="4a49" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我认为有了Julia在，Python不再是快速原型制作的理想选择。</p><p id="a61f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">除非您决定深入研究Python和它的库，否则您很可能会陷入性能瓶颈，而没有立即解决的方法。在你看到解决方案之前，需要一些尝试和错误。</p><p id="b4ed" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">相比之下，Julia就像Python一样富于表现力，并且拥有一个涵盖许多领域的繁荣的生态系统，就像Python一样。作为一种编译语言，它没有Python的性能缺点。您第一次编写的Julia代码通常足以完成您的原型/分析。</p><p id="6d9d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我希望这篇文章已经说服你在你的下一个数据科学项目中给Julia一个尝试。</p><p id="782b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">请在评论中告诉我你对在数据科学中使用Python进行快速原型制作的看法。</p><h1 id="fcd3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">参考</h1><p id="c9ad" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">【1】<a class="ae mc" href="https://arxiv.org/abs/2001.02491" rel="noopener ugc nofollow" target="_blank"><em class="mg">比较Python、Go、C++关于N皇后问题</em> </a> <em class="mg">。</em> Fua和Lis <em class="mg">。2020年</em></p><p id="1771" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">【2】<a class="ae mc" href="https://medium.com/@_init_/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d" rel="noopener"><em class="mg">为什么熊猫itertuples()比iterrows()快，如何让它更快</em> </a> <em class="mg">。</em>_ _ _ _ _ _<em class="mg">。2019 </em></p></div></div>    
</body>
</html>