<html>
<head>
<title>Detecting Road Damages From Image And Video</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从图像和视频中检测道路损伤</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/detecting-road-damages-from-image-and-video-6e6d56241e7d?source=collection_archive---------1-----------------------#2022-05-14">https://pub.towardsai.net/detecting-road-damages-from-image-and-video-6e6d56241e7d?source=collection_archive---------1-----------------------#2022-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8274" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从为对象识别训练yolov5模型到在streamlit上托管</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/40b8b0d41e7b9917907278dc85ace61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-FnBiZ2cs_ozvISTGZoLaw.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">从视频中检测道路缺陷的模型</figcaption></figure><h1 id="c929" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">动机</h1><p id="d80e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">假设您在一个行业工作，该行业会生成大量图像数据，并且图像中有您感兴趣的某些对象。例如，您有大量的X射线图像，这些图像标有出现异常的确切位置。你想要一个能在新的x光图像中发现同样异常的模型。不幸的是，在你的数据集上没有训练。你是做什么的？</p><p id="3ad5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这就是你利用yolov5或类似工具，根据你的数据训练一个深度神经网络，可以在新的X射线图像中检测出相同的异常。也许你想检测水族馆中的鱼，或者闭路电视镜头中穿大衣的人，训练对象检测模型是解决这类问题的首选方法。</p><p id="1403" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这次我们要深入研究yolov5，学习如何从零开始构建一个对象检测模型。嗯，实际上不是从头开始，因为我们将使用预训练的yolov5模型进行迁移学习。但这本身是一项艰巨的任务，因为要将训练数据输入yolov5，需要进行大量的数据预处理。像往常一样，我们将通过创建一个streamlit web应用程序来公开我们的项目，用户可以上传道路的图像或视频，应用程序将生成一个带有边框的输出图像，突出显示道路上的缺陷。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/df3c548a92d292a00524542eb4effe77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*W5DTSc-nmRvYfUTrgS3iVg.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">背景为yolov5的Streamlit应用程序</figcaption></figure><h1 id="d776" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">第1部分:数据预处理</h1><p id="9a1f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">数据集</strong></p><p id="78c8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">包含路面裂缝的图片可以从下面的<a class="ae mn" href="https://mycityreport.s3-ap-northeast-1.amazonaws.com/02_RoadDamageDataset/RoadDamageDataset.tar.gz" rel="noopener ugc nofollow" target="_blank">链接</a>下载。下载的文件将被命名为RoadDamageDataset.tar.gz的<em class="mo">。</em>我们将使用Python代码提取数据，所以先不要解压缩。</p><p id="e6f0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="mo">文件夹结构</em> </strong></p><p id="9cf4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这就是文件夹结构应该的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/df160991209a384e299092a87e869663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P60xdgm0bV1gkOAgmhNIjQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">初始文件夹结构。确保压缩文件保存在名为data的文件夹中。</figcaption></figure><p id="acbf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们开始编写提取数据的代码。打开Jupyter笔记本并导入所需的库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9883" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们从tar.gz文件中提取数据</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8b26" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦执行了上面这段代码，提取的文件将存储在data文件夹中名为RoadDamageDataset的文件夹中。项目文件夹结构现在如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mw"><img src="../Images/5b9d204ac2ed18ff05828bf7843da961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMMvD5yC91o27r4rvrpG4g.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">提取后</figcaption></figure><p id="6cbf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们查看<strong class="lo iu"> RoadDamageDataset </strong>文件夹，我们会看到收集数据的不同位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mx"><img src="../Images/c21db2b6d6578be9bcf62e4cef3f90f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgV8gqKY64dxldubkSC6Lw.png"/></div></div></figure><p id="e897" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">足立、千叶、市原等是日本不同的城市，在这些城市拍摄了道路图像并发现了缺陷。让我们仔细看看。</p><p id="34e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于每个城市，存在以下文件夹</p><ul class=""><li id="ccf2" class="my mz it lo b lp mi ls mj lv na lz nb md nc mh nd ne nf ng bi translated">释文</li><li id="f47a" class="my mz it lo b lp nh ls ni lv nj lz nk md nl mh nd ne nf ng bi translated">图像集</li><li id="b8a4" class="my mz it lo b lp nh ls ni lv nj lz nk md nl mh nd ne nf ng bi translated">JPEGImages</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nm"><img src="../Images/53440f88975cfaa26c203ba8ab58a580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*WtxuL4W8wZ0TMlewWjZYsw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">JPEGImages包含道路的彩色图像</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nn"><img src="../Images/e9211b44aa1437a0c5f9c4c8ea2339e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*VtI2-31Y65vsoD3zp7bQEA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">“注释”文件夹包含每个图像的标签细节</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi no"><img src="../Images/2394f4c043d3e0a01024f1713815f3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jszPBBa7mkKV0zDEZRPuAA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">图像和注释并列</figcaption></figure><p id="6aea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了便于理解，图像及其对应的注释文件是并排保存的。我们感兴趣的标记是<object>和其中的组件。例如，在该图像中，存在的缺陷是D20，并且其位于X轴上的像素点87至226和Y轴上的像素点281至432。一些图像往往包含不止一个缺陷。下图是一个例子。一对缺陷其实是肉眼可见的。</object></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi no"><img src="../Images/c4cb2f55cfb9b9e381ba98b44ae82bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdoNxWvhWq57k04U8sTfpg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">道路上有多个缺陷的图像</figcaption></figure><p id="60fc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">缺陷的名称各不相同，通常以D开头，后面是一个2位数，如“D20”、“D01”等。</p><p id="5ab3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们已经有了注释文件和图像，我们需要以一种可以用来训练PyTorch模型的方式来排列它们。首先，我们需要将所有图像放在一个文件夹中，将所有注释放在另一个文件夹中。它们应该有相同的名称，只是扩展名不同。比如一个文件“Chiba_20170913094022”，Chiba_20170913094022.jpg要存放在一个文件夹中，Chiba_20170913094022.xml要存放在另一个文件夹中。让我们看一下下面的代码片段，它将不同城市的所有图像和注释放在两个独立的文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9b24" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">输出</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/30be9aa71b564c570c1d130684290c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*sOle02ropjx73_fjiQTG9g.png"/></div></figure><p id="d490" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">代码的第一部分(try块)创建保存所有图像和注释的文件夹。创建必要的文件夹后，排列如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nq"><img src="../Images/8dcd1e4da0e908a1b86b25cb55295a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy5o5dfxVWbjgKJ5NvAZeg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">将所有图像和注释存储在一个位置的文件夹</figcaption></figure><p id="b430" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦代码的第二部分执行，文件将被复制到images和labels目录中，这取决于它们是图像文件还是XML文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nr"><img src="../Images/2b3c9ea024826cadde5f421e8a73d5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sB4I5byGL8wP9mMQLckkZw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">排列到图像和标签文件夹的文件</figcaption></figure><p id="f0b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">注解文件</strong></p><p id="eb04" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们仔细看看注释文件。我们可以随便挑一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ns"><img src="../Images/4bf47dbc6f337ebf3ad11e6ddd4dbffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2l49SJDu4PSzZeb66KixEw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">该文件包含5个缺陷的坐标</figcaption></figure><p id="2434" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上图是一个包含5个路上缺陷的文件的例子。对于每个缺陷，我们有xmin、ymin、xmax和ymax——基本上是角。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nt"><img src="../Images/b824aa2b8a08e889976bccbca3307f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-f3ggP87Zkqe_QiZ_tnpiA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">XML文件中的注释</figcaption></figure><p id="fdb7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是我们必须将这个文件转换成yolov5训练时可以理解的格式。在yolov5的情况下，它需要突出显示部分的中心的x和y坐标以及其长度和宽度。让我们看看yolov5的理想注释文件是什么样的。上面显示的相同文件转换成yolov5可理解的格式后将如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/62ba0a0de2858828dff5790403f960e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*J6zCAhTE-8LopRQTsI505g.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">XML变成了txt文件</figcaption></figure><p id="9a16" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意只有5行，每个缺陷一行。第一个值是类的数字编码，后面是x_center、y_center、高亮块的宽度和高亮块的高度。此外，这些不是绝对值，而是与图像的高度或宽度成比例的值。让我们试着进一步理解这一点。</p><p id="ece3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第一个值是高亮部分中心的x坐标除以图像的长度。让我们看看第一个突出显示的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mx"><img src="../Images/6b2e6f820e1169371e028a9267d20669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99VIASDTMRexeW8eQQj-Ig.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">如Adachi_20170906093900.xml的原始XML文件中所述</figcaption></figure><p id="3a58" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">xmin和xmax分别为328和418。因此，x_center应该是</p><blockquote class="nv nw nx"><p id="0f48" class="lm ln mo lo b lp mi ju lr ls mj jx lu ny mk lx ly nz ml mb mc oa mm mf mg mh im bi translated"><em class="it"> (xmin + xmax)/2 </em></p></blockquote><p id="e770" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因此x_center是(328+418)/2 = 373</p><p id="8a97" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但这还不是全部。yolov5需要的是一个比例值。373相对于图像高度的比例是多少？如果我们看上面图像的顶部，我们可以看到图像的高度是600。因此，比例为373/600 = <strong class="lo iu"> 0.622 </strong></p><p id="8a7f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同理，y_center = (246 + 367) / 2 =306.5，其对应的比例值为306.5 /600= <strong class="lo iu"> 0.511 </strong></p><p id="8020" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在是高亮块的宽度和高度。</p><p id="7392" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">突出显示块的宽度= (xmax — xmin)</p><p id="fff8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是由于我们需要一个比例值，它将除以图像的总宽度。</p><p id="bda5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">宽度比例=(xmax-xmin)/图像宽度</p><p id="d24b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">高度比例=(ymax-ymin)/图像高度</p><p id="8584" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于本例，宽度比例=(418–328)/600 =<strong class="lo iu">0.150</strong></p><p id="1a12" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">身高比例=(367–246)/600 =<strong class="lo iu">0.202</strong></p><p id="2219" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们看转换后的文件的第一行，这些是我们得到的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/53464479aafdbd7a34807c13b55c4fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*YERRZPgzw_6CC7u92rQWLg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">注释的Yolov5格式</figcaption></figure><p id="4a38" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好的一面是，我们已经有了一些功能，可以为我们执行这种转换。让我们先确定目标。下面是我们的目录结构</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oc"><img src="../Images/d7c36fe4c8db21651888a8a906fc8b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IQ13WhIK0dc0Ogijmo6Zw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">当前目录结构</figcaption></figure><p id="518b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们需要的是分类文件目录中的另一个文件夹，名为annotations，其中包含yolov5可理解格式的注释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/42543ca6d04e381a3e9c36f8fdb795f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*UkWifm_4goccdej54r12ow.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">我们想要的—注释文件夹包含与标签文件夹中相同的注释，但采用yolov5可理解的格式</figcaption></figure><p id="8377" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">突出显示的部分是我们想要的。让我们看看代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="22ef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">前两个函数<em class="mo">extract _ info _ from _ xml()</em>和<em class="mo"> convert_to_yolov5(…) </em>负责从XML文件中提取数据，然后转换成比例，最后保存为txt文件。在这一步之后，将在分类文件目录中以编程方式创建annotations文件夹，并生成文本文件。请注意，我们已经创建了一个映射字典来将灾难类型D11、D44等转换为数字，因为yolov5只理解数字。</p><p id="db6a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们完成数据预处理之前，让我们快速检查注释是否已经正确完成。让我们运行下面这段代码，它拾取一个图像及其相应的注释txt文件，并根据文件中的值绘制边界框。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9b9a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们定义了一个plot_bounding_box(…)函数，它在图像上绘制一个边界框。然后，我们使用任何旧的fille，访问其相应的annotations (txt)文件，并查看这些文件中的坐标是否实际上突出了道路的缺陷区域。输出如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6a582179421755cf963fdab5dc55e3a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*evqFLmjkVIOutUKaOJUNeg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">缺陷明显突出</figcaption></figure><p id="3b79" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">数据预处理的最后一步是将数据分为训练、验证和测试。我们要吃的东西如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d28d57e994b314940bf867f3482b868e.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*6l14W79DkFvlFfnmqHuANA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">图像和注释分为训练、验证和测试</figcaption></figure><p id="5acf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上图中突出显示的部分显示了分布情况。来自<strong class="lo iu">分类文件/图像</strong>的图像将在<em class="mo">最终道路/图像/列车</em>、<em class="mo">最终道路/图像/val </em>和<em class="mo">最终道路/图像/测试</em>之间重新分配。同样，来自<strong class="lo iu">分类文件/注释</strong>的注释将被分配到<em class="mo">最终道路/注释/列车</em>、<em class="mo">最终道路/注释/val </em>和<em class="mo">最终道路/注释/测试</em>中。请记住，finalRoad/images/*/中的文件应该与finalRoad/annotations/*/中的文件相匹配。也就是说，对于图像目录的train文件夹中存在的每个文件，它应该在注释目录的train文件夹中具有相应的注释文件。下面这段代码会处理所有这些问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">用于对图像和注释进行模式化以进行训练、评估和测试的代码</figcaption></figure><p id="192d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">代码的第一部分将文件名分为图像和注释的三个列表，注意相同的文件出现在图像和注释的每个组中。然后我们创建test、train和vali文件夹。最后，我们将图像从分类文件文件夹复制到最终的道路文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/452f6f00d9d8a03e1fecd794e026e7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*ONcqntHVYmA7GIfelN-kBw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">已填充训练、Val和测试文件夹。</figcaption></figure><p id="0c92" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们做一个健全性检查，看看每个文件夹中有多少文件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="72c9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2f4650d937a157c595206b6ce5db5c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*fGrXWDDl2liEqhAsatjb8A.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">数字加起来。我们可以进入下一阶段</figcaption></figure><p id="9a97" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第1部分的所有代码可以在jupyter笔记本<a class="ae mn" href="https://github.com/ashhadulislam/medium_road_analysis_core/blob/main/01_Data_PreProcessing.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="77b0" class="oi kv it bd kw oj ok dn la ol om dp le lv on oo lg lz op oq li md or os lk ot bi translated">数据预处理结束。</h2><p id="2b80" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您已经到了这一步，请深入到下一部分，您将在数据集上训练一个定制的yolov5模型。这似乎是一次艰难的旅程，但回报是令人满意的。</p><p id="311a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您现在可以打开一个新的jupyter笔记本。</p><h1 id="ee8f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">第2部分:培训</h1><p id="4d21" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">得到约洛夫5 </p><p id="6ea5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是我们下载yolov5代码库的地方，以便利用已经存在的代码库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/27caca4a41736552c57a7c8b9fa2d609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*sCyU-u0g0tiJbCCJGkMfTQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">当前目录结构</figcaption></figure><p id="f5bf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是文件夹结构的样子。这是我们在第1部分中所做工作的延续。<em class="mo">01 _ Data _ preprocessing . ipynb</em>是我们写数据预处理(第1部分)代码的笔记本。现在，我们有一个名为<strong class="lo iu"><em class="mo">02 _ trainyolo . ipynb</em></strong>的新笔记本，我们将在其中编写第02部分。</p><p id="14ea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在您刚刚打开的新jupyter笔记本(<strong class="lo iu"><em class="mo">02 _ train yolo . ipynb</em></strong>)中，执行以下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="994c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第2行将yolov5代码repo下载到当前目录中。第3行将工作目录更改到yolov5文件夹中，其中包含所有下载的代码repo。存储库中有一个requirement.txt文件，其中包含了所有必需的库。第4行将它们安装在当前正在执行的内核中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ov"><img src="../Images/3cf48e8ea37d62bfb2c3ee59f03a82fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzxHan51myZDzq7kIuL71A.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">已成功安装库</figcaption></figure><p id="4c9c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果您现在检查文件夹结构，您将在代码库中看到一个名为yolov5的文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/87e95fddd0a1e1d34828575e4c4b4eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*Lct-guIlPoMsm-opcac1CQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">我们现在在yolov5文件夹中</figcaption></figure><p id="9fe7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">YAML文件</strong></p><p id="7dc1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是本部分最关键的部分。我们需要通知yolov5关于训练、验证和测试文件的位置。这是通过YAML文件传达的。最终的YAML文件如下所示，尽管我们将以编程方式创建它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ox"><img src="../Images/80101d7caef5d304168feedeabd69eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eItBTxO5wmeStUBQphjCpQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">用于培训的元数据</figcaption></figure><p id="7ab8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请注意我们是如何给出train、validation和test文件夹的绝对路径的。这很重要。为了减少混乱，我们将使用代码来创建文件。下面的代码片段创建了YAML文件——将其粘贴到您当前正在处理和执行的jupyter笔记本中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">YAML文件的代码</figcaption></figure><p id="0d44" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">代码的第一部分获取父目录的绝对路径，因为我们在yolov5文件夹中，而数据在yolov5目录外的单独文件夹<strong class="lo iu">中。该代码导致创建一个名为dataRoad的文件。yolov5文件夹里的YAML。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2e2e4fdcb95af192766e198a8a792e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*wTIkqlT5vSukBHVVd5Eofg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">为培训创建元数据</figcaption></figure><p id="4005" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们将运行代码来执行训练。实际上，训练的代码已经写好了。我们需要做的是用正确的参数执行代码。我们的做法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">使用正确的参数执行训练</figcaption></figure><p id="14d6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这里重写命令</p><p id="56d0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">！python train . py-—data data road . YAML-—CFG yolov 5s . YAML-—批量大小32 -— epochs 1 -—名称RoadTrainModel</p><p id="c410" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一个重要的参数是- <em class="mo"> data </em>，这里我们给出了刚刚创建的YAML文件的名称。另一个必要的参数是- <em class="mo"> epochs </em>，在上面的例子中它仅仅是1，但是它应该被改变为20或更多以获得更好的精度。最后，参数- <em class="mo"> name </em>很重要，因为它声明了最终训练好的模型将存储在哪里。例如，在这种情况下，训练好的模型将被存储在yolov5文件夹的运行目录内的文件夹<em class="mo"> RoadTrainModel </em>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/0d3b9cf852c195aabd89fd018b358e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*reuHk3rhSBSQGjaQ792MAg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">每当我们运行train.py文件时，都会创建一个新的RoadTrainModel*文件夹。</figcaption></figure><p id="f720" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上述代码的输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oz"><img src="../Images/c092530699a15d4a6ef9dedac75ea1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-ah88z9eSLAkpuOW2gYCw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">接受1个时代的培训</figcaption></figure><p id="55ae" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正如你所看到的，我是在一个CPU系统中训练的，所以我花了5个小时来完成一个纪元！不过，如果你用的是google colab，应该会快很多。</p><p id="e3bb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">训练过的重量</strong></p><p id="0cd1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们需要能够重用经过训练的模型。模型的重量可以在RoadTrainModel*文件夹中找到。*代表最高数字。例如，我有一些错误，而我的最终成功训练发生在第4次尝试时，这就是为什么在我的情况下，训练的权重将在RoadTrainModel4目录中找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/74466045d33a980f2d2faae226ec4b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*0BrLSC8lW0eIjJ8jmNDtJw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">best.pt是我们追求的目标</figcaption></figure><p id="0a3c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最佳权重存储在best.pt中，这是我们测试模型时需要加载的文件。</p><p id="7a0b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第02部分的所有代码可以在<a class="ae mn" href="https://github.com/ashhadulislam/medium_road_analysis_core/blob/main/02_TrainYolo.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="ea4e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您现在可以关闭此笔记本并开始一个新的。我们姑且称之为<strong class="lo iu"> <em class="mo"> 03_Test.ipynb </em> </strong></p><h1 id="eb39" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">第3部分:测试</h1><p id="5704" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们再次利用yolov5的代码库来测试训练好的网络。它可以应用于图像以及视频，因此我们下载了一个测试图像<a class="ae mn" href="https://drive.google.com/file/d/1yspXaykHW0XOBgshZDMuSFtYu-FJz9J3/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">和一个测试视频</a><a class="ae mn" href="https://drive.google.com/file/d/1ku_2I0A_58NXNoGonokGeGmPpxcuIRTr/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"/>。让我们创建一个名为test的文件夹，并将图像和视频保存在那里。文件夹结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/032b341e161b90fabe45a5811eb075ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*nt5Hx5RgnKEaXjHA0G35PA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">创建一个名为test的文件夹，并添加图像和视频文件</figcaption></figure><p id="c7cc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">另外，请注意03_Test.ipynb文件，我们将在该文件中编写这一部分的代码。代码非常简单。我们需要使用yolov5目录中的detect.py文件，让它知道哪些是测试文件，哪些是训练权重。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">只有两行</figcaption></figure><p id="a0cf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了清楚起见，在这里重复命令。</p><p id="5137" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">！python yolov 5/detect . py-源数据/测试/-权重yolov 5/runs/train/roadtraintmodel 4/weights/best . pt-conf 0.25-名称RoadTestModel</p><p id="7d1e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">—源是测试图像和视频所在的位置。—权重是已训练的最佳权重的位置。同样，name是可以找到测试输出的文件夹的名称。这可以在yolov5的runs文件夹中再次找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/4fa393c4908f04ac91b88ef793beb969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*9mcJG3zgZGPnx-cYE5S3QQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">输出文件与输入测试文件同名。</figcaption></figure><p id="2d4e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意到名为detect的新文件夹了吗？这是输出将被存储的地方。代码的输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi pc"><img src="../Images/82e187ec0deb234d086cdcb8eb237f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Jd5FU53XaSGgHYMMTI7uQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">告诉您输出存储在哪里</figcaption></figure><p id="0cce" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">输出文件如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/d9410c6889ddaf1089f80a47b01a378d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*6xnIlizqUO9leHfh1nc_7g.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">检测输出图像</figcaption></figure><p id="7102" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">就是这样！您已经能够在自定义数据集上训练和测试yolov5对象检测模型。</p><h1 id="d798" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">奖励部分:Streamlit应用程序</h1><p id="cc40" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果我们能把这作为一个应用程序与全世界分享，那就太好了。你只需上传任何道路的图像，它就会给出道路受损的区域。我们可以使用streamlit做到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/df3c548a92d292a00524542eb4effe77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*W5DTSc-nmRvYfUTrgS3iVg.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">行动中的简化应用</figcaption></figure><p id="61ec" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">关于streamlit中编码的更详细的解释，请看这篇<a class="ae mn" rel="noopener ugc nofollow" target="_blank" href="/deep-learning-a692669f6f42">文章</a>，并转到作为Streamlit应用程序托管的<em class="mo">部分(本地和云中)。</em>这个应用程序的代码以类似的格式编写。我在这里附上streamlit应用<a class="ae mn" href="https://github.com/ashhadulislam/medium_road_analysis" rel="noopener ugc nofollow" target="_blank">的GitHub repo。你可以试试这里的app</a><a class="ae mn" href="https://share.streamlit.io/ashhadulislam/medium_road_analysis/main/main.py" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7838" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">遗言</strong></p><p id="b1cc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你坚持到了最后，那么恭喜你——我希望这段时间花得值，你可以利用本文分享的知识开发出一些很棒的应用程序。请随时与我在ashhadulislam@gmail.com取得联系，提出意见或改进建议。</p><p id="9db5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下次见。</p></div></div>    
</body>
</html>