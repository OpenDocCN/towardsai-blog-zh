<html>
<head>
<title>Building a Super-resolution Image Web-app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建超分辨率图像网络应用</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/building-a-super-resolution-image-web-app-57e26886cb45?source=collection_archive---------2-----------------------#2020-07-21">https://pub.towardsai.net/building-a-super-resolution-image-web-app-57e26886cb45?source=collection_archive---------2-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="24fe" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning/deep-learning" rel="noopener ugc nofollow" target="_blank">深度学习</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="a692" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在本文中，我们将构建一个基于SRCNN模型的web应用程序。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fc4d85693ce56ebd033bc08139add799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdnKsJBOk8v2vpbpaA76oQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">超分辨率网络应用</figcaption></figure><p id="13a7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当给定一幅图像作为输入时，它重建同一幅图像的更高分辨率的图像。我做了这个应用程序，作为我的细化编码试点任务。任务包括找到一个合适的模型，制作推理算法，将它包装在一个REST API中，最后将应用程序dockerizing。</p><p id="cb42" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于这个任务，我使用Keras和Tensorflow后端和Flask。这个博客是关于我在这个任务中面临的同样的挑战，以及当你在做你的项目时如何克服它们。</p><h2 id="656d" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">第一步:找到合适的模型</h2><p id="866e" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">对于模型，我研究了一下图像的超分辨率问题，找到了SRCNN模型。</p><p id="8202" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我选择这个模型的原因是预先训练的重量是可用的。这意味着，我不用再重新训练这个模型了。并且模型架构相对简单易懂。于是我又多了解了一下模型，敲定用这个。对于模型结构和权重，我遵循了这个存储库:【https://github.com/MarkPrecursor/SRCNN-keras】T4</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="af85" class="md me it nc b gy ng nh l ni nj">import tensorflow</span><span id="f791" class="md me it nc b gy nk nh l ni nj">from keras.models import Sequential<br/>from keras.layers import Conv2D<br/>from keras.optimizers import Adam</span><span id="2120" class="md me it nc b gy nk nh l ni nj"># define model type<br/>SRCNN = Sequential()<br/> <br/> # add model layers<br/>SRCNN.add(Conv2D(filters=128, kernel_size = (9, 9), kernel_initializer=’glorot_uniform’,<br/> activation=’relu’, padding=’valid’, use_bias=True, input_shape=(None, None, 1)))<br/>SRCNN.add(Conv2D(filters=64, kernel_size = (3, 3), kernel_initializer=’glorot_uniform’,<br/> activation=’relu’, padding=’same’, use_bias=True))<br/>SRCNN.add(Conv2D(filters=1, kernel_size = (5, 5), kernel_initializer=’glorot_uniform’,<br/> activation=’linear’, padding=’valid’, use_bias=True))<br/> <br/> # define optimizer<br/>adam = Adam(lr=0.0003)<br/> <br/> # compile model<br/>SRCNN.compile(optimizer=adam, loss=’mean_squared_error’, metrics=[‘mean_squared_error’])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nl"><img src="../Images/be41a3ee941fa017aa730fb5c0660a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SluqfbfZ4LAXjYHaFx4NiQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">SRCNN架构</figcaption></figure><h2 id="7d15" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">步骤2:设置推理算法</h2><p id="ec36" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">所以我的任务是建立一个模型，使它能为给定的图像返回一个更高分辨率的重建图像。首先，我需要获得模型结构的model.json文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7ca0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个简单的代码片段获取JSON格式的模型，用于推理和测试。现在我也抢到了预先训练好的负重。在现有模型回购的一些帮助下，作为确切的模型回报，并准备开始。</p><p id="482c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，首先必须编写一些辅助函数，用于图像预处理。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6551" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上述函数获取输入图像，并按因子缩小图像，即，用因子除尺寸，并返回新图像。现在定义了用于计算图像的PSNR(峰值信噪比)和MSE(均方误差)值的函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="aaec" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">还有一些更多的图像处理功能，以裁剪和删除图像的边界。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4fcc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后是预测函数。现在，predict函数有两个参数，image和image_name(输入图像)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d876" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，加载模型和预训练模型。以及图像被加载。现在，ref将加载并存储来自<strong class="lj jd">“静态/输入”</strong>位置的图像，并将其输入到模型中，以获得重建图像。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dc71" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一步是将“ref”图像转换为YCrCb形式，用于模型输入，并将其存储在一个名为“Y”的变量中。接下来，从模型获得的输出再次被预处理，以将其转换回BGR(蓝-绿-红)格式。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7b7f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，通过更多的预处理，我们将最终输出以及PSNR和MSE值发送给返回。</p><h2 id="c1b3" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">步骤3:制作烧瓶应用程序</h2><p id="bfd5" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">现在，预测的功能已经完成，模型正在返回重建的图像。所需要的是制作一个界面，通过它用户可以输入任何图像。方法是将它包装在一个RESTApi中，它可以接受图像作为输入。</p><p id="f2cf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我用Flask来设计API。API设计很简单，因为它只有一个端点“/”。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6e80" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里代码定义了端点，可以处理“GET和POST”请求。GET将根据请求返回新图像。而POST就是将图像发送到服务器。</p><p id="3b5c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">与此同时，我们有一个模板，index.html就绪，这将显示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="282b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">表单是从用户输入一个图像。现在“图像文件”存储图像输入。下一步是将图像发送到模型，以获得重建的图像。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cf28" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，图像保存在“静态/输入”文件夹中，然后进行预处理。最后，使用predict函数将缩小的图像输入到模型中。从那里我们得到输出图像以及PSNR，MSE和SSIM值。</p><p id="2c07" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，这个图像，从数组转换回图像格式，最后，我们保存这个图像。现在我们已经保存了输出图像和输入图像，下一个任务是在屏幕上显示它们。使用“jinja模板”可以轻松完成这项任务。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4cac" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，render_template中发送的值显示在index.html页面上。</p><h2 id="26c4" class="md me it bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu iz bi translated">第四步:归档</h2><p id="d54f" class="pw-post-body-paragraph lh li it lj b lk mv kd lm ln mw kg lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">网络应用也准备好了，直到这一部分是顺利的。现在是最困扰我的部分。要在Windows中运行Docker，需要启用“虚拟化”。但不幸的是，我的设备不支持这一点。所以我不得不迁移到Ubuntu来完成剩下的代码。</p><p id="da1c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要对flask应用程序进行dockerizing，需要两件事，一是列出所有包和依赖项的requirements.txt。第二个是docker文件，它是一个文本文档，包含用户可以在命令行上调用的所有命令，以组装docker映像。</p><p id="c244" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我面临另一个错误，关于. cv2的使用，基本上使用pip3没有帮助。所以，这是一个问题，我最终明白了。因此，无论何时，一个使用open-cv的Flask应用程序都必须使用<code class="fe no np nq nc b">sudo-apt-get</code>。这是docker文件…</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e8f2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">任务就是这样完成的。</p><p id="d407" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Github库:<a class="ae na" href="https://github.com/Aanisha/SuperResolution/" rel="noopener ugc nofollow" target="_blank">https://github.com/Aanisha/SuperResolution</a></p><p id="657d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">幸运的是，我被选为Tessellate Imaging的开源实习生。我将使用MonkAI库，这是一个低代码的计算机视觉库，来帮助用户轻松地构建和训练模型。</p></div></div>    
</body>
</html>