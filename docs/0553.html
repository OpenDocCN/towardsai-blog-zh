<html>
<head>
<title>A Tour of Conditional Random Field</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">条件随机场巡礼</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-tour-of-conditional-random-field-7d8476ce0201?source=collection_archive---------2-----------------------#2020-06-04">https://pub.towardsai.net/a-tour-of-conditional-random-field-7d8476ce0201?source=collection_archive---------2-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="efc2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><p id="1d6f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本文中，我们将探索和深入条件随机场(CRF)。条件随机场是一种概率图形模型，在基因预测、部分图像识别等领域有着广泛的应用。它还被广泛用于自然语言处理(NLP)中的神经序列标记、命名实体识别、词性标注等领域。在计算单个序列项目的标签时，如果关于相邻标签的信息是必需的，则使用条件随机场。</p><p id="14ea" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">图形模型是使用随机变量之间的条件依赖的图形的概率模型。有两种类型的图形模型，即贝叶斯网络和马尔可夫随机场。贝叶斯网络大多是有向无环图，而马尔可夫随机场是无向图，可能是循环的。条件随机场属于后一类。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/b0f37a9b9dc41f49c36564dc20ce311b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taxDq2q_u9EyyYVFO8JxCw.jpeg"/></div></div></figure><p id="bf75" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">从这里，我们将深入研究条件随机场的数学。为此，我们需要首先理解条件依赖的概念。如果变量<em class="lj"> y </em>有条件地依赖于变量<em class="lj"> x，</em>，那么给定输入<em class="lj"> x，</em>，我们可以通过下面的表达式来识别它的类:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/e0e0d9b4cdb4f32cb7da1e1847cf02cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*snb8QIwcu4NDThdYARaUvQ.png"/></div></figure><p id="452d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">假设这是一个结构化预测的问题，即，我们需要识别顺序输入的标签序列，我们可以通过下面的表达式利用不同元素<em class="lj"> xi </em>之间的条件独立性的概念。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/43b42125728ce9c2ae4069b848e3c1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*FP6wEI39VR8EUzFwA2W9LA.png"/></div></figure><p id="e1c1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里<em class="lj"> ϕ(.)</em>是激活函数，k是序列长度，<em class="lj"> Z(xi) </em>是配分函数。之后，<em class="lj"> P(y|x) </em>可以写成:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/63f1aab97942037cf26947053d31e95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*_02SNpofwqtbConcaJ8V2A.png"/></div></figure><p id="b6f9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当我们使用贪婪解码时，上面的表达式给了我们一个表达式<em class="lj"> P(y|x) </em>。在条件随机场的情况下，我们需要关于相邻标签的信息。该信息被合并到带有转换表v的表达式<em class="lj"> P(y|x) </em>中。在CRF的另一个变体中，输入x{i}上的上下文窗口也被用于计算标签信息。例如，如果有一个3的上下文窗口，<em class="lj"> P(y|x) </em>的表达式如下:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/7fdab0e8e329db079104695689cb8220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*sVjbXobRZwTHTm_lo7N9Ug.png"/></div></figure><p id="f077" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们分别考虑一元对数术语和成对转换术语的下列符号。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/6aec958622358548b352b1d6c9e34a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*HFg6w1-AWEDi8Uq5RP_DxQ.png"/></div></figure><p id="f778" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lj"> P(y|x) </em>的表达式可以写成:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/b374f7df04ef7ac9c024b04805cc117b.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*AxZE6p7dxsNop9VxZU4gtQ.png"/></div></figure><h1 id="9ceb" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">推理</h1><p id="682b" class="pw-post-body-paragraph jz ka it kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw im bi translated">我们知道，<em class="lj"> Z(X) </em>是一个配分函数。如果我们天真地计算配分函数，我们得到配分函数的表达式如下:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b544386dd8565b255ed1ff1e3d3835e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*XV-tkmykAh8o8m_0VZICSw.png"/></div></figure><p id="a1fe" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面的表达式中，我们可以看到，每次计算配分函数时，我们都在进行K求和。上述计算的计算复杂度大约为<em class="lj"> O(C^K、</em>，这是不可扩展的。为了降低复杂性，我们需要以稍微不同的方式排列<em class="lj"> Z(X) </em>。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/62114635594d309d825059c6eb280009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*pJ-vli3DxeKFkycyfUecLA.png"/></div></figure><p id="14d0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这种重新排列项的优点在下面给出的算法1中变得明显。我们引入另一类向量值函数α{i}(。)，它通过对y{1}处的所有可能标签执行最内部求和来初始化。这种术语的重新排列允许我们利用动态编程的优势来降低任务的复杂性。下面给出了更详细的算法。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mv"><img src="../Images/4333c708ecabab7bf0d8f29ea99f2cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-8VQU4NSGn94R5vKuiWfQ.png"/></div></div></figure><p id="a87e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">上述算法的计算复杂度为<em class="lj"> O(KC)，</em>其中<em class="lj"> C </em>为每个位置的标签数。</p><p id="e965" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">再次，重新排列<em class="lj"> Z(X) </em>的和，使得在给定序列的第<em class="lj">个</em>标签上执行最内部的和，并且从第k个标签遍历到序列的第一个标签。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mw"><img src="../Images/708839f992afa4a3fdb248a3be2e5d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gC0WXlxrar1qkMf-l4PF9g.png"/></div></div></figure><p id="1725" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这次我们引入另一个向量值函数β(。).我们通过在第k个位置对所有可能的标签求和来初始化β函数，并迭代直到第2个位置的标签。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mx"><img src="../Images/0317d4e50c47a0aa7fdf49db5381f274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rQAi1ubq4GPpqEuEm1gug.png"/></div></div></figure><p id="b203" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">从算法1(或2)计算配分函数被称为CRF的向前-向后算法。计算α函数称为前向传递，而计算β函数称为后向传递。上述过程合在一起也称为信念传播。</p><p id="cc5c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在本文中，我们首先对图形模型进行了概述。然后我们讨论了什么是条件随机场及其应用——它的另一种基于上下文的变体。在进行推理时，我们看到了向前向后算法的必要性及其时间复杂性。除了这些主题，我们还应该研究CRF的损失函数以及反向传播在训练时的表现。这些话题可以在另一次讨论中涉及。</p><p id="1328" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">参考资料和进一步阅读:</strong></p><ol class=""><li id="f1fd" class="my mz it kb b kc kd kg kh kk na ko nb ks nc kw nd ne nf ng bi translated">雨果·拉罗彻尔的Youtube系列讲座<a class="ae nh" href="https://www.youtube.com/watch?v=SGZ6BttHMPw&amp;list=PL6Xpj9I5qXYEcOhn7TqghAJ6NAPrNmUBH" rel="noopener ugc nofollow" target="_blank"/></li><li id="1404" class="my mz it kb b kc ni kg nj kk nk ko nl ks nm kw nd ne nf ng bi translated"><a class="ae nh" href="http://www.cs.cmu.edu/~10715-f18/lectures/lecture2-crf.pdf" rel="noopener ugc nofollow" target="_blank">http://www.cs.cmu.edu/~10715-f18/lectures/lecture2-crf.pdf</a></li><li id="4970" class="my mz it kb b kc ni kg nj kk nk ko nl ks nm kw nd ne nf ng bi translated"><a class="ae nh" href="http://www.davidsbatista.net/blog/2017/11/13/Conditional_Random_Fields/" rel="noopener ugc nofollow" target="_blank">http://www . davidsbatista . net/blog/2017/11/13/Conditional _ Random _ Fields/</a></li><li id="25e4" class="my mz it kb b kc ni kg nj kk nk ko nl ks nm kw nd ne nf ng bi translated">条件随机场:分割和标记序列数据的概率模型(<a class="ae nh" href="https://www.seas.upenn.edu/~strctlrn/bib/PDF/crf.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>)</li></ol></div></div>    
</body>
</html>