<html>
<head>
<title>Genetic Algorithm (GA) Introduction with Example Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法介绍及示例代码</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/genetic-algorithm-ga-introduction-with-example-code-e59f9bc58eaf?source=collection_archive---------0-----------------------#2021-01-18">https://pub.towardsai.net/genetic-algorithm-ga-introduction-with-example-code-e59f9bc58eaf?source=collection_archive---------0-----------------------#2021-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dd967e6b76eba78fb40d33fc91f9ef47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Le0zcOjAWy6vXOuBBBC2mQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来源:由<a class="ae jg" href="https://pixabay.com/images/search/genetics/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/illustrations/dna-string-biology-3d-1811955/" rel="noopener ugc nofollow" target="_blank">奇摩诺</a>和<a class="ae jg" href="https://pixabay.com/illustrations/matrix-code-computer-pc-data-356024/" rel="noopener ugc nofollow" target="_blank">康弗里</a>衍生而来</figcaption></figure><h2 id="7efb" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>、<a class="ae ep" href="https://towardsai.net/p/category/editorial" rel="noopener ugc nofollow" target="_blank">编辑</a>、<a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="ecaa" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">遗传算法、优化和Python代码示例实现的介绍</h2></div><p id="f4e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">作者:</strong>苏扬·希罗，<a class="ae jg" href="https://mktg.best/vguzs" rel="noopener ugc nofollow" target="_blank">罗伯托·伊里翁多</a></p><p id="add6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated">他的教程将详细探究遗传算法，并解释它们在Python中的实现。我们还将探索每一步所涉及的不同方法。像往常一样，我们包含代码是为了再现的目的。在探索实现过程中涉及的不同步骤时，我们根据需要对代码进行了拆分。</p><p id="24d0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请务必在<a class="ae jg" href="https://colab.research.google.com/drive/161ijkvn8wG_seVtQexm-p3fW3r5p8s_x?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt"> Google Colab </strong> </a>或<a class="ae jg" href="https://github.com/towardsai/tutorials/tree/master/genetic-algorithm-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt"> Github </strong> </a>上查看本教程的完整实现。</p><div class="is it gp gr iu mm"><a href="https://towardsai.net/backers" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd jt gy z fp mr fr fs ms fu fw js bi translated">加入我们吧↓</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">走向人工智能是一个社区，讨论人工智能，数据科学，数据可视化，深度…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsai.net</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ja mm"/></div></div></a></div><h1 id="9297" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">什么是遗传算法？</h1><p id="4529" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">遗传算法属于一类进化算法，它广泛地受到生物进化的启发。我们都知道生物进化——它是父母的选择、繁殖和后代的变异。进化的主要目的是繁殖在生物学上优于父母的后代。遗传算法主要基于达尔文的自然选择进化理论，并且它试图模拟同样的理论。</p><p id="c0a6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">基本的直觉是从群体中选择最好的个体作为父母，要求他们通过繁殖来延长他们的一代，并在繁殖过程中生育他们的孩子，其中父母双方的交叉基因发生了称为突变的错误。这些孩子再次被要求繁殖他们的后代，这个过程继续下去，导致更健康的一代。这一理论启发了进化计算来解决优化问题、特征选择、经典背包问题等等。</p><p id="6b32" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们用一个背包问题来理解遗传算法的应用。假设我们正在寻宝，经过所有的努力和辛勤工作，我们终于在一个充满黄金和钻石饰品的洞穴深处找到了宝藏。我们想要做的第一件事就是在背包里装满尽可能多的装饰品。然而，在我们的问题中，有几个参数需要考虑，我们的背包空间有限。它不能承载超过35公斤的重量。</p><p id="f075" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们必须选择最佳的装饰品，这样背包就不会超载，我们选择的所有装饰品都必须具有很高的价值，并且一个装饰品不应该损坏背包中的另一个装饰品——这就是遗传算法发挥作用，通过照顾所有参数来优化我们的问题。</p><p id="5ce5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们对遗传算法有了一个基本的概念。让我们看看涉及的步骤，并用Python编写实现代码。</p><h1 id="ffc3" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">遗传算法的步骤</h1><ol class=""><li id="6040" class="ny nz jj lj b lk nt ln nu lq oa lu ob ly oc mc od oe of og bi translated">初始化群体</li><li id="9d79" class="ny nz jj lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">通过评估父母的健康状况来选择他们</li><li id="aebd" class="ny nz jj lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">杂交父母来繁殖</li><li id="70de" class="ny nz jj lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">变异后代</li><li id="1d59" class="ny nz jj lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">评估后代</li><li id="0e77" class="ny nz jj lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">将子代与主种群合并并排序</li></ol><p id="5088" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在遗传算法中，优化问题的候选解群体(称为个体、生物或表型)朝着更好的解进化。每个候选解都有一组可以变异和改变的特性(它的染色体或基因型);传统上，解以二进制表示为0和1的字符串，但其他编码也是可能的[ <a class="ae jg" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank"> 2 </a> ] [ <a class="ae jg" href="http://cobweb.cs.uga.edu/~potter/CompIntell/ga_tutorial.pdf" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]”。</p><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/f7caa615d7e6095977ee9bbd944906e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UHuCl0mv5gojuGId.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图1:染色体、基因和群体。</figcaption></figure><h1 id="5029" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">1.初始化</h1><p id="20f6" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">该算法通常从随机生成的群体开始。人口的多少取决于问题的性质。我们可以使用0和1编码。然而，在本教程中，我们将使用均匀分布的数字来表示每个基因。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="a820" class="ow nc jj os b gy ox oy l oz pa"># Placeholder for every individual<br/>population = {}</span><span id="7af9" class="ow nc jj os b gy pb oy l oz pa"># population size<br/>npop = 20<br/># lower bound<br/>varmin = -10<br/># upper bound<br/>varmax = 10<br/># cost function<br/>costfunc = sphere</span><span id="1468" class="ow nc jj os b gy pb oy l oz pa"># each inidivdual has position(chromosomes) and cost<br/>for i in range(npop):<br/>   population[i] = {'position': None, 'cost': None}</span><span id="dc27" class="ow nc jj os b gy pb oy l oz pa">for i in range(npop):<br/>   population[i]['position'] = np.random.uniform(varmin, varmax,          num_var)<br/>   population[i]['cost'] = costfunc(population[i]['position'])</span></pre><p id="e884" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们创建一个字典来保存群体，每个个体都与染色体(<em class="pc">位置</em>)和一个成本相关联。<em class="pc">位置</em>用随机产生的均匀分布的数(基因)填充，下限-10，上限+10。<em class="pc">成本</em>是我们试图优化的成本函数。在本教程中，我们将优化<em class="pc"> x </em>的平方和，其中<em class="pc"> x </em>是每个染色体的单个基因。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="fe8a" class="ow nc jj os b gy ox oy l oz pa"># cost function<br/>def sphere(x):<br/>   return sum(x**2)</span></pre><h1 id="796e" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">2.亲代选择</h1><p id="3920" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">在每一个连续的世代中，现有种群的一部分被选择来繁殖新一代。通过基于适应度<em class="pc"> - </em>的过程[ <a class="ae jg" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]选择个体解决方案。因为我们是第0代，所以我们没有后代。我们从随机产生的群体中选择父母。有三种主要方法来定义最适合的个体并选择用于育种。</p><ul class=""><li id="e0d3" class="ny nz jj lj b lk ll ln lo lq pd lu pe ly pf mc pg oe of og bi translated"><strong class="lj jt">随机选择</strong>:这是最简单也是最低效的选择亲本的方式。在这种方法中，我们通过执行排列来改组种群，并选择前两个个体作为育种的亲本。不推荐这种方法，因为它不符合“达尔文的自然选择进化理论”，即个体是根据其适应性而不是随机选择的。</li></ul><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="509c" class="ow nc jj os b gy ox oy l oz pa">q = np.random.permutation(npop)<br/>p1 = population[q[0]]<br/>p2 = population[q[1]]</span></pre><ul class=""><li id="d44b" class="ny nz jj lj b lk ll ln lo lq pd lu pe ly pf mc pg oe of og bi translated"><strong class="lj jt">锦标赛选择</strong>:这种方法基于每个个体的选择概率。我们在随机选择的一组个体中运行几个锦标赛，从每组中选择一个个体作为获胜者，并通过将第一次迭代中的获胜者分组来再次运行锦标赛，重复该过程，直到我们收敛到两个获胜者父母用于繁殖。每次迭代中每组的最佳成员具有最高的选择概率。</li><li id="2c70" class="ny nz jj lj b lk oh ln oi lq oj lu ok ly ol mc pg oe of og bi translated"><strong class="lj jt">轮盘赌轮盘选择</strong>:这是一种广泛使用且最有效的选择父母的方法；因此，我们将在今天的算法中使用它。我们都知道赌场里的轮盘赌是如何运作的，丢球，旋转轮盘，然后等到轮盘停下来，看看球落入哪个锅里。让我们更深入地研究一下实现部分。</li></ul><h1 id="4859" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">父母选择的轮盘赌方法</h1><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2000adcf1b8c4da7670f3721c59e431c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sMoHK26bY2O-NzZBGqSmw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">资料来源:<a class="ae jg" href="https://unsplash.com/photos/kQW7xY7ponQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="0d59" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">赌场轮盘赌和用于父母选择的轮盘赌方法之间的唯一区别在于，在赌场轮盘赌中，当轮盘停止旋转时，每个罐具有相等的持球概率。然而，这里我们定义了每个底池(群体中的个体)的概率。每个个体的概率称为个体的适应度。</p><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/3f7fd82be1908ec0071bc1366b3a3870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1KZQfvbi5T2h_rKk.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图2:轮盘赌轮盘选择过程。</figcaption></figure><p id="1a8e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们有四个亲本P1、P2、P3和P4，被选择育种的概率分别为0.1、0.2、0.3、0.4。箭头固定在一个地方，轮子旋转。当轮子停止转动时，箭头所指的亲本被选中进行繁殖——轮子上的区域越大，被选中的概率越大。</p><p id="f04c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们如何编程实现轮盘赌？我们把轮子开成一条均匀的线，把这条线分成种群中的父母数，每个父母在这条线上占据的空间等于其被选中的概率，每个切割点就是概率的累积和。<a class="ae jg" href="https://towardsai.net/p/data-science/random-number-generator-tutorial-with-python-3b35986132c7" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">生成一个0到1之间的随机数</strong> </a>会像箭头一样选择要育种的亲本。这里，随机数是0.28；因此，赢家是P2。</p><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/bd3c41855c846c9f0d16fe1fb3588ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RXV2IqV1sT9NapGq.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图3: <a class="ae jg" href="https://towardsai.net/p/data-science/random-number-generator-tutorial-with-python-3b35986132c7" rel="noopener ugc nofollow" target="_blank"> <strong class="bd nd">生成伪随机数</strong> </a>选择亲本进行配种。</figcaption></figure><p id="67f5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了更简单，我们计算每个父母的概率的累积和，用一个随机产生的数乘以它的和。然后得到累计值大于随机数的第一个父代的索引。例如，P1的累积值为0.1，P2为0.3，P3为0.6，P4为1。如果产生的随机数是0.28，那么累积值大于0.28的第一个亲本是P2，因此是育种的获胜亲本。函数<em class="pc"> argwhere </em>()根据作为参数传递的表达式返回Trues和Falses数组。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="cdf4" class="ow nc jj os b gy ox oy l oz pa">def roulette_wheel_selection(p):<br/>   c = np.cumsum(p)<br/>   r = sum(p) * np.random.rand()<br/>   ind = np.argwhere(r &lt;= c)<br/>   return ind[0][0]</span><span id="9215" class="ow nc jj os b gy pb oy l oz pa">p1 = population[roulette_wheel_selection(<strong class="os jt">probs</strong>)]<br/>p2 = population[roulette_wheel_selection(<strong class="os jt">probs</strong>)]</span></pre><p id="9975" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们通过负beta乘以成本的指数来计算每个父母的概率，其中beta是预定义的整数，成本是每个父母的成本除以群体中所有父母的平均成本。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="0745" class="ow nc jj os b gy ox oy l oz pa"># Calculating probability for roulette wheel selection<br/>beta = 1<br/>for i in range(len(population)):<br/>   # list of all the population cost<br/>   costs.append(population[i]['cost'])</span><span id="c274" class="ow nc jj os b gy pb oy l oz pa">costs = np.array(costs)<br/>avg_cost = np.mean(costs)<br/>if avg_cost != 0:<br/>   costs = costs/avg_cost<br/><strong class="os jt">probs = np.exp(-beta*costs)</strong></span></pre><h1 id="1def" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">3.交叉</h1><p id="f1eb" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">既然我们已经得到了两个用于育种的亲本，下一步就是进行杂交/交配/育种。交叉是指来自双亲染色体的某些基因重叠、混合或交换以产生新后代的过程。由于后代是双亲染色体交叉的结果，它继承了双亲的特征。有三种方法来执行交叉。</p><ul class=""><li id="45a4" class="ny nz jj lj b lk ll ln lo lq pd lu pe ly pf mc pg oe of og bi translated"><strong class="lj jt">单点交叉</strong>:在这种方法中，双亲染色体在同一个随机点被切割，剩下的部分被交换产生两个新的后代染色体。黄色基因代表染色体的截断部分。</li></ul><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/63a9f6e7e1055ac2f979e6783917243e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4yZ7VBKdQV-kcwBv.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图4:单点交叉。</figcaption></figure><ul class=""><li id="d634" class="ny nz jj lj b lk ll ln lo lq pd lu pe ly pf mc pg oe of og bi translated"><strong class="lj jt">两点交叉</strong>:一种类似于单点交叉的方法，唯一不同的是在两个随机点切割亲代染色体。同样，黄色的染色体被切掉的部分被交换了。</li></ul><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/b4500511ca686886cd010d2a4eb32988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pQL21129SObz2vAR.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图5:两点交叉。</figcaption></figure><ul class=""><li id="eeb9" class="ny nz jj lj b lk ll ln lo lq pd lu pe ly pf mc pg oe of og bi translated"><strong class="lj jt">均匀交叉</strong>:我们首先随机选择哪些基因应该从双亲染色体中遗传，没有遗传的基因用黄色标出。然后，我们将它们建模为0和1，用绿色书写。要遗传的基因编码为1，不该遗传的基因编码为0。这一系列的0和1从现在开始将被称为alpha。将双亲的基因值与相应的α值相乘，然后将结果相加，生成后代染色体的单个基因。让我们考虑每个亲代染色体的第一个基因。对于parent-1，基因值为1，对应的alpha值也为1；于是，<strong class="lj jt"> 1x1=1 </strong>。对于parent-2，基因值为0，相应的alpha值也为0，因此，<strong class="lj jt"> 0x0=0 </strong>。后代染色体的第一个基因是<strong class="lj jt"> 1+0=1，</strong>以此类推——这样，我们得到后代-1，为了繁殖后代-2，我们取α的恭维值并执行相同的过程。</li></ul><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/36ef4f12dce3de657e4e5be7106c16ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dUczZqdp4q7N_UqU.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图6:均匀交叉。</figcaption></figure><p id="9382" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过编程，我们将两个父变量复制到子变量c1，c2中。随机生成0到1之间均匀分布的alpha值，这是父染色体的形状(<em class="pc">位置</em>)。过程的其余部分保持不变，除了在理论上，我们取alpha值的补码来产生后代-2，而在程序中，我们在与alpha相乘时交换父代，这与取alpha值的补码相同。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="e6d7" class="ow nc jj os b gy ox oy l oz pa">def crossover(p1, p2):<br/>   c1 = copy.deepcopy(p1)<br/>   c2 = copy.deepcopy(p2)</span><span id="b859" class="ow nc jj os b gy pb oy l oz pa">   alpha = np.random.uniform(0, 1, *(c1['position'].shape))<br/>   c1['position'] = alpha*<strong class="os jt">p1</strong>['position'] + (1-alpha)*<strong class="os jt">p2</strong>['position']<br/>   c2['position'] = alpha*<strong class="os jt">p2</strong>['position'] + (1-alpha)*<strong class="os jt">p1</strong>['position'] </span><span id="4af3" class="ow nc jj os b gy pb oy l oz pa">   return c1, c2</span></pre><h1 id="2387" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">4.变化</h1><p id="58a0" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">突变是由于基因的复制或拷贝错误而发生的自然过程。在进行杂交时，我们通过混合匹配双亲的基因来复制双亲染色体。不能保证亲本基因的复制是100%准确的。总会出现一个错误，这导致了探索的范围。例如，如果你的父母都是棕色眼睛和蓝色眼睛，那很可能是因为在复制你父母的基因时发生了错误而导致的突变，而你的下一代可能会继承这一特征。</p><p id="c619" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">改变遗传算法中的染色体是必要的，因为它可能会产生革命性的结果，有助于更有效地解决我们的问题。所以，我们有三个参数:子染色体(<em class="pc"> c </em>)、突变率(<em class="pc"> mu </em>)和步长(<em class="pc"> sigma </em>)。突变率(<em class="pc"> mu </em>)决定了经历突变的子染色体的百分比。</p><p id="0eb5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了定义哪些基因将发生突变，我们生成随机数并将它们与突变率进行比较，然后使用<em class="pc"> argwhere </em>()函数找到值小于突变率的子染色体(<em class="pc">位置</em>)的索引。用通过将步长(<em class="pc">∑</em>)乘以随机生成的值并将其添加到原始基因而生成的新(突变)基因来替换那些指数。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="d5c2" class="ow nc jj os b gy ox oy l oz pa">def mutate(c, mu, sigma):<br/>   # mu - mutation rate. % of gene to be modified<br/>   # sigma - step size of mutation<br/>   # mutation = original gene + (step size * random number)   </span><span id="f72e" class="ow nc jj os b gy pb oy l oz pa">   y = copy.deepcopy(c)   </span><span id="31a3" class="ow nc jj os b gy pb oy l oz pa">   # array of True and Flase, indicating the mutation position<br/>   flag = np.random.rand(*(c['position'].shape)) &lt;= mu<br/>   ind = np.argwhere(flag)<br/>   y['position'][ind] += sigma * np.random.randn(*ind.shape)</span><span id="ecca" class="ow nc jj os b gy pb oy l oz pa">   return y</span></pre><h1 id="f908" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">5.评估后代</h1><p id="1094" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">一旦后代发生变异，我们需要用代价函数来评估它们，以确定它们的适应度。此外，在每一代/迭代中替换最佳解决方案。</p><pre class="on oo op oq gt or os ot ou aw ov bi"><span id="c845" class="ow nc jj os b gy ox oy l oz pa"># Evaluate first off spring<br/># calculate cost function of child 1<br/>c1['cost'] = costfunc(c1['position'])</span><span id="fa36" class="ow nc jj os b gy pb oy l oz pa">if type(bestsol_cost) == float:<br/>  # replacing best solution in every generation/iteration<br/>  if c1['cost'] &lt; bestsol_cost:<br/>    bestsol_cost = copy.deepcopy(c1)</span><span id="8ba3" class="ow nc jj os b gy pb oy l oz pa">else:<br/>   # replacing best solution in every generation/iteration<br/>   if c1['cost'] &lt; bestsol_cost['cost']:<br/>     bestsol_cost = copy.deepcopy(c1)</span><span id="96b0" class="ow nc jj os b gy pb oy l oz pa"># Evaluate second off spring<br/>if c2['cost'] &lt; bestsol_cost['cost']:<br/>bestsol_cost = copy.deepcopy(c2)</span></pre><h1 id="b62c" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">6.将子代与主种群合并并排序</h1><p id="d7c3" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">融合后代对于它们被认为是父母来繁衍下一代是至关重要的。在对新群体进行分类时，我们在顶部找到了更好的个体。由于群体大小与第一次迭代(<em class="pc"> npop </em>)保持不变，与前一次迭代产生的新子代数量相等的排序群体底部的个体数量从选择过程中被淘汰，以繁殖新的子代，该过程继续——这就是淘汰过程的发生方式。</p><figure class="on oo op oq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/0d51340964fd82ffa7ab02c35686aa94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MSgSz6CzQxbwYM9M.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图7:合并、排序和消除的过程。</figcaption></figure><h1 id="8295" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">结果</h1><p id="999e" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">要运行的迭代次数取决于问题的性质。在本教程中，我们运行500次迭代。</p><figure class="on oo op oq gt iv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/6d04857d9ba2d69610941e2c73e8cb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*EihWHD3UUo04CTRy.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图8:生成遗传算法(GA)实现的结果。</figcaption></figure><p id="66e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以看到在每次迭代中成本是如何降低的，在大约490次迭代中，成本降低到0.134，并且在其余的10次迭代中保持不变。因此，给出了我们的最优解。</p></div><div class="ab cl po pp hx pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="im in io ip iq"><p id="8218" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">免责声明:</strong>本文表达的观点仅代表作者个人观点，不代表卡内基梅隆大学或其他(直接或间接)与作者相关的公司的观点。这些文章并不打算成为最终产品，而是当前思想的反映，同时也是讨论和改进的催化剂。</p><p id="d0b0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">所有图片均来自作者，除非另有说明。</strong></p><p id="642d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过<a class="ae jg" href="https://towardsai.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">向AI </strong> </a>发布</p><h1 id="e91b" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">资源</h1><h2 id="442b" class="ow nc jj bd nd pv pw dn nh px py dp nl lq pz qa nn lu qb qc np ly qd qe nr jp bi translated">教程伙伴</h2><p id="bc3c" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated"><a class="ae jg" href="https://github.com/towardsai/tutorials/tree/master/genetic-algorithm-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt"> Github资源库</strong> </a>。</p><p id="89cb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae jg" href="https://colab.research.google.com/drive/161ijkvn8wG_seVtQexm-p3fW3r5p8s_x?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt"> Google Colab实现</strong> </a> <strong class="lj jt">。</strong></p><h2 id="6301" class="ow nc jj bd nd pv pw dn nh px py dp nl lq pz qa nn lu qb qc np ly qd qe nr jp bi translated">进一步学习</h2><p id="c765" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated"><a class="ae jg" href="https://www.youtube.com/c/YarpizProjects/videos" rel="noopener ugc nofollow" target="_blank"><strong class="lj jt">Youtube上的Yarpiz</strong></a></p><h1 id="b75b" class="nb nc jj bd nd ne nf ng nh ni nj nk nl ky nm kz nn lb no lc np le nq lf nr ns bi translated">参考</h1><p id="f071" class="pw-post-body-paragraph lh li jj lj b lk nt kt lm ln nu kw lp lq nv ls lt lu nw lw lx ly nx ma mb mc im bi translated">[1]“进化”。2021.En.Wikipedia.Org。【https://en.wikipedia.org/wiki/Evolution. T4】</p><p id="b41b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">[2]“遗传算法”。2011.En.Wikipedia.Org。<a class="ae jg" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Genetic_algorithm</a>。</p><p id="6ee0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">[3]遗传算法教程，Darrel Whitley，2021。Cobweb.Cs.Uga.Edu。<a class="ae jg" href="https://ibug.doc.ic.ac.uk/media/uploads/documents/courses/GeneticAlgorithm-tutorial.pdf" rel="noopener ugc nofollow" target="_blank">http://cobweb . cs . uga . edu/~ Potter/compin tel/ga _ tutorial . pdf .</a></p></div></div>    
</body>
</html>