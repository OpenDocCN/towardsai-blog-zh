<html>
<head>
<title>8 Active Learning Insights of Python Collection Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8 Python集合模块的主动学习见解</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b?source=collection_archive---------0-----------------------#2021-08-05">https://pub.towardsai.net/8-active-learning-insights-of-python-collection-module-6c9e0cc16f6b?source=collection_archive---------0-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="76cd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="669c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据收集容器</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/88b3851673ef286b187a969a687cb392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2geHqPV1vJxntUSP"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@afgprogrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="li lj lk"><p id="0ffc" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">采集模块</em> </strong></p></blockquote><p id="dc8e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">python集合模块是一个容器，用于存储许多数据集合，如对象，并提供对这些包含的对象的访问。列表、元组和字典是一些内置的容器。这些模块主要是为了改进这些内置收集容器的功能。让我们看一下集合模块提供的一些特殊类型的容器。</p><blockquote class="li lj lk"><p id="af19" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">涵盖的主题</em> </strong></p></blockquote><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="1b22" class="mq mr it mm b gy ms mt l mu mv">1. Counters<br/>2. Ordered Dic<br/>3. Default Dic<br/>4. Chain Map<br/>5. Named Tuple<br/>6. DeQue<br/>7. User Dic<br/>8. User List<br/>9. User String</span></pre><blockquote class="li lj lk"><p id="ed96" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">计数器</em> </strong></p></blockquote><p id="2487" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">计数器是一个字典子类，我们用它来计算可散列对象。</p><p id="896e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类集合。计数器([可迭代或映射])</p><p id="5706" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">例子:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="5f81" class="mq mr it mm b gy ms mt l mu mv">from collections import Counter</span><span id="7520" class="mq mr it mm b gy mw mt l mu mv">numbers = [9, 5, 7, 4, 7, 10, 9, 10, 3, 5, 3, 6, 8, 4, 5, 10, 5]<br/>Count = Counter(numbers)</span><span id="5a1a" class="mq mr it mm b gy mw mt l mu mv">print(Count)<br/>print(list(Count.elements()))<br/>print(Count.most_common())</span><span id="d155" class="mq mr it mm b gy mw mt l mu mv">sub = {10:1, 9:2}<br/>print(Count.subtract(sub))<br/>print(Count.most_common())</span><span id="9819" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>Counter({5: 4, 10: 3, 9: 2, 7: 2, 4: 2, 3: 2, 6: 1, 8: 1})<br/>[9, 9, 5, 5, 5, 5, 7, 7, 4, 4, 10, 10, 10, 3, 3, 6, 8]<br/>[(5, 4), (10, 3), (9, 2), (7, 2), (4, 2), (3, 2), (6, 1), (8, 1)]<br/>None<br/>[(5, 4), (7, 2), (4, 2), (10, 2), (3, 2), (6, 1), (8, 1), (9, 0)]</span></pre><p id="9a28" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解释:</strong></p><ul class=""><li id="a7b5" class="mx my it lo b lp lq ls lt mi mz mj na mk nb mh nc nd ne nf bi translated">这里，第一个代码片段是查找每个唯一元素的计数。输出以字典的形式返回。输出格式:首先是元素，接着是冒号，然后是它在列表中出现的次数。(5:4)</li><li id="12fc" class="mx my it lo b lp ng ls nh mi ni mj nj mk nk mh nc nd ne nf bi translated">第二段代码显示了一个列表，其中包含每个唯一元素的所有重复元素。</li><li id="615b" class="mx my it lo b lp ng ls nh mi ni mj nj mk nk mh nc nd ne nf bi translated">第三个代码片段以元组的形式显示每个唯一元素的计数。</li><li id="9bda" class="mx my it lo b lp ng ls nh mi ni mj nj mk nk mh nc nd ne nf bi translated">第四个代码片段是使用subtract函数减少特定元素的计数。</li></ul><p id="e065" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">上述程序也使用元组、列表、集合和字典来执行。</p><blockquote class="li lj lk"><p id="5cd7" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd">命令<em class="it">命令</em>命令</strong></p></blockquote><p id="6886" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">OrderedDict也是dictionary的子类。它的功能是记住输入的顺序。</p><p id="8cb2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类集合。OrderDict()</p><p id="72b0" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">例如:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="89bb" class="mq mr it mm b gy ms mt l mu mv">from collections import OrderedDict</span><span id="ebd1" class="mq mr it mm b gy mw mt l mu mv">od = OrderedDict()<br/>od[2] = ‘h’<br/>od[5] = ‘e’<br/>od[4] = ‘l’<br/>od[7] = ‘l’<br/>od[9] = ‘o’</span><span id="b522" class="mq mr it mm b gy mw mt l mu mv">print(od)<br/>print(od.keys())</span><span id="0395" class="mq mr it mm b gy mw mt l mu mv">od[2] = ‘b’<br/>print(od)</span><span id="a207" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>OrderedDict([(2, ‘h’), (5, ‘e’), (4, ‘l’), (7, ‘l’), (9, ‘o’)])<br/>odict_keys([2,5,4,7,9])<br/>OrderedDict([(2, ‘b’), (5, ‘e’), (4, ‘l’), (7, ‘l’), (9, ‘o’)])</span></pre><p id="fc62" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解释:</strong></p><ul class=""><li id="e628" class="mx my it lo b lp lq ls lt mi mz mj na mk nb mh nc nd ne nf bi translated">第一个代码片段按照条目的顺序显示存储的元素作为输出。</li><li id="69a9" class="mx my it lo b lp ng ls nh mi ni mj nj mk nk mh nc nd ne nf bi translated">第二个代码片段按照输入的顺序只显示键作为输出。</li><li id="d2da" class="mx my it lo b lp ng ls nh mi ni mj nj mk nk mh nc nd ne nf bi translated">第三个代码片段是将存储在“od[2]”中的元素替换为“b”，作为最终输出。</li></ul><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/standardization-in-data-preprocessing-with-python-96ae89d2f658"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">用Python实现数据预处理的标准化</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">机器学习和深度学习算法中的缩放方法</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pub.towardsai.net</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lb no"/></div></div></a></div><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/a-comprehensive-guide-of-regular-expressions-using-python-6ff8de3d1a67"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">使用Python的正则表达式综合指南</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">文本分析中“重”模块的概念</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pub.towardsai.net</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc lb no"/></div></div></a></div><blockquote class="li lj lk"><p id="6bd4" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"><em class="it"/></strong></p></blockquote><p id="1270" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">DefaultDict也是一本字典。它的功能是调用工厂函数来提供缺失的值。</p><p id="cb7e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>class collections . default dict(default _ factory)</p><p id="f773" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">举例:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="f2c3" class="mq mr it mm b gy ms mt l mu mv">from collections import defaultdict</span><span id="7497" class="mq mr it mm b gy mw mt l mu mv">dd = defaultdict(int)<br/>dd[1] = ‘hello’<br/>dd[2] = ‘world’</span><span id="d506" class="mq mr it mm b gy mw mt l mu mv">print(dd[3])</span><span id="f03b" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>0</span></pre><p id="0758" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解说:</strong></p><p id="0d4d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这里，因为我们在这里使用了defaultdict()函数，所以在显示第三个字符串(未创建)时，输出显示为“0”而不是“关键字错误”消息。</p><blockquote class="li lj lk"><p id="843e" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">链图</em> </strong></p></blockquote><p id="ae1d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">链表也是类下的字典。它用于创建多个映射的单一视图。</p><p id="75e2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类集合。链式映射(字典1，字典2)</p><p id="414a" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">示例:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="5063" class="mq mr it mm b gy ms mt l mu mv">from collections import ChainMap</span><span id="7689" class="mq mr it mm b gy mw mt l mu mv">sub1 = {1: ‘Maths’, 2: ‘English’, 3: ‘Science’}<br/>sub2 = {4: ‘Social’, 5: ‘Computer’, 6: ‘Hindi’}<br/>subt = ChainMap(sub1, sub2)</span><span id="4c4b" class="mq mr it mm b gy mw mt l mu mv">print(subt)</span><span id="2fe6" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>ChainMap({1: ‘Maths’, 2: ‘English’, 3: ‘Science’}, {4: ‘Social’, 5: ‘Computer’, 6: ‘Hindi’})</span></pre><p id="9105" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">解释:</strong>从上面的程序中我们可以看到，在python中可以获得多个映射的单个视图。这里创建了两个字典(sub1 &amp; sub2)。在使用ChianMap函数时，两个字典显示为一个视图。</p><blockquote class="li lj lk"><p id="7746" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">名为</em> </strong></p></blockquote><p id="4fbc" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">namedtuple()返回一个元组，该元组由元组中每个元素的命名值组成。该容器也用于列表存储和访问数据。</p><p id="ed78" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">语法:class collections . named tuple(typename，field_names)</p><p id="7f9a" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">例如:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="6c27" class="mq mr it mm b gy ms mt l mu mv">from collections import namedtuple</span><span id="c8fb" class="mq mr it mm b gy mw mt l mu mv">Employee = namedtuple(‘Details’, [‘name’, ‘age’, ‘gender’])<br/>a = Employee(‘Ram’, 24, ‘Male’)</span><span id="d205" class="mq mr it mm b gy mw mt l mu mv">print(a)<br/>print(a[2])<br/>print(a.age)</span><span id="23a1" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output: <br/></strong>Details(name=‘Ram’, age=24, gender=’Male’)<br/>Male<br/>24</span></pre><p id="cfd2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">说明:</strong>这里程序执行将数据存储在一个命名字段下，需要时可以访问。第一步是导入集合库。下一步是声明我们想要存储的数据的类型名和字段名。之后，将数据存储在这些字段中(第3行)。我们现在可以看到数据存储在声明的属性中。也可以使用索引来访问数据。</p><blockquote class="li lj lk"><p id="3627" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">德奎</em> </strong></p></blockquote><p id="556c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">deque是一个优化的列表，可以非常容易地执行插入和删除等功能。</p><p id="781b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类collections.deque(list)</p><p id="ada6" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">例如:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="0f78" class="mq mr it mm b gy ms mt l mu mv">from collections import deque</span><span id="1cff" class="mq mr it mm b gy mw mt l mu mv">job = [‘e’, ‘l’, ‘e’, ‘c’, ‘t’, ‘r’, ‘i’, ‘c’]</span><span id="dcbf" class="mq mr it mm b gy mw mt l mu mv">b = deque(job)<br/>print(b)</span><span id="5b90" class="mq mr it mm b gy mw mt l mu mv">b.appendleft(‘mechanics’)<br/>print(b)</span><span id="0bdf" class="mq mr it mm b gy mw mt l mu mv">b.popleft()<br/>print(b)</span><span id="325b" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>deque([‘e’, ‘l’, ‘e’, ‘c’, ‘t’, ‘r’, ‘i’, ‘c’])<br/>deque([‘mechanics’, ‘e’, ‘l’, ‘e’, ‘c’, ‘t’, ‘r’, ‘i’, ‘c’])<br/>deque([‘e’, ‘l’, ‘e’, ‘c’, ‘t’, ‘r’, ‘i’, ‘c’])</span></pre><p id="9dc8" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">说明:</strong>上面的程序描述了在一个列表中插入和删除。第一步是导入集合库。在这里，我们创建了一个名为“job”的列表主要目的是将字符串“mechanic”插入到创建的列表的最左侧位置。因此我们使用appendleft()函数。现在，为了删除最左边的元素，我们使用函数popleft()。</p><div class="nl nm gp gr nn no"><a rel="noopener  ugc nofollow" target="_blank" href="/image-processing-morphological-operations-with-python-7e0f8d1983eb"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jd gy z fp nt fr fs nu fu fw jc bi translated">图像处理:用Python进行形态学运算</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">为了从图像中去除噪声</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pub.towardsai.net</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc lb no"/></div></div></a></div><blockquote class="li lj lk"><p id="5e13" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it"> UserDict </em> </strong></p></blockquote><p id="ef03" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">UserDict类充当字典对象的包装器，使字典的子类化更容易。当我们想要创建一个具有一些修改功能或新功能的字典时，这个类是很有用的。最后，这个字典可以通过类的数据属性来访问。</p><p id="a949" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类集合。用户字典([初始数据])</p><p id="3805" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">举例:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="d858" class="mq mr it mm b gy ms mt l mu mv">from collections import UserDict</span><span id="d480" class="mq mr it mm b gy mw mt l mu mv">ud = {1:’h’, 2:’a’, 3:’i’}</span><span id="0476" class="mq mr it mm b gy mw mt l mu mv">usdi = UserDict(ud)<br/>print(usdi.data)</span><span id="a3bb" class="mq mr it mm b gy mw mt l mu mv">usdi = UserDict()<br/>print(usdi.data)</span><span id="1d12" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>{1: ‘h’, 2: ‘a’, 3: ‘i’}<br/>{}</span></pre><blockquote class="li lj lk"><p id="9a6f" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">用户列表</em> </strong></p></blockquote><p id="c9eb" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">UserList类充当列表的包装器，使列表的子类化更容易。当我们想要创建一个包含一些修改过的功能或新功能的列表时，这个类是很有用的。最后，列表可以通过类的数据属性来访问。</p><p id="e225" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类集合。用户列表([列表])</p><p id="8e11" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">示例:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="ee71" class="mq mr it mm b gy ms mt l mu mv">from collections import UserList</span><span id="052a" class="mq mr it mm b gy mw mt l mu mv">ul = [‘h’,’e’,’l’,’l’,’o’]</span><span id="1148" class="mq mr it mm b gy mw mt l mu mv">usli = UserList(ul)<br/>print(usli.data)</span><span id="52c2" class="mq mr it mm b gy mw mt l mu mv">usli = UserList()<br/>print(usli.data)</span><span id="16ae" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>[‘h’, ‘e’, ‘l’, ‘l’, ‘o’]<br/>[]</span></pre><blockquote class="li lj lk"><p id="8291" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">用户字符串</em> </strong></p></blockquote><p id="9fe7" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">UserString类还充当String对象的包装器，使字符串的子类化更容易。当我们想要创建一个包含一些修改过的功能或新功能的列表时，这个类是很有用的。这个类更容易使用，因为底层字符串可以作为属性访问。最后，这个字符串可以被类的数据属性访问。</p><p id="034b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">语法:</strong>类集合。用户字符串(序列)</p><p id="4192" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><strong class="lo jd">示例:</strong></p><pre class="ks kt ku kv gt ml mm mn mo aw mp bi"><span id="0df7" class="mq mr it mm b gy ms mt l mu mv">from collections import UserString</span><span id="48e7" class="mq mr it mm b gy mw mt l mu mv">str = ‘hello’</span><span id="3c92" class="mq mr it mm b gy mw mt l mu mv">us = UserString(str)<br/>print(us.data)</span><span id="80f0" class="mq mr it mm b gy mw mt l mu mv">us = UserString(“”)<br/>print(“Empty string is created”,us.data)</span><span id="39dd" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm jd">Output:<br/></strong>hello<br/>Empty string is created</span></pre><blockquote class="li lj lk"><p id="7924" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd"> <em class="it">结论</em> </strong></p></blockquote><p id="4f76" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">总之，本文涵盖了9个Python集合模块的基础知识。我强烈建议阅读更多的文章，因为在每个模块中有许多功能，你可以在这个主题上进行实验。</p><p id="cfb0" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="9c86" class="of mr it bd og oh oi oj ok ol om on oo ki op kj oq kl or km os ko ot kp ou ov bi translated">推荐文章</h1><p id="6370" class="pw-post-body-paragraph ll lm it lo b lp ow kd lr ls ox kg lu mi oy lx ly mj oz mb mc mk pa mf mg mh im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/numpy-linear-algebra-on-images-ed3180978cdb?source=friends_link&amp;sk=d9afa4a1206971f9b1f64862f6291ac0"> NumPy:图像上的线性代数</a>T5】3。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/principal-component-analysis-in-dimensionality-reduction-with-python-1a613006d531?source=friends_link&amp;sk=3ed0671fdc04ba395dd36478bcea8a55">用Python进行主成分分析降维</a> <br/> 5。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-k-means-clustering-with-python-e7caa573176a?source=friends_link&amp;sk=9c5c613ceb10f2d203712634f3b6fb28" rel="noopener">用Python全面讲解K-means聚类</a> <br/> 6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae lh" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>