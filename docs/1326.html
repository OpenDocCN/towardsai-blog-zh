<html>
<head>
<title>ResNeXt: from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ResNeXt:从零开始</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/resnext-from-scratch-e73110530586?source=collection_archive---------7-----------------------#2020-12-31">https://pub.towardsai.net/resnext-from-scratch-e73110530586?source=collection_archive---------7-----------------------#2020-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c7c0fc3fd0286a830e145a6d888b4ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ly9MZGqNdI0MM9hA"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来源:<a class="ae jd" href="https://unsplash.com/photos/8bghKxNU1j0" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="3fd3" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/computer-vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>，<a class="ae ep" href="https://towardsai.net/p/category/research" rel="noopener ugc nofollow" target="_blank">研究</a></h2><div class=""/><p id="6149" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">ResNeXt遵循一个简单的概念“分而治之”。ResNeXt通常被称为“ResNet”的扩展版本。它的一些重要应用是在生物医学工程领域，尤其是在生物成像领域。在这里，我将探索“ResNeXt的制作:从零开始”</p><blockquote class="lk"><p id="aa21" class="ll lm jg bd ln lo lp lq lr ls lt lj dk translated">模块:PyTorch、CUDA(可选)</p></blockquote><p id="e3dc" class="pw-post-body-paragraph km kn jg ko b kp lu kr ks kt lv kv kw kx lw kz la lb lx ld le lf ly lh li lj ij bi translated">如果你对如何在你的系统中安装PyTorch感到困惑，那么你可能想看看这里的<a class="ae jd" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">链接</a>。它会帮助你！向前发展…</p><h1 id="7001" class="lz ma jg bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">ResNeXt</h1><p id="11bf" class="pw-post-body-paragraph km kn jg ko b kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj ij bi translated">ResNeXt体系结构与ResNet体系结构非常相似。如果你想了解ResNet架构，那么请往<a class="ae jd" href="https://medium.com/analytics-vidhya/resnet-from-scratch-638e901e0934" rel="noopener">这个方向</a>走。这是一种基于深度学习的算法，其主要任务是理解图像特征的更深层次的见解。那我们怎么开始呢？…</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="4f31" class="nl ma jg nh b gy nm nn l no np">import torch<br/>import torch.nn as nn</span></pre><p id="e1c0" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这是在Python环境中初始化PyTorch库的初始代码块。这些都是非常庞大的架构，因此需要大量的计算。默认情况下，架构会期望系统具有良好的规格(就CPU和GPU容量而言),能够在适当的时间内以最高的准确性完成任务。</p><p id="8d16" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，如果你是Python的新手，想要了解这些大型CNN架构的基础，那么这可能对你没有什么帮助，因为在“ResNeXt”的定义中，定义了许多继承和类实例，这对有经验的程序员来说甚至很难。这对新手来说可能会很刺眼，因此我会要求你先浏览一下<a class="ae jd" href="https://www.youtube.com/watch?v=SiBw7os-_zI&amp;ab_channel=freeCodeCamp.org" rel="noopener ugc nofollow" target="_blank">OOPs</a>的基础知识。</p><blockquote class="lk"><p id="9ae6" class="ll lm jg bd ln lo lp lq lr ls lt lj dk translated">哎呀够舒服了吧？让我们继续前进…</p></blockquote><pre class="nq nr ns nt nu ng nh ni nj aw nk bi"><span id="41dd" class="nl ma jg nh b gy nm nn l no np">class resnext_block(nn.Module):<br/>    def __init__(self, in_channels, cardinality, bwidth, idt_downsample=None, stride=1):<br/>        super(resnext_block, self).__init__()<br/>        self.expansion = 2<br/>        out_channels = cardinality * bwidth<br/>        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0)<br/>        self.bn1 = nn.BatchNorm2d(out_channels)<br/>        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, groups=cardinality, stride=stride, padding=1)<br/>        self.bn2 = nn.BatchNorm2d(out_channels)<br/>        self.conv3 = nn.Conv2d(out_channels, out_channels*self.expansion, kernel_size=1, stride=1, padding=0)<br/>        self.bn3 = nn.BatchNorm2d(out_channels*self.expansion)<br/>        self.relu = nn.ReLU()<br/>        self.identity_downsample = idt_downsample</span></pre><p id="1ad1" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">从层块的定义开始，在第一个块中，我们定义了继续推进结构所需的后续组件。这只是初始化阶段。每当我们调用该类时，该类要做的第一件事就是初始化这些模块以及它们定义的规范。</p><p id="383b" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你已经学习了ResNet和ResNeXt 的<a class="ae jd" href="https://arxiv.org/abs/1611.05431" rel="noopener ugc nofollow" target="_blank">研究论文，你可能会想到的一件事是，我们有在前面的函数中定义的组的基数和基宽。我们没有在ResNet中定义它，因为现在我们正在划分整个结构并将它们并排堆叠，然后分析一切。因此,“基数”将定义整个体系结构中的组，而基宽将完全定义体系结构中的“外部通道”。</a></p><blockquote class="lk"><p id="f110" class="ll lm jg bd ln lo lp lq lr ls lt lj dk translated">下一步做什么？…</p></blockquote><pre class="nq nr ns nt nu ng nh ni nj aw nk bi"><span id="6e49" class="nl ma jg nh b gy nm nn l no np">def forward(self, x):<br/>        identity = x<br/>        x = self.conv1(x)<br/>        x = self.bn1(x)<br/>        x = self.relu(x)<br/>        x = self.conv2(x)<br/>        x = self.bn2(x)<br/>        x = self.relu(x)<br/>        x = self.conv3(x)<br/>        x = self.bn3(x)<br/>        <br/>        if self.identity_downsample is not None:<br/>            identity = self.identity_downsample(identity)<br/>            <br/>        x += identity<br/>        x = self.relu(x)<br/>        return x</span></pre><p id="f445" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">初始化后将立即调用“forward”函数。正如研究论文中所描述的，这将有序地包含所有的方法。你可以在<a class="ae jd" href="https://medium.com/analytics-vidhya/resnet-from-scratch-638e901e0934" rel="noopener"> ResNet </a>博客中找到“转发”功能的相似之处。</p><blockquote class="lk"><p id="8cd2" class="ll lm jg bd ln lo lp lq lr ls lt lj dk translated">为您呈现全新的架构…</p></blockquote><pre class="nq nr ns nt nu ng nh ni nj aw nk bi"><span id="cca6" class="nl ma jg nh b gy nm nn l no np">class ResNeXt(nn.Module):<br/>    def __init__(self, resnet_block, layers, cardinality, bwidth, img_channels, num_classes):<br/>        super(ResNeXt, self).__init__()<br/>        self.in_channels = 64<br/>        self.conv1 = nn.Conv2d(img_channels, 64, kernel_size=7, stride=2, padding=3)<br/>        self.bn1 = nn.BatchNorm2d(64)<br/>        self.relu = nn.ReLU()<br/>        self.cardinality = cardinality<br/>        self.bwidth = bwidth<br/>        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)<br/>        <br/>        # ResNeXt Layers<br/>        self.layer1 = self._layers(resnext_block, layers[0], stride=1)<br/>        self.layer2 = self._layers(resnext_block, layers[1], stride=2)<br/>        self.layer3 = self._layers(resnext_block, layers[2], stride=2)<br/>        self.layer4 = self._layers(resnext_block, layers[3], stride=2)<br/>        <br/>        self.avgpool = nn.AdaptiveAvgPool2d((1,1))<br/>        self.fc = nn.Linear(self.cardinality * self.bwidth, num_classes)</span></pre><p id="125e" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们来看“ResNeXt”架构的正式定义。同样，这是初始化阶段。人们可能会注意到，有一些' _layers '方法的初始化，但没有定义相同的实例。我们将在接下来的步骤中对其进行定义…</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="1402" class="nl ma jg nh b gy nm nn l no np">def forward(self, x):<br/>        x = self.conv1(x)<br/>        x = self.bn1(x)<br/>        x = self.relu(x)<br/>        x = self.maxpool(x)<br/>        <br/>        x = self.layer1(x)<br/>        x = self.layer2(x)<br/>        x = self.layer3(x)<br/>        x = self.layer4(x)<br/>        <br/>        x = self.avgpool(x)<br/>        x = x.reshape(x.shape[0], -1)<br/>        x = self.fc(x)<br/>        return x</span></pre><p id="d418" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">“前进”功能来了。我们的ResNeXt函数被正式定义了。我们按照论文中的定义构建“前进”函数。使用Conv层的初始阶段，然后根据需要设置整个层。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="60b6" class="nl ma jg nh b gy nm nn l no np">def _layers(self, resnext_block, no_residual_blocks, stride):<br/>        identity_downsample = None<br/>        out_channels = self.cardinality * self.bwidth<br/>        layers = []<br/>        <br/>        if stride != 1 or self.in_channels != out_channels * 2:<br/>            identity_downsample = nn.Sequential(nn.Conv2d(self.in_channels, out_channels*2, kernel_size=1,<br/>                                                          stride=stride),<br/>                                                nn.BatchNorm2d(out_channels*2))<br/>        <br/>        layers.append(resnext_block(self.in_channels,  self.cardinality, self.bwidth, identity_downsample, stride))<br/>        self.in_channels = out_channels * 2<br/>        <br/>        for i in range(no_residual_blocks - 1):<br/>            layers.append(resnext_block(self.in_channels, self.cardinality, self.bwidth))<br/>        <br/>        self.bwidth *= 2<br/>        <br/>        return nn.Sequential(*layers)</span></pre><p id="78c7" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">所以，我们已经定义了一切，是时候来确定我们的推测是否正确了。我们可以实现下面给出的代码块来测试架构。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f09d" class="nl ma jg nh b gy nm nn l no np">def ResNeXt50(img_channels=3, num_classes=1000, cardinality=32, bwidth=4):<br/>    return ResNeXt(resnext_block, [3,4,6,3],  cardinality, bwidth, img_channels, num_classes)</span></pre><p id="74b5" class="pw-post-body-paragraph km kn jg ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们完了。那是一项艰巨的工作。谢谢你坚持到最后。这是CNN领域中的一个重要架构，理解它确实很困难！如果您需要进一步的帮助，请参阅以下部分…</p><h1 id="9be9" class="lz ma jg bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">救援马上就到！</h1><p id="a5e0" class="pw-post-body-paragraph km kn jg ko b kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj ij bi translated">如果你仍然觉得你需要完整的代码，那么请点击这里的<a class="ae jd" href="https://github.com/tanmaydn/CNNfromScratch/blob/main/ResNeXt.py" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h1 id="5ada" class="lz ma jg bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">参考</h1><p id="d564" class="pw-post-body-paragraph km kn jg ko b kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj ij bi translated">请查阅研究人员的<a class="ae jd" href="https://arxiv.org/abs/1611.05431" rel="noopener ugc nofollow" target="_blank">原创作品。</a></p></div></div>    
</body>
</html>