<html>
<head>
<title>Exploratory Analysis and Visualization of Time-series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据的探索性分析和可视化</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/exploratory-analysis-and-visualization-of-time-series-data-53aa5c8b547f?source=collection_archive---------0-----------------------#2020-06-17">https://pub.towardsai.net/exploratory-analysis-and-visualization-of-time-series-data-53aa5c8b547f?source=collection_archive---------0-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6a8e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-visualization" rel="noopener ugc nofollow" target="_blank">数据可视化</a></h2><div class=""/><div class=""><h2 id="c388" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据争论、创建时间序列对象、过滤和可视化，所有这些都是您可以充分利用时间序列数据的事情</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e9bd1b5621b656658831e57441ef471c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1wuZ_RxgigNqJLb"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">杰克·希尔斯在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="a766" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">时间序列是你能遇到的最简单的数据形式。为什么简单？因为它的核心只是一列观察值和另一列相应的时间段。</p><p id="d8e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从实用的角度来看，时间序列也是最重要的数据类型之一。仅仅一个简单的时间序列图就可以揭示如此多的信息，即使是未经训练的眼睛也可以提取有价值的见解，以做出重要的商业决策。</p><p id="f085" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而…..</p><p id="6cdd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果处理不当，这种最简单的数据形式、最重要的讲述者和最广泛使用的数据类型可能很难处理。</p><p id="4b00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在本文中，我将触及时间序列分析的一些基本分析过程——对于理解数据、讲故事或高级建模和预测至关重要。</p><p id="c0d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们开始吧。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="22d3" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">1.数据争论</h1><p id="786b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">数据争论包含广泛的活动，可以说是数据科学中最耗时的任务。一些人经常指出，数据争论是数据科学家在任何一天所做的80%的工作。</p><p id="d55a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 1.1导入&amp;检查</strong></p><p id="2763" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一项任务是导入数据。在这个演示中，我使用了<a class="ae lh" href="https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv" rel="noopener ugc nofollow" target="_blank">一个预先格式化的数据集</a>，这样你就可以跟着练习了。这是一个关于各种形式的能源消耗的多元数据，在2006年至2017年之间每月报告一次。它共有4，383个观察值和7列。您需要以下几行代码来获取机器上的数据。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="d085" class="nn mm it nj b gy no np l nq nr"># import libraries<br/>import pandas as pd<br/>import numpy as np</span><span id="303d" class="nn mm it nj b gy ns np l nq nr"># import data<br/>data = "<a class="ae lh" href="https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv</a>"</span><span id="b6a3" class="nn mm it nj b gy ns np l nq nr">df = pd.read_csv(data)</span><span id="9a25" class="nn mm it nj b gy ns np l nq nr"># take a peek <br/>df.head()</span></pre><p id="52cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">导入后，您想通过调用<code class="fe nt nu nv nj b">head()</code>函数来了解数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/10a8643ba73dd7abcdd72b68dd4d541c.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*K9_MUXKKIgddUOwdLqlp3g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:调用head()函数来查看数据集</figcaption></figure><p id="a1b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以做的一些其他操作是选择和重命名列、排序和过滤、分组、合并等。您还需要检查数据中可能丢失的值。以下代码行为您提供了每一列的所有null值的总和。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a322" class="nn mm it nj b gy no np l nq nr">df.isnull().sum()</span></pre><p id="d6a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2处理缺失值</strong></p><p id="ef46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个干净的玩具数据集，所以它没有任何空值，但如果有空值，有几个选项可以处理它们:</p><ul class=""><li id="99c8" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">行删除:</strong>如果数据集相对较大，则删除缺少值的完整记录</li><li id="7bae" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd">替换:</strong>用(a)列平均值、(b)最近邻居的平均值、(c)移动平均值或(d)用最后一次观察值填充来替换缺失的单元格</li><li id="e814" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd">统计插补:</strong>在给定数据集中其他信息的情况下，回归可能是确定缺失像元值的有效方法</li></ul><h1 id="6a03" class="ml mm it bd mn mo ol mq mr ms om mu mv ki on kj mx kl oo km mz ko op kp nb nc bi translated"><strong class="ak"> 2。创建时间序列对象</strong></h1><p id="5748" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">原始数据通常不针对时间序列分析进行格式化，因此编程库(例如<code class="fe nt nu nv nj b">pandas</code>)将它们视为任何其他数据帧，其中时间维度存储为字符串而不是<code class="fe nt nu nv nj b">datetime</code>对象。所以首要任务是将普通的数据框架转换成时间序列对象。</p><p id="ace9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，您需要遵循以下步骤:</p><ul class=""><li id="be18" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">将时间列转换成<code class="fe nt nu nv nj b">datetime</code>对象</li><li id="1cd7" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">将新列设置为系列的索引</li><li id="926f" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">通过分解时间索引创建新列(例如，2020–06–12获得三个新列:年、月和日)</li></ul><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="8216" class="nn mm it nj b gy no np l nq nr"># convert Date column to a datetime object<br/>df["Date"] = pd.to_datetime(df["Date"])</span><span id="dfa6" class="nn mm it nj b gy ns np l nq nr"># set Date as the index<br/>df = df.set_index("Date")</span><span id="5781" class="nn mm it nj b gy ns np l nq nr"># add new columns by splitting index<br/>df["Year"] = df.idex.year<br/>df["Month"] = df.index.month<br/>df["Weekday"] = df.index.weekday_name</span><span id="dfcc" class="nn mm it nj b gy ns np l nq nr"># take a peek at the new dataframe<br/>df.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4cd713fdc19fde7987e9b6894b7a2500.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*D_4IKcF7M9r2GGUUsqFgBw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:转换为日期时间对象并设置为索引的日期列</figcaption></figure><h1 id="165b" class="ml mm it bd mn mo ol mq mr ms om mu mv ki on kj mx kl oo km mz ko op kp nb nc bi translated"><strong class="ak"> 3。限幅/滤波</strong></h1><p id="5b64" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">既然您已经将普通的数据框转换为时间序列对象，那么就没有限制了！你可以随心所欲地对数据进行切片、切块和过滤，也可以随心所欲地以不同的方式呈现和可视化。例如，现在可以过滤特定年/月/日或特定日期范围的数据:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a8bf" class="nn mm it nj b gy no np l nq nr"># filtering data for a specific year<br/>df.loc["2006"]</span><span id="0262" class="nn mm it nj b gy ns np l nq nr"># filter data for a specific month of the year<br/>df.loc["2006-01"]</span><span id="784d" class="nn mm it nj b gy ns np l nq nr"># filter data within a range of dates<br/>df.loc["2006-02-02" : "2007-01-12"]</span></pre><h1 id="9c03" class="ml mm it bd mn mo ol mq mr ms om mu mv ki on kj mx kl oo km mz ko op kp nb nc bi translated"><strong class="ak"> 4。可视化</strong></h1><p id="e61b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一张图胜过千言万语！</p><p id="0607" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据可视化是数据科学的基础，无论是用于探索性数据分析、构建更好的模型，还是用于可视化<a class="ae lh" href="https://towardsdatascience.com/storytelling-with-data-a-data-visualization-guide-for-business-professionals-97d50512b407" rel="noopener" target="_blank">讲故事</a>。</p><p id="2b24" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">时间序列数据更是如此。很难想象一个没有情节的时间序列分析；下面是我展示的几个基本情节，但是，天空才是极限！</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="13b4" class="nn mm it nj b gy no np l nq nr"># install libraries<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span><span id="2925" class="nn mm it nj b gy ns np l nq nr"># set default figure dimensions<br/>sns.set(rc={'figure.figsize':(11, 4)})</span></pre><h2 id="dfb6" class="nn mm it bd mn or os dn mr ot ou dp mv lr ov ow mx lv ox oy mz lz oz pa nb iz bi translated">4.1单变量</h2><p id="48c2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一旦读入数据并将其转换为时间序列对象，第一个图通常是简单的可视化，以获得数据的“感觉”。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="1f4a" class="nn mm it nj b gy no np l nq nr"># simple visualization of multivariate time series<br/>df_weather[["Consumption"]].plot(linewidth = 0.45)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/4d2989840844fa2ced48423dec080b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*oNWUs-Jctuu7nKla6ATfPg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:简单的单变量时间序列图</figcaption></figure><h2 id="a436" class="nn mm it bd mn or os dn mr ot ou dp mv lr ov ow mx lv ox oy mz lz oz pa nb iz bi translated">4.2多元</h2><p id="273a" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">您也可以仅使用一行代码来绘制多元时间序列。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4400" class="nn mm it nj b gy no np l nq nr"># plottng multivariate<br/>df[["col1", "col2", "col3"]].plot()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/a78b087910a8442cd1a27de0d9772ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*BjSOZsyvKrfuntEisQCfTg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:多元时间序列图</figcaption></figure><h2 id="5f75" class="nn mm it bd mn or os dn mr ot ou dp mv lr ov ow mx lv ox oy mz lz oz pa nb iz bi translated">3.3多元重采样</h2><p id="ab72" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">时间序列对象的美妙之处在于您可以进行<em class="pc">重采样。</em>也就是说，您可以按不同的时间维度(每周、每月、每年等)对数据进行分组。)然后使用一行代码将它们全部绘制出来。</p><p id="e565" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是一个重采样示例，其中每天的观察值被分组为每月的总和(在代码中找到“M”表示每月)。这是上述4.1中同一图的不同表示。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="87aa" class="nn mm it nj b gy no np l nq nr"># Resampling daily/monthly/annually with mean/sum<br/>df['Consumption'].resample("M").sum().plot()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/4941200c1b90bb37a7669dd80165492f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*RxBJGRz43fEQ_KraPTvnAw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:将每日观察总结为每月总数的重新取样方法</figcaption></figure><h2 id="99cd" class="nn mm it bd mn or os dn mr ot ou dp mv lr ov ow mx lv ox oy mz lz oz pa nb iz bi translated">4.4滚动窗口</h2><p id="fc25" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">也称为<em class="pc">移动平均</em>，滚动窗口对最后<em class="pc"> N </em>次观察进行平均或求和，并显示为单个数据点。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4d2f" class="nn mm it nj b gy no np l nq nr"># sumplots of rolling window<br/>df[["Solar", "Wind"]].rolling(window=12).mean().plot(subplots=True)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/d4f8138084bd868ef6151ab252647aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*ANQYjkB4CMxgVvCv8pAQBQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:N = 12的滚动窗口</figcaption></figure><h2 id="4dec" class="nn mm it bd mn or os dn mr ot ou dp mv lr ov ow mx lv ox oy mz lz oz pa nb iz bi translated">4.5箱线图</h2><p id="91e5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">箱线图是一种非常强大的可视化信息的方式。在时间序列中，您可以按不同的时间单位对数据进行汇总或分组，并在单个箱线图中查看值的分布。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5f4f" class="nn mm it nj b gy no np l nq nr"># boxplot of weekdays<br/>sns.boxplot(data = df, x = 'Weekday', y = 'Consumption')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/ce4a7e33d3e53cd33341dd3e0019744f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*AW7E4nJkW4hEapSzeeRNNQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图:显示工作日分布和数据差异的箱线图</figcaption></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="fd44" class="nn mm it bd mn or os dn mr ot ou dp mv lr ov ow mx lv ox oy mz lz oz pa nb iz bi translated">最后的想法</h2><p id="f176" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">本文的目的是探索时间序列数据分析的几个基本方面:数据争论、创建时间序列对象、过滤和可视化。我希望你已经找到了一些有用的技巧和窍门来处理时间序列数据，以及如何将它们可视化。在以后的文章中，我将会用更多的代码片段更深入地探讨这些主题。</p><p id="90be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">敬请期待！</p></div></div>    
</body>
</html>