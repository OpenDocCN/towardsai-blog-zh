<html>
<head>
<title>TensorFlow Callbacks in Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow回调在运行</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/tf-callbacks-in-action-966e8ff52900?source=collection_archive---------2-----------------------#2020-05-09">https://pub.towardsai.net/tf-callbacks-in-action-966e8ff52900?source=collection_archive---------2-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a7fd7e0c0194da3b220530f2487a2f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5mBC2KTs0oQ_SRGnbtuLA.jpeg"/></div></div></figure><p id="1175" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通俗地说，如果我想引入回调，那么它就是控制器，通过它你可以控制你的飞机。没有这些控制器，你就无法控制飞机，你就会坠毁。</p><p id="4cd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调:在keras.io中，回调是一个可以在训练的不同阶段执行动作的对象(例如，在一个时期的开始或结束，在一个批处理之前或之后，等等)。).</p><p id="1d6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着回调是在模型的训练过程中执行特定任务的函数。<br/>那么，这些回调你能做什么呢？<br/> 1。您可以在训练/批次/时期开始和结束后执行特定任务。<br/> 2。您可以定期将模型状态保存在磁盘中。<br/> 3。你可以根据你的任务来安排学习速度。<br/> 4。当特定条件变为真时，您可以自动停止训练。<br/> 5。在训练过程中，你可以通过子类化这些回调函数来做任何事情。</p><p id="37bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子，你可以让你的训练输出像这样干净多彩，挺牛逼的吧？</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/84125f44ae29695247dcbe8b7b590e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnOcxRCIhX7gtX7nv9RdGQ.png"/></div></div></figure><p id="e8b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Tensorflow在基类“tf.keras.callbacks”下提供了广泛的回调。有关回调的完整列表，请访问<a class="ae lb" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/Callback" rel="noopener ugc nofollow" target="_blank"> TensorFlow的网站</a>。</p><p id="4d19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将介绍一些基本的TensorFlow回调，以及如何使用它们来完全控制培训。</p><p id="e77a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的上下文是:- <br/> 1。通过子类化回调类来定制回调。<br/> 2。提前停止回调。<br/> 3。模型检查点回调。<br/> 4。ReduceOnPlateu回调。<br/> 5。学习率计划程序。<br/> 6。奖励包，让输出干净多彩，如上图。</p><p id="2ab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是让我们首先加载cats_vs_dogs数据集，我一直使用原始数据集的非常小的子类。然后，让我们使用顺序API来定义我们的模型架构。在整篇文章中，我都在使用这个数据集和这个模型架构。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/898880b5336ce9ac773f15d3feced9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSuHL1TUQ8R_m8W8HNSXuw.png"/></div></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/058c5d959397a4225e81a9af25e18a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRCO7A6g-xN_Y_F08M_qyw.png"/></div></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/e746617b9c7080ef6a69c0340846dced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLfWln5XjPiqy33oW6WuyQ.png"/></div></div></figure><p id="77ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:-这篇文章是关于TensorFlow回调的，而不是为了制作世界级的ML模型和实现最先进的结果。因此，在整篇文章中，忽略损失和指标，试着专注于如何使用这些回调。数据集是最小的，可能会过拟合，但你可以忽略所有这些东西。</p><p id="7b4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，不再拖延，让我们开始学习上面提到的回调。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="657d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">1.通过子类化回调类来定制回调。</h1><p id="b866" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这些回调属于基类“TF . keras . callbacks”。<br/>通过对这些回调进行子类化，我们可以在训练/批处理/时期开始或结束时执行某些功能。<br/>为此，我们可以覆盖回调类的功能。<br/>这些功能的名称是自我解释它们的行为。<br/>例如def on_train_begin()，这表示当<br/>训练开始时该做什么。<br/>下面我们来看看如何覆盖这些函数。我们还可以<br/>监控日志并执行某些操作，通常是在<br/>训练/批次/时期的开始或结束。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/0950d6a03d16a72c5c224a5f12fe9aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGOhsL79FZa8wj0lKlyqgg.png"/></div></div></figure><h2 id="03e3" class="mq ln iq bd lo mr ms dn ls mt mu dp lw kj mv mw ma kn mx my me kr mz na mi nb bi translated">输出:</h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/c91726f3a1797a4bb1dc0f1b910f4088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w03z-RdHpES2_24NqZj17Q.png"/></div></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="6dbb" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">2.提前停止回调。</h1><p id="8004" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">假设我们不知道回调，并且您想要防止由于将我们的模型训练到额外的时期而导致的模型过度拟合(我们不是上帝，所以我们知道我们的模型将在多少时期收敛)。因此，我们绘制val_loss与历元的关系图，并检查<br/>有多少个历元开始过度拟合数据。然后，我们将在小于该纪元编号的时间内重新训练我们的模型。如果我告诉你不用手动做这件事呢？<br/>是的，你可以用EarlyStopping回调来做到这一点。<br/>那么，让我们看看如何使用这个回调函数。</p><p id="037a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，导入回调，然后创建<br/> EarlyStopping回调的实例，并根据我们的需要传递参数。让我来解释这些论点。</p><ul class=""><li id="b4ef" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">“监控”您可以传递损失或指标。<br/>一般我们通过val_loss来监控。</li><li id="43ef" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">" min_delta "您可以在此参数中传递一个整数。<br/>简而言之，如果模型<br/>的下降幅度不大于/小于损失/指标，那么您就是在告诉回调模型<br/>没有改善。</li><li id="650d" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">“耐心”，意思是要等多少个纪元。<br/>之后，如果根据“最小增量”的值，在<br/>模型性能中没有看到改进，则停止训练。</li><li id="61f8" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">“mode”<br/>默认设置为“auto ”,这在<br/>处理自定义损耗/指标时很方便。因此，您可以<br/>告诉回调，当<br/>其定制损耗/指标降低时，模型是否正在改进，然后将其设置为“最小”<br/>或增加，然后将其设置为“最大”</li></ul><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/cdf6ac6efe80ffc597f6a3a0c042b70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZnvwzjQZ9mwmQqRVqalRA.png"/></div></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="c8ad" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">3.ReduceLROnPlateau。</h1><p id="10fe" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">如果损失/指标没有任何改善，此回调用于降低学习率。</p><p id="eb46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些论点是:</p><p id="c80b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">*“monitor”它被设置为一个字符串<br/>形式的损失/指标，如果没有改善，我们将减少学习。</p><ul class=""><li id="7034" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">" factor "您可以在此参数中传递一个整数，<br/>并说您当前的学习率是LR，那么如果<br/>在监控的损失/度量中没有看到任何改进，<br/>那么学习将减少该" factor "<br/>即新学习率= lr *因子</li><li id="7239" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">" Verbose" <br/>可以设置verbose =1，查看每个历元的学习率。<br/>或verbose = 0来禁用它。</li></ul><p id="4b75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参数min_delta和mode与EarlyStopping回调的参数中解释的相同。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/33e1c890623826268aff8d9f791a1886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnHPbv6vcM7s5y9_0KNgPA.png"/></div></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ef01" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">4.模型检查点</h1><p id="3057" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">让我们想象一下，你正在训练一个像colab中的Bert一样重的模型，这需要大量的训练时间。于是，你开始了模特训练，去睡觉了。然后第二天早上<br/>你醒来，打开可乐罐。<br/>但是你会在屏幕上看到“运行时断开”的信息。<br/>听起来像噩梦一样艰难？<br/>对于这个问题，ModelCheckpoint就像我们生活中的救星一样出现了。我们可以在每个纪元结束时保存检查点。<br/>这样，如果在训练过程中发生了可怕的事情，我们就可以加载重量或继续训练。</p><p id="a8de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，让我们看看如何使用这个回调函数。我们可以用Keras h5/hd5格式或者TensorFlow pb <br/>格式保存<br/>模型检查点。如果您传递参数“file path = model . H5”(. H5扩展名)<br/>，它将被保存为Keras格式或“filepath= model.p”(。pb扩展)<br/>用于以TensorFlow模型格式保存。</p><p id="d596" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，有两种选择来保存检查点，您可以保存整个体系结构+权重，也可以只保存权重。可以通过设置“save_only_weights=True”或“save_only_weights=False”来实现这一点</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/8f080562e9074405eb4d074682309a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vONkDZiWccWGODEcldupQQ.png"/></div></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="1300" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">5.学习率计划程序</h1><blockquote class="nu nv nw"><p id="8a9b" class="jy jz nx ka b kb kc kd ke kf kg kh ki ny kk kl km nz ko kp kq oa ks kt ku kv ij bi translated">调度学习的最简单方法是将学习速率<br/>从大的初始值线性降低到小的值。<br/>这允许在<br/>学习过程开始时进行大的重量变化，并在<br/>学习过程结束时进行小的变化或微调。</p></blockquote><p id="4f00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来看看如何安排学习率。为此，我们必须<br/>定义一个包含<br/>改变学习率规则的辅助函数。<br/>然后我们可以简单地将这个辅助函数的名称<br/>传递给LearningRateScheduler类的对象的参数。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/70fa59a00e9f28053ca58f3162307281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSwVhCH4nNh9YMVT2wpfFw.png"/></div></div></figure><h2 id="f2b4" class="mq ln iq bd lo mr ms dn ls mt mu dp lw kj mv mw ma kn mx my me kr mz na mi nb bi translated">输出:</h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/588a8c83bb335cd3db6e85c38ef415ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9kGtMuAvqXEpbn00uNf_g.png"/></div></div></figure><p id="681b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，这里是实用程序文件，使培训输出更干净和丰富多彩。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/84125f44ae29695247dcbe8b7b590e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnOcxRCIhX7gtX7nv9RdGQ.png"/></div></div></figure><h2 id="b5f8" class="mq ln iq bd lo mr ms dn ls mt mu dp lw kj mv mw ma kn mx my me kr mz na mi nb bi translated">资源</h2><p id="a114" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated"><a class="ae lb" href="https://github.com/abhinavsp0730/callback_blog" rel="noopener ugc nofollow" target="_blank">Github上的资源库</a>:</p><p id="cca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae lb" href="https://colab.research.google.com/drive/1HRAt-ViaZW2BpwjY51rn64W3VBrTp-FI?usp=sharing" rel="noopener ugc nofollow" target="_blank">谷歌的colab </a>上运行上面所有的代码。</p></div></div>    
</body>
</html>