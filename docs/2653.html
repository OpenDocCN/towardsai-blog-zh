<html>
<head>
<title>Decision and Classification Tree (CART) for Binary Classification: Hands-On with Scikit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于二元分类的决策和分类树(CART ): sci kit-Learn实践</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/decision-and-classification-tree-cart-for-binary-classification-hands-on-with-scikit-learn-b59474b2c039?source=collection_archive---------1-----------------------#2022-04-01">https://pub.towardsai.net/decision-and-classification-tree-cart-for-binary-classification-hands-on-with-scikit-learn-b59474b2c039?source=collection_archive---------1-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f82a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python和Google Colab</h2></div><p id="6d97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">决策树是一种机器学习技术，它应用类似于“if-else”语句的序列来构建逻辑模型并将值分类。该模型通过构建问题和阈值来工作，并期望得到“是”或“否”的二元答案。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/5886b1247d48368e1f261ab3139c8262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onp_R9h60Qc3Pc8K13kO_w.png"/></div></div></figure><p id="9a55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将展示使用Google Colab用Python实现决策树所需的步骤。如果您熟悉这项技术背后的理论，并且对Python有基本的了解，那么本教程可能会更容易理解。但是，如果不知道决策树算法是如何工作的，不要担心，我会用代码和例子来解释它，因为这样更容易理解。</p><p id="54b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本教程，我们将使用您可以在Kaggle上找到的<a class="ae lq" href="https://www.kaggle.com/datasets/mathchi/diabetes-data-set" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">糖尿病_数据集</strong> </a> <strong class="kk iu"> </strong>。该数据集有8个特征和1个二元结果(疾病或非疾病)。我们的目标是基于这8个特征来预测糖尿病的存在或不存在。</p><blockquote class="lr ls lt"><p id="40df" class="ki kj lu kk b kl km ju kn ko kp jx kq lv ks kt ku lw kw kx ky lx la lb lc ld im bi translated">开始吧！</p></blockquote><p id="0d34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一件事是在你的Google Colab笔记本中加载必要的库:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="dd2c" class="md me it lz b gy mf mg l mh mi">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from sklearn.model_selection import train_test_split</span></pre><p id="d433" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用左侧的菜单将数据集上传到笔记本会话:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/8af5b76e0a7dd30febde116a7b113ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*l06q21m6eMuWh0p-fzjd-A.png"/></div></figure><p id="5c56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阅读并查看数据集:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="dfac" class="md me it lz b gy mf mg l mh mi">df = pd.read_csv("/content/diabetes_dataset.csv")<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mk"><img src="../Images/f8cd8a12d5c3c435cc7d4d2d55e37ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3lBqm9bXtc7q_ugEtqVmA.png"/></div></div></figure><p id="7d71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切正常，您将看到一个像这样的表，有9列(8个特性+ 1个结果)和768行(数据点)。为了全面了解我们的变量，我们可以使用<strong class="kk iu"> describe() </strong>函数:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="d858" class="md me it lz b gy mf mg l mh mi">print(df.describe())</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/322bb31be871531f8c10a8a7d374bfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*yMBgq11IRnrtinntll7twg.png"/></div></figure><p id="e827" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于“结果”是一个二元变量，<strong class="kk iu"> count() </strong>函数是一个更好的方法:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="5d20" class="md me it lz b gy mf mg l mh mi">print(df.value_counts("Outcome"))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mm"><img src="../Images/38b0aa087c38d674cbca8ec7948e674f.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/format:webp/1*QL8cIei2lGcAW8FK5Xfn5Q.png"/></div></div></figure><p id="8069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以根据结果探索我们的数据集，并直观地检查每个特征在分离二元结果方面的表现:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="5056" class="md me it lz b gy mf mg l mh mi"><strong class="lz iu">#Exploring dataset:</strong><br/>sns.pairplot(df, kind="scatter", hue="Outcome")<br/>plt.show()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mn"><img src="../Images/75c52ab82693d5c39d48668ec6a89813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_V8ol_zH-jmTPxGAZvZ2w.png"/></div></div></figure><p id="29e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以评估共线性，并检查要素如何相互关联:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="8a5d" class="md me it lz b gy mf mg l mh mi"><strong class="lz iu">#Drop the outcome:</strong><br/>df_corr = df.drop(["Outcome"], axis=1)</span><span id="d95c" class="md me it lz b gy mo mg l mh mi"><strong class="lz iu">#Build heatmap:<br/></strong>corr_matrix=df_corr.corr()</span><span id="d36b" class="md me it lz b gy mo mg l mh mi">mask = np.zeros_like(corr_matrix)<br/>mask[np.triu_indices_from(mask)] = True</span><span id="015f" class="md me it lz b gy mo mg l mh mi">sns.heatmap(corr_matrix, mask=mask, square=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1d8ed40d6f38d6a62c2ba1964c16555b.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*2Zs3R6K59BO-niLzK2JEIw.png"/></div></figure><p id="c672" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在热图中，我们可以看到只有“年龄”和“怀孕”的相关系数高于0.5。然而，这是可以预料的，而且可能不会影响我们的分析。分布图有助于直观显示两种结果的预测值分布情况，以及这些分布是否存在较大差异:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="380c" class="md me it lz b gy mf mg l mh mi">fig, axs = plt.subplots(4, 2, figsize=(15, 15))</span><span id="bc91" class="md me it lz b gy mo mg l mh mi">sns.histplot(data=df, x="Pregnancies", hue="Outcome", kde=True, color="skyblue", ax=axs[0, 0])<br/>sns.histplot(data=df, x="Glucose", hue="Outcome", kde=True, color="skyblue", ax=axs[0, 1])<br/>sns.histplot(data=df, x="BloodPressure", hue="Outcome", kde=True, color="skyblue", ax=axs[1, 0])<br/>sns.histplot(data=df, x="SkinThickness", hue="Outcome", kde=True, color="skyblue", ax=axs[1, 1])<br/>sns.histplot(data=df, x="Insulin", hue="Outcome", kde=True, color="skyblue", ax=axs[2, 0])<br/>sns.histplot(data=df, x="BMI", hue="Outcome", kde=True, color="skyblue", ax=axs[2, 1])<br/>sns.histplot(data=df, x="DiabetesPedigreeFunction", hue="Outcome", kde=True, color="skyblue", ax=axs[3, 0])<br/>sns.histplot(data=df, x="Age", hue="Outcome", kde=True, color="skyblue", ax=axs[3, 1])</span><span id="8b82" class="md me it lz b gy mo mg l mh mi">plt.show()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mq"><img src="../Images/34690664146dc11d33dbe5fb8c1f42c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkAYmiu9k8eGzWG4rflB0g.png"/></div></div></figure><p id="14cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种可视化数据的方法是:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="45d5" class="md me it lz b gy mf mg l mh mi">fig, axs = plt.subplots(4, 2, figsize=(15, 15))</span><span id="835b" class="md me it lz b gy mo mg l mh mi">sns.boxplot(x=df["Outcome"], y=df["Pregnancies"], ax=axs[0, 0])<br/>sns.boxplot(x=df["Outcome"], y=df["Glucose"], ax=axs[0, 1])<br/>sns.boxplot(x=df["Outcome"], y=df["BloodPressure"], ax=axs[1, 0])<br/>sns.boxplot(x=df["Outcome"], y=df["SkinThickness"],ax=axs[1, 1])<br/>sns.boxplot(x=df["Outcome"], y=df["Insulin"], ax=axs[2, 0])<br/>sns.boxplot(x=df["Outcome"], y=df["BMI"], ax=axs[2, 1])<br/>sns.boxplot(x=df["Outcome"], y=df["DiabetesPedigreeFunction"], ax=axs[3, 0])<br/>sns.boxplot(x=df["Outcome"], y=df["Age"], ax=axs[3, 1])</span><span id="50b7" class="md me it lz b gy mo mg l mh mi">plt.show()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mr"><img src="../Images/4047ecf99634f82d14b034e8d2dfeaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nur3fpPtFCNOErFGZL8ciQ.png"/></div></div></figure><p id="5008" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经知道了数据的样子，我们可以构建我们的模型了:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="8388" class="md me it lz b gy mf mg l mh mi"><strong class="lz iu">#Import libraries:</strong><br/>from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.model_selection import train_test_split</span></pre><p id="b002" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要定义我们的变量:<strong class="kk iu"> X </strong>将包含特性，而<strong class="kk iu"> y </strong>将包含结果:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="a6e1" class="md me it lz b gy mf mg l mh mi">X = df.drop(["Outcome"], axis=1)<br/>y = df["Outcome"]</span></pre><p id="5120" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将数据分成训练和测试两部分:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="1f9d" class="md me it lz b gy mf mg l mh mi">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)</span></pre><p id="4eba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要构建和拟合模型:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="498e" class="md me it lz b gy mf mg l mh mi">tree = DecisionTreeClassifier()<br/>tree.fit(X_train, y_train)</span></pre><p id="634a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了评估这个模型:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="31b0" class="md me it lz b gy mf mg l mh mi">print("accuracy on training set: %f" % tree.score(X_train, y_train))<br/>print("accuracy on test set: %f" % tree.score(X_test, y_test))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5924e4000b46f654af6b78e5de06ca9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*EdOFqs1wQypSwYVzyWjr8w.png"/></div></figure><p id="910d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到我们的模型明显过度拟合。这是因为我们没有限制树中节点的数量，我们的模型使用了8个可用的特性。这已经建立了一个大而复杂的“树”，如下图所示:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mt"><img src="../Images/5dffa816500ae7a1bb8f825bb2545a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbYCcBjCDnmTbZUJhgSG7w.png"/></div></div></figure><p id="6929" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检查哪些特性最有能力区分这两个类别，我们可以打印一个数组，显示每个特性的重要性。如果我们将所有值相加，它将等于1。</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="8537" class="md me it lz b gy mf mg l mh mi">tree.feature_importances_</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/dce0d94e00458a48970ea030b1ccbe27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*i78IE1-D4vQbKOSsf5e7QA.png"/></div></figure><p id="2292" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，这三个特征比所有其他特征更重要。这是一个暗示，我们可以建立一个只有三个节点的树。我们不需要知道选择哪些特性，因为模型会为我们完成这项工作。但是，如果我们想知道哪些特征具有最大的预测能力，我们可以使用树特征重要性构建一个图:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="2d23" class="md me it lz b gy mf mg l mh mi">import matplotlib.pyplot as plt</span><span id="1275" class="md me it lz b gy mo mg l mh mi">plt.plot(tree.feature_importances_, 'o')<br/>plt.xticks(range(X.shape[1]), X.columns, rotation=90)</span><span id="e924" class="md me it lz b gy mo mg l mh mi">plt.ylim(0, 1)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f2050daae2732b386aafe0952ccabf20.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*ktCcflbq8RjJgFok4hZk2w.png"/></div></figure><p id="fa0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道“葡萄糖”、“身体质量指数”和“糖尿病患者的肾功能”是最重要的特征。让我们构建一个只有这三个节点的树:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="aae2" class="md me it lz b gy mf mg l mh mi">tree = DecisionTreeClassifier(max_depth=3)<br/>tree.fit(X_train, y_train)</span><span id="6492" class="md me it lz b gy mo mg l mh mi">print("accuracy on training set: %f" % tree.score(X_train, y_train))<br/>print("accuracy on test set: %f" % tree.score(X_test, y_test))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/58e31278bea2965105fb1d72f5e7bcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*CcN2tYHFuH1yiMi6HcZOYA.png"/></div></figure><p id="7fde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这棵树的特点很重要:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4e1a1e295434baa925df7556e94a2d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*XLtL9XP5r4CyhuJQK7L3YA.png"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/725e4c3ddd4689562e974afea48e203a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*qFZyUSYraIv6_gK2qUQTog.png"/></div></figure><p id="e809" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然仍然过度拟合，但我们可以看到现在训练和测试精度更接近了。如果我们再次构建我们的树，我们可以看到它是多么简单:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="a8ec" class="md me it lz b gy mf mg l mh mi"><strong class="lz iu">#To build the tree diagram:</strong><br/>from sklearn.tree import export_graphviz<br/>import graphviz</span><span id="3c19" class="md me it lz b gy mo mg l mh mi"><strong class="lz iu">#Create the tree:</strong><br/>export_graphviz(tree, out_file="mytree.dot", class_names=["Diabetes", "No-Diabetes"], feature_names = X.columns, impurity=False, filled=True)</span><span id="c8de" class="md me it lz b gy mo mg l mh mi"><strong class="lz iu">#Tree visualisation:</strong><br/>with open("mytree.dot") as f:<br/>    dot_graph = f.read()</span><span id="a6b1" class="md me it lz b gy mo mg l mh mi">graphviz.Source(dot_graph)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/5886b1247d48368e1f261ab3139c8262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onp_R9h60Qc3Pc8K13kO_w.png"/></div></div></figure><p id="b450" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果要将树形图保存为<strong class="kk iu">。png </strong>，你需要执行这些额外的步骤:</p><pre class="lf lg lh li gt ly lz ma mb aw mc bi"><span id="7290" class="md me it lz b gy mf mg l mh mi">import pydot</span><span id="331b" class="md me it lz b gy mo mg l mh mi"><strong class="lz iu"># Use dot file to create a graph:</strong><br/>(graph, ) = pydot.graph_from_dot_file('mytree.dot')</span><span id="7524" class="md me it lz b gy mo mg l mh mi"><strong class="lz iu"># Write graph to a png file:</strong><br/>tree_png = graph.write_png('mytree.png')</span></pre><p id="2b01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会找到你的<strong class="kk iu">。png </strong>和你的<strong class="kk iu">糖尿病_数据集</strong>在同一个目录下。</p><p id="37c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！如果您对本教程有任何建议，请告诉我，不要忘记订阅以接收关于我未来出版物的通知。</p><p id="f393" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果:你喜欢这篇文章，别忘了关注我，这样你就能收到关于新出版物的所有更新。</p><p id="dcb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">其他如果:</strong>你想在Medium上阅读更多，可以通过<a class="ae lq" href="https://cdanielaam.medium.com/membership" rel="noopener"> <strong class="kk iu">我的推荐链接</strong> </a>订阅Medium会员。它不会花你更多的钱，但会给我一杯咖啡。</p><p id="e354" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">其他:</strong>谢谢！</p></div></div>    
</body>
</html>