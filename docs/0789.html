<html>
<head>
<title>Observer Pattern vs. Pub-Sub Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">观察者模式与发布-订阅模式</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/observer-pattern-vs-pub-sub-pattern-7f467bcf5fe?source=collection_archive---------1-----------------------#2020-08-12">https://pub.towardsai.net/observer-pattern-vs-pub-sub-pattern-7f467bcf5fe?source=collection_archive---------1-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="11a2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/software-engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a>，<a class="ae ep" href="https://towardsai.net/p/category/systems" rel="noopener ugc nofollow" target="_blank">系统</a></h2><div class=""/><p id="c965" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">不要把这两种相似但不同的模式搞混了，要知道什么时候用哪个。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/df2784872c4db61c5c80e2076c26c2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtWMeiKo8Ni5Bg357RMg5g.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">何塞·巴勃罗·多明格斯在<a class="ae ln" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="76c5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这种差异不仅对普通软件工程师很重要，对数据工程师也很重要，并且是理解数据管道的事件驱动架构的基础。</p><p id="b587" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在我们最终列出它们的区别之前，让我们分别来看看它们。</p><h1 id="c529" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">观察者模式</h1><p id="824f" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated"><em class="mr"/><strong class="kb jd"><em class="mr">观察者模式</em> </strong> <em class="mr">是一种软件设计模式，其中一个名为</em> <strong class="kb jd"> <em class="mr">主题</em> </strong> <em class="mr">，</em> <strong class="kb jd"> <em class="mr">的对象维护一个其依赖者的列表</em> </strong> <em class="mr">，名为</em> <strong class="kb jd"> <em class="mr">观察者</em> </strong> <em class="mr">，并自动通知它们任何状态变化，通常是通过调用它们的一个—维基百科定义[1] </em></p><p id="38db" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="mr">观察者模式允许一个给定的对象(称为</em> <strong class="kb jd"> <em class="mr">主题</em> </strong> <em class="mr">)被一组动态的“观察者”对象监控。每当主体上的一个值发生变化，它就让所有的</em> <strong class="kb jd"> <em class="mr">观察者</em> </strong> <em class="mr">对象知道发生了变化，通过调用它们的方法</em> <code class="fe ms mt mu mv b"><em class="mr">update()</em></code> <em class="mr">(说)方法。每当核心对象改变时，每个观察者可能负责不同的任务；受试者不知道或不关心那些任务是什么，观察者通常也不知道或不关心其他观察者在做什么。</em></p><p id="b07f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">作为一个例子，让我们创建一个<code class="fe ms mt mu mv b">SubjectMixin</code>,我们可以将它混合在任何Python类中，以使它容易地符合观察者模式的主题。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mw"><img src="../Images/3f4b0bdbd495f9a265e88d09ad004534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IER51PIY9C1Id5lt9rvACA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">一段作者代码的截图</figcaption></figure><p id="c5e8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">类似地，让我们创建一个<code class="fe ms mt mu mv b">ObserverMixin</code>，我们可以将它混合到任何类中，使它很容易附着到观察者模式的对象上。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mx"><img src="../Images/214500de92a8c51a0fdc47174c0feaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBk3khX8fsZplr6k0AK2aQ.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">一段作者代码的截图</figcaption></figure><p id="8178" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">此外，让我们创建一个名为<code class="fe ms mt mu mv b">Data</code>的主题和两个名为<code class="fe ms mt mu mv b">HexViewer</code>和<code class="fe ms mt mu mv b">DecimalViewer</code>的观察者。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi my"><img src="../Images/ea72e9960eb474c7147ddde551e1063a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mU5vJdg-B69cREmzXU4OA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">一段作者代码的截图</figcaption></figure><p id="c189" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">最后，让我们来看看观察者模式的作用:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mz"><img src="../Images/b91095354ac252a45a929502f1d3d7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovqh_m2OtPFFBPsfWaCxyw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">一段作者代码的截图</figcaption></figure><h1 id="5f48" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">发布-订阅(发布-订阅)模式</h1><p id="74a6" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated"><em class="mr"/><strong class="kb jd"><em class="mr">发布者-订阅者模式</em> </strong> <em class="mr">可以被认为是观察者模式</em>  <em class="mr">的</em> <strong class="kb jd"> <em class="mr">改进(异步和松耦合)版本。在发布-订阅模式中，消息的发送者(称为发布者)不直接向特定的接收者(称为订阅者)发送消息。有一个</em> <strong class="kb jd"> <em class="mr">中间组件</em> </strong> <em class="mr">，称为</em><strong class="kb jd"><em class="mr">broker</em></strong><em class="mr">，(或消息代理，事件总线)，发布者向其发送数据，订阅者从其接收数据。它过滤所有传入的消息并相应地分发它们。常用的消息过滤方法有</em> <strong class="kb jd"> <em class="mr">基于主题的</em> </strong> <em class="mr">和</em> <strong class="kb jd"> <em class="mr">基于内容的</em> </strong> <em class="mr">。</em></strong></p><p id="2ffe" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="mr">这意味着发布者和订阅者</em> <strong class="kb jd"> <em class="mr">甚至不知道对方</em> </strong> <em class="mr">的存在，因此只是松散耦合。</em></p><p id="b3a5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">您可能希望使用Apache Kafka 检查<a class="ae ln" href="https://medium.com/@goyalmunish/data-streaming-with-apache-kafka-e1676dc5e975" rel="noopener">数据流，以欣赏发布-订阅机制的美妙之处，这有助于使您的架构具有水平可伸缩性、容错性，并允许您以低延迟传输数据。</a></p><h1 id="66d5" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">观察者和发布-订阅模式之间的区别</h1><p id="6c80" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">我们现在明白了这两种模式分别是什么。让我们列出它们的不同之处:</p><ul class=""><li id="08e4" class="na nb it kb b kc kd kg kh kk nc ko nd ks ne kw nf ng nh ni bi translated">在观察者模式中，数据源本身(主体)知道谁是它的观察者。所以，在主体和观察者之间没有中间人。而在发布订阅中，发布者和订阅者是松散耦合的，他们甚至不知道对方的存在。他们只是通过经纪人进行交流。</li><li id="d1ca" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">与我们在前面的例子中看到的类似，观察者模式大部分是同步实现的，即当事件发生时，主体调用其所有观察者的适当方法。然而，发布-订阅模式通常是异步实现的(使用消息队列)，比如Apache Kafka。</li><li id="86f5" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">观察者模式通常在单个应用程序范围内实现。另一方面，发布者-订阅者模式主要用作跨应用程序模式(例如Kafka如何被用作事件驱动架构的核心),并且通常用于解耦数据/事件流和系统。</li></ul><p id="d2d6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">参考资料:</p><p id="5db0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">[1] <a class="ae ln" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>，维基百科</p><p id="e125" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">这里有一些相关的有趣故事，你可能会觉得有帮助:</strong></p><ul class=""><li id="e630" class="na nb it kb b kc kd kg kh kk nc ko nd ks ne kw nf ng nh ni bi translated"><a class="ae ln" href="https://medium.com/@goyalmunish/distributed-data-processing-with-apache-spark-2a5e473b0cb1" rel="noopener">用Apache Spark进行分布式数据处理</a></li><li id="c326" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><a class="ae ln" href="https://medium.com/@goyalmunish/data-streaming-with-apache-kafka-e1676dc5e975" rel="noopener">使用Apache Kafka进行数据流传输</a></li><li id="9c44" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><a class="ae ln" href="https://medium.com/@goyalmunish/apache-cassandra-distributed-row-partitioned-database-for-structured-and-semi-structured-data-1dc37e72e67c" rel="noopener"> Apache Cassandra —用于结构化和半结构化数据的分布式行分区数据库</a></li><li id="674e" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><a class="ae ln" href="https://medium.com/@goyalmunish/data-pipelines-with-apache-airflow-46258deb2844" rel="noopener">带有Apache气流的数据管道</a></li><li id="1c49" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><a class="ae ln" href="https://medium.com/@goyalmunish/designing-workflows-using-argo-9d0dc5036348" rel="noopener">使用Argo设计工作流</a></li><li id="715d" class="na nb it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><a class="ae ln" href="https://medium.com/@goyalmunish/the-why-and-how-of-mapreduce-17c3d99fa900" rel="noopener">MapReduce的原因和方式</a></li></ul></div></div>    
</body>
</html>