<html>
<head>
<title>Unleashing the power of WebSockets for real-time Model Inference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放WebSockets的力量进行实时模型推理</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/unleashing-the-power-of-websockets-for-real-time-model-inference-e100d597c7a2?source=collection_archive---------3-----------------------#2022-12-17">https://pub.towardsai.net/unleashing-the-power-of-websockets-for-real-time-model-inference-e100d597c7a2?source=collection_archive---------3-----------------------#2022-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1622" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用套接字进行模型推理的实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c481ebd87b797684ad2c191b7fe5aff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*X88a_Z0p95Xi9v461SKdBA.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者GIF</figcaption></figure><p id="ffce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<em class="lq">套接字</em>指定了一个网络地址和端口，应用程序可以通过它与网络上的进程进行通信。套接字是低级编程接口，通常用于开发应用程序之间的实时双向通信。</p><h1 id="1f37" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">套接字与REST APIs有什么不同？</h1><ul class=""><li id="7b7e" class="mj mk it kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated"><strong class="kw iu"> <em class="lq"> REST </em> </strong>和<strong class="kw iu"> <em class="lq"> Sockets </em> </strong>都是用来创建网络应用的。<strong class="kw iu"> REST </strong> ( <em class="lq">表述性状态转移</em>)是一种<em class="lq">软件架构</em>风格，它定义了一组用于创建web服务的约束和属性</li><li id="dc4b" class="mj mk it kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><strong class="kw iu"> <em class="lq"> REST </em> </strong>使用<em class="lq">无状态请求-响应模型</em>，其中服务器响应请求，而不保持先前的状态或先前请求中交换的数据</li><li id="7245" class="mj mk it kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated"><strong class="kw iu"> <em class="lq">插座</em> </strong>使用一个<em class="lq">双向全双工通信通道</em>，这意味着可以同时发送和接收数据。</li></ul><p id="2310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">如果太复杂理解不了，我也有ChatGPT的回答。</em>我请<strong class="kw iu"> <em class="lq"> ChatGPT </em> </strong>给一个孩子解释一下<em class="lq"> REST API和Socket的区别；下面的</em>是它生成的响应，</p><blockquote class="mz na nb"><p id="6a7a" class="ku kv lq kw b kx ky ju kz la lb jx lc nc le lf lg nd li lj lk ne lm ln lo lp im bi translated">“REST和sockets是计算机通过互联网相互对话的两种不同方式。休息就像打电话，一台电脑打电话给另一台电脑，询问一些信息。另一台计算机监听，然后给第一台计算机它所要求的信息。插座就像一个对讲机，两台电脑可以同时通话和听对方说话。”</p><p id="5a76" class="ku kv lq kw b kx ky ju kz la lb jx lc nc le lf lg nd li lj lk ne lm ln lo lp im bi translated">“REST是计算机共享信息的一种简单方式，但只能用于单向通信。套接字稍微复杂一点，但是它们允许计算机进行双向对话。这对于视频游戏或聊天应用来说非常有用，在这些应用中，电脑需要能够实时地来回发送信息。”</p></blockquote><p id="dc31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">既然我们知道了</em> <strong class="kw iu"> <em class="lq">套接字</em> </strong> <em class="lq">背后的基本理论，以及它们与</em><strong class="kw iu"><em class="lq">REST API的不同之处，</em> </strong> <em class="lq">让我们继续用套接字</em>构建一些更酷的东西</p><h1 id="21a9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">在本教程中，</h1><ul class=""><li id="21d2" class="mj mk it kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated">我们将看到如何使用<strong class="kw iu"> FastAPI </strong>构建<em class="lq"> Socket </em>服务器，并通过<em class="lq"> WebSockets </em>提供<strong class="kw iu">模型推理</strong>。</li><li id="deae" class="mj mk it kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated">作为<em class="lq">模型推理的一部分，</em>我们将部署一个<em class="lq"> NER </em>模型，它将检测并标记给定句子中的不同实体。</li></ul><p id="185e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">所以让我们来建造</em></p><h1 id="49ba" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">FastAPI WebSockets入门</h1><ul class=""><li id="afd1" class="mj mk it kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated">安装<em class="lq"> FastAPI和uvicon</em>python包，</li></ul><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="7c08" class="nk ls it ng b be nl nm l nn no">pip install fastapi uvicorn</span></pre><ul class=""><li id="16c2" class="mj mk it kw b kx ky la lb ld np lh nq ll nr lp mq mr ms mt bi translated">创建一个<code class="fe ns nt nu ng b">server.py</code>文件并创建一个<em class="lq">套接字</em>端点</li></ul><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="6cee" class="nk ls it ng b be nl nm l nn no">import os<br/><br/>from typing import List, Dict, Union<br/><br/>from fastapi import FastAPI, Header, WebSocket, WebSocketDisconnect<br/><br/>import uvicorn<br/><br/><br/>class ConnectionManager:<br/><br/> def __init__(self):<br/> <br/>  self.active_connections: List[WebSocket] = []<br/>  <br/>  async def connect(self, websocket: WebSocket):<br/>  <br/>  await websocket.accept()<br/>  <br/>  self.active_connections.append(websocket)<br/> <br/> def disconnect(self, websocket: WebSocket):<br/> <br/>  self.active_connections.remove(websocket)<br/>  <br/> async def send_personal_message(self, data: Union[List[Dict], Dict, List],<br/> websocket: WebSocket):<br/> <br/>  await websocket.send_json(data)<br/><br/><br/>manager = ConnectionManager()<br/><br/># healthcheck path<br/>@app.get("/health")<br/>async def health():<br/> return {"ok": True}<br/><br/><br/>@app.websocket("/ws/socket-endpoint")<br/>async def ws_get_entities(websocket: WebSocket):<br/> await manager.connect(websocket)<br/> <br/> try:<br/> <br/>  while True:<br/>  <br/>   data = await websocket.receive_text()<br/>   <br/>   await manager.send_personal_message({"ok": True, "message": "Received"}, websocket)<br/><br/> except WebSocketDisconnect:<br/> <br/>  manager.disconnect(websocket)<br/><br/><br/>if __name__ == "__main__":<br/> uvicorn.run(app, port=5010, host="0.0.0.0")</span></pre><ul class=""><li id="2345" class="mj mk it kw b kx ky la lb ld np lh nq ll nr lp mq mr ms mt bi translated"><code class="fe ns nt nu ng b">ConnectionManager</code>帮助跟踪活动的<em class="lq"> WebSocket </em>连接，如果这些连接从客户端断开，则可以删除/移除连接。</li><li id="72ad" class="mj mk it kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated">我们创建了一个API <code class="fe ns nt nu ng b">/health</code>来检查服务器启动后是否启动</li></ul><p id="9f8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，<code class="fe ns nt nu ng b">/ws/socket-endpoint</code>什么也不做。它返回一个带有两个键<code class="fe ns nt nu ng b">ok</code>和<code class="fe ns nt nu ng b">message</code>的JSON对象</p><p id="ad7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在终端中运行以下命令来启动WebSocket</p><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="1dcd" class="nk ls it ng b be nl nm l nn no">python server.py</span></pre><h1 id="a9f6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">模型推理</h1><p id="bf3d" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">让我们从<em class="lq"> HuggingFace </em>空间中选取一个预先训练好的NER模型，并编写一个函数来返回给定文本中的实体。</p><p id="138f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用HuggingFace空间中的任何模型之前，我们需要安装以下软件包</p><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="5d23" class="nk ls it ng b be nl nm l nn no">pip install transformers torch sentencepiece</span></pre><p id="a477" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦软件包安装完毕，我们就可以继续下一步了。</p><p id="d7f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个预训练的模型，该模型由<a class="ae ny" href="https://huggingface.co/dslim" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> David S. Lim </em> </a>训练，并且在<a class="ae ny" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu"/></a>上的<a class="ae ny" href="https://huggingface.co/dslim/bert-base-NER" rel="noopener ugc nofollow" target="_blank"><em class="lq">Bert-base-NER</em></a>下可用。</p><p id="c16b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用下面这段代码来初始化模型，并处理句子或文本进行推理。创建一个<code class="fe ns nt nu ng b">predict.py</code>文件，并将以下代码添加到该文件中</p><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="ebc9" class="nk ls it ng b be nl nm l nn no">import os<br/>import re<br/>import json<br/>from typing import List, Dict, Union, Tuple<br/>from transformers import AutoTokenizer, AutoModelForTokenClassification, pipeline<br/><br/>class NERPredictor:<br/>    """NER Predictor Instance<br/>    """<br/>    def __init__(self, model_path: str):<br/>        """Initializes the NER Predictor<br/>        Args:<br/>            model_path (str): Path To Model Files<br/>        """<br/>        self.model_path = model_path<br/>        print(f"LOADING TOKENIZER")<br/>        self.tokenizer = AutoTokenizer.from_pretrained(self.model_path,<br/>                                                       local_files_only=True)<br/>        print(f"LOADED TOKENIZER")<br/>        print(f"LOADING MODEL")<br/>        self.model = AutoModelForTokenClassification.from_pretrained(<br/>            self.model_path, local_files_only=True)<br/>        print(f"LOADED MODEL")<br/>        self.nlp_pipeline = pipeline("ner",<br/>                                     model=self.model,<br/>                                     tokenizer=self.tokenizer)<br/>    def __combine_start_end__(self, text: str,<br/>                              results: List[Dict]) -&gt; List[Dict]:<br/>        """Combines consecutive same entity types into one<br/>        Args:<br/>            text (str): Input Text<br/>            results (List[Dict]): NER Result from the pipeline<br/>        Returns:<br/>            List[Dict]: Combined NER Result<br/>        """<br/>        index = 0<br/>        current = None<br/>        output = []<br/>        while index &lt; len(results):<br/>            current = results[index].get("entity")<br/>            start = results[index].get("start")<br/>            end = results[index].get("end")<br/>            index += 1<br/>            while index &lt; len(results) and results[index].get(<br/>                    "entity") == current:<br/>                end = results[index].get("end")<br/>                index += 1<br/>            output.append({<br/>                "entity": current,<br/>                "start": start,<br/>                "end": end,<br/>                "text": text[start:end]<br/>            })<br/>        return output<br/>    def __clean_entity__(self, result: List[Dict]) -&gt; List[Dict]:<br/>        """Remove the B, I in entity<br/>        Args:<br/>            result (List[Dict]): NER Results<br/>        Returns:<br/>            List[Dict]: NER Results<br/>        """<br/>        [e.update({"entity": e.get("entity").split("-")[-1]}) for e in result]<br/>        return result<br/>    def __tag_input_text__(self, text: str,<br/>                           formatted_result: List[Dict]) -&gt; List[Dict]:<br/>        """Tagging parts of the sentences<br/>        Args:<br/>            text (str): Input Text<br/>            formatted_result (List[Dict]): NER Result<br/>        Returns:<br/>            List[Dict]: Tagged Parts of Sentences<br/>        """<br/>        start_end = list(<br/>            map(lambda r: (r.get("start"), r.get("end")), formatted_result))<br/>        start_end = sorted(start_end, key=lambda se: se[0])<br/>        index = 0<br/>        op = []<br/>        while index &lt; len(text):<br/>            if not index in list(map(lambda se: se[0], start_end)):<br/>                lst = []<br/>                start = index<br/>                while not index in list(map(lambda se: se[0],<br/>                                            start_end)) and index &lt; len(text):<br/>                    lst.append({"entity": "other", "char": text[index]})<br/>                    index += 1<br/>                op.append({<br/>                    "entity":<br/>                    "other",<br/>                    "text":<br/>                    "".join(list(map(lambda char: char.get("char"), lst))),<br/>                    "start":<br/>                    start,<br/>                    "end":<br/>                    index<br/>                })<br/>            else:<br/>                rng = list(filter(lambda se: se[0] == index, start_end))[0]<br/>                en = rng[-1]<br/>                res = list(<br/>                    filter(<br/>                        lambda re: re.get("start") == index and re.get("end")<br/>                        == en, formatted_result))[0]<br/>                op.append({<br/>                    "entity": res.get("entity"),<br/>                    "text": text[index:en],<br/>                    "start": index,<br/>                    "end": en<br/>                })<br/>                index = en<br/>        return op<br/>    def predict_result(self, text: str) -&gt; List[Dict]:<br/>        """Given the text predicts the NER Result<br/>        Args:<br/>            text (str): Input Text<br/>        Returns:<br/>            List[Dict]: NER Result with Start and End index and entity types<br/>        """<br/>        ner_results = self.nlp_pipeline(text)<br/>        ner_results = self.__clean_entity__(ner_results)<br/>        results = self.__tag_input_text__(text, ner_results)<br/>        results = list(<br/>            filter(lambda rs: len(rs.get("text").rstrip().lstrip()) &gt; 0,<br/>                   results))<br/>        return self.__combine_start_end__(text, results)</span></pre><h1 id="61a2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">将模型推理与WebSocket集成</h1><ul class=""><li id="8667" class="mj mk it kw b kx ml la mm ld mn lh mo ll mp lp mq mr ms mt bi translated">在<code class="fe ns nt nu ng b">server.py</code>文件中导入<code class="fe ns nt nu ng b">NERPredictor</code></li></ul><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="bd41" class="nk ls it ng b be nl nm l nn no"># --- #<br/>from predict import NERPredictor<br/># --- #</span></pre><ul class=""><li id="feb2" class="mj mk it kw b kx ky la lb ld np lh nq ll nr lp mq mr ms mt bi translated">初始化顶部的<code class="fe ns nt nu ng b">NERPredictor</code></li></ul><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="7de0" class="nk ls it ng b be nl nm l nn no"># --- #<br/>manager = ConnectionManager() <br/>pred_obj = NERPredictor("dslim/bert-base-NER")<br/># --- #</span></pre><ul class=""><li id="8eaa" class="mj mk it kw b kx ky la lb ld np lh nq ll nr lp mq mr ms mt bi translated">添加一个新的WebSocket端点<code class="fe ns nt nu ng b">/ws/get-entities</code>并监听连接和文本数据</li></ul><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="f0b1" class="nk ls it ng b be nl nm l nn no"># --- #<br/><br/>@app.websocket("/ws/get-entities")<br/>async def ws_get_entities(websocket: WebSocket):<br/><br/> await manager.connect(websocket)<br/> <br/> try:<br/> <br/>  while True:<br/>  <br/>  data = await websocket.receive_text()<br/>  <br/>  # print(f"RECEIVED: {data}")<br/>  <br/>  result = pred_obj.predict_result(data)<br/>  <br/>  # print(f"RESULT: {result}")<br/>  <br/>  await manager.send_personal_message(result, websocket)<br/> <br/> except WebSocketDisconnect:<br/> <br/>  manager.disconnect(websocket)<br/><br/># --- #</span></pre><pre class="nz nf ng oa ob aw oc bi"><span id="a0e5" class="od ls it ng b gy oe of l og no">@app.websocket("/ws/get-entities")<br/>async def ws_get_entities(websocket: WebSocket):</span><span id="71f1" class="od ls it ng b gy oh of l og no">    await manager.connect(websocket)</span><span id="7a31" class="od ls it ng b gy oh of l og no">    try:</span><span id="4500" class="od ls it ng b gy oh of l og no">        while True:</span><span id="2ee9" class="od ls it ng b gy oh of l og no">        data = await websocket.receive_text()</span><span id="a930" class="od ls it ng b gy oh of l og no">        # print(f"RECEIVED: {data}")</span><span id="e65b" class="od ls it ng b gy oh of l og no">        result = pred_obj.predict_result(data)</span><span id="fc96" class="od ls it ng b gy oh of l og no">        # print(f"RESULT: {result}")</span><span id="122b" class="od ls it ng b gy oh of l og no">        await manager.send_personal_message(result, websocket)</span><span id="7c21" class="od ls it ng b gy oh of l og no">    except WebSocketDisconnect:</span><span id="7cae" class="od ls it ng b gy oh of l og no">        manager.disconnect(websocket)</span><span id="3c0e" class="od ls it ng b gy oh of l og no"># --- #</span></pre><p id="49ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的服务器端套接字已经准备好了。现在让我们构建客户端应用程序</p><p id="4cb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用<strong class="kw iu"> <em class="lq"> Javascript </em> </strong>与服务器端代码进行交互</p><h1 id="05b3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">与WebSocket交互</h1><p id="f075" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">用javascript安装用于WebSocket支持的<code class="fe ns nt nu ng b">ws</code>模块</p><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="2d95" class="nk ls it ng b be nl nm l nn no">npm install -g ws</span></pre><p id="49ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个<code class="fe ns nt nu ng b">test_ws.js</code>文件并添加以下代码</p><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="89d7" class="nk ls it ng b be nl nm l nn no">const ws = new WebSocket("ws://localhost:5010/ws/get-entities")<br/><br/>const readline = require("readline").createInterface({<br/>    input: process.stdin,<br/>    output: process.stdout<br/>})<br/><br/>let is_read = true;<br/><br/>const send_message = (ws) =&gt; {<br/>    console.log("\nSEND TEXT")<br/>    readline.question("\nEnter your Text: ,", (msg) =&gt; {<br/>        ws.send(msg);<br/>    })<br/>    ws.on("message", (data) =&gt; {<br/>        console.log(data.toString())<br/>        send_message(ws)<br/>    })<br/>}<br/><br/>ws.on("open", () =&gt; {<br/>    if (is_read) {<br/>        send_message(ws)<br/>    } <br/>})<br/></span></pre><p id="1110" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令运行脚本，并尝试一些句子</p><pre class="kj kk kl km gt nf ng nh bn ni nj bi"><span id="620c" class="nk ls it ng b be nl nm l nn no">node test_ws.js</span></pre><p id="f2ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述实现的代码可从<a class="ae ny" href="https://github.com/vatsalsaglani/SocketNER/tree/main/server" rel="noopener ugc nofollow" target="_blank"> SocketNER </a>获得</p><h1 id="46da" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="2964" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">在这篇博客中，我们讨论了如何使用WebSockets，通过FastAPI实现超快的实时模型推理。您可以查看客户端连接器的<a class="ae ny" href="https://github.com/vatsalsaglani/SocketNER.git" rel="noopener ugc nofollow" target="_blank"> SocketNER </a>存储库，以连接到服务器端WebSocket。用户界面是使用<em class="lq"> SvelteKit </em>构建的。</p></div></div>    
</body>
</html>