<html>
<head>
<title>TensorFlow OCR Model for Reading Captchas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于读取验证码的TensorFlow OCR模型</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/tensorflow-ocr-model-for-reading-captchas-8c6b9d72380b?source=collection_archive---------6-----------------------#2022-12-23">https://pub.towardsai.net/tensorflow-ocr-model-for-reading-captchas-8c6b9d72380b?source=collection_archive---------6-----------------------#2022-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8514" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用TensorFlow和CTC Loss函数训练用于Captcha图像文本提取的自定义OCR:分步指南。使用mltu库简化流程</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="fac1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">您见过的最先进的数据科学路线图！附带数以千计的免费学习资源和ChatGPT集成！</strong><a class="ae ll" href="https://87v9.short.gy/K93jZA" rel="noopener ugc nofollow" target="_blank"><strong class="kr iu"/></a></p><p id="0ffb" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><a class="ae ll" href="../ctc-text-recognition" rel="noopener ugc nofollow" target="_blank">在之前的教程</a>中，我向您展示了如何为简单的word图像训练我们的自定义OCR来提取文本。在那里，我给出了许多关于我们在哪里、为什么以及如何做事的解释，但它有一个巨大的缺点——我们使用10 GB的训练数据集，并不是每个人都可以下载那个巨大的失败，然后仅仅为了好玩而训练几个小时。因此，我为该教程创建了一个延续，解释如何为简单的验证码图片训练CTC。</p><p id="876b" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">验证码(完全自动化的公共图灵测试，用于区分计算机和人类)通过提出一个人类容易解决但计算机很难解决的挑战，来保护网站免受机器人和自动化脚本的攻击。一种常见的验证码是一个简单的图像，包含用户必须输入才能继续的一系列字母或数字。</p><p id="75f8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">本教程将使用TensorFlow和Connectionist时态分类(CTC)损失函数创建一个验证码到文本的解决方案。并不是从头开始写所有的东西，我将使用我的“mltu”库。</p><h2 id="d107" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">先决条件:</h2><p id="b07d" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">开始之前，您需要安装以下软件:</p><ul class=""><li id="549b" class="mk ml it kr b ks kt kv kw ky mm lc mn lg mo lk mp mq mr ms bi translated">python 3；</li><li id="3f2b" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated">TensorFlow(本教程我们将使用2.10版本)；</li><li id="8513" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated">mltu==0.1.4</li></ul><p id="5fae" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您还需要一个captcha图像及其相应标签的数据集(即图像中文本的正确转录)。您可以通过手动转录一组captcha图像来创建数据集，也可以使用预先存在的数据集。</p><h2 id="20c4" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">下载验证码数据集:</h2><p id="2825" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">在安装了所需的包之后，我们可以下载用于训练模型的数据集。数据集你可以从这个<a class="ae ll" href="https://github.com/AakashKumarNain/CaptchaCracker/raw/master/captcha_images_v2.zip" rel="noopener ugc nofollow" target="_blank">https://github . com/AakashKumarNain/captcha cracker/raw/master/captcha _ images _ v2 . zip</a>链接下载。该数据集包含1040个作为png图像的验证码文件。每个示例的标签是一个字符串，即文件名(减去文件扩展名)。</p><p id="8b43" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是为了简化我们的工作，我写了一段简短的代码来下载并解压这个zip文件:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="4fc7" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">运行此脚本后，所需的数据集将保存到名为“数据集”的文件夹中。如果我们观察它，我们会看到下面的图像:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl mz"><img src="../Images/7f0c5649b399cfa00dc9428b29519686.png" data-original-src="https://miro.medium.com/v2/format:webp/1*bC_LanVdL_8okq9Dc5mitQ.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">作者图片:验证码训练数据集</figcaption></figure><h2 id="4ccd" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">预处理数据集:</h2><p id="79b0" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">在训练模型之前，我们通常需要预处理数据集。但是因为我使用的是定制的TensorFlow数据提供者，所以我们只需要生成一个数据集列表，其中的每一行都会给出图像和实际标签的路径。我们可以用下面的代码做到这一点:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="e6fb" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里我们迭代一个目录中的所有文件，并将路径和标签保存到数据集。此外，我们正在收集词汇和最大单词长度。这些将在培训过程中使用。</p><p id="3cd8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这里，您应该注意这些配置是什么。这是一个简单的配置对象，用于保存培训过程的参数:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="00d2" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里:</p><ul class=""><li id="2e9a" class="mk ml it kr b ks kt kv kw ky mm lc mn lg mo lk mp mq mr ms bi translated"><strong class="kr iu"> model_path </strong>是保存模型的目录的文件路径。目录名包括当前日期和时间；</li><li id="aeb6" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> vocab </strong>是一个字符串，可以用来指定模型应该识别或使用的词汇或字符集；</li><li id="6c27" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> height </strong>和<strong class="kr iu"> width </strong>为整数，可以表示模型输入数据的大小或维度，如图像的高度和宽度；</li><li id="3d3f" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> max_text_length </strong>是一个整数，可以表示模型期望处理的某些文本的最大长度；</li><li id="f023" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> batch_size </strong>是一个整数，用于确定单个批次中一起处理的样本数量；</li><li id="4d51" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> learning_rate </strong>是一个浮点数，表示模型在训练期间用来更新其权重的学习率；</li><li id="2c33" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> train_epochs </strong>是一个整数，表示训练过程将执行的训练时期或通过整个训练数据集的次数；</li><li id="56fe" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> train_workers </strong>是一个整数，可以表示用于并行化训练过程的工作者线程或过程的数量。</li></ul><p id="e048" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们需要创建我们的数据提供者，在那里我们将在训练和验证我们的模型时完成完整的数据预处理:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="5c19" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">DataProvider对象是一个实用程序，可用于读取、预处理数据并将其提供给TensorFlow训练“fit”函数。我们将用几个参数初始化DataProvider:</p><ul class=""><li id="0159" class="mk ml it kr b ks kt kv kw ky mm lc mn lg mo lk mp mq mr ms bi translated"><strong class="kr iu">数据集</strong>:这是我们之前创建的数据集列表，将用于为训练过程提供数据；</li><li id="2fc0" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> skip_validation </strong>:这是一个布尔标志，决定数据提供者是否应该对数据集执行验证检查。如果设置为True，数据提供程序将跳过这些检查；</li><li id="33e3" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> batch_size </strong>:这是一个整数，决定一个批次中一起处理的样本数量；</li><li id="703b" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> data_preprocessors </strong>:这是一个数据预处理对象的列表，这些对象将在数据被馈送到模型之前应用于数据。该列表中的<strong class="kr iu"> ImageReader </strong>对象将从文件中读取并解码图像数据；</li><li id="d080" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> transformers </strong>:这是一个数据转换对象的列表，这些对象将在数据输入训练过程之前应用于数据。该列表中的<strong class="kr iu"> ImageResizer </strong>、<strong class="kr iu"> LabelIndexer </strong>和<strong class="kr iu">label add</strong>对象将分别用于调整图像大小、将文本标签转换为数字索引以及将文本标签填充为固定长度。</li></ul><p id="b905" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">DataProvider实例将遍历数据集，并将经过预处理和转换的数据提供给训练过程(fit函数)。</p><h2 id="a247" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">将数据集分成训练集和测试集:</h2><p id="ba45" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">接下来，我们需要将数据集分成训练集和测试集。我们将使用训练集来训练模型，使用测试集来评估模型的性能。同样，使用我的定制DataProvider时也毫不费力:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="773a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们有一个分割数据集，其中90%用于训练，10%用于验证。<br/>但是你可能已经注意到我没有使用任何增强技术，因为测试数据在验证时不应该被增强。因此，我们只需要向训练数据提供者添加增强器:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="8d97" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这种情况下，augmentors列表被设置为一个包含三个数据增强对象的列表:<strong class="kr iu"> RandomBrightness </strong>、<strong class="kr iu"> RandomRotate </strong>和<strong class="kr iu">randomerodedial</strong>。这些对象被假定为定义特定数据扩充操作的类，例如随机调整图像的亮度、以随机角度旋转图像或者侵蚀和扩张图像。当<strong class="kr iu"> DataProvider </strong>实例遍历数据集时，它会在将数据提供给模型之前对数据应用这些扩充操作。</p><h2 id="3fa6" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">定义模型架构:</h2><p id="0b62" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">现在我们可以定义模型架构了。一种常见的方法是使用卷积神经网络(CNN)从验证码图像中提取特征，然后使用递归神经网络(RNN)处理特征序列并预测相应的文本标签。我正在做以下事情:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="3629" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是如果您需要更多的细节，下面是这个train_model函数的脚本:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="fd3f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">每种情况都是不同的，如果这对验证码有效，并不意味着对其他数据集也有效。你需要四处玩耍和实验。</p><h2 id="fb12" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">编译和训练模型:</h2><p id="7d55" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">现在我们已经定义了模型架构，我们可以使用CTC损失函数来编译和训练模型。CTC损失函数被设计成训练模型，该模型在给定输入图像的情况下预测字符序列。</p><p id="0787" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了编译这个模型，我们可以使用下面的代码:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="75c6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于这个模型，我使用的是CTCloss和CWEMetric。这一具体指标将计算字符错误率和单词错误率。这是最重要的指标之一，将用于在培训期间监控模型的性能。</p><p id="4287" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">接下来，在我们的培训过程中加入回访至关重要:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="c991" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这段代码在训练TensorFlow模型时为我们定义了一组回调。回调可用于定制模型在训练期间的行为，例如保存检查点、记录训练进度或提前停止。</p><p id="e34c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下面是正在定义的每个回调的简要描述:</p><ul class=""><li id="4ec7" class="mk ml it kr b ks kt kv kw ky mm lc mn lg mo lk mp mq mr ms bi translated"><strong class="kr iu"> EarlyStopping </strong>:当模型在验证集上的性能在指定的时期数(由<strong class="kr iu">耐心</strong>参数确定)内没有改善时，该回调将停止训练过程；</li><li id="dfc6" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> ModelCheckpoint </strong>:这个回调会在每个历元之后保存一个模型权重的检查点。检查点将被保存到由<strong class="kr iu">文件路径</strong>参数指定的文件中。只有当模型在验证集上的性能提高时，回调才会保存权重，这是由<strong class="kr iu">监视器</strong>参数确定的；</li><li id="db8c" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> TrainLogger </strong>:这个回调将训练日志写入一个文件；</li><li id="39d8" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> TensorBoard </strong>:该回调将训练日志写入TensorBoard日志目录，可以用来可视化训练进度；</li><li id="cfd1" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> ReduceLROnPlateau </strong>:当验证集上的模型性能在指定的时期数(由<strong class="kr iu"> patience </strong>参数确定)内没有提高时，此回调会降低优化器的学习率。学习率按照<strong class="kr iu">因子</strong>参数指定的因子降低；</li><li id="87b4" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk mp mq mr ms bi translated"><strong class="kr iu"> Model2onnx </strong>:这个回调将训练后的模型转换成onnx格式。ONNX文件将与Keras保存的模型一起保存。</li></ul><p id="4ea3" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以使用fit方法来训练模型，并将其传递给训练和验证数据提供程序。设置适当的超参数，例如批量大小、时期数、回调等。：</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="5947" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">你可能注意到我在跟踪“瓦尔CER”而不是损失，所以让我们看看我的训练和验证CER曲线是什么样子的:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl mz"><img src="../Images/b1620f686cfb5154042bc8de9566b000.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZYquKdnx1ZFR-Q32oTWZMw.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">作者图片:培训和验证CER</figcaption></figure><p id="2b7d" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这很好，我们可以看到，在第227步，我们的验证字符错误率是0.007，不到1%，非常好的结果！现在让我们看看我们的单词错误率(WER):</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl mz"><img src="../Images/12cfd351fac2913cbc2bf6dd71108cf8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wpI6idVcXvmY68oDAkcbww.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">作者图片:培训和验证WER</figcaption></figure><p id="f4c6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以看到，在同样的227步，我们的WER是0.03846。这也不错，但这告诉我们，几乎4%的验证码图片被预测错误。但是知道我们在这个任务中使用了什么样的小数据集，这不是问题。</p><h2 id="552a" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">使用训练好的模型创建验证码到文本的解决方案:</h2><p id="3d3a" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">现在，让我们用下面的推理代码来测试我们的模型如何执行:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="my ko l"/></div></figure><p id="81ef" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">此代码是一个脚本，用于评估预先训练的ONNX模型的captcha-to-word识别性能。该脚本执行以下步骤:</p><ol class=""><li id="6891" class="mk ml it kr b ks kt kv kw ky mm lc mn lg mo lk ng mq mr ms bi translated">它加载模型配置文件，并使用配置文件中的<strong class="kr iu"> model_path </strong>和<strong class="kr iu"> char_list </strong>参数创建<strong class="kr iu"> ImageToWordModel </strong>对象的实例。<strong class="kr iu"> ImageToWordModel </strong>对象是<strong class="kr iu"> OnnxInferenceModel </strong>类的子类，该类加载ONNX模型并提供使用该模型进行预测的预测方法。<strong class="kr iu"> ImageToWordModel </strong>类添加了一个<strong class="kr iu"> char_list </strong>属性并覆盖predict方法以预处理输入图像并解码模型的输出；</li><li id="2965" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk ng mq mr ms bi translated">它从CSV文件加载验证数据，并将其转换为元组列表。验证数据由图像文件路径和相应的文本标签组成；</li><li id="341d" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk ng mq mr ms bi translated">它遍历验证数据，并使用<code class="fe nh ni nj nk b">model.predict</code>方法获得每张图像的预测文本。该函数计算预测文本和基本事实标注之间的字符错误率(CER)。CER衡量预测文本和标签之间的差异，以百分比表示；</li><li id="d70b" class="mk ml it kr b ks mt kv mu ky mv lc mw lg mx lk ng mq mr ms bi translated">它打印每个影像的影像文件路径、标注、预测和CER，并在循环结束时计算和打印整个数据集的平均CER。</li></ol><p id="e2c1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">此脚本可以评估模型在验证数据集上的性能，并识别模型预测中的任何错误。还可以修改该脚本，以使用模型对新数据或生产环境进行预测。</p><p id="d122" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们看看该模型在验证数据集中的结果:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl mz"><img src="../Images/6867359c5b87d542c28a4833bbd88c04.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dNcTk0nLLb8GpB1QKRWgNQ.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">作者图片:预测验证码图片</figcaption></figure><p id="7b0e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">正如我们所看到的，它从这16个例子中预测了100%!太神奇了！</p><h1 id="0a3b" class="nl ln it bd lo nm nn no lr np nq nr lu jz ns ka lx kc nt kd ma kf nu kg md nv bi translated">结论:</h1><p id="c095" class="pw-post-body-paragraph kp kq it kr b ks mf ju ku kv mg jx kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">在本教程中，我们使用Connectionist时态分类(CTC)损失函数和TensorFlow创建了一个从captcha图像中提取文本的解决方案。</p><p id="4972" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">本教程提供了使用CTC和TensorFlow实现验证码到文本解决方案的实用指南。我们介绍了安装必要的包和下载captcha图像及其相应标签的数据集。我们对数据集进行了预处理，并为训练和验证设置了一个数据提供者。然后我们训练这个模型，保存它，并在新的验证码图片上展示它的准确性。</p><p id="f44c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就是这样！您现在有了一个使用TensorFlow和CTC loss函数的验证码到文本的解决方案。你可以用这个实现来预测不同的验证码图片。</p><p id="c4a7" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我希望这篇教程对你有所帮助，希望你能更好地理解如何使用TensorFlow创建一个验证码到文本的解决方案。如果您有任何问题或需要进一步帮助，请告诉我。</p><p id="17ec" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">训练好的模型可以从<a class="ae ll" href="https://drive.google.com/drive/folders/1gFvpjMj3tC_H1WIhM8r7oWyglOCjqo7C?usp=share_link" rel="noopener ugc nofollow" target="_blank"> <strong class="kr iu">这个链接</strong> </a>下载。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="70a6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">【https://pylessons.com/tensorflow-ocr-captcha】原载于<a class="ae ll" href="https://pylessons.com/tensorflow-ocr-captcha" rel="noopener ugc nofollow" target="_blank"><em class="od"/></a></p></div></div>    
</body>
</html>