<html>
<head>
<title>Synthetically Generating a Baseline Labeled data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">综合生成基线标记数据</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/synthetically-generating-a-baseline-labeled-data-b11e346498dc?source=collection_archive---------3-----------------------#2022-09-23">https://pub.towardsai.net/synthetically-generating-a-baseline-labeled-data-b11e346498dc?source=collection_archive---------3-----------------------#2022-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何生成乱码和非乱码电子邮件的标签数据集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90aa357fae37bb59830da9d76ac22543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7F2oBt7GrJbynBxj"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@imperiumnordique?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">海伦娜·赫兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="1740" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="f732" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">关于数据的一些流行说法是</p><blockquote class="mo mp mq"><p id="cf31" class="lv lw mr lx b ly ms ju ma mb mt jx md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">数据无处不在</p></blockquote><p id="1eb6" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">或者</p><blockquote class="mo mp mq"><p id="bfaf" class="lv lw mr lx b ly ms ju ma mb mt jx md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">大数据正在兴起</p></blockquote><p id="e3fa" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated"><strong class="lx iu"> <em class="mr">的微妙和，在我看来</em> </strong>，最重要的是</p><blockquote class="mo mp mq"><p id="123e" class="lv lw mr lx b ly ms ju ma mb mt jx md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">相关的现实生活数据通常不容易获得，并且通常是杂乱的、非结构化的，并且在大多数情况下是没有标记的。</p></blockquote><p id="b22a" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">这句话在商业场景中非常适用。监督模型的一个关键要素是<strong class="lx iu">训练的先验标记数据。</strong></p><p id="8ae3" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">业务团队找到创造性的方法来标记可用于训练模型的数据。</p><p id="15ae" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">三种主要方式</p><ul class=""><li id="cd3f" class="na nb it lx b ly ms mb mt li nc lm nd lq ne mn nf ng nh ni bi translated">人类标记</li><li id="61b8" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">基于规则的标注</li><li id="2847" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">合成数据标记</li></ul><p id="3992" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated"><em class="mr">不要误会，上面的列表并不详尽，因为还有其他方法，如</em> <strong class="lx iu"> <em class="mr">无监督/半监督模型标记</em> </strong> <em class="mr">。但就像上面提到的方法一样，它们只是代理标记，因为即使是人类标记也会有错误。</em></p><p id="ab11" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">我们今天要关注的一种方法是<strong class="lx iu">合成数据标记</strong>。这涉及到人工生成的数据，既有正面的也有负面的情景要识别。反过来，这可以用于训练/建立基线模型，该模型可以随着时间的推移得到改进和监控。</p><p id="4c29" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated"><em class="mr">(通常建议在生产初期以影子模式实现此类模型)</em></p><p id="6c7a" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">假设我们想知道一封进入数据库的电子邮件是不是乱码。我们没有现成的标记数据来进行分类，而且人工标记很昂贵。实事求是地说，预计数据库中的乱码邮件和非乱码邮件的类别会不平衡。该团队决定综合生成带有电子邮件标签的电子邮件类型，因为这似乎比其他选项更容易。</p><p id="5e9a" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">为此，我们需要两样东西。</p><ul class=""><li id="0ad5" class="na nb it lx b ly ms mb mt li nc lm nd lq ne mn nf ng nh ni bi translated">获取无意义的文本或单词</li><li id="a30e" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">访问令人信服、格式正确的电子邮件</li></ul><p id="5fcb" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">所有这些都将在python中完成</p><p id="5fb7" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated"><strong class="lx iu">对于乱码文本数据集</strong>，<a class="ae ky" href="https://www.kaggle.com/datasets/johnwdata/gibberish-text-classification?select=Gibberish.csv" rel="noopener ugc nofollow" target="_blank">这个</a>数据集来源于Kaggle。</p><p id="bc4e" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated"><strong class="lx iu">为了让人相信格式正确的电子邮件</strong>，我们将使用一个名为<strong class="lx iu"> Faker </strong>的库来生成它们。Pip安装库，以便继续。</p><p id="c2aa" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated"><em class="mr">为了简单起见，我们将只考虑三个最受欢迎的域名的电子邮件:gmail.com、yahoo.com和hotmail.com</em></p><p id="dac3" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">关于数据集，乱码文本来源于此，它是通过汇编成千上万个糟糕的亚马逊调查回复创建的。</p><h2 id="3587" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码演示</h2><p id="9d51" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">代码步骤可以总结为4个步骤</p><ul class=""><li id="d4f4" class="na nb it lx b ly ms mb mt li nc lm nd lq ne mn nf ng nh ni bi translated">读那些胡言乱语</li><li id="c01e" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">创建类似胡言乱语的电子邮件和看起来真实的电子邮件</li><li id="9b98" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">标记两种电子邮件类型并合并数据</li><li id="fc19" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">转换为Pandaframe并存储/保存数据</li></ul><h2 id="c42f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> 1。念着胡言乱语的文字</strong></h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4109" class="kz la it np b gy nt nu l nv nw">import pandas as pd</span><span id="ad4a" class="kz la it np b gy nx nu l nv nw">df = pd.read_csv('/work/Gibberish.csv')</span><span id="d635" class="kz la it np b gy nx nu l nv nw">df['Response'] = df['Response'].str.replace(' ', '')</span><span id="d1d6" class="kz la it np b gy nx nu l nv nw">focus_df = df[df['Response'].str.len() &lt;= 21]<br/>gibberish_text = list(focus_df['Response'])</span></pre><p id="ee0f" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">上面的代码读取乱码文本数据，删除文本之间的所有空格，而<strong class="lx iu">为了简单起见</strong>，只获取长度小于或等于21的文本。然后将乱码文本列转换为列表。</p><p id="1056" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">输出列表如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="a259" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.创建类似胡言乱语的电子邮件和看起来真实的电子邮件</h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e0a7" class="kz la it np b gy nt nu l nv nw">from faker import Faker</span><span id="1ead" class="kz la it np b gy nx nu l nv nw">import random</span><span id="a229" class="kz la it np b gy nx nu l nv nw">fake = Faker()</span><span id="1796" class="kz la it np b gy nx nu l nv nw">def transform(number, text_list=None):</span><span id="cd0a" class="kz la it np b gy nx nu l nv nw">    domain_list = ['gmail.com', 'yahoo.com', 'hotmail.com']</span><span id="7dca" class="kz la it np b gy nx nu l nv nw">    if text_list is not None:</span><span id="e80d" class="kz la it np b gy nx nu l nv nw">        result = [random.choice(text_list) for i in range(number)]</span><span id="7ce7" class="kz la it np b gy nx nu l nv nw">        result = [i+'@'+random.choice(domain_list) for i in result]</span><span id="ed1f" class="kz la it np b gy nx nu l nv nw">    else:</span><span id="dc9a" class="kz la it np b gy nx nu l nv nw">        result = [fake.profile()['mail'] for _ in range(2000)]</span><span id="3f2b" class="kz la it np b gy nx nu l nv nw">    return result</span><span id="53c6" class="kz la it np b gy nx nu l nv nw">gibberish_list = transform(2000, gibberish_text)</span><span id="750e" class="kz la it np b gy nx nu l nv nw">email_list = transform(2000)</span></pre><p id="61a3" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">上面的代码</p><ul class=""><li id="7541" class="na nb it lx b ly ms mb mt li nc lm nd lq ne mn nf ng nh ni bi translated">实例化<strong class="lx iu"> Faker </strong>类，该类用于在创建的函数中生成2000封看起来令人信服的电子邮件</li><li id="ffcc" class="na nb it lx b ly nj mb nk li nl lm nm lq nn mn nf ng nh ni bi translated">该功能还用于随机选择2000个乱码文本，并将每个文本与随机选择的域连接起来。</li></ul><p id="79a1" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">乱码邮件的输出如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="2010" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.标记两种电子邮件类型并合并</h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="95ef" class="kz la it np b gy nt nu l nv nw">def label_and_zip_list(label_constant, list_name):</span><span id="3708" class="kz la it np b gy nx nu l nv nw">    tag = [label_constant] * len(list_name)</span><span id="b484" class="kz la it np b gy nx nu l nv nw">    return list(zip(list_name, tag))<br/></span><span id="d8b4" class="kz la it np b gy nx nu l nv nw">gibberish_zip = label_and_zip_list(1,gibberish_list )</span><span id="daaa" class="kz la it np b gy nx nu l nv nw">email_zip = label_and_zip_list(0,email_list)</span><span id="8edb" class="kz la it np b gy nx nu l nv nw">email_zip.extend(gibberish_zip)</span></pre><p id="8fe0" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">从上面的代码中，两种电子邮件类型都被标记并存储在python zip中</p><h2 id="d606" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4.将压缩数据转换为Pandaframe并存储/保存数据</h2><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b5dd" class="kz la it np b gy nt nu l nv nw">data = pd.DataFrame(email_zip, columns=['email', 'label'])<br/>data.to_csv('labelled_email_types.csv',index=False)</span></pre><p id="5d47" class="pw-post-body-paragraph lv lw it lx b ly ms ju ma mb mt jx md li mv mf mg lm mx mi mj lq mz ml mm mn im bi translated">数据帧的输出如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa nz l"/></div></figure><h2 id="61e9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="cd4a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">恭喜你，你现在有了乱码邮件标记的数据，可以用作基线数据集来训练和建立基线模型。这并不需要很多资源。当然，这种方法也有一些问题，其中一个明显的问题就是样本偏差。然而，这是构建一个基线模型的良好开端，可以对其进行分析、监控、评估和改进。这就是数据科学和机器学习的美妙之处。这是一个迭代的过程，一开始总会有“不那么完美”的模型。</p><blockquote class="ob"><p id="6ac3" class="oc od it bd oe of og oh oi oj ok mn dk translated">你不能改进还没有建成或完成的东西。总会有一个<strong class="ak">版本1 </strong></p></blockquote></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><blockquote class="mo mp mq"><p id="7ca8" class="lv lw mr lx b ly ms ju ma mb mt jx md mu mv mf mg mw mx mi mj my mz ml mm mn im bi translated">使用此<a class="ae ky" href="https://anitaokoh.medium.com/membership" rel="noopener">链接</a>订阅媒体，并获取媒体上的所有报道</p></blockquote></div></div>    
</body>
</html>