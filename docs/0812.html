<html>
<head>
<title>The Architecture and Implementation of VGG-16</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VGG-16的体系结构和实现</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-architecture-and-implementation-of-vgg-16-b050e5a5920b?source=collection_archive---------0-----------------------#2020-08-17">https://pub.towardsai.net/the-architecture-and-implementation-of-vgg-16-b050e5a5920b?source=collection_archive---------0-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="18ea" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><p id="b6c3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi kx translated"><span class="l ky kz la bm lb lc ld le lf di"> V </span> <strong class="kb jd"> GG </strong>是牛津大学视觉几何小组的首字母缩写<strong class="kb jd"> VGG-16 </strong>是视觉几何小组提出的16层网络。这16层包含可训练参数，还有其他层也像最大池层，但那些不包含任何可训练参数。该架构是2014年视觉识别挑战赛的亚军，即<strong class="kb jd"> <em class="lg"> ILSVRC-2014 </em> </strong>，由<em class="lg"/><strong class="kb jd"><em class="lg">Simon Yan</em></strong>和<strong class="kb jd"> <em class="lg"> Zisserman </em> </strong>开发。</p><p id="3470" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">VGG研究组发布了从VGG11到VGG19的一系列卷积网络模型。VGG深度小组的主要目的是了解卷积网络的深度如何影响大规模图像分类和识别模型的准确性。与具有16个卷积层和3个全连接层的最大VGG19相比，最小VGG11具有8个卷积层和3个全连接层。vgg的不同变体在最后三个完全连接的层中完全相同。整体结构包括5组卷积层，后面是一个最大池。但不同之处在于，随着深度的增加，即从VGG11到VGG19，越来越多的级联卷积层被添加到五组卷积层中。</p><p id="55ac" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">下图是VGG创建的不同模型的整体网络配置，这些模型使用相同的原理，只是深度不同。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/95bc5b899e7c025d96e65a263f7b12b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dsdd_ElH2V-CyrqnGZWdtw.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd lx">来自原始纸张的图像-参考文献[1] </strong></figcaption></figure><p id="19de" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">从上面代表不同网络的比较表中，我们可以看到，随着模型从简单到复杂，网络的深度也在增加。这是解决任何问题的最佳方式，也就是说，用一个更简单的模型解决问题，然后通过使它变得复杂来逐步优化它。</p><p id="a31b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">下图显示了不同型号中可训练参数的数量:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/459914ad0ed0fb5e3c77b407e4699cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*1s6aMw5L1S8IrUR4f4BluA.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd lx">来自原始纸张的图像-参考文献[1] </strong></figcaption></figure><p id="d44e" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在这里，我们将深入探索VGG 16号的建筑。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lz"><img src="../Images/146286df4bc5c0d377ea962fbf09fe62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Lg1i7wv1pLpzp2F4MLrvw.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd lx">来自Researchgate.net的VGG 16号的建筑图片</strong></figcaption></figure><p id="b074" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上图中，所有蓝色矩形代表卷积层以及非线性激活函数，它是一个校正的线性单元(或ReLU)。从图中可以看出，有13个蓝色和5个红色矩形，即有13个卷积层和5个最大池层。除此之外，还有3个绿色矩形，代表3个完全连接的层。因此，具有可调参数的总层数为16层，其中13层用于卷积层，3层用于全连接层，因此命名为VGG-16。在输出端，我们有一个softmax层，在imagenet数据集中每个图像类别有1000个输出。</p><p id="7721" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在这种架构中，我们从一个非常低的通道大小(64)开始，然后在每个最大池层之后逐渐增加2倍，直到达到512。</p><p id="d29f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">VGG-16的扁平架构如下图所示:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ma"><img src="../Images/151e654a3940335d5fe5c358a6b7339f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqkQYVB3_Gw0hjrAMzi6_A.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd lx">作者图片</strong></figcaption></figure><p id="e00d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">架构非常简单。它有2个由2个卷积层组成的连续块，后跟一个最大池，然后有3个由3个卷积层组成的连续块，后跟一个最大池，最后，我们有3个密集层。后3个卷积层在不同的架构中具有不同的深度。</p><p id="a086" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这里要分析的重要一点是，每次最大池化之后，大小都会减半。</p><h1 id="cde4" class="mb mc it bd lx md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">VGG-16网络的特点</h1><ol class=""><li id="2b3f" class="my mz it kb b kc na kg nb kk nc ko nd ks ne kw nf ng nh ni bi translated"><strong class="kb jd">输入层:</strong>接受彩色图像作为输入，尺寸为224 x 224，3个通道，即红、绿、蓝。</li><li id="6666" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><strong class="kb jd">卷积层:</strong>图像通过一堆卷积层，其中每个卷积滤波器都有一个3 x 3的非常小的感受野和1的步幅。每个卷积核使用行和列填充，以便输入和输出特征图的大小保持不变，或者换句话说，执行卷积后的分辨率保持不变。</li><li id="11d9" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated"><strong class="kb jd">最大池:</strong>它在大小为2 x 2的最大池窗口上执行，跨距等于2，这意味着这里的最大池窗口是非重叠窗口。</li><li id="3957" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">并非每个卷积层后面都有一个最大池层，因为在某些地方，一个卷积层后面是另一个卷积层，中间没有最大池层。</li><li id="493b" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">前两个完全连接的层各有4096个通道，第三个完全连接的层(也是输出层)有1000个通道，每个通道用于imagenet数据库中的一类图像。</li><li id="7a43" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">隐藏层的激活函数是ReLU。</li></ol></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><blockquote class="nv nw nx"><p id="fd56" class="jz ka lg kb b kc kd ke kf kg kh ki kj ny kl km kn nz kp kq kr oa kt ku kv kw im bi translated"><strong class="kb jd">注意:</strong>这里要注意的一件重要事情是，我们使用了3 x 3的内核大小，这是捕捉左/右、上/下和中心概念的最小可能大小。此外，两个3 × 3卷积层(中间没有空间汇集或最大汇集)的堆叠具有5×5的有效感受野，并且相同的三个3 × 3卷积层具有7 × 7的有效感受野。</p></blockquote><h2 id="77a6" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated"><strong class="ak">让我们从数学上来理解这个:</strong></h2><blockquote class="om"><p id="62b5" class="on oo it bd op oq or os ot ou ov kw dk translated">用于计算每个卷积层的输出大小的公式如下- [(N-f)/S] + 1</p></blockquote><p id="432d" class="pw-post-body-paragraph jz ka it kb b kc ow ke kf kg ox ki kj kk oy km kn ko oz kq kr ks pa ku kv kw im bi translated">假设我们有一个形状为224 x 224的输入，具有K个通道，即224 x 224 x K。我们将使用步长=1的不同大小的内核来应用卷积。</p><h2 id="11f5" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">情况1:当我们的内核大小为3×3时</h2><ul class=""><li id="8bfc" class="my mz it kb b kc na kg nb kk nc ko nd ks ne kw pb ng nh ni bi translated"><strong class="kb jd">第一次卷积后</strong></li></ul><p id="95b2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">N = 224，f = 3，S = 1</p><p id="8ba4" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">输出形状<strong class="kb jd">=</strong>[(N-f)/S]+1<strong class="kb jd">=</strong>[(224–3)/1]+1<strong class="kb jd">=</strong>222</p><ul class=""><li id="7757" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">第二次卷积后</strong></li></ul><p id="4bbf" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">N = 222，f = 3，S = 1</p><p id="3681" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">输出形状<strong class="kb jd">=</strong>[(N-f)/S]+1<strong class="kb jd">=</strong>[(222–3)/1]+1<strong class="kb jd">=</strong>220</p><ul class=""><li id="dc39" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">在第三个卷积后</strong></li></ul><p id="ecb5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">N = 220，f = 3，S = 1</p><p id="cee3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">输出形状<strong class="kb jd">=</strong>[(N-f)/S]+1<strong class="kb jd">=</strong>[(220–3)/1]+1<strong class="kb jd">=</strong>218</p><p id="5065" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">因此，在三次同时卷积之后，我们得到了大小为<strong class="kb jd"> 218 x 218 x K </strong>的输出</p><h2 id="de53" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">案例2:当我们的内核大小为7×7时</h2><p id="f292" class="pw-post-body-paragraph jz ka it kb b kc na ke kf kg nb ki kj kk pf km kn ko pg kq kr ks ph ku kv kw im bi translated">N = 224，f = 7，S = 1</p><p id="db40" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">输出形状<strong class="kb jd">=</strong>[(N-f)/S]+1<strong class="kb jd">=</strong>[(224–7)/1]+1<strong class="kb jd">=</strong>218</p><p id="758c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">因此，仅在一次卷积之后，我们就获得了大小为<strong class="kb jd"> 218 x 218 x K </strong>的输出</p><p id="cb33" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">因此，看着上面的两种情况，我们说三个3 × 3卷积层具有7 × 7的有效感受野。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="f038" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">内核大小为3 x 3的优势</h2><ol class=""><li id="126f" class="my mz it kb b kc na kg nb kk nc ko nd ks ne kw nf ng nh ni bi translated">因为我们知道的卷积层数越多，与层数较少时相比，从输入中提取的特征就越清晰。因此，具有3×3的内核大小将导致比7×7的内核大小更好的特征提取。</li><li id="d5a4" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">当我们取3×3内核大小时，可训练参数的数量将是27K，相比之下，当取7×7内核大小时，给出49K可训练参数，多81%。</li></ol></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="77de" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">从每个图层获取输出大小所涉及的计算</h2><p id="c17e" class="pw-post-body-paragraph jz ka it kb b kc na ke kf kg nb ki kj kk pf km kn ko pg kq kr ks ph ku kv kw im bi translated">下表总结了VGG-16的完整结构:</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi pi"><img src="../Images/252b3d88ee284aff8f57845681e24196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEuoX8lso9vNn8savmTwHQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd lx">作者图片</strong></figcaption></figure><p id="b3e5" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">输入图层</em> : </strong></p><ul class=""><li id="58d7" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated">输入图像的尺寸为<strong class="kb jd"> 224 x 224 </strong>。</li></ul><p id="daec" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 1 </em> : </strong></p><ul class=""><li id="5df6" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 224</li><li id="6d65" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f =</strong>3×3</li><li id="906a" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">过滤器的数量=  64</li><li id="cfa7" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">步幅= S = </strong> 1</li><li id="b9d1" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">填充= P = </strong> 1</li><li id="9944" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(224–3+2)/1]+1<strong class="kb jd">=</strong>224</li><li id="f136" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">带通道的输出= </strong> 224 x 224 x 64</li></ul><p id="2cbe" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 2 </em> : </strong></p><ul class=""><li id="ddd9" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 224</li><li id="bfe0" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f = </strong> 3 x 3</li><li id="89b1" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">过滤器的数量=  64</li><li id="67c4" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">大踏步= S = </strong> 1</li><li id="f093" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">填充= P =  1</li><li id="e6e7" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征映射大小=</strong>[(224–3+2)/1]+1<strong class="kb jd">=</strong>224</li><li id="d39b" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">通道输出= </strong> 224 x 224 x 64</li></ul><p id="07e6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">最大池层- 1 </em> : </strong></p><ul class=""><li id="76fa" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 224</li><li id="2f43" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">滤镜尺寸= f = </strong> 2 x 2</li><li id="b7e8" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">步幅= S =  2</li><li id="2516" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd"> Padding = P = </strong> 0</li><li id="c163" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(224–2+0)/2]+1<strong class="kb jd">=</strong>112</li><li id="1e9a" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">带通道的输出=</strong>112×112×64</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="a35c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 3 </em> : </strong></p><ul class=""><li id="75d7" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 112</li><li id="4712" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f = </strong> 3 x 3</li><li id="f5e5" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器数量= 128</strong></li><li id="b3fd" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">大踏步= S = </strong> 1</li><li id="9b0a" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">填充= P = </strong> 1</li><li id="1149" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(112–3+2)/1]+1<strong class="kb jd">= 112</strong></li><li id="14cb" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">通道输出= </strong> 112 x 112 x 128</li></ul><p id="c014" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 4 </em> : </strong></p><ul class=""><li id="0f57" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 112</li><li id="3fda" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f =</strong>3×3</li><li id="7c37" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">过滤器数量=  128</li><li id="4837" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">大步数= S = </strong> 1</li><li id="bf64" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">填充= P = </strong> 1</li><li id="6f61" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图size =</strong>[(112–3+2)/1]+1<strong class="kb jd">=</strong>112</li><li id="0b2b" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">通道输出= </strong> 112 x 112 x 128</li></ul><p id="7cb2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"><em class="lg">Max-Pooling Layer-2</em>:</strong></p><ul class=""><li id="ccde" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 112</li><li id="dbc1" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f = </strong> 2 x 2</li><li id="fd90" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">2大踏步</li><li id="9519" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd"> Padding = P = </strong> 0</li><li id="012e" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(112–2+0)/2]+1<strong class="kb jd">=</strong>56</li><li id="be8b" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">通道输出=</strong>56×56×128</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="79ef" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 5 </em> : </strong></p><ul class=""><li id="d912" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 56</li><li id="b9a7" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f =</strong>3×3</li><li id="52ff" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">过滤器数量=  256</li><li id="384d" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">大步数= S = </strong> 1</li><li id="603f" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">填充= P = </strong> 1</li><li id="1b2c" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(56–3+2)/1]+1<strong class="kb jd">=</strong>56</li><li id="0ab4" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">带通道的输出=</strong>56×56×256</li></ul><p id="506d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 6 </em> : </strong></p><ul class=""><li id="5546" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 56</li><li id="7c2e" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f = </strong> 3 x 3</li><li id="1c0f" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">过滤器数量=  256</li><li id="7ad3" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">步幅= S =  1</li><li id="b866" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">1</strong></li><li id="bed6" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图size =</strong>[(56–3+2)/1]+1<strong class="kb jd">=</strong>56</li><li id="86db" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">通道输出= </strong> 56 x 56 x 256</li></ul><p id="1e6b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">卷积层- 7 </em> : </strong></p><ul class=""><li id="213e" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 56</li><li id="accd" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f = </strong> 3 x 3</li><li id="3486" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">过滤器数量=  256</li><li id="a6ae" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">大踏步= S =  1</li><li id="1aed" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">填充= P =  1</li><li id="3034" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(56–3+2)/1]+1<strong class="kb jd">=</strong>56</li><li id="cb42" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出通道数=</strong>56×56×256</li></ul><p id="f9f7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"><em class="lg">Max-Pooling Layer-3</em>:</strong></p><ul class=""><li id="d537" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw pb ng nh ni bi translated"><strong class="kb jd">输入大小= N = </strong> 56</li><li id="b36c" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">过滤器尺寸= f = </strong> 2 x 2</li><li id="60f0" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">大步数= S = </strong> 2</li><li id="cc19" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">填充= P = </strong> 0</li><li id="0f24" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">输出特征图大小=</strong>[(56–2+0)/2]+1<strong class="kb jd">=</strong>28</li><li id="fe3d" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated"><strong class="kb jd">带通道的输出=</strong>28×28×256</li></ul><p id="6ec1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">将对网络的其余部分进行类似的计算。</strong></p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="0420" class="mb mc it bd lx md pj mf mg mh pk mj mk ml pl mn mo mp pm mr ms mt pn mv mw mx bi translated">VGG-16和AlexNet的区别</h1><ol class=""><li id="b7d6" class="my mz it kb b kc na kg nb kk nc ko nd ks ne kw nf ng nh ni bi translated">与VGG-16相比，其中所有卷积核的大小都是统一的3×3，跨距为1，AlexNet具有可变大小的卷积核，如5×5和3×3。</li></ol><p id="0053" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">虽然AlexNet使用不同大小的多个核，但是不同大小的每个卷积核的实现可以使用多个3×3大小的核来完成。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><blockquote class="om"><p id="8534" class="on oo it bd op oq or os ot ou ov kw dk translated">探索VGG16架构的代码</p></blockquote><p id="8371" class="pw-post-body-paragraph jz ka it kb b kc ow ke kf kg ox ki kj kk oy km kn ko oz kq kr ks pa ku kv kw im bi translated"><strong class="kb jd">任务- </strong>将图像分成两类- <strong class="kb jd"> <em class="lg">猫</em> </strong>和<strong class="kb jd"> <em class="lg">狗</em> </strong></p><p id="4acd" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">有两种方法可以完成这项任务- </strong></p><ol class=""><li id="51ed" class="my mz it kb b kc kd kg kh kk pc ko pd ks pe kw nf ng nh ni bi translated">从头开始编写代码</li><li id="4eef" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">使用在imagenet数据集上训练的预训练VGG16模型</li></ol></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="b403" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">方法-1: W <em class="lg">从头开始编写VGG16架构代码</em> </strong></p><h2 id="ea55" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*导入库:</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="3717" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*增加训练和测试数据集</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="c968" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*模型的创建</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="ebae" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*模型摘要</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="7c23" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lg">总结的输出如下:</em></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi pq"><img src="../Images/c06b40c6b541e9e9d9103187c56d8acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*m323IW157xAbL2yJzUWqbw.png"/></div></div></figure><h2 id="8619" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*模型的编译</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="e0e2" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*拟合模型</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="c1b6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lg">拟合的输出如下:</em></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi pr"><img src="../Images/52350ac3b30c15382a990366b80d92aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIzhXVLNofz3aytrz_r-2A.png"/></div></div></figure><h2 id="770c" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*加载图像进行测试</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="cfe7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lg">待预测的图像如下:</em></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/39b9999aa547ba2f4bac80f34a09354c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*fEJodYPcw0cOWhUQLQBBfg.jpeg"/></div></figure><h2 id="dfc6" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*将加载的图像转换成数组</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="17c9" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*预测加载图像的标签</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="e8e3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lg">输出将- </em> <strong class="kb jd"> <em class="lg">猫</em> </strong></p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="3c24" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">方法-2: U <em class="lg">唱出在imagenet数据集上训练的预训练VGG16模型</em> </strong></p><h2 id="8174" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*直到增强，步骤将与上述方法相同</h2><blockquote class="nv nw nx"><p id="0a70" class="jz ka lg kb b kc kd ke kf kg kh ki kj ny kl km kn nz kp kq kr oa kt ku kv kw im bi translated">现在，首先需要下载预训练VGG16模型的权重。</p></blockquote><h2 id="34a3" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*从预先训练的模型中下载重量</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="3429" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lg">第一次运行时，上述代码会将权重下载到我们的本地系统，因此第一次运行上述代码将需要一些时间来执行，因为下载的权重大约为528 Mb，当您再次运行相同的代码时，将需要几秒钟的时间来执行，因为这次权重将被本地加载，并使模型在几秒钟内即可使用</em></p><h2 id="4049" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">注意:</h2><ul class=""><li id="d976" class="my mz it kb b kc na kg nb kk nc ko nd ks ne kw pb ng nh ni bi translated">从上面的总结中，我们可以看到，我们已经把<code class="fe pt pu pv pw b">include_top = False</code>因此，我们没有密集层在我们的总结。</li><li id="2ceb" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">此外，我们输入了<code class="fe pt pu pv pw b">weights="imagenet"</code>,这意味着我们需要在imagenet数据集上训练的VGG-16模型的权重</li><li id="bea4" class="my mz it kb b kc nj kg nk kk nl ko nm ks nn kw pb ng nh ni bi translated">正如我们所说的<code class="fe pt pu pv pw b">include_top = False</code>，这就是为什么必须指定<code class="fe pt pu pv pw b">input_shape</code>参数的原因。</li></ul><h2 id="461b" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*防止训练13个卷积层</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="cc03" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*模型的创建</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="723c" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*编译模型</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><h2 id="7601" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*拟合模型</h2><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="e953" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><em class="lg">拟合的输出如下:</em></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi px"><img src="../Images/680b2529a46629e81438e78e6aef252f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZruyBM0iyTu4bTZYkSqUEA.png"/></div></div></figure><h2 id="9386" class="ob mc it bd lx oc od dn mg oe of dp mk kk og oh mo ko oi oj ms ks ok ol mw iz bi translated">*其余步骤将与前一方法相同</h2></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="5554" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">📌<strong class="kb jd">要获得VGG16或任何其他网络的完整代码，请访问我的</strong> <a class="ae py" href="https://github.com/vaibhavcodes/DeepLearning-Architectures" rel="noopener ugc nofollow" target="_blank"> <strong class="kb jd"> GitHub资源库</strong> </a> <strong class="kb jd">。</strong></p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="886f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd"> <em class="lg">参考文献</em> </strong></p><p id="843d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">[1]卡伦·西蒙扬*和安德鲁·齐泽曼，<a class="ae py" href="https://arxiv.org/pdf/1409.1556.pdf" rel="noopener ugc nofollow" target="_blank">用于大规模图像识别的极深度卷积网络</a>，2015年ICLR会议论文</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><blockquote class="om"><p id="089d" class="on oo it bd op oq or os ot ou ov kw dk translated">感谢阅读。希望这篇博客对你的编码和理解架构有所帮助。😃</p></blockquote></div></div>    
</body>
</html>