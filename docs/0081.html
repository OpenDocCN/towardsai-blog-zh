<html>
<head>
<title>The Why, When, and How of Using Python Multi-threading and Multi-Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python多线程和多处理的原因、时间和方式</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/the-why-when-and-how-of-using-python-multi-threading-and-multi-processing-afd1b8a8ecca?source=collection_archive---------0-----------------------#2019-06-21">https://pub.towardsai.net/the-why-when-and-how-of-using-python-multi-threading-and-multi-processing-afd1b8a8ecca?source=collection_archive---------0-----------------------#2019-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9057" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a>，<a class="ae ep" href="https://towardsai.net/p/category/programming/python" rel="noopener ugc nofollow" target="_blank"> Python </a></h2><div class=""/><div class=""><h2 id="935a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">本指南旨在解释为什么Python中需要多线程和多处理，何时使用其中一个，以及如何在程序中使用它们。作为一名人工智能研究人员，我在为我的模型准备数据时广泛使用它们！</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/603d5717433776c8294fb9a76e1e06ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5m-oIHJA4WLcnUMttLgUA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3216677" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lh" href="https://pixabay.com/users/Parker_West-7094318/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3216677" rel="noopener ugc nofollow" target="_blank"> Parker_West </a></figcaption></figure><p id="0515" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很久以前，在一个遥远的星系里…</p><p id="4f6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个聪明而强大的巫师住在一个偏僻的小村庄里。让我们叫他Dumbledalf。他不仅智慧和强大，而且他也乐于帮助任何请求帮助的人，这意味着人们会从四面八方向巫师寻求帮助。我们的故事开始于一个晴朗的日子，一个年轻的旅行者带给巫师一个魔法卷轴。旅行者不知道卷轴上有什么，但他知道如果有人能破译卷轴上的秘密，那一定是伟大的巫师丹布尔达夫。</p><h2 id="99cd" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">第1章:单线程、单进程</h2><p id="3e3e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你还没有猜到，我的这个相当伤感的比喻是在谈论CPU及其功能。我们的向导是CPU，而神奇的卷轴是一系列的<em class="nb">URL</em>,它引导出Python的力量和运用这种力量的知识。</p><p id="d2b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">巫师毫不费力地破译了卷轴，他的第一个想法是派他信任的朋友<em class="nb">(哈拉贡？我知道，我知道，那太可怕了)</em>到卷轴上给出的每一个位置去看看，把他能找到的东西带回来。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2089" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，我们只是使用一个<code class="fe ne nf ng nh b">for loop</code>一个接一个地缓慢通过<em class="nb">URL并读取响应。感谢<code class="fe ne nf ng nh b">%%time</code>IPython的魔力，</em>我们可以看到，在我糟糕的互联网上，它只需要12秒。</p><h2 id="0bfd" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">第2章:多线程</h2><p id="ac79" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">巫师的智慧在这片土地上广为人知，他很快就想出了一个更有效的方法。与其按顺序派一个人去每个地点，为什么不召集一群(值得信赖的)人，同时分别派他们去每个地点，<em class="nb">！一旦他们都回来了，巫师可以简单地组合他们带来的所有东西。</em></p><p id="7aef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没错，我们可以使用<code class="fe ne nf ng nh b">multithreading</code>同时访问多个<em class="nb">URL</em>，而不是逐个遍历列表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b2c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好多了！几乎像..魔法。使用多线程可以显著提高许多<strong class="lk jd"> <em class="nb"> IO绑定</em> </strong>任务的速度。这里，读取<em class="nb">URL</em>所花费的大部分时间是由于网络延迟。<strong class="lk jd"> <em class="nb"> IO绑定</em> </strong>程序大部分时间都在等待，你猜对了，输入/输出<em class="nb">(类似于向导需要等待他的一个/多个朋友去卷轴中给定的位置然后回来)</em>。这可能是来自网络、数据库、文件甚至用户的I/O。这种I/O往往会花费大量的时间，因为源本身可能需要在传递I/O之前执行自己的处理。例如，CPU的工作速度比网络连接传送数据的速度快得多(想想Flash与您的祖母)。</p><p id="f7e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nb">注意:</em> <code class="fe ne nf ng nh b"><em class="nb">Multithreading</em></code> <em class="nb">在网页抓取这样的任务中非常有用。</em></p><h2 id="40e2" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">第3章:多重处理</h2><p id="8724" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">随着岁月的流逝，我们巫师的名声越来越大，一个相当令人讨厌的黑巫师(萨鲁铎)也受到了嫉妒？沃尔德曼。).在狡猾和嫉妒的驱使下，黑巫师对邓布利达尔夫施了一个可怕的诅咒。一旦诅咒被解除，丹布尔达尔夫知道他只有很短的时间来打破它。绝望中，他翻看了他的咒语书，发现了一个看起来可能有用的反咒语。唯一的问题是，它要求他计算1000000以下所有质数的总和。奇怪的咒语，但事实就是如此。</p><p id="1755" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，向导知道如果有足够的时间，计算值将是微不足道的，但时间对他来说不是奢侈品。尽管他是个巫师，但他也受到人性的限制，一次只能计算一个数字。如果他要一个一个地把质数加起来，那要花太长时间了。在逆转诅咒还剩几秒钟的时候，他突然想起了几年前从魔法卷轴中学到的<code class="fe ne nf ng nh b">multiprocessing</code>咒语。这个咒语可以让他复制自己，并且把复制的数字分开可以让他同时检查多个数字是否是质数。最后，他要做的就是把他和他的复制品发现的所有质数加起来。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="adee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于现代CPU通常拥有不止一个内核，我们可以通过使用<code class="fe ne nf ng nh b">multiprocessing</code>模块来加速<strong class="lk jd"> <em class="nb"> CPU绑定的</em> </strong>任务。<strong class="lk jd"> <em class="nb"> CPU受限</em> </strong>任务是将大部分时间花在CPU中执行计算(数学计算、图像处理等)的程序。).如果计算可以彼此独立地执行，我们可以在可用的CPU内核之间进行分配，从而显著提高处理速度。</p><p id="4f53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你要做的就是:</p><ol class=""><li id="0c19" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">定义要应用的功能</li><li id="3b89" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">准备要应用该功能的项目列表</li><li id="f2d7" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">使用<code class="fe ne nf ng nh b">multiprocessing.Pool</code>生成进程。传递给<code class="fe ne nf ng nh b">Pool()</code>的数字将是产生的进程数。嵌入在一个<code class="fe ne nf ng nh b">with</code>语句中确保了进程在完成执行后被终止。</li><li id="839c" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">使用池进程的<code class="fe ne nf ng nh b">map</code>函数组合输出。<code class="fe ne nf ng nh b">map</code>功能的输入是应用于每个项目的功能和项目列表。</li></ol><p id="77ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nb">注意:可以定义函数，以便执行任何可以并行完成的任务。例如，该函数可能包含将计算结果写入文件的代码。</em></p><p id="0b7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，为什么我们需要分开的<code class="fe ne nf ng nh b">multiprocessing</code>和<code class="fe ne nf ng nh b">multithreading</code>？如果你试图使用<code class="fe ne nf ng nh b">multithreading</code>来提高一个<strong class="lk jd"> <em class="nb"> CPU绑定的</em> </strong>任务的性能，你可能会注意到你实际得到的是一个<strong class="lk jd"> <em class="nb">性能下降</em> </strong>。异端！让我们看看为什么会这样。</p><p id="3583" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像巫师被他的人性所限制，一次只能计算一个数字一样，Python自带了一个叫做<strong class="lk jd">全局解释器锁(GIL)的东西。</strong> Python会很乐意让你产生尽可能多的<code class="fe ne nf ng nh b">threads</code>，但是<strong class="lk jd"> GIL </strong>确保在任何给定的时间，那些<code class="fe ne nf ng nh b">threads</code>中只有<em class="nb">一个</em>会被<em class="nb">执行</em>。</p><p id="46d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于一个与IO相关的<strong class="lk jd"><em class="nb"/></strong>任务来说，这完全没问题。一个<code class="fe ne nf ng nh b">thread</code>向一个URL发出请求，当它等待响应时，那个<code class="fe ne nf ng nh b">thread </code>可以被另一个<code class="fe ne nf ng nh b">thread</code>替换，后者向另一个URL发出另一个请求。因为在收到响应之前<code class="fe ne nf ng nh b">thread</code>不需要做任何事情，所以在给定时间只有一个<code class="fe ne nf ng nh b">thread</code>在执行并不重要。</p><p id="1d0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于一个受<strong class="lk jd"> <em class="nb"> CPU限制的</em> </strong>任务来说，拥有多个<code class="fe ne nf ng nh b">threads</code>就像胸甲上的乳头一样有用。因为一次只有一个<code class="fe ne nf ng nh b">thread</code>被执行，即使你产生了多个<code class="fe ne nf ng nh b">threads</code>，每个都有自己的数来检查<em class="nb">质数</em>，CPU仍然一次只处理一个<code class="fe ne nf ng nh b">thread</code>。实际上，这些数字仍然会被一个接一个地检查。如果在CPU受限的<strong class="lk jd"><em class="nb"/></strong>任务中使用<code class="fe ne nf ng nh b">multithreading</code>，处理多个<code class="fe ne nf ng nh b">threads</code>的开销会导致性能下降。</p><p id="e4de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了避开这个“限制”，我们使用了<code class="fe ne nf ng nh b">multiprocessing</code>模块。<code class="fe ne nf ng nh b">multiprocessing</code>不使用<code class="fe ne nf ng nh b">threads</code>，而是使用多个<code class="fe ne nf ng nh b">processes</code>。每个<code class="fe ne nf ng nh b">process</code>都有自己的解释器和内存空间，所以GIL不会有所保留。本质上，每个<code class="fe ne nf ng nh b">process</code>使用不同的CPU内核同时处理不同的数字<em class="nb">。</em>甜！</p><p id="ab4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能会注意到，与使用简单的for循环甚至是<code class="fe ne nf ng nh b">multithreading</code>相比，使用<code class="fe ne nf ng nh b">multiprocessing</code>时CPU的利用率要高得多。这是因为您的程序使用了多个CPU内核，而不仅仅是一个内核。这是好事！</p><p id="af33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，<code class="fe ne nf ng nh b">multiprocessing</code>有自己的管理多个<code class="fe ne nf ng nh b">processes</code>的开销，这通常比<code class="fe ne nf ng nh b">multithreading</code>的开销更大。(<code class="fe ne nf ng nh b">Multiprocessing</code>衍生出一个单独的解释器，给每个<code class="fe ne nf ng nh b">process</code>分配一个单独的内存空间，所以咄！).这意味着，根据经验，如果可以的话，最好使用轻量级的<code class="fe ne nf ng nh b">multithreading</code>(阅读:<strong class="lk jd"> <em class="nb"> IO绑定的</em> </strong>任务)。当CPU处理成为你的瓶颈时，一般就是召唤<code class="fe ne nf ng nh b">multiprocessing</code>模块的时候了。但是请记住，权力越大，责任越大。</p><p id="d549" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你产生的<code class="fe ne nf ng nh b">processes</code>超过了你的CPU一次可以处理的数量，你会发现你的性能开始下降。这是因为操作系统现在必须做更多的工作来交换进出CPU内核，因为你有更多的内核。现实可能比简单的解释更复杂，但这是基本的想法。当我们到达16 <code class="fe ne nf ng nh b">processes</code>时，您可以在我的系统上看到性能下降。这是因为我的CPU只有16个逻辑核心。</p><h2 id="f04f" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">第四章:TLDR；</h2><ul class=""><li id="9063" class="ni nj it lk b ll mw lo mx lr nw lv nx lz ny md nz no np nq bi translated">对于<strong class="lk jd"> <em class="nb"> IO绑定的</em> </strong>任务，使用<code class="fe ne nf ng nh b">multithreading</code>可以提高性能。</li><li id="f37a" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nz no np nq bi translated">对于<strong class="lk jd"> <em class="nb"> IO绑定的</em> </strong>任务，使用<code class="fe ne nf ng nh b">multiprocessing</code>也能提高性能，但开销往往比使用<code class="fe ne nf ng nh b">multithreading</code>高。</li><li id="57e8" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nz no np nq bi translated">Python GIL意味着在一个Python程序中，任何给定时间只能执行一个<code class="fe ne nf ng nh b">thread</code>。</li><li id="f7d1" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nz no np nq bi translated">对于<strong class="lk jd"> <em class="nb"> CPU绑定的</em> </strong>任务，使用<code class="fe ne nf ng nh b">multithreading</code>实际上会恶化性能。</li><li id="89ce" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nz no np nq bi translated">对于<strong class="lk jd"> <em class="nb"> CPU绑定</em> </strong>的任务，使用<code class="fe ne nf ng nh b">multiprocessing</code>可以提高性能。</li><li id="d0b6" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nz no np nq bi translated">巫师太牛逼了！</li></ul><p id="8d99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对Python中的<code class="fe ne nf ng nh b">multithreading</code>和<code class="fe ne nf ng nh b">multiprocessing</code>的介绍到此结束。勇往直前去征服吧！</p></div></div>    
</body>
</html>