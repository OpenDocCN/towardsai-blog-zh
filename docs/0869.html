<html>
<head>
<title>6 Pandas Operations You Should Not Miss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不应该错过的6个熊猫行动</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/6-pandas-operations-you-should-not-miss-d531736c6574?source=collection_archive---------1-----------------------#2020-08-30">https://pub.towardsai.net/6-pandas-operations-you-should-not-miss-d531736c6574?source=collection_archive---------1-----------------------#2020-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e4fb" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a></h2><div class=""/><div class=""><h2 id="96ec" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">先进的方法和功能来处理一些数据</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e8f5a2e62ecb32290705eea60a6cff52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGRXR8huI0nAgTLz7cR7_w.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来源:<a class="ae le" href="https://www.amazon.com/Kung-Fu-Panda-Jack-Black/dp/B0051XQI84" rel="noopener ugc nofollow" target="_blank">亚马逊</a></figcaption></figure><p id="1942" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Pandas主要用于阅读、清理和从数据中提取见解。我们将看到熊猫的高级用途，这对数据科学家来说非常重要。这些操作用于分析数据，并在需要时对其进行操作。这些在建立任何机器学习模型之前执行的步骤中使用。</p><ol class=""><li id="ea69" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">汇总数据</li><li id="3a1e" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">串联</li><li id="4abc" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">合并并加入</li><li id="3efb" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">分组</li><li id="04b1" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">数据透视表</li><li id="eb3a" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">重塑多索引数据帧</li></ol><p id="e8de" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将使用非常著名的泰坦尼克号数据集来探索熊猫的功能。让我们快速导入NumPy，Pandas，并从Seaborn加载Titanic数据集。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="62b0" class="mu mv iq mq b gy mw mx l my mz"><em class="na">import numpy as np<br/>import pandas as pd<br/>import seaborn as sns</em></span><span id="a947" class="mu mv iq mq b gy nb mx l my mz"><em class="na">df = sns.load_dataset('titanic')<br/>df.head()</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/bfb65f735f25f885ee73de795c467c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzYH7lT5jNEqT2jakPceFw.png"/></div></div></figure><h2 id="4202" class="mu mv iq bd nd ne nf dn ng nh ni dp nj lo nk nl nm ls nn no np lw nq nr ns iw bi translated">汇总数据</h2><p id="a689" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">任何数据科学家首先想知道的是整个数据的统计数据。在熊猫<strong class="lh ja">的帮助下。describe()方法</strong>，我们可以看到每个特性的汇总统计。请注意，统计数据仅针对数字列给出，这是一个显而易见的行为。我们还可以要求describe函数包含参数为“include”且值等于“all”的分类列(include =“all”)。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="4de0" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.describe()</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/20871ba1a0b85b3d94e324c7db7ad16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z616zq9rgPqB16kMhT4eVA.png"/></div></div></figure><p id="49c5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一种方法是<strong class="lh ja">。info() </strong>。它给出了数据集的元数据。我们可以看到数据集的大小、数据类型以及每一列中null值的数量。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="d0e6" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.info()</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c4760fe3ead73e7dfef1e9561f33ad75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*Z_YHdIsnMr8_1E_meJSSdw.png"/></div></figure><h2 id="3d31" class="mu mv iq bd nd ne nf dn ng nh ni dp nj lo nk nl nm ls nn no np lw nq nr ns iw bi translated">串联</h2><p id="bcc6" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">由于Pandas <strong class="lh ja">方法concat() </strong>，两个数据帧的连接非常简单。让我们在向量索引的帮助下，从庞大的数据中取出一小部分。V <strong class="lh ja">向量索引</strong>是一种指定行和列名/整数的方法，我们希望以列表的形式按任意顺序进行索引。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="dba6" class="mu mv iq mq b gy mw mx l my mz"><em class="na">smallData = df.loc[[1,7,21,10], ['sex','age','fare','who','class']]<br/>smallData</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d19bc363cd54c07426a10a51fa015183.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*EXuSqmkv_LQUMVCsK4In4A.png"/></div></figure><p id="1cc7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此外，我还创建了一个包含匹配列的数据集来解释串联。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fb0a32176f76834256e73eff2de5b0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*nzFrArFW-UB8iusB_4uEXg.png"/></div></figure><p id="18e9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">默认情况下，串联按行方式发生<strong class="lh ja"/>。让我们看看当我们连接两个数据帧时，新数据集是什么样子的。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="8bbe" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pd.concat([smallData, newData])</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9954a6f8d1eec0fdd717251629799844.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*mJ3fjNOaw9olgM-N6ThCaA.png"/></div></figure><p id="87d3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们想忽略索引连接呢？只需将<strong class="lh ja"> ingore_index参数</strong>设置为真。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3604" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pd.concat([ newData,smallData], ignore_index=True)</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/76513be4c2a5bc7c278a19d9da080040.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*R3RVF6b_loHFIyhpXMRM9w.png"/></div></figure><p id="1566" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们希望将列和<strong class="lh ja">连接在一起，我们只需将轴参数改为1。</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="17e5" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pd.concat([ newData,smallData], axis=1)</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/04ff3857fdf3d2b1202464c3663a6eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*OnJB-fR5pwXCogECe2GhDg.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/030053eec55702f4d0d13b88a2db622c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*vifWmvrEAYMxvMnEpSYKOQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">左表-小数据，右表-新数据</figcaption></figure><p id="c9e9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意到变化了吗？当我们按列连接时，Pandas按行索引的顺序排列数据。在smallData中，行0和行2缺失，但在newData中存在，因此按顺序插入它们。但是我们在数据中都有第1行，Pandas保留了第1个数据集的数据，因为这是我们作为参数传递给concat的第1个数据集。此外，缺失的数据表示为NaN。</p><p id="c2b1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还可以以<strong class="lh ja"> SQL join </strong>的方式执行串联。让我们创建一个新的数据帧“newData ”,它有几列与smallData相同，但不是全部。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/bbf2806f2666a2c539ad9965bc73c417.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*LFMxTcDu6nliUK1d-tIsGw.png"/></div></figure><p id="ca13" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您熟悉SQL连接操作，我们可以注意到这一点。默认情况下，concat()执行<strong class="lh ja">外部连接</strong>。不匹配列的缺失值用NaN填充。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="2cd0" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pd.concat([smallData, newData])</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/887cd67be1d53cc762e068b1280fefaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*viSYfAyjQVMVic0Nx5GOuw.png"/></div></figure><p id="d89f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以通过<strong class="lh ja">“加入”参数</strong>控制加入操作的类型。让我们执行一个内部连接，它只从两个。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="ccc2" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pd.concat([smallData, newData], join='inner')</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/5cb66d17ad3c9260f1bed638984a9aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*f4VHT18eySrdkp8VwGXddA.png"/></div></figure><p id="2136" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">合并并加入</strong></p><p id="a394" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">熊猫为我们提供了一种独家的、更高效的方法<strong class="lh ja">。merge() </strong>执行内存中的连接操作。Merge方法是SQL下关系代数的一个子集。</p><blockquote class="ol om on"><p id="e947" class="lf lg na lh b li lj ka lk ll lm kd ln oo lp lq lr op lt lu lv oq lx ly lz ma ij bi translated">在本节中，我将远离我们的Titanic数据集，以便于理解不太复杂的数据的连接操作。</p></blockquote><p id="638e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有不同类型的连接操作:</p><ol class=""><li id="f682" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">一对一</li><li id="d68f" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">多对一</li><li id="99af" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">多对多</li></ol><p id="22ab" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">用于解释雇员数据集中SQL连接的经典数据。让我们创建数据帧。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi or"><img src="../Images/e9e33e7d8cc29425a31ce144534f4b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*9lh6bv7i4yoAywZsAidaYw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">左表-df1，右表-df2</figcaption></figure><blockquote class="os"><p id="65ac" class="ot ou iq bd ov ow ox oy oz pa pb ma dk translated">一对一</p></blockquote><p id="b263" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">一对一合并非常类似于按列连接。我们用“df1”和“df2”来组合。merge()方法。Merge能够识别数据集中的<strong class="lh ja">公共列</strong>，并将其用作<strong class="lh ja">键</strong>，在我们的例子中是列‘employee _ name’。还有，名字也不是按顺序排的。让我们通过忽略索引来看看合并是如何为我们工作的。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="8c09" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df3 = pd.merge(df1,df2)<br/>df3</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e5e6794416791030d07d8020dbc693f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*adKpftqlaQ1dFW9bGbOGlw.png"/></div></figure><blockquote class="os"><p id="66a7" class="ot ou iq bd ov ow ox oy oz pa pb ma dk translated">多对一</p></blockquote><p id="ac0e" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">多对一是一种联接类型，其中两个键列中的一个具有<strong class="lh ja">重复值</strong>。假设我们每个部门都有主管，每个部门都有许多员工，因此，<strong class="lh ja">许多</strong>员工<strong class="lh ja">对一个</strong>主管。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/682ba68388a35297dc8d183b160bbb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*kohlH6maHlcs3fd4KJi45Q.png"/></div></figure><blockquote class="os"><p id="4372" class="ot ou iq bd ov ow ox oy oz pa pb ma dk translated">多对多</p></blockquote><p id="322f" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">这是两个数据集中的关键字列都有重复值的情况。假设许多技能被映射到每个部门，那么产生的数据框架将有重复的条目。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/b3c2eaeede2443cb3e5070bbf056b2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*fQprt2oTs4Vu2OaO3n7hdw.png"/></div></figure><h2 id="b4b3" class="mu mv iq bd nd ne nf dn ng nh ni dp nj lo nk nl nm ls nn no np lw nq nr ns iw bi translated">合并不常用的列名和值</h2><blockquote class="os"><p id="f125" class="ot ou iq bd ov ow pj pk pl pm pn ma dk translated">不常用的列名</p></blockquote><p id="3a6e" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">很多时候，合并并不是那么简单，因为我们收到的数据不会那么干净。我们看到了如果我们有一个公共列，merge是如何完成所有工作的。如果我们根本没有共同的栏目怎么办？或者有<strong class="lh ja">多个公共列</strong>。Pandas为我们提供了明确指定列作为两个数据帧中的键的灵活性。</p><p id="10f8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">假设我们将“df2”中的“雇员姓名”列更改为“姓名”。让我们看看数据集是什么样子，以及如何明确地告诉merge键列。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/b91ab2c4ec862c552e5743c525f0ef85.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*Got7uJ7nEX7c3gm4gsQpqA.png"/></div></figure><p id="d11a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">参数' left_on '指定第一列的键，参数' right_on '指定第二列的键。请记住,“left_on”的值应该与您传递的第一个数据帧的列相匹配，而“right_on”的值应该与第二个数据帧的列相匹配。注意，我们得到了多余的列' name '，如果不需要，我们可以删除它。</p><blockquote class="os"><p id="be42" class="ot ou iq bd ov ow pj pk pl pm pn ma dk translated">不寻常的价值</p></blockquote><p id="ae30" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">以前我们看到，一个数据集中出现的所有雇员姓名也会出现在另一个数据集中。如果名字不见了呢。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/22d78d0a079a06f94e708cb05911bc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*h0kqKgxrj4-2J65S9P_fTA.png"/></div></figure><p id="a224" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">默认情况下，merge应用<strong class="lh ja"> inner join </strong>，这意味着只对公共值执行join，这通常不是首选方式，因为会有数据丢失。连接方法可以通过使用参数“how”来控制。我们可以执行<strong class="lh ja">左连接或右连接</strong>来克服数据丢失。缺失值将由熊猫表示为NaN。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="ac83" class="mu mv iq mq b gy mw mx l my mz"><em class="na">print('-------left join--------\n',pd.merge(df1, df2, how='left'))<br/>print('\n-------right join--------\n',pd.merge(df1,df2,how='right'))</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/26289c2a36a32c7326195ae0450d33b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*qVUbeMLVkoFFV54H0PQnIg.png"/></div></figure><h2 id="d355" class="mu mv iq bd nd ne nf dn ng nh ni dp nj lo nk nl nm ls nn no np lw nq nr ns iw bi translated">分组依据</h2><p id="46c6" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">GroupBy是一个非常灵活的抽象，我们可以把它看作是数据帧的集合。它允许我们做许多不同的强大的操作。简而言之，它根据我们指定的列的值对整个数据集进行分组，并允许我们执行操作来提取细节。</p><blockquote class="ol om on"><p id="5b1e" class="lf lg na lh b li lj ka lk ll lm kd ln oo lp lq lr op lt lu lv oq lx ly lz ma ij bi translated">让我们回到我们的泰坦尼克号数据集</p></blockquote><p id="12c9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">假设我们想看看有多少男性和女性乘客幸存。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="5c31" class="mu mv iq mq b gy mw mx l my mz"><em class="na">print(df.groupby('sex'))<br/>df.groupby('sex').sum()</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pr"><img src="../Images/4df8cf7310ea7ba771d1865fac701e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geMwIsV0T1uPvYX_b2srnw.png"/></div></div></figure><p id="8b29" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，只打印groupby而不执行任何操作会给出GroupBy对象。由于“性别”列中只有两个唯一值，我们可以看到按男性和女性分组的每隔一列的总和。更有见地的是得到百分比。我们将在求和时只捕获上面groupby结果的“存活”列，并计算百分比。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="0de8" class="mu mv iq mq b gy mw mx l my mz"><em class="na">data = df.groupby('sex')['survived'].sum()</em></span><span id="42a0" class="mu mv iq mq b gy nb mx l my mz"><em class="na">print('% of male survivers',(data['male']/(data['male']+data['female']))*100)</em></span><span id="6120" class="mu mv iq mq b gy nb mx l my mz"><em class="na">print('% of male female',(data['female']/(data['male']+data['female']))*100)</em></span><span id="6270" class="mu mv iq mq b gy nb mx l my mz"><strong class="mq ja"><em class="na">Output</em></strong></span><span id="c2c7" class="mu mv iq mq b gy nb mx l my mz"><em class="na">% of male survivers 31.87134502923976<br/>% of male female 68.12865497076024</em></span></pre><p id="ff72" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在幕后，GroupBy函数执行三个操作:<em class="na">拆分-应用-合并。</em></p><ol class=""><li id="2f61" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">拆分数据帧，以便将其分组到指定的关键字中。</li><li id="322c" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">应用——它包括计算我们想要的函数，如聚合、转换或过滤。</li><li id="a6fd" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">合并——将输出合并成一个数据帧。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ps"><img src="../Images/2e150e8479d5a6de9a33f906dfa7ae74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHBiTp-jsfFgjp_SE7ulYg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Jake VanderPlas的Python数据科学手册</figcaption></figure><p id="b9b0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">或许，可以在groupby上执行的更强大的操作有:</p><ol class=""><li id="b6e1" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">总计</li><li id="ae2f" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">过滤器</li><li id="2de1" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">改变</li><li id="8c81" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">应用</li></ol><p id="0a13" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们用一个例子来看看每一个。</p><blockquote class="os"><p id="3b34" class="ot ou iq bd ov ow pj pk pl pm pn ma dk translated">总计</p></blockquote><p id="b6d4" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">聚合函数允许我们一次执行<strong class="lh ja">多个聚合</strong>。我们需要将所需聚合的列表作为参数传递给。聚合()函数。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3b79" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.groupby('sex')['survived'].aggregate(['sum', np.mean,'median'])</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/c1dc295cd0741cadd9a700ef384ba054.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*Lqej7lVscyDu3kjpDAsJsw.png"/></div></figure><blockquote class="os"><p id="82f6" class="ot ou iq bd ov ow ox oy oz pa pb ma dk translated">过滤器</p></blockquote><p id="0ff5" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">过滤功能允许我们根据组属性删除数据<strong class="lh ja">。假设我们希望看到按“幸存”分组时“票价”的标准偏差大于阈值(比如50)的数据。</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3ed7" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.groupby('survived').filter(lambda x: x['fare'].std() &gt; 50)</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pv"><img src="../Images/1ba39fd97ce215e699575b2ed374348d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARvmeVJqx332TT1IUuqVbA.png"/></div></div></figure><p id="b46d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于“票价”的标准偏差仅在“幸存”值等于1时大于50，因此我们只能看到“幸存”值为1的数据。</p><blockquote class="os"><p id="6737" class="ot ou iq bd ov ow pj pk pl pm pn ma dk translated">改变</p></blockquote><p id="744f" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">Transform返回整个数据的<strong class="lh ja">转换版本</strong>。最好的解释例子是将数据集居中。将数据居中只不过是用相应列的平均值减去该列的每个值。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="2583" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.groupby('survived').transform(lambda x: x - x.mean())</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pw"><img src="../Images/26c44d06871a15260f145b1499534fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4S2lH0gSwF2QpOeLpHJa6Q.png"/></div></div></figure><blockquote class="os"><p id="ac1d" class="ot ou iq bd ov ow ox oy oz pa pb ma dk translated">应用</p></blockquote><p id="1be2" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">与过滤和转换不同，应用非常灵活，唯一的标准是它接受数据帧并返回Pandas对象或标量。我们可以灵活地在函数中做任何我们想做的事情。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="c13f" class="mu mv iq mq b gy mw mx l my mz"><em class="na">def func(x):<br/>    x['fare'] = x['fare'] / x['fare'].sum()<br/>    return x</em></span><span id="651d" class="mu mv iq mq b gy nb mx l my mz"><em class="na">df.groupby('survived').apply(func)</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi px"><img src="../Images/eeee39fd3ae5af9e41f611cbe0f634ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNBgUJ8B5xYkYztMfaBAtw.png"/></div></div></figure><h2 id="af18" class="mu mv iq bd nd ne nf dn ng nh ni dp nj lo nk nl nm ls nn no np lw nq nr ns iw bi translated">数据透视表</h2><p id="5527" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">在之前的GroupBy中，我们看到了“性别”是如何影响存活率的，雌性的存活率比雄性高得多。假设我们也想知道‘阶级’是如何影响生存的，但是‘性’和‘阶级’是同时存在的。使用GroupBy，我们可以这样做。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="a7e0" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.groupby(['sex', 'pclass']['survived'].aggregate('mean').unstack()</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi py"><img src="../Images/c75282c233b46cddc2107de9c81f5081.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*SSckXXkoAa7B4sJEDwC-Dw.png"/></div></figure><p id="ddb7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这更有见地，我们可以很容易地看出泰坦尼克号三等舱的乘客生还的可能性更小。</p><p id="83d4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这种类型的操作在分析中很常见。因此，熊猫提供了这一功能。pivot_table()，它以更大的灵活性和更低的复杂性执行相同的操作。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="736f" class="mu mv iq mq b gy mw mx l my mz"><em class="na">df.pivot_table('survived', index='sex', columns='pclass')</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi py"><img src="../Images/c75282c233b46cddc2107de9c81f5081.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*SSckXXkoAa7B4sJEDwC-Dw.png"/></div></figure><p id="0c2b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">pivot table函数的结果是一个DataFrame，不像groupby返回一个groupby对象。我们可以在上面正常执行所有的数据帧操作。</p><p id="c617" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还可以在结果中添加一个第三维的<strong class="lh ja"/>。假设我们想知道“年龄”和“性别”以及“阶级”是如何影响存活率的。让我们将我们的“年龄”分成以下几组:0-18岁的儿童/青少年，18-40岁的成人，以及41-80岁的老人。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="8558" class="mu mv iq mq b gy mw mx l my mz"><em class="na">age = pd.cut(df['age'], [0, 18, 40, 80])<br/>pivotTable = df.pivot_table('survived', ['sex', age], 'class')<br/>pivotTable</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/399bbabd1381d0a9e5be5a4c5e443f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*9HXqnDDOMAetPkzO-Bc6aQ.png"/></div></figure><p id="751e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有趣的是，第二个班的女性儿童和青少年有100%的存活率。这就是熊猫的数据透视表所具有的那种力量。</p><h2 id="f5e1" class="mu mv iq bd nd ne nf dn ng nh ni dp nj lo nk nl nm ls nn no np lw nq nr ns iw bi translated">重塑多索引数据帧</h2><p id="051f" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">为了从不同的角度查看多索引数据帧，我们对其进行了整形。堆叠和拆分是实现这一点的两种方法。</p><blockquote class="os"><p id="c9be" class="ot ou iq bd ov ow pj pk pl pm pn ma dk translated">拆分( )</p></blockquote><p id="71c4" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">这是将行索引转换为列索引的过程。我们之前创建的数据透视表是按行进行多索引的。我们可以将最里面的行索引(年龄组)放入最里面的列索引。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="378d" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pivotTable = pivotTable.unstack()<br/>pivotTable</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qa"><img src="../Images/dfbe9c9a84877030ccd129e7ca2fc9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zvM29HYsdxF5PFx8pzABIw.png"/></div></div></figure><p id="3ab9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还可以通过使用参数“level”将最外面的行索引(sex)转换为最里面的列索引。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="fa5c" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pivotTable = pivotTable.unstack(level=0)<br/>piviotTable</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/e6874bfcc4546803f29736fa4eaa7962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*o95BHbnTwhoM3otVRWq9_Q.png"/></div></figure><blockquote class="os"><p id="53e0" class="ot ou iq bd ov ow ox oy oz pa pb ma dk translated">堆栈( )</p></blockquote><p id="46d3" class="pw-post-body-paragraph lf lg iq lh b li pc ka lk ll pd kd ln lo pe lq lr ls pf lu lv lw pg ly lz ma ij bi translated">堆叠与拆分正好相反。我们可以将多索引数据帧的列索引转换为行索引。最里面的列索引“sex”被转换为最里面的行索引。结果与原始数据帧略有不同，因为我们之前未堆叠0级。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="cc8f" class="mu mv iq mq b gy mw mx l my mz"><em class="na">pivotTable.stack()</em></span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/b5b9cf7fae3f20c1954b3cffc1d447bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*8_Bn1WVrpE-B--kDvXTw_w.png"/></div></figure></div><div class="ab cl qd qe hu qf" role="separator"><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi"/></div><div class="ij ik il im in"><p id="f02b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些函数和方法非常有助于理解数据，进一步用于操作，或建立预测模型。我们还可以绘制图表来获得直观的见解。</p></div><div class="ab cl qd qe hu qf" role="separator"><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi"/></div><div class="ij ik il im in"><div class="kp kq kr ks gt qk"><a href="https://medium.com/swlh/unpacking-pandas-for-data-science-part-1-32e480ca1688" rel="noopener follow" target="_blank"><div class="ql ab fo"><div class="qm ab qn cl cj qo"><h2 class="bd ja gy z fp qp fr fs qq fu fw iz bi translated">为数据科学打开熊猫包装</h2><div class="qr l"><h3 class="bd b gy z fp qp fr fs qq fu fw dk translated">利用经典的泰坦尼克号数据释放熊猫的力量。</h3></div><div class="qs l"><p class="bd b dl z fp qp fr fs qq fu fw dk translated">medium.com</p></div></div><div class="qt l"><div class="qu l qv qw qx qt qy ky qk"/></div></div></a></div></div></div>    
</body>
</html>