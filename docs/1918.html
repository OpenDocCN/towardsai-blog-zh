<html>
<head>
<title>Class and Objects in Python with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的类和对象及其示例</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/class-and-objects-in-python-with-examples-591c6ca95ee6?source=collection_archive---------0-----------------------#2021-06-16">https://pub.towardsai.net/class-and-objects-in-python-with-examples-591c6ca95ee6?source=collection_archive---------0-----------------------#2021-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c93e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/programming" rel="noopener ugc nofollow" target="_blank">编程</a></h2><div class=""/><div class=""><h2 id="1783" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">软件开发程序的便捷概念</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2cf3dcff78eddd4ab78089ed8c6f12d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dw-LGZxhV_W90W8d"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e642" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python也有面向对象的编程方法。在此之前，我们在函数的帮助下编写程序，但现在面向对象编程是基于类、方法和对象的。</p><p id="941f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说，如果我们想设计一些东西，我们需要一个设计蓝图，这意味着我们需要创建一个设计类来创建一个对象。</p><h2 id="c0fd" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">涵盖的主题:</h2><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="3d6f" class="me mf it mx b gy nb nc l nd ne">1. Class and objects<br/>2. Special methods ( __init__ )<br/>3. Heap memory, Constructor, Self</span></pre><blockquote class="nf ng nh"><p id="b09f" class="li lj ni lk b ll lm kd ln lo lp kg lq nj ls lt lu nk lw lx ly nl ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">类和对象</em> </strong></p></blockquote><p id="d148" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在面向对象编程中，在类内部，我们处理两件主要的事情，第一件是<strong class="lk jd"> <em class="ni">属性</em> </strong>也称为变量，第二件是<strong class="lk jd"> <em class="ni">行为</em> </strong>也称为函数或方法。</p><p id="886e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该类的语法如下所示:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="0a8a" class="me mf it mx b gy nb nc l nd ne">class home:     # home is a class name<br/>    .....<br/>    variables<br/>    functions <br/>    .....</span><span id="5738" class="me mf it mx b gy nm nc l nd ne">h1 = home()     # h1 is an object or instance of the class home</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="3da8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们常说的，编程语言中的一切都是对象。</p><p id="59a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="0460" class="me mf it mx b gy nb nc l nd ne">#for integer         #for string            #for class<br/>                                             class home:                                              <br/>a = 5                 a = '5'                    pass <br/>print(type(a))        print(type(a))         h1 = home()<br/>                                             print(type(h1))</span><span id="0115" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:              #output:               #output:</strong><br/>&lt;class 'int'&gt;         &lt;class 'str'&gt;          &lt;class '__main__.home'&gt;</span></pre><p id="7d84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在上面的例子中看到，在编程中一切都属于类。在这里，我们注意到在“home”类的输出中有特殊的变量如<code class="fe nu nv nw mx b">__name__</code>或特殊的方法如<code class="fe nu nv nw mx b">__init__</code>。同样，<code class="fe nu nv nw mx b">__name__</code>属于python的主文件，类就是从这个主文件开始的，在我们的例子中，home类就是从这个python文件开始的。有时，我们会看到一个if语句，比如(if __name__ = '__main__ ')这意味着程序是由用户执行的。</p><p id="4da9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看一个python中的类的例子:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="48e3" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    #method inside a class<br/>    def rooms():<br/>        print("This home has 4 rooms")</span><span id="8207" class="me mf it mx b gy nm nc l nd ne">#To access the methods and variable in the class home<br/>h1 = home()</span></pre><p id="0823" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以将类内部的方法分为两种类型。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="8de8" class="me mf it mx b gy nb nc l nd ne"><strong class="mx jd"># 1. By using the method name '<em class="ni">rooms</em>'</strong></span><span id="5b27" class="me mf it mx b gy nm nc l nd ne">#just calling the method as we do in function but it will give the  #error</span><span id="234a" class="me mf it mx b gy nm nc l nd ne">rooms()</span><span id="545e" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:<br/>NameError</strong>: name 'rooms' is not defined</span><span id="94a5" class="me mf it mx b gy nm nc l nd ne">#we are in a class now so, everything belongs to the class</span><span id="267e" class="me mf it mx b gy nm nc l nd ne">home.rooms(self)</span><span id="fa22" class="me mf it mx b gy nm nc l nd ne">#output:<br/>This home has 4 rooms</span><span id="3c3f" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd"># 2. By using the object of the class</strong></span><span id="1161" class="me mf it mx b gy nm nc l nd ne">h1.rooms()</span><span id="2f24" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/><strong class="mx jd">TypeError</strong>: rooms() takes 0 positional arguments but 1 was given</span></pre><p id="a1f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们在对象的帮助下调用该方法时，它会给出一个位置参数错误。我们没有传递任何参数，在rooms的方法中也没有实际的参数。所以，本质上，在这个叫做自我的方法中有一个实际的论点。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="ea6b" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def rooms(self):<br/>        print("This home has 4 rooms")</span><span id="fdda" class="me mf it mx b gy nm nc l nd ne">h1 = home()</span><span id="05e0" class="me mf it mx b gy nm nc l nd ne">h1.rooms()</span><span id="1148" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/>This home has 4 rooms</span></pre><p id="8ab3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们仍然没有在使用类对象的方法调用中传递形式参数。这里幕后的技巧是对象本身作为参数被传递。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5beba3ed98786d3fb96cbdda8f18c83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*n8-boOYlgVOBw928DDVA6A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/python-zero-to-hero-with-examples-c7a5dedb968b"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">Python:从零到英雄(带示例)</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">python初学者手册指南</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">pub.towardsai.net</p></div></div><div class="ok l"><div class="ol l om on oo ok op lb ob"/></div></div></a></div><blockquote class="nf ng nh"><p id="4b0d" class="li lj ni lk b ll lm kd ln lo lp kg lq nj ls lt lu nk lw lx ly nl ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">特殊方法(__init__ ) </em> </strong></p></blockquote><p id="0ad3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们必须声明变量时，这个特殊的方法非常有用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/71d1986c0a0364465b941ea74221dd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*URVEgoQxc5FSpNGscug0CA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</figcaption></figure><p id="e22d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们看到的，当我们在两个下划线后按tab时，它显示了各种特殊的方法，(__init__)就是其中之一。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="af84" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def __init__(self):<br/>        print("I am in the INIT method")<br/>    <br/>    def rooms(self):<br/>        print("This home has 4 rooms")</span><span id="bf79" class="me mf it mx b gy nm nc l nd ne">h1 = home()</span><span id="ec4b" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/>I am in the INIT method</span></pre><p id="fc96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在上面的例子中看到，我没有调用rooms方法或init方法，而是自动调用了init方法。这取决于一个类中对象的数量。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="04dc" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def __init__(self, parking, kitchen):<br/>        self.parking = parking<br/>        self.kitchen = kitchen<br/>        <br/>    <br/>    def information(self):<br/>        print("Home information")<br/>        print("Number of parking:", self.parking)<br/>        print("Number of Kitchen:", self.kitchen)</span><span id="077a" class="me mf it mx b gy nm nc l nd ne">#here h1 is passed automatically, so technically passing three #parameters (h1,2,1)</span><span id="b51f" class="me mf it mx b gy nm nc l nd ne">h1 = home(2,1)</span><span id="28c0" class="me mf it mx b gy nm nc l nd ne">h1.information()</span><span id="0854" class="me mf it mx b gy nm nc l nd ne">#output:<br/>Home information<br/>Number of parking: 2<br/>Number of Kitchen: 1</span></pre><blockquote class="nf ng nh"><p id="b143" class="li lj ni lk b ll lm kd ln lo lp kg lq nj ls lt lu nk lw lx ly nl ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">堆内存，构造函数，自我</em> </strong></p></blockquote><h2 id="dad7" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">堆内存</h2><p id="38d1" class="pw-post-body-paragraph li lj it lk b ll or kd ln lo os kg lq lr ot lt lu lv ou lx ly lz ov mb mc md im bi translated">当我们创建一个类和它的对象时，在我们的系统中有堆内存，在创建对象后，它会占用堆内存中的一些空间。当任何物体占据空间时，它也有地址。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="d0ce" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    pass</span><span id="c826" class="me mf it mx b gy nm nc l nd ne">h1 = home()</span><span id="cf03" class="me mf it mx b gy nm nc l nd ne">#To know the address of the object<br/>print(id(h1))</span><span id="c21a" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/>91975920</span></pre><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/inheritance-and-its-type-with-python-f35b993d712e"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">Python中的继承及其类型</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">单一、多级和多重继承方法的概念</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">pub.towardsai.net</p></div></div><div class="ok l"><div class="ow l om on oo ok op lb ob"/></div></div></a></div><h2 id="1491" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">构造器</h2><p id="93a3" class="pw-post-body-paragraph li lj it lk b ll or kd ln lo os kg lq lr ot lt lu lv ou lx ly lz ov mb mc md im bi translated">它用于分配每个变量的大小。在上面的例子中，home()是一个自动调用(__init__)方法的构造函数。对象的大小取决于我们在类中使用的变量的数量。</p><p id="5d05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在init方法中定义变量，我们将创建对象，然后打印变量名。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="2792" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def __init__(self):<br/>        self.parking = 2<br/>        self.kitchen = 3<br/>        <br/>h1 = home() <br/>print(h1.parking)</span><span id="0d1f" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/>2</span></pre><p id="98ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们制作另一个对象并打印相同的变量。它将打印相同的结果，因为两个对象的构造函数调用相同的init方法。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="a833" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def __init__(self):<br/>        self.parking = 2<br/>        self.kitchen = 3<br/>        <br/>h1 = home() <br/>h2 = home()</span><span id="f144" class="me mf it mx b gy nm nc l nd ne">print(h1.parking)<br/>print(h2.parking)</span><span id="c677" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/>2<br/>2</span></pre><p id="3bb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们也可以自己改变变量的值。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="f783" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def __init__(self):<br/>        self.parking = 2<br/>        self.kitchen = 3<br/>        <br/>h1 = home() <br/>h2 = home()</span><span id="8f70" class="me mf it mx b gy nm nc l nd ne">h1.parking = 4</span><span id="6aac" class="me mf it mx b gy nm nc l nd ne">print(h1.parking)<br/>print(h2.parking)</span><span id="c629" class="me mf it mx b gy nm nc l nd ne"><strong class="mx jd">#output:</strong><br/>4<br/>2</span></pre><h2 id="ce77" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">自己</h2><p id="8984" class="pw-post-body-paragraph li lj it lk b ll or kd ln lo os kg lq lr ot lt lu lv ou lx ly lz ov mb mc md im bi translated">如果我们想用两个不同的对象来比较两个变量。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="35e2" class="me mf it mx b gy nb nc l nd ne">class home:<br/>    <br/>    def __init__(self):<br/>        self.parking = 2<br/>        self.kitchen = 3<br/>        <br/>    def compare(self, other):<br/>        if self.parking == other.parking:<br/>            return True<br/>        else:<br/>            return False<br/>        <br/>h1 = home() <br/>h2 = home()</span><span id="4663" class="me mf it mx b gy nm nc l nd ne">if h1.compare(h2):<br/>    print("They are same")<br/>    <br/>print(h1.parking)<br/>print(h2.parking)</span><span id="838c" class="me mf it mx b gy nm nc l nd ne">#output:<br/>They are same<br/>2<br/>2</span></pre><p id="a5f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，在比较方法中，h1对象在'<strong class="lk jd"> <em class="ni"> self </em> </strong>'中传递自身，h2对象在'<strong class="lk jd"> <em class="ni"> other </em> </strong>'参数中传递自身。这就是self关键字在python类中派上用场的地方。</p><blockquote class="nf ng nh"><p id="85a8" class="li lj ni lk b ll lm kd ln lo lp kg lq nj ls lt lu nk lw lx ly nl ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">结论</em> </strong></p></blockquote><p id="921c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类和对象的概念在软件开发程序中非常重要。</p><p id="01f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae lh" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="321b" class="ox mf it bd mg oy oz pa mj pb pc pd mm ki pe kj mp kl pf km ms ko pg kp mv ph bi translated">推荐文章</h1><p id="6037" class="pw-post-body-paragraph li lj it lk b ll or kd ln lo os kg lq lr ot lt lu lv ou lx ly lz ov mb mc md im bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30">Python中的异常处理概念</a> <br/> 4。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/deep-learning-88e218b74a14?source=friends_link&amp;sk=540bf9088d31859d50dbddab7524ba35">为什么LSTM在深度学习方面比RNN更有用？</a> <br/> 5。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/neural-networks-the-rise-of-recurrent-neural-networks-df740252da88?source=friends_link&amp;sk=6844935e3de14e478ce00f0b22e419eb">神经网络:递归神经网络的兴起</a> <br/> 6。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae lh" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae lh" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>