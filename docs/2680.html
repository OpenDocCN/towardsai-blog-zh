<html>
<head>
<title>Game of Cops &amp; Robbers on Graph Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图网络上的警察&amp;强盗游戏</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/game-of-cops-robbers-on-graph-networks-912525090239?source=collection_archive---------0-----------------------#2022-04-13">https://pub.towardsai.net/game-of-cops-robbers-on-graph-networks-912525090239?source=collection_archive---------0-----------------------#2022-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cc3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">网络警察与强盗背后的数学</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60a0d06ebf06310112c282ad4ac2de1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7H7WBm9zAdq7cVh3sbeLw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://unsplash.com/photos/V79loOjFOLA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae ky" href="https://unsplash.com/@introspectivedsgn" rel="noopener ugc nofollow" target="_blank">埃里克·麦克林</a>拍摄</figcaption></figure><p id="1581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">目录</strong></p><ol class=""><li id="7975" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">介绍</li><li id="ffd5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">树和缩回</li><li id="ccac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">平面图形</li><li id="0cc0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">讨论和后续步骤</li><li id="5a55" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">资源</li></ol><h1 id="01ce" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1导言</h1><p id="d694" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">图论是数学的一个分支，它通过节点和边的形式帮助建立成对关系的数学表示。现实世界中的各种问题都可以通过图形有效地表示出来，本文关注的主题是警察与强盗的博弈。要了解过度描述的警察和强盗，必须先了解警察和强盗的游戏。警察和强盗的游戏是由[1，2，3]引入的。</p><p id="4b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于图的警察和强盗的游戏可以被说明如下，想象一个自反图G，使得每个节点有一个环，并且可以存在连接节点的多条边，但是游戏假设只有1条边连接节点。这些节点可以由两个玩家居住，第一个玩家代表一组警察(至少1个警察)，第二个玩家代表一个强盗(每个图只能有1个强盗)。这个游戏是反复进行的，警察和强盗轮流玩，直到游戏结束。由C表示的警察总是先移动，由R表示的强盗总是跟着警察移动。警察和强盗通过从一个节点移动到另一个节点来移动，因为在每个节点都有自循环，所以总是有机会停留在相同的位置。当警察能够抓住强盗，使得警察和强盗占据相同的节点时，游戏结束。同样，如果你能证明强盗永远不会被抓到，这个游戏就会以有利于强盗的方式结束。警察和强盗的获胜策略是让他们的对手失败。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6410e8a523f942444714da517298446c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S0bFyZ2ULFaanQSP"/></div></div></figure><p id="23cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图3 </strong>:图g上玩的警察和强盗的游戏，蓝色节点代表警察，红色节点代表强盗。经过2次迭代(0索引)后，抢劫犯被抓获</p><p id="202e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">cop数(在[1]中创造)是指拥有有利于COP的获胜策略所需的COP的最小数量[4]。博弈长度代表抓捕劫匪所需的回合数，如果博弈长度是警察的最小整体可能策略，c(G)警察是最优的[4]。在这种情况下，c(G)表示图G的cop数，Meyniels猜想指出n顶点图上cop数的上界是O(√n)。K-capture time指的是k个警察玩游戏的时候，其中k ≥ c(G)表示为captk(G)。因此，当k = c(G)时，记为capt(G ),也称为G的捕获时间。</p><p id="4f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经对警察和强盗建立了一个基本的理解，过度规定的警察和强盗的游戏是指当警察的数量严格大于副本数量时[4]。对于本文的上下文，图G将是有限的和自反的。我们将概述关于平面图和树的各种证明。</p><h1 id="5047" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2个采油树和收回装置</h1><p id="caf2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">与本节相关的基础理解和证明源于理解什么是图论中的树和收缩。树被定义为一个连通的无环无向图。参考图2。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/890f85d88a59d3cbf3b8ce0ddc2e2419.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/0*M7ZcAMgCY4Y8vOAc"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ml">图二:</strong>上图是一棵树。它是一棵树，因为图中的边是无向的，没有圈。图片由作者提供。</figcaption></figure><p id="e40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解什么是回缩，就必须知道什么是同态。同态是两个图之间的映射，它是给定一对图的顶点集，将相邻顶点相互映射的函数。收缩是从图G到G的子图H的同态r，使得对于H的每个顶点v，r(v)= v[5]。在这种情况下，子图H被称为g的收缩，图同态和收缩参见图3。Aigner和Fromme在[1]中证明了与G的收缩H相关的cop数≤与G相关的cop数。这种说法经常被用在论文解释的整个证明中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/140e9fc5f222052c1fff4a155388d5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9RX2pdQX4sDZgYWU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ml">图3: </strong>图H是二分图g的回缩图，图片由作者提供。</figcaption></figure><p id="ba05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整篇论文中阐述了各种证明，Bonato等人在[4]中证明了以下陈述是有效的。下列定理、引理和推论已被证明是正确的:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="4757" class="no mk it nk b gy np nq l nr ns">Lemma 1. For a retract H of a graph G, rad_k(H) ≤ rad_k(G).<br/>Lemma 2. For any graph G, capt_k (G) ≥ rad_k(G).<br/>Corollary 3. For any G and any k, capt_k (G) ≥ diam(G)−k+1/ 2k.<br/>Theorem 4. For any tree T, capt(T) = rad(T).<br/>Theorem 5. Suppose that V (G) = V1 ∪ · · · ∪ V_t , where G[V_i] is a retract of G for every i and k = Sum(i∈[t] k_i). Then capt_k(G) ≤ maxi∈[t] capt_ki (G[V_i]). Note that if k_i &lt; c(G[V_i]), then we say that capt_ki (G[V_i]) = ∞.<br/>Corollary 6. For any tree T, capt_k (T) = rad_k(T).</span></pre><p id="235c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再深入一点，让我们证明从引理2得出的定理4。用rad(G)表示，图半径是图中任何节点的最小图偏心率(图G中一个节点到另一个节点的最大距离)。定理陈述了树T的捕获时间等价于T的半径，证明如下，cop放在树的一个中心节点上。树的中心节点被称为中间节点，即保存树中最长路径的节点。您可以通过算法识别中心节点，为此，您可以迭代地从树中删除叶节点，直到只剩下一个节点。如果剩下一对节点，那么该对中的两个节点都可以被认为是中心节点。这样，您可以最大化从这个节点到树中所有其他节点的距离。一旦cop被放置在中心节点上，cop必须简单地沿着通向强盗的路径前进。现在警察扎根在中心，不管强盗位于什么位置，警察都可以狭窄地困住强盗。因此，强盗最多只能被抓到一步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/5f32a2e42e9b7fcf77b3fc8f33c7204d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*NEbRGmcSevEleZ9-"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ml">图4: </strong>树上中心节点的例子。蓝点代表警察的位置，而红点代表劫匪的潜在位置。图片由作者提供。</figcaption></figure><h1 id="6fc1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3平面图</h1><p id="00c1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这一节中，我们将探索平面图形上的警察和强盗的游戏。根据定义，如果一个图可以被直观地绘制成没有边相交，那么这个图就是平面的。请参考图5，了解平面图的可视化表示。要记住的另一个定义与图的半径有关。用rad(G)表示，图半径是图中任何节点的最小图偏心率(图G中一个节点到另一个节点的最大距离)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bc28b43d6665c7f283b5aea89aa975b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/0*KkQj5z-wLgjq8XbZ"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ml">图5: </strong>左边的图形是平面的，右边的图形不是。右侧图形上的红点表示边之间的交点，导致它不是一个平面图形。图片由作者提供。</figcaption></figure><p id="3edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇论文中有各种与平面图相关的证明，Bonato等人在[4]中证明了以下陈述是有效的。下面的定理是我们将深入探究的一个:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a3b5" class="no mk it nk b gy np nq l nr ns">Theorem 13. For any connected planar graph G, if k ≥ 12√n, then captk (G) ≤ 6 rad(G) log n [4].</span></pre><p id="d71a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与该定理相关的证明依赖于Alon、Seymour和Thomas创造的平面分离器定理[6]。平面分隔符定理指出，有一组最多2.13√n个节点将图分成大小最多为2/3n的两组[4]。这产生了以下界限:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/a582821f905a908ad2f615471b5f174f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m97JaUucI1vkD8Ro"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这个公式取自<a class="ae ky" href="https://math.ryerson.ca/~abonato/papers/OverprescribedCR_Nov22.pdf" rel="noopener ugc nofollow" target="_blank">【4】</a>。图片由作者提供。</figcaption></figure><p id="b7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，cop的策略是将COP放置在中心节点和分隔符上，使得每个分隔符最多有一个COP(符合2.13√n界限)。不管强盗放在哪里，我们都可以把警察放在中心节点上，然后把警察从隔板上向内移动，以减少给强盗的空间。这基本上让警察可以诱捕强盗。COP以迭代速率向内移动，其中在第二次迭代期间，它们将以2.13√(2/3n)的速率移动(根据上面的公式)，等等。现在要问的问题是，要使这个约束有效，需要多少组警察。下面的公式表明了团队t的必要数量</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c8351e684e3097675c5f9709d5f9d1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/0*LGNyiAN4OyMyNkYP"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">公式取自<a class="ae ky" href="https://math.ryerson.ca/~abonato/papers/OverprescribedCR_Nov22.pdf" rel="noopener ugc nofollow" target="_blank">【4】</a>。图片由作者提供。</figcaption></figure><p id="7402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中t表示警察队伍的数量。上述公式适用于t = 6log(n)的情况，每个小组最多采取rad(G)步[4]。</p><h1 id="7b8a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">4讨论和后续步骤</h1><p id="66e9" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">本文涵盖和证明的概念绝不是详尽的，警察和强盗游戏背后的数学可以通过多种方式进行探索。本文介绍的证明和概念可以在各种不同版本的《警察与强盗》中探索，看看它们是否仍然成立。</p><p id="f04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学家们还没有彻底探索的一个领域是警察和强盗的博弈。在这个版本的游戏中，你可以探索警察和强盗之间一对一或一对多的映射。这是可行的，因为有许多警察和许多强盗，请注意，在这种情况下，强盗的数量不能超过地图中警察的数量。每个地图实际上代表了每个警察小组要追捕的目标强盗。虽然这可能看起来是对最初引入的主题的简单旋转，但问题的数学复杂性已经急剧增加。考虑这个问题的一种方式是，想象每个警察和强盗配对被映射到g的有限连通子图。然而，每个子图上可以有不止一个配对，并且映射到配对的子图可以基于警察和强盗的移动而扩展。这种简单的理解开启了各种数学探索的机会。其中一个领域将是探索当前用于识别cop-win的界限和公式是否仍然适用于这类问题。</p><p id="a72a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一数学领域的进步对各种其他行业都有许多影响。这是因为警察和强盗的游戏在许多领域都有广泛的应用，从机器人到游戏到反恐到生成性对抗网络(一种强化学习的框架，其中代理人相互竞争以学习某项任务)。解决《警察与强盗》中的问题的持续进展也可以帮助其他研究领域的进展。</p><h1 id="b787" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">5资源</h1><ul class=""><li id="179e" class="lv lw it lb b lc nb lf nc li nx lm ny lq nz lu oa mb mc md bi translated">[1] M. Aigner，M. Fromme，警察和强盗的游戏，离散应用数学。8 (1984) 1–11.</li><li id="6fd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">[2] R.J. Nowakowski，P. Winkler,《图中的顶点到顶点追踪》,《离散数学》43(1983)235–239。</li><li id="591c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">[3] A. Quilliot,《图形的青年和尖锐问题》,巴黎第六大学，1978年，第131-145页。</li><li id="67b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">[4] A. Bonato，X. Perez-Gimenez，P. Pralat，B. Reiniger，图形与组合学33(2017)801–815。</li><li id="302d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">【5】<a class="ae ky" href="https://en.wikipedia.org/wiki/Pavol_Hell" rel="noopener ugc nofollow" target="_blank">地狱，帕沃尔</a>；<a class="ae ky" href="https://en.wikipedia.org/wiki/Jaroslav_Ne%C5%A1et%C5%99il" rel="noopener ugc nofollow" target="_blank"> Nešetřil，雅罗斯拉夫</a> (2004)，<a class="ae ky" href="http://www.cs.sfu.ca/~pavol/hombook.html" rel="noopener ugc nofollow" target="_blank">图与同态</a>，牛津数学及其应用系列讲座，第28卷，牛津大学出版社，<a class="ae ky" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">ISBN</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Special:BookSources/0-19-852817-5" rel="noopener ugc nofollow" target="_blank">0–19–852817–5</a># p19。</li><li id="c8ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">[6] N. Alon，P. Seymour，R. Thomas，平面分离器，SIAM离散数学杂志7(1994)184–193。</li></ul></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="a9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢读这篇文章，你可能也会喜欢与数学相关的其他文章。</p><div class="oi oj gp gr ok ol"><a href="https://towardsdatascience.com/mining-modelling-character-networks-part-i-e37e4878c467" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">挖掘和模拟字符网络——第一部分</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">图论研究论文讨论</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://towardsdatascience.com/mining-modelling-character-networks-part-ii-a3d77de89638" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">挖掘和模拟字符网络—第二部分</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">本文将介绍挖掘和建模角色网络的Python实现</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/dynamic-time-warping-explained-fbb24c1e079b"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">动态时间扭曲解释</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">动态时间扭曲背后的直觉&amp;股票数据的Python实现</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">pub.towardsai.net</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://towardsdatascience.com/linear-algebra-explained-through-graph-theory-1c79711e9a20" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">图论解释的线性代数</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">用图论直观地解释线性代数的基础</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://towardsdatascience.com/active-learning-in-machine-learning-explained-777c42bd52fa" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">机器学习中的主动学习解释</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">Python中主动学习管道的直觉和实现</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://towardsdatascience.com/recommendation-systems-explained-a42fc60591ed" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">推荐系统解释</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">用Python解释和实现基于内容的协同过滤和混合推荐系统</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pe l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>