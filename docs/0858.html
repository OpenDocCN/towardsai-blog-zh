<html>
<head>
<title>Building a Spicy Pepper Classifier with No Datasets, 96% Accuracy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有数据集的情况下构建一个辣椒分类器，准确率为96%</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/building-a-spicy-pepper-classifier-with-no-datasets-96-accuracy-8262d54a8117?source=collection_archive---------1-----------------------#2020-08-27">https://pub.towardsai.net/building-a-spicy-pepper-classifier-with-no-datasets-96-accuracy-8262d54a8117?source=collection_archive---------1-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6aa3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsai.net/p/category/data-science" rel="noopener ugc nofollow" target="_blank">数据科学</a>，<a class="ae ep" href="https://towardsai.net/p/category/machine-learning" rel="noopener ugc nofollow" target="_blank">机器学习</a></h2><div class=""/><div class=""><h2 id="8006" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">不在数据集上使用分类模型。全部代码可在我的Github repo 获得<a class="ae kr" href="https://github.com/arditoibryan/Projects/tree/master/20200821_Spicy_Pepper_Classifier" rel="noopener ugc nofollow" target="_blank">。</a></h2></div><p id="346a" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在这篇文章中，我将创建一个能够从尺寸和颜色识别辣椒的人工智能。因为你在网上找不到任何关于辣椒测量的数据集，我将使用统计学方法自己生成它。在第二篇文章中，我可能会尝试应用回归算法来估计你的辣椒在斯科维尔尺度上的辣度。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/7292bcadc857121de8f27dc898a3cff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XtRsGJfYYma2lk30"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Andrew Coop 在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="c1d3" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">流程:</h2><ol class=""><li id="c452" class="mw mx it ku b kv my ky mz lb na lf nb lj nc ln nd ne nf ng bi translated">查找可用数据</li><li id="c141" class="mw mx it ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">进行测量</li><li id="5865" class="mw mx it ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">从分布创建数据集</li><li id="31c8" class="mw mx it ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">创建模型</li><li id="70b9" class="mw mx it ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">性能赋值</li></ol><h1 id="2cd9" class="nm mf it bd mg nn no np mj nq nr ns mm ki nt kj mp kl nu km ms ko nv kp mv nw bi translated">1.查找可用数据</h1><p id="97bc" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">如前所述，您不太可能找到一个包含您希望构建的所有内容的数据集。在我的例子中，我想建立一个辣椒分类器，如果你没有数据，这是一个困难的任务。我在网上唯一能找到的是一张不同辣椒的对比表(希望是同一级别)。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1b96dda5da7163545b242e600c9e67dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*7uFner6vlvism3cWV6Feiw.jpeg"/></div></figure><p id="5284" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我需要将这些数据转换成数字形式。我能做的是测量这些图像，并将它们作为特征放入数据集中。</p><h1 id="9da2" class="nm mf it bd mg nn no np mj nq nr ns mm ki nt kj mp kl nu km ms ko nv kp mv nw bi translated">2.进行测量</h1><p id="97b8" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">为了进行测量，我可以使用像素。知道了像素到厘米的转换率后，我就可以用像素来测量每个辣椒的大小，并将其转换成现实世界的比例。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b6430e858b4840bdbad17d66377c4e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*Z4z0HKkq9EMNOGY1E395rA.jpeg"/></div></figure><p id="2be1" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这是所有尺寸(名称、高度、宽度和颜色)都转换为特征的最终表格。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="e613" class="me mf it od b gy oh oi l oj ok">#   measurements<br/>pepper_measurements_px = [<br/>                          ['Anaheim', 262, 63, 'Green'],<br/>                          ['Cubanelle', 222, 70, 'Green'],<br/>                          ['Cayenne', 249, 22, 'Red'],<br/>                          ['Shishito', 140, 21, 'Green'],<br/>                          ['Hungarian Wax', 148, 63, 'Orange'],<br/>['Jimmy Nardello', 190, 23, 'Red'],<br/>                          ['Fresno', 120, 43, 'Red'],<br/>                          ['Jalapeno', 106, 40, 'Dark Green'],<br/>                          ['Aji Amarillo', 92, 13, 'Yellow'],<br/>                          ['Aji Dulce', 81, 30, 'Red'],<br/>['Serrano', 74, 14, 'Dark Green'],<br/>                          ['Padron', 62, 38, 'Dark Green'],<br/>                          ['Scotch Bonnet', 37, 42, 'Yellow'],<br/>                          ['Habanero', 67, 21, 'Orange'],<br/>                          ['Cumari', 18, 11, 'Yellow'],<br/>]</span></pre><p id="4d62" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我现在将为辣椒生成一个包含100，000个样本的数据集。</p><h1 id="ba96" class="nm mf it bd mg nn no np mj nq nr ns mm ki nt kj mp kl nu km ms ko nv kp mv nw bi translated">3.从发行版创建数据集</h1><p id="085c" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">在开始创建分布之前，我首先需要将像素转换成厘米。然后对于长度和宽度，我将需要两个单独的正态分布，使用这些数据作为平均值。对于标准差，我将使用平均值的10%(这样我就不必谷歌每个辣椒的细节)。</p><h2 id="ffa7" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">创建函数</h2><p id="783c" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">我正在创建一组函数，允许创建n个数据集，输入大小。我会用100，000个样品做辣子。</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="cba7" class="me mf it od b gy oh oi l oj ok">#simulated probability distribution of one stock<br/>from scipy.stats import skewnorm<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>import numpy as np</span><span id="5adc" class="me mf it od b gy ol oi l oj ok">def create_peppers(sd, mean, alfa, size):<br/>  #invertire il segno di alfa<br/>  x = skewnorm.rvs(-alfa, size=size) <br/>  def calc(k, sd, mean):<br/>    return (k*sd)+mean<br/>  x = calc(x, sd, mean) #standard distribution</span><span id="719d" class="me mf it od b gy ol oi l oj ok">#graph the distribution<br/>  #pd.DataFrame(x).hist(bins=100)</span><span id="3cdc" class="me mf it od b gy ol oi l oj ok">#pick one random number from the distribution<br/>  #formally I would use cdf, but I just have to pick randomly from the 1000000 samples<br/>  df = [np.random.choice(x) for k in range(size)]<br/>  #return the DataFrame<br/>  return pd.DataFrame(df)</span><span id="6420" class="me mf it od b gy ol oi l oj ok">def cm_converter(px_measurements):<br/>  pc_cm = 0.05725<br/>  for _ in range(len(px_measurements)):<br/>    px_measurements[_][1] *= pc_cm<br/>    px_measurements[_][2] *= pc_cm<br/>  return px_measurements</span></pre><h2 id="1c9a" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">创建数据集</h2><p id="4ca6" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">我现在准备好创建数据集了。我可以指定使用平均值的10%作为标准差(我可以很容易地从height_sd和widht_sd中更改它):</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="9dc5" class="me mf it od b gy oh oi l oj ok">#   create converted list<br/>pepper_measurements_cm = cm_converter(pepper_measurements_px)</span><span id="7741" class="me mf it od b gy ol oi l oj ok">#   create final datasets<br/>heigh_sd = 0.1<br/>width_sd = 0.1</span><span id="b131" class="me mf it od b gy ol oi l oj ok">df = pd.DataFrame()<br/>for _ in pepper_measurements_cm:<br/>  #   create height<br/>  #SD is 10% of the height<br/>  df_height = create_peppers(_[1]*heigh_sd, _[1], 0, 100000)<br/>  #   create width<br/>  #SD is 10% of the width<br/>  df_width = create_peppers(_[2]*width_sd, _[2], 0, 100000)<br/>  #create DataFrame<br/>  df_single = pd.concat([df_height, df_width], axis=1)<br/>  df_single.columns = ['height', 'width']<br/>  #create name<br/>  df_single['name'] = str(_[0])<br/>  df_single['color'] = str(_[3])</span><span id="88c0" class="me mf it od b gy ol oi l oj ok">df = pd.concat([df, df_single], axis=0)<br/>df</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/48c951e7d773929256936593811af85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*UEr-31wGfl8U5X0qEVAzeA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">单个生成要素的正态分布</figcaption></figure><p id="d232" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这是最终结果:综合起来，数据集计数为150万个样本:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/bbdd5a1a8512712f9a86a548d031ca54.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*8eSGO5Vn2fvn_sB6Q4rVOw.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">最终数据集</figcaption></figure><p id="efb7" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如果我们在不同的直方图中绘制高度和宽度:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oo"><img src="../Images/2b550518c1ccced86d50d70a9c4a1c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRp4I_pQex3Z-tPa743AYA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">独立直方图中的高度和宽度</figcaption></figure><h1 id="ca05" class="nm mf it bd mg nn no np mj nq nr ns mm ki nt kj mp kl nu km ms ko nv kp mv nw bi translated">4.创建模型</h1><p id="4d70" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">我将使用的模型是朴素贝叶斯分类器。与许多其他模型不同，此模型专门处理以下数据:</p><ul class=""><li id="c086" class="mw mx it ku b kv kw ky kz lb op lf oq lj or ln os ne nf ng bi translated">是独立的</li><li id="68f3" class="mw mx it ku b kv nh ky ni lb nj lf nk lj nl ln os ne nf ng bi translated">遵循正态分布</li></ul><p id="8a9f" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">因为我是按照这些前提构建数据集的，所以这个分类器非常适合我想要构建的东西。</p><h2 id="d641" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">预处理</h2><p id="1127" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">我必须做的唯一预处理步骤是用one_hot编码算法对颜色进行编码:</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="add8" class="me mf it od b gy oh oi l oj ok">#backup<br/>X = df.copy()</span><span id="c191" class="me mf it od b gy ol oi l oj ok">def one_hot(df, partitions):<br/>  #togliamo le colonne da X<br/>  for col in partitions:<br/>    k = df.pop(col)<br/>    k = pd.get_dummies(k, prefix=col)<br/>    df = pd.concat([df, k] , axis=1)<br/>  return df</span><span id="01b2" class="me mf it od b gy ol oi l oj ok">X = one_hot(X, ['color'])<br/>X</span></pre><h2 id="79c7" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">选择要素和标签</h2><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="bd75" class="me mf it od b gy oh oi l oj ok">y = X.pop('name')<br/>y</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/bdc23704c7c84258851640d1baa647e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*0zmO4GKdFOL6wQSA-izvxA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">标签</figcaption></figure><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="8d01" class="me mf it od b gy oh oi l oj ok">X</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ou"><img src="../Images/3e61d8af743f375cdf6ebd63866111c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kY-AaSClAbpBm3o_yJsfdQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">one_hot编码后的功能</figcaption></figure><h2 id="8108" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">剧烈的</h2><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="9893" class="me mf it od b gy oh oi l oj ok">from sklearn.model_selection import train_test_split</span><span id="2e5e" class="me mf it od b gy ol oi l oj ok">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</span></pre><p id="c378" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">我现在将随机分割特征和标签，比例为80:20就足够了。</p><h2 id="ded4" class="me mf it bd mg mh mi dn mj mk ml dp mm lb mn mo mp lf mq mr ms lj mt mu mv iz bi translated">训练模型</h2><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="4bbd" class="me mf it od b gy oh oi l oj ok">from sklearn.naive_bayes import GaussianNB<br/>clf = GaussianNB()<br/>clf.fit(X_train, y_train)</span></pre><p id="2d76" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">该模型已经被训练:</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="59f8" class="me mf it od b gy oh oi l oj ok">GaussianNB(priors=None, var_smoothing=1e-09)</span></pre><h1 id="eb91" class="nm mf it bd mg nn no np mj nq nr ns mm ki nt kj mp kl nu km ms ko nv kp mv nw bi translated">5.性能赋值</h1><p id="30f2" class="pw-post-body-paragraph ks kt it ku b kv my kd kx ky mz kg la lb nx ld le lf ny lh li lj nz ll lm ln im bi translated">在训练模型之后，我将在AI在训练期间从未见过的数据集部分上测试它:</p><pre class="lp lq lr ls gt oc od oe of aw og bi"><span id="7ed7" class="me mf it od b gy oh oi l oj ok">clf.score(X_test, y_test, sample_weight=None)<br/>0.9659133333333333</span></pre><p id="2c22" class="pw-post-body-paragraph ks kt it ku b kv kw kd kx ky kz kg la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">该模型达到了令人瞩目的96%的准确率！</p></div></div>    
</body>
</html>