<html>
<head>
<title>A guide to Persistent storage in Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker中的持久存储指南</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/a-guide-to-persistent-storage-in-docker-74a50d26a2a1?source=collection_archive---------1-----------------------#2022-12-16">https://pub.towardsai.net/a-guide-to-persistent-storage-in-docker-74a50d26a2a1?source=collection_archive---------1-----------------------#2022-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">绑定装载、卷和临时文件存储装载</h2></div><h1 id="9fa4" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Docker中持久存储的需求是什么？</h1><p id="48e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">应用程序生成两种数据，持久的和非持久的。非持久数据可以忽略，它们不必保存在任何地方。另一方面，需要保存持久数据以备将来使用；无论如何都不能丢。如果应用程序作为一个容器托管，持久数据必须可以被多个容器访问，因为它们共享负载和存储。数据必须是持久的，与容器的状态无关。既然我们已经理解了持久化数据的需要，那么让我们看看数据是如何存储在容器中的。</p><p id="996d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">容器由多个层组成，容器内的文件存储在可写层中。只要容器存在，数据就只能持久化，这意味着当容器被删除时，其中的所有数据都将丢失。这存在以下问题，</p><ol class=""><li id="95e2" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">另一个容器很难访问该容器中存在的数据。</li><li id="0a65" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">因为容器的可写层与主机紧密耦合，所以很难将数据移动到不同的系统。</li></ol><p id="8d1c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为了解决这个问题，docker提出了两种持久存储的方法，卷和绑定挂载。Docker还支持内存用例的临时文件存储。</p><blockquote class="mm mn mo"><p id="fee7" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">在本文中，我们将学习不同的持久存储选项、它们的实现、它们的用例以及代码示例。</p></blockquote><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mt"><img src="../Images/c2d3adc1bf758ea314f806de8705acbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HsLpnWHNtin47xtu"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">由<a class="ae nj" href="https://unsplash.com/@jsalvino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约翰·萨尔维诺</a>在<a class="ae nj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="fccc" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">目录</h1><blockquote class="nk"><p id="0801" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">1.代码走查</p><p id="f6f5" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">2.绑定安装</p><p id="95e3" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">3.卷</p><p id="57b7" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">4.临时文件存储装载</p><p id="7791" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">5.结论</p></blockquote><h1 id="d902" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw nu jx kr jz nv ka kt kc nw kd kv kw bi translated">1.代码走查</h1><p id="2e13" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于本文，我们以一个简单的python应用程序为例，该应用程序将文件名和文件内容作为参数，并创建具有指定内容的文件。这个应用程序的源代码可以在<a class="ae nj" href="https://github.com/Prithivee7/Docker-Fundamentals/tree/main/Docker%20Persistence" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="5c01" class="oc kg iq ny b be od oe l of og">from flask import Flask, request<br/>import os<br/><br/>app = Flask(__name__)<br/><br/>if not os.path.exists("docker_bind"):<br/>    os.makedir("docker_bind")<br/><br/>@app.route("/create_file",methods=["POST"])<br/>def run():<br/>    data = request.get_json()<br/>    file_name, content =  data['file_name'], data['content']<br/>    file_path = f"docker_bind/{file_name}"<br/>    with open(file_path,'w') as write_file:<br/>        write_file.write(content)<br/>    return {"Status":"Success"}<br/><br/>app.run(debug=False,host='0.0.0.0',port = 5000)</span></pre><p id="8f1a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要将这个应用程序作为容器运行，先决条件是docker必须安装<a class="ae nj" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank"/>。安装docker后，打开命令提示符并执行以下命令。所有命令的列表可以在<a class="ae nj" href="https://github.com/Prithivee7/Docker-Fundamentals/blob/main/Docker%20Persistence/docker%20commands%20for%20persistence.txt" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="b2c3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">构建容器。</strong></p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="774d" class="oc kg iq ny b be od oe l of og">docker build -t create_file_py_image .</span></pre><p id="fa81" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">来运行容器。</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="6160" class="oc kg iq ny b be od oe l of og">docker run --name create_file_py_container -p 5001:5000 create_file_py_image</span></pre><p id="b487" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">运行上述命令后，我们可以打开postman，向正在运行的容器发送一个请求，以文件名和内容作为参数。应用程序接受参数，用指定的名称和内容创建文件，并返回状态success。我们将使用相同的代码来解释卷和绑定装载。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/9d62c9df7b230cac488e816cb6f97d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7Ra7KCfgwzax5eOFx3wtQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者排序的图像—向容器发送请求</figcaption></figure><h1 id="1acc" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">2.绑定安装</h1><blockquote class="mm mn mo"><p id="3d76" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">2.1什么是绑定挂载？</p><p id="29e6" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">2.2创建绑定挂载。</p><p id="1ff7" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">2.3多个容器访问同一个绑定挂载。</p><p id="5a27" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">2.4演示绑定挂载的持久性。</p><p id="217b" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">2.5我们可以在哪里使用绑定挂载</p></blockquote><h2 id="1ec2" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">2.1什么是绑定挂载？</h2><p id="f0ba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">绑定挂载用于持久化，从docker早期就有了。当我们使用绑定装载时，主机上的目录被装载到容器中。在绑定挂载中，目录由我们管理，而不是由docker管理。</p><p id="f29b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">绑定挂载也有一点缺点，因为容器能够在主机操作系统中修改、删除和创建资源。如果非docker元素需要访问mount文件夹，就必须引起注意。</p><h2 id="a329" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">2.2创建绑定挂载</h2><p id="e597" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">mount标志用于表示我们需要的持久性类型。它可以是bind、tmpfs或volume。在本例中，我们将其设置为bind。为了创建绑定挂载，我们需要显式地提供源路径。它必须是绝对路径，而不是相对路径。源路径是主机中的路径。同样，我们需要提供目标路径。这是我们想要挂载的容器内部的路径。</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="a454" class="oc kg iq ny b be od oe l of og">docker run -d -it -p 5000:5000 --name create_file_py_container1 --mount type=bind,source="C:\Users\prithiveer\Documents\Docker_Bind",target=/app/docker_bind create_file_py_image</span></pre><p id="b87d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用上面的命令，将创建一个容器。我们从Postman发送了一个请求，创建一个名为“sample_1.txt”的文件，内容为“我的第一个文件”。如下所示，我们可以在容器中使用exec并找到我们创建的文件。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/1cb98c0e3724306d24272418ed462eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkZ9SRVT92bQLDWsB-OV7A.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者分类的图像-使用create_file_py_container1创建文件</figcaption></figure><h2 id="fb68" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">2.3多个容器访问同一个绑定挂载</h2><p id="7e31" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在现实生活中，一个应用程序将被托管在多个容器中，我们要求将它们挂载到一个绑定挂载上。因此，出于演示的目的，我们又创建了两个容器。</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="2ea9" class="oc kg iq ny b be od oe l of og">docker run -d -it -p 5002:5000 --name create_file_py_container2 --mount type=bind,source="C:\Users\prithiveer\Documents\Docker_Bind",target=/app/docker_bind create_file_py_image<br/><br/>docker run -d -it -p 5003:5000 --name create_file_py_container3 --mount type=bind,source="C:\Users\prithiveer\Documents\Docker_Bind",target=/app/docker_bind create_file_py_image</span></pre><p id="0c6b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">像第一个容器一样，我们从容器2和容器3发送请求，并分别生成文件sample_2.txt和sample_3.txt。在创建绑定挂载时，我们提供了一个源地址。我们可以在指定位置的容器中找到我们创建的所有文件。类似地，我们还可以在所有3个容器的docker_bind文件夹中找到所有文件，而不考虑每个容器创建的文件。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/66f13c6069c67ef76a0944bfecca9a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhqZlU1vGpzv6c-zIlcGxA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者分类的图像—源文件夹包含在3个容器中创建的所有文件</figcaption></figure><h2 id="9d7e" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">2.4演示绑定挂载的持久性。</h2><p id="8915" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了演示持久性，我们删除了所有3个容器并再次创建它们。因为当我们删除容器时，数据被写入可写层，所以容器中的所有数据都将丢失。但是由于绑定挂载，我们将能够看到所有创建的文件。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/792ded1994446014f5f0d97c20efb52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrWUf0cuTyn6dOQMw1N9Ww.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者排序的图像—再次创建容器并找到之前创建的文件</figcaption></figure><h2 id="2268" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">2.5我们可以在哪里使用绑定挂载？</h2><p id="6f3e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们确信主机的目录结构将保持一致时，我们可以使用绑定装载。它还可以用于将配置文件从容器共享到主机。</p><h1 id="56fa" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">3.卷</h1><blockquote class="mm mn mo"><p id="c59e" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">3.1什么是卷？</p><p id="10f0" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">3.2创建卷并将其装入容器。</p><p id="5cdf" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">3.3多个容器访问同一个卷。</p><p id="1c55" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">3.4用体积证明持久性。</p></blockquote><p id="373c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">3.5我们可以在哪里使用卷？</p><h2 id="612a" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">3.1什么是卷？</h2><p id="095d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">卷是处理持久文件存储的首选方式。卷基本上是绑定装载，除了docker管理主机上的存储。因此，您不必知道文件或目录的完全限定路径。</p><p id="09e5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">1.体积与容器无关。</p><p id="7a86" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">2.它们可以映射到外部存储</p><p id="ce3b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">3.多个容器可以访问同一个卷。</p><h2 id="8448" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">3.2创建卷并将其装入容器。</h2><p id="4989" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">卷是docker中的一级对象。它可以显式创建，也可以在装载容器时动态创建。在安装过程中，docker会检查卷是否可用，如果不可用，它会创建一个卷。</p><p id="7aaa" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">显式创建卷</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="34fa" class="oc kg iq ny b be od oe l of og">docker volume create my_volume </span></pre><p id="f403" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">装载时创建卷</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="dce8" class="oc kg iq ny b be od oe l of og">docker run -d -p 5000:5000 --name container1 --mount type=volume, source="my_volume", target=/app/docker_bind create_file_py_image</span></pre><p id="3776" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用上面的命令，我们创建一个名为container1的容器，端口为5000。使用设置为type volume的装载标志类型，我们将“my_volume”装载到容器中。源将具有卷的名称，而目标将是容器内部需要连接的文件夹。当我们在挂载后发送请求时，文件在docker_bind文件夹中创建，并保存在我们创建的卷中。</p><p id="0db2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">列出卷并检查它</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="7a5a" class="oc kg iq ny b be od oe l of og">docker volume ls<br/>docker volume inspect my_volume</span></pre><p id="153e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们需要检查文件在卷中的保存位置，我们可以使用inspect命令。这将返回挂载点位置和元数据。在/app/docker_bind中生成的所有文件都可以在/var/lib/docker/volumes/my _ volume/_ data位置找到。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/c3c614d3f716e7596dffd991cae6b62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2j7I11oX27HovOzwf0kv4Q.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">作者检查卷的图像</figcaption></figure><h2 id="e2dc" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">3.3多个容器访问同一个卷。</h2><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="5d91" class="oc kg iq ny b be od oe l of og">docker run -d -p 5002:5000 --name container2 --mount type=volume, source="my_volume", target=/app/docker_bind create_file_py_image<br/>.<br/>docker run -d -p 5003:5000 --name container3 --mount type=volume, source="my_volume", target=/app/docker_bind create_file_py_image</span></pre><p id="477d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，容器1、容器2和容器3正在访问同一个卷。因此，由所有3个容器创建的文件将驻留在同一个卷中。</p><h2 id="4088" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">3.4用体积证明持久性。</h2><p id="6513" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们向container1发送一个请求，创建一个名为volume_file.txt的文件。在内容中，我们写道，“我在卷文件存储中”。该文件将在container1的docker_bind文件夹中创建。然后会复制到我的_volume。为了演示持久性，我们删除了container1。之后，我们执行container2并检查volume_file.txt是否存在。正如我们在下图中看到的，我们能够显示volume_file.txt的内容，它是在container1中从container2创建的。这证明了体积的持久性。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/f5cc67f632c34066631fde4fb88c38aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qx44WfX5-5evr-w6T0FZ-Q.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">作者提供的图片——展示卷的持久性</figcaption></figure><h2 id="a45a" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">3.5我们可以在哪里使用卷？</h2><ol class=""><li id="4192" class="ly lz iq kz b la lb ld le lg ou lk ov lo ow ls md me mf mg bi translated">当我们希望将数据存储在远程主机或云提供商而不是本地存储时，可以使用卷。</li></ol><p id="dd78" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">2.卷可用于从一台Docker主机向另一台迁移、创建备份或恢复数据。我们可以停止正在运行的容器，并从挂载路径目录中获取数据。</p><h1 id="8a8b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">4.临时文件存储挂载(tmpfs)</h1><blockquote class="mm mn mo"><p id="b165" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">4.1什么是临时文件存储挂载？</p><p id="be5d" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">4.2创建临时文件存储。</p><p id="59a2" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">4.3演示临时文件存储中的“临时”。</p><p id="ff6b" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">4.4演示内存中属性。</p><p id="222d" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">4.5我们可以在哪里使用临时文件存储？</p></blockquote><h2 id="de54" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">4.1什么是临时文件存储挂载？</h2><p id="088c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">顾名思义，临时文件存储挂载不会永久存储数据。它们本质上是短暂的。它们是内存中的文件存储。任何其他容器都不能访问它们，一旦容器关闭，信息就会丢失。对于tmpfs，不会创建任何卷。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/0d494c5c4216e4834a0280f7520ac3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZESytWnaZDb3Q_o5wuimbw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者分类的图像—创建tmpfs不会创建卷</figcaption></figure><h2 id="1991" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">4.2创建临时文件存储。</h2><p id="8c40" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了创建临时文件存储，我们需要将挂载标志设置为类型tmpfs。执行以下命令后，将创建一个名为my_temp_storage的文件夹。</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="33eb" class="oc kg iq ny b be od oe l of og">docker run -it --name ubututu_container1 --mount type=tmpfs,dst=/my_temp_storage ubuntu</span></pre><p id="1b65" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在创建临时文件存储之后，我们可以在tmpfs目录中创建一个文件，在这种情况下，它将是my_temp_storage。</p><pre class="mu mv mw mx gt nx ny nz bn oa ob bi"><span id="6e1f" class="oc kg iq ny b be od oe l of og">echo "This is my file in temporary file storage" &gt; my_temp_storage/logs.txt</span></pre><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/785a6402527553be8c0c8413b9ba46b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISaiWi2kKTiQfMwR5raqWA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者分类的图像—在tmpfs中创建文件</figcaption></figure><h2 id="62f9" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">4.3演示临时文件存储中的“临时”。</h2><p id="60a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了演示临时文件存储的短暂行为，我们停止ubututu_container1并再次启动它。这样做之后，我们会发现我们之前创建的文件(logs.txt)不再存在了。这是因为tmpfs不持久存储数据。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/913fd32c399a15354474e076667784aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-I620225YkJ_RAVvDOl9cA.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">作者提供的图片——演示tmpfs的短暂行为</figcaption></figure><h2 id="4dec" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">4.4演示内存中属性。</h2><p id="e9ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在解释绑定装载和卷时，我们创建了多个容器来展示数据是如何持久存储的。但是对于tmpfs，我们不能这样做，因为它是内存中的属性。这意味着一个容器的tmpfs文件夹中的文件不能被另一个容器访问。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/21070e1d5835a611a947a3a87d2eb662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxlAmFmaJuXONjd3O7-p0A.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">作者提供的图片—展示内存中的属性</figcaption></figure><p id="e71e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Tmpfs不同于将文件保存在不同的位置。在tmpfs的情况下，当我们停止或退出容器时，信息会丢失。但在任何其他位置，如果我们停下来，启动容器，我们将能够找到文件。</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3079f343c951fcb6bbeb012bb338217e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*BG9y4bYykyVnDLLFCrcemQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">按作者分类的图片—展示普通文件夹和tmpfs文件夹之间的差异</figcaption></figure><h2 id="ba84" class="oi kg iq bd kh oj ok dn kl ol om dp kp lg on oo kr lk op oq kt lo or os kv ot bi translated">4.5我们可以在哪里使用临时文件存储？</h2><p id="3c7a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们不希望数据同时保存在容器和本地系统中时，最好使用Tmpfs挂载。它们用于存储与安全相关的信息，比如一旦容器关闭就需要过期的令牌。这也提高了容器的性能。</p><h1 id="9c20" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">5.结论</h1><p id="735f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我们学习了Docker提供的不同类型的持久存储选项、它们的用例以及它们的实现。这些选项保证了一旦容器被移除，数据不会丢失。如果你不确定选择哪一个，就选卷。在绑定挂载的情况下，我们必须提供挂载的位置，但是在卷的情况下，docker会为我们处理这个问题。对于敏感数据，我们可以使用临时文件存储，但我们必须小心，因为它们是短暂的。</p><h1 id="168c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">参考</h1><ol class=""><li id="6ad0" class="ly lz iq kz b la lb ld le lg ou lk ov lo ow ls md me mf mg bi translated"><a class="ae nj" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank">管理Docker | Docker文档中的数据</a></li><li id="2cba" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated"><a class="ae nj" href="https://www.youtube.com/watch?v=G-5c25DYnfI&amp;t=105s" rel="noopener ugc nofollow" target="_blank"> Docker卷解释(PostgreSQL示例)— YouTube </a></li><li id="08b5" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated"><a class="ae nj" href="https://www.youtube.com/watch?v=YV78PJ-o9w0" rel="noopener ugc nofollow" target="_blank">(7384)Docker中持久存储选项介绍— YouTube </a></li></ol><h1 id="0beb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">想要连接吗？</h1><p id="8955" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你喜欢这篇文章，请关注我<a class="ae nj" href="https://medium.com/@getprithivee" rel="noopener">这里</a>关于机器学习和计算机科学的更多故事。</p><p id="825b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">linked In—<a class="ae nj" href="https://www.linkedin.com/in/prithivee-ramalingam-032b42110/" rel="noopener ugc nofollow" target="_blank">Prithivee Ramalingam | LinkedIn</a></p></div></div>    
</body>
</html>