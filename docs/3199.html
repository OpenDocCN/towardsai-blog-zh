<html>
<head>
<title>Pencil Sketch Image With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的铅笔素描图像</h1>
<blockquote>原文：<a href="https://pub.towardsai.net/pencil-sketch-image-with-python-d8df27be9037?source=collection_archive---------4-----------------------#2022-10-10">https://pub.towardsai.net/pencil-sketch-image-with-python-d8df27be9037?source=collection_archive---------4-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1cf3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，我将向您展示如何使用Python创建一个“铅笔”草图图像，只需几行代码。</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="43ee" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">您见过的最先进的数据科学路线图！附带数以千计的免费学习资源和ChatGPT集成！</strong><a class="ae ll" href="https://87v9.short.gy/K93jZA" rel="noopener ugc nofollow" target="_blank">【https://aigents.co/learn/roadmaps/intro】</a></p><p id="c871" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我一直对计算机视觉很着迷，尤其是它在快速矩阵乘法中处理图像的能力。在Python中，图片是一组数字。所以我们可以做各种矩阵操作来得到令人兴奋的结果。因此，在之前的教程中，我们学习了如何将我们自己从背景中分离出来，检测人脸，并实时完成所有这些工作。在本教程中，我将向您展示如何用几行代码创建一个“铅笔”草图。</p><p id="f2a6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这个过程非常简单:</p><ol class=""><li id="d170" class="lm ln it kr b ks kt kv kw ky lo lc lp lg lq lk lr ls lt lu bi translated">将图像灰度化；</li><li id="33e3" class="lm ln it kr b ks lv kv lw ky lx lc ly lg lz lk lr ls lt lu bi translated">颠倒它的颜色；</li><li id="8104" class="lm ln it kr b ks lv kv lw ky lx lc ly lg lz lk lr ls lt lu bi translated">模糊反转图像；</li><li id="e74e" class="lm ln it kr b ks lv kv lw ky lx lc ly lg lz lk lr ls lt lu bi translated">将减淡混合应用于模糊的灰度图像。</li></ol><p id="6294" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们可以选择任何我们想要的图像。但是我将演示如何创建一个可以应用于任何图像、视频或实时流的对象。我这样做是为了扩展我在本系列教程中所做的背景去除项目的功能。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/11eae86da60336e246d6d54261e6b694.png" data-original-src="https://miro.medium.com/v2/format:webp/1*p_OMBb_ynWkgqYYm7AyAzA.png"/></div></figure><h2 id="81d7" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">导入库</h2><p id="5166" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">OpenCV和Numpy是这个项目唯一需要的库。我们用下面两行代码导入它们:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><h2 id="dd7c" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">阅读照片</h2><p id="9f3d" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">以下是使用OpenCV读取存储在光盘上的图像的命令之一:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="abf2" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">该命令读取光盘上当前文件夹中的文件“<code class="fe nc nd ne nf b">image.png</code>”，并以帧的形式存储在内存中。但正如我提到的，这可以是一系列帧或通过其他方法加载的图像。</p><h2 id="6808" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">使用OpenCV显示图像</h2><p id="82f9" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">在我们的项目中创建这样一个草图的下一个重要步骤是知道如何快速查看结果，而不用将它们保存在光盘上。以下OpenCV命令可用于在屏幕上显示图像:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="4336" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当执行这些行时，图像将在一个标题为“图像”的新窗口中打开:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/5a869642edc300a66fa0c07797f549d6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PlBUGZr7v-0kNk_Ru22G7w.jpeg"/></div></figure><h2 id="650b" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">将图像灰度化</h2><p id="afad" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">首先，我们需要做的是对图像进行灰度化(转换成黑白)。我们可以用cv2库或numpy来做。但是numpy没有任何内置的灰度函数。但是我们可以很容易地将我们的图像转换成灰度，知道背后的数学原理。但不进行数学计算，公式如下:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="48ed" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里，我们将RGB图像通道乘以适当的值，并将它们连接成一个通道。正因为如此，我们需要返回到3层图像；我们用numpy堆栈函数来实现。这是我们得到的结果:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/b0483748b2ef5c139ea6363cdf49d789.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EWo67WdP1eUS0R5dueVpRw.jpeg"/></div></figure><h2 id="7bd8" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">反转图像</h2><p id="f81a" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">现在我们需要反转图像。当我说反转时，我的意思是白色应该变成黑色，反之亦然。就像从每个图像像素中减去255一样简单。因为默认情况下，图像是8位的，最多有256种色调:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="01c2" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当我们显示反转后的图像或将其保存在光盘上时，我们会收到以下图片:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/59404e75e3d99ca75b728031f8050b1d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zIFiQO8jPj7QZzTnyChdKg.jpeg"/></div></figure><h2 id="bc76" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">模糊图像</h2><p id="6ea8" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">现在我们需要模糊反转的图像。通过对反转图像应用高斯滤波器来执行模糊。这里最重要的是高斯函数或sigma的方差。随着sigma的增加，图像变得越来越模糊。适马控制色散量，从而控制模糊程度。可以通过反复试验来选择合适的σ值:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="c196" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">模糊图像的结果如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/442cc7ae6e352337da11c7313557041a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*5ajO0k1rNNwGm4PouOaKCw.jpeg"/></div></figure><h2 id="c990" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">减淡并合并</h2><p id="5dbc" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated"><a class="ae ll" href="https://en.wikipedia.org/wiki/Blend_modes" rel="noopener ugc nofollow" target="_blank">颜色减淡</a>混合模式从反转的顶层中分离出底层。这将根据上层的值使下层变亮。我们有一个模糊的图像，突出了最大胆的边缘。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="c691" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就是这样！结果如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/7e2ba1784a56fcb5aa7ad0c341c47708.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1_Ere4W1AFksxw2jBHEYfA.jpeg"/></div></figure><p id="fc85" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以下是该对象的完整铅笔草图代码:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="4364" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">可以猜测，在模糊过程中，除了<code class="fe nc nd ne nf b">blur_sigma</code>参数之外，我们没有太多的空间可以使用。我添加了一个额外的函数来锐化图像，以解决这个问题。锐化的结果可以在这个动画GIF中看到:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/6a001f0bbe1626d7bc122ae9566c8090.png" data-original-src="https://miro.medium.com/v2/1*rpodGJC8EGs4orCeKklPoQ.gif"/></div></figure><p id="271f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这与模糊处理非常相似，只是现在，我们不是创建一个平均每个像素强度的内核，而是创建一个使像素强度更高的内核，因此人眼更容易看到。</p><p id="e386" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以下是如何使用PencilSketch对象作为门廊图像的基本代码:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nb ko l"/></div></figure><p id="6d4f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以上代码的结果你可以看到以下内容:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/9268380f7012a1ea7a52a94147e023d9.png" data-original-src="https://miro.medium.com/v2/1*kDgPk0XUE57RavvH73WupQ.gif"/></div></figure><h1 id="3c6e" class="ng me it bd mf nh ni nj mi nk nl nm ml jz nn ka mo kc no kd mr kf np kg mu nq bi translated">结论:</h1><p id="726f" class="pw-post-body-paragraph kp kq it kr b ks mw ju ku kv mx jx kx ky my la lb lc mz le lf lg na li lj lk im bi translated">这是一个非常好的教程，不需要任何深入的python知识就可以从任何图像中获得这种惊人的“铅笔”草图风格。在使用GitHub中的my project文件和Engine对象时，您可以轻松地将这种效果应用于任何图像、视频或实时网络摄像机流。</p><p id="bac0" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在下一篇教程中，我将讲述一些更加激动人心的东西。我在考虑人脸识别，因为我们已经实现了人脸检测。剩下的——从那张脸上辨认一个人。</p><p id="f0b8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">感谢阅读！一如既往，本教程给出的所有代码都可以在我的<a class="ae ll" href="https://github.com/pythonlessons/background_removal" rel="noopener ugc nofollow" target="_blank"> GitHub </a>页面上找到，并且免费使用！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="4564" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ny">原载于</em><a class="ae ll" href="https://pylessons.com/pencil-sketch" rel="noopener ugc nofollow" target="_blank"><em class="ny"/></a></p></div></div>    
</body>
</html>